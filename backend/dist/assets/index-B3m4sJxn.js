function _mergeNamespaces(e, t) { for (var xe = 0; xe < t.length; xe++) { const Ee = t[xe]; if (typeof Ee != "string" && !Array.isArray(Ee)) { for (const _e in Ee) if (_e !== "default" && !(_e in e)) { const Re = Object.getOwnPropertyDescriptor(Ee, _e); Re && Object.defineProperty(e, _e, Re.get ? Re : { enumerable: !0, get: () => Ee[_e] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const _e of document.querySelectorAll('link[rel="modulepreload"]')) Ee(_e); new MutationObserver(_e => { for (const Re of _e) if (Re.type === "childList") for (const Ce of Re.addedNodes) Ce.tagName === "LINK" && Ce.rel === "modulepreload" && Ee(Ce) }).observe(document, { childList: !0, subtree: !0 }); function xe(_e) { const Re = {}; return _e.integrity && (Re.integrity = _e.integrity), _e.referrerPolicy && (Re.referrerPolicy = _e.referrerPolicy), _e.crossOrigin === "use-credentials" ? Re.credentials = "include" : _e.crossOrigin === "anonymous" ? Re.credentials = "omit" : Re.credentials = "same-origin", Re } function Ee(_e) { if (_e.ep) return; _e.ep = !0; const Re = xe(_e); fetch(_e.href, Re) } })(); var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function getDefaultExportFromCjs(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } function getAugmentedNamespace(e) { if (Object.prototype.hasOwnProperty.call(e, "__esModule")) return e; var t = e.default; if (typeof t == "function") { var xe = function Ee() { var _e = !1; try { _e = this instanceof Ee } catch { } return _e ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments) }; xe.prototype = t.prototype } else xe = {}; return Object.defineProperty(xe, "__esModule", { value: !0 }), Object.keys(e).forEach(function (Ee) { var _e = Object.getOwnPropertyDescriptor(e, Ee); Object.defineProperty(xe, Ee, _e.get ? _e : { enumerable: !0, get: function () { return e[Ee] } }) }), xe } var jsxRuntime = { exports: {} }, reactJsxRuntime_production = {};/**
 * @license React
 * react-jsx-runtime.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactJsxRuntime_production; function requireReactJsxRuntime_production() { if (hasRequiredReactJsxRuntime_production) return reactJsxRuntime_production; hasRequiredReactJsxRuntime_production = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.fragment"); function xe(Ee, _e, Re) { var Ce = null; if (Re !== void 0 && (Ce = "" + Re), _e.key !== void 0 && (Ce = "" + _e.key), "key" in _e) { Re = {}; for (var Me in _e) Me !== "key" && (Re[Me] = _e[Me]) } else Re = _e; return _e = Re.ref, { $$typeof: e, type: Ee, key: Ce, ref: _e !== void 0 ? _e : null, props: Re } } return reactJsxRuntime_production.Fragment = t, reactJsxRuntime_production.jsx = xe, reactJsxRuntime_production.jsxs = xe, reactJsxRuntime_production } var hasRequiredJsxRuntime; function requireJsxRuntime() { return hasRequiredJsxRuntime || (hasRequiredJsxRuntime = 1, jsxRuntime.exports = requireReactJsxRuntime_production()), jsxRuntime.exports } var jsxRuntimeExports = requireJsxRuntime(), react = { exports: {} }, react_production = {};/**
 * @license React
 * react.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReact_production; function requireReact_production() { if (hasRequiredReact_production) return react_production; hasRequiredReact_production = 1; var e = Symbol.for("react.transitional.element"), t = Symbol.for("react.portal"), xe = Symbol.for("react.fragment"), Ee = Symbol.for("react.strict_mode"), _e = Symbol.for("react.profiler"), Re = Symbol.for("react.consumer"), Ce = Symbol.for("react.context"), Me = Symbol.for("react.forward_ref"), De = Symbol.for("react.suspense"), Pe = Symbol.for("react.memo"), Oe = Symbol.for("react.lazy"), je = Symbol.iterator; function Be(We) { return We === null || typeof We != "object" ? null : (We = je && We[je] || We["@@iterator"], typeof We == "function" ? We : null) } var Ie = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Fe = Object.assign, ze = {}; function qe(We, dn, Je) { this.props = We, this.context = dn, this.refs = ze, this.updater = Je || Ie } qe.prototype.isReactComponent = {}, qe.prototype.setState = function (We, dn) { if (typeof We != "object" && typeof We != "function" && We != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, We, dn, "setState") }, qe.prototype.forceUpdate = function (We) { this.updater.enqueueForceUpdate(this, We, "forceUpdate") }; function He() { } He.prototype = qe.prototype; function Ge(We, dn, Je) { this.props = We, this.context = dn, this.refs = ze, this.updater = Je || Ie } var Ze = Ge.prototype = new He; Ze.constructor = Ge, Fe(Ze, qe.prototype), Ze.isPureReactComponent = !0; var sn = Array.isArray, Xe = { H: null, A: null, T: null, S: null, V: null }, St = Object.prototype.hasOwnProperty; function un(We, dn, Je, rn, hn, mn) { return Je = mn.ref, { $$typeof: e, type: We, key: dn, ref: Je !== void 0 ? Je : null, props: mn } } function on(We, dn) { return un(We.type, dn, void 0, void 0, void 0, We.props) } function bn(We) { return typeof We == "object" && We !== null && We.$$typeof === e } function Tn(We) { var dn = { "=": "=0", ":": "=2" }; return "$" + We.replace(/[=:]/g, function (Je) { return dn[Je] }) } var fn = /\/+/g; function En(We, dn) { return typeof We == "object" && We !== null && We.key != null ? Tn("" + We.key) : dn.toString(36) } function Pn() { } function Rn(We) { switch (We.status) { case "fulfilled": return We.value; case "rejected": throw We.reason; default: switch (typeof We.status == "string" ? We.then(Pn, Pn) : (We.status = "pending", We.then(function (dn) { We.status === "pending" && (We.status = "fulfilled", We.value = dn) }, function (dn) { We.status === "pending" && (We.status = "rejected", We.reason = dn) })), We.status) { case "fulfilled": return We.value; case "rejected": throw We.reason } }throw We } function In(We, dn, Je, rn, hn) { var mn = typeof We; (mn === "undefined" || mn === "boolean") && (We = null); var Ye = !1; if (We === null) Ye = !0; else switch (mn) { case "bigint": case "string": case "number": Ye = !0; break; case "object": switch (We.$$typeof) { case e: case t: Ye = !0; break; case Oe: return Ye = We._init, In(Ye(We._payload), dn, Je, rn, hn) } }if (Ye) return hn = hn(We), Ye = rn === "" ? "." + En(We, 0) : rn, sn(hn) ? (Je = "", Ye != null && (Je = Ye.replace(fn, "$&/") + "/"), In(hn, dn, Je, "", function (yn) { return yn })) : hn != null && (bn(hn) && (hn = on(hn, Je + (hn.key == null || We && We.key === hn.key ? "" : ("" + hn.key).replace(fn, "$&/") + "/") + Ye)), dn.push(hn)), 1; Ye = 0; var an = rn === "" ? "." : rn + ":"; if (sn(We)) for (var pn = 0; pn < We.length; pn++)rn = We[pn], mn = an + En(rn, pn), Ye += In(rn, dn, Je, mn, hn); else if (pn = Be(We), typeof pn == "function") for (We = pn.call(We), pn = 0; !(rn = We.next()).done;)rn = rn.value, mn = an + En(rn, pn++), Ye += In(rn, dn, Je, mn, hn); else if (mn === "object") { if (typeof We.then == "function") return In(Rn(We), dn, Je, rn, hn); throw dn = String(We), Error("Objects are not valid as a React child (found: " + (dn === "[object Object]" ? "object with keys {" + Object.keys(We).join(", ") + "}" : dn) + "). If you meant to render a collection of children, use an array instead.") } return Ye } function xn(We, dn, Je) { if (We == null) return We; var rn = [], hn = 0; return In(We, rn, "", "", function (mn) { return dn.call(Je, mn, hn++) }), rn } function vn(We) { if (We._status === -1) { var dn = We._result; dn = dn(), dn.then(function (Je) { (We._status === 0 || We._status === -1) && (We._status = 1, We._result = Je) }, function (Je) { (We._status === 0 || We._status === -1) && (We._status = 2, We._result = Je) }), We._status === -1 && (We._status = 0, We._result = dn) } if (We._status === 1) return We._result.default; throw We._result } var tn = typeof reportError == "function" ? reportError : function (We) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var dn = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof We == "object" && We !== null && typeof We.message == "string" ? String(We.message) : String(We), error: We }); if (!window.dispatchEvent(dn)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", We); return } console.error(We) }; function nn() { } return react_production.Children = { map: xn, forEach: function (We, dn, Je) { xn(We, function () { dn.apply(this, arguments) }, Je) }, count: function (We) { var dn = 0; return xn(We, function () { dn++ }), dn }, toArray: function (We) { return xn(We, function (dn) { return dn }) || [] }, only: function (We) { if (!bn(We)) throw Error("React.Children.only expected to receive a single React element child."); return We } }, react_production.Component = qe, react_production.Fragment = xe, react_production.Profiler = _e, react_production.PureComponent = Ge, react_production.StrictMode = Ee, react_production.Suspense = De, react_production.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Xe, react_production.__COMPILER_RUNTIME = { __proto__: null, c: function (We) { return Xe.H.useMemoCache(We) } }, react_production.cache = function (We) { return function () { return We.apply(null, arguments) } }, react_production.cloneElement = function (We, dn, Je) { if (We == null) throw Error("The argument must be a React element, but you passed " + We + "."); var rn = Fe({}, We.props), hn = We.key, mn = void 0; if (dn != null) for (Ye in dn.ref !== void 0 && (mn = void 0), dn.key !== void 0 && (hn = "" + dn.key), dn) !St.call(dn, Ye) || Ye === "key" || Ye === "__self" || Ye === "__source" || Ye === "ref" && dn.ref === void 0 || (rn[Ye] = dn[Ye]); var Ye = arguments.length - 2; if (Ye === 1) rn.children = Je; else if (1 < Ye) { for (var an = Array(Ye), pn = 0; pn < Ye; pn++)an[pn] = arguments[pn + 2]; rn.children = an } return un(We.type, hn, void 0, void 0, mn, rn) }, react_production.createContext = function (We) { return We = { $$typeof: Ce, _currentValue: We, _currentValue2: We, _threadCount: 0, Provider: null, Consumer: null }, We.Provider = We, We.Consumer = { $$typeof: Re, _context: We }, We }, react_production.createElement = function (We, dn, Je) { var rn, hn = {}, mn = null; if (dn != null) for (rn in dn.key !== void 0 && (mn = "" + dn.key), dn) St.call(dn, rn) && rn !== "key" && rn !== "__self" && rn !== "__source" && (hn[rn] = dn[rn]); var Ye = arguments.length - 2; if (Ye === 1) hn.children = Je; else if (1 < Ye) { for (var an = Array(Ye), pn = 0; pn < Ye; pn++)an[pn] = arguments[pn + 2]; hn.children = an } if (We && We.defaultProps) for (rn in Ye = We.defaultProps, Ye) hn[rn] === void 0 && (hn[rn] = Ye[rn]); return un(We, mn, void 0, void 0, null, hn) }, react_production.createRef = function () { return { current: null } }, react_production.forwardRef = function (We) { return { $$typeof: Me, render: We } }, react_production.isValidElement = bn, react_production.lazy = function (We) { return { $$typeof: Oe, _payload: { _status: -1, _result: We }, _init: vn } }, react_production.memo = function (We, dn) { return { $$typeof: Pe, type: We, compare: dn === void 0 ? null : dn } }, react_production.startTransition = function (We) { var dn = Xe.T, Je = {}; Xe.T = Je; try { var rn = We(), hn = Xe.S; hn !== null && hn(Je, rn), typeof rn == "object" && rn !== null && typeof rn.then == "function" && rn.then(nn, tn) } catch (mn) { tn(mn) } finally { Xe.T = dn } }, react_production.unstable_useCacheRefresh = function () { return Xe.H.useCacheRefresh() }, react_production.use = function (We) { return Xe.H.use(We) }, react_production.useActionState = function (We, dn, Je) { return Xe.H.useActionState(We, dn, Je) }, react_production.useCallback = function (We, dn) { return Xe.H.useCallback(We, dn) }, react_production.useContext = function (We) { return Xe.H.useContext(We) }, react_production.useDebugValue = function () { }, react_production.useDeferredValue = function (We, dn) { return Xe.H.useDeferredValue(We, dn) }, react_production.useEffect = function (We, dn, Je) { var rn = Xe.H; if (typeof Je == "function") throw Error("useEffect CRUD overload is not enabled in this build of React."); return rn.useEffect(We, dn) }, react_production.useId = function () { return Xe.H.useId() }, react_production.useImperativeHandle = function (We, dn, Je) { return Xe.H.useImperativeHandle(We, dn, Je) }, react_production.useInsertionEffect = function (We, dn) { return Xe.H.useInsertionEffect(We, dn) }, react_production.useLayoutEffect = function (We, dn) { return Xe.H.useLayoutEffect(We, dn) }, react_production.useMemo = function (We, dn) { return Xe.H.useMemo(We, dn) }, react_production.useOptimistic = function (We, dn) { return Xe.H.useOptimistic(We, dn) }, react_production.useReducer = function (We, dn, Je) { return Xe.H.useReducer(We, dn, Je) }, react_production.useRef = function (We) { return Xe.H.useRef(We) }, react_production.useState = function (We) { return Xe.H.useState(We) }, react_production.useSyncExternalStore = function (We, dn, Je) { return Xe.H.useSyncExternalStore(We, dn, Je) }, react_production.useTransition = function () { return Xe.H.useTransition() }, react_production.version = "19.1.0", react_production } var hasRequiredReact; function requireReact() { return hasRequiredReact || (hasRequiredReact = 1, react.exports = requireReact_production()), react.exports } var reactExports = requireReact(); const React = getDefaultExportFromCjs(reactExports), React$1 = _mergeNamespaces({ __proto__: null, default: React }, [reactExports]); var client = { exports: {} }, reactDomClient_production = {}, scheduler = { exports: {} }, scheduler_production = {};/**
 * @license React
 * scheduler.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredScheduler_production; function requireScheduler_production() { return hasRequiredScheduler_production || (hasRequiredScheduler_production = 1, function (e) { function t(xn, vn) { var tn = xn.length; xn.push(vn); e: for (; 0 < tn;) { var nn = tn - 1 >>> 1, We = xn[nn]; if (0 < _e(We, vn)) xn[nn] = vn, xn[tn] = We, tn = nn; else break e } } function xe(xn) { return xn.length === 0 ? null : xn[0] } function Ee(xn) { if (xn.length === 0) return null; var vn = xn[0], tn = xn.pop(); if (tn !== vn) { xn[0] = tn; e: for (var nn = 0, We = xn.length, dn = We >>> 1; nn < dn;) { var Je = 2 * (nn + 1) - 1, rn = xn[Je], hn = Je + 1, mn = xn[hn]; if (0 > _e(rn, tn)) hn < We && 0 > _e(mn, rn) ? (xn[nn] = mn, xn[hn] = tn, nn = hn) : (xn[nn] = rn, xn[Je] = tn, nn = Je); else if (hn < We && 0 > _e(mn, tn)) xn[nn] = mn, xn[hn] = tn, nn = hn; else break e } } return vn } function _e(xn, vn) { var tn = xn.sortIndex - vn.sortIndex; return tn !== 0 ? tn : xn.id - vn.id } if (e.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") { var Re = performance; e.unstable_now = function () { return Re.now() } } else { var Ce = Date, Me = Ce.now(); e.unstable_now = function () { return Ce.now() - Me } } var De = [], Pe = [], Oe = 1, je = null, Be = 3, Ie = !1, Fe = !1, ze = !1, qe = !1, He = typeof setTimeout == "function" ? setTimeout : null, Ge = typeof clearTimeout == "function" ? clearTimeout : null, Ze = typeof setImmediate < "u" ? setImmediate : null; function sn(xn) { for (var vn = xe(Pe); vn !== null;) { if (vn.callback === null) Ee(Pe); else if (vn.startTime <= xn) Ee(Pe), vn.sortIndex = vn.expirationTime, t(De, vn); else break; vn = xe(Pe) } } function Xe(xn) { if (ze = !1, sn(xn), !Fe) if (xe(De) !== null) Fe = !0, St || (St = !0, En()); else { var vn = xe(Pe); vn !== null && In(Xe, vn.startTime - xn) } } var St = !1, un = -1, on = 5, bn = -1; function Tn() { return qe ? !0 : !(e.unstable_now() - bn < on) } function fn() { if (qe = !1, St) { var xn = e.unstable_now(); bn = xn; var vn = !0; try { e: { Fe = !1, ze && (ze = !1, Ge(un), un = -1), Ie = !0; var tn = Be; try { t: { for (sn(xn), je = xe(De); je !== null && !(je.expirationTime > xn && Tn());) { var nn = je.callback; if (typeof nn == "function") { je.callback = null, Be = je.priorityLevel; var We = nn(je.expirationTime <= xn); if (xn = e.unstable_now(), typeof We == "function") { je.callback = We, sn(xn), vn = !0; break t } je === xe(De) && Ee(De), sn(xn) } else Ee(De); je = xe(De) } if (je !== null) vn = !0; else { var dn = xe(Pe); dn !== null && In(Xe, dn.startTime - xn), vn = !1 } } break e } finally { je = null, Be = tn, Ie = !1 } vn = void 0 } } finally { vn ? En() : St = !1 } } } var En; if (typeof Ze == "function") En = function () { Ze(fn) }; else if (typeof MessageChannel < "u") { var Pn = new MessageChannel, Rn = Pn.port2; Pn.port1.onmessage = fn, En = function () { Rn.postMessage(null) } } else En = function () { He(fn, 0) }; function In(xn, vn) { un = He(function () { xn(e.unstable_now()) }, vn) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (xn) { xn.callback = null }, e.unstable_forceFrameRate = function (xn) { 0 > xn || 125 < xn ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : on = 0 < xn ? Math.floor(1e3 / xn) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return Be }, e.unstable_next = function (xn) { switch (Be) { case 1: case 2: case 3: var vn = 3; break; default: vn = Be }var tn = Be; Be = vn; try { return xn() } finally { Be = tn } }, e.unstable_requestPaint = function () { qe = !0 }, e.unstable_runWithPriority = function (xn, vn) { switch (xn) { case 1: case 2: case 3: case 4: case 5: break; default: xn = 3 }var tn = Be; Be = xn; try { return vn() } finally { Be = tn } }, e.unstable_scheduleCallback = function (xn, vn, tn) { var nn = e.unstable_now(); switch (typeof tn == "object" && tn !== null ? (tn = tn.delay, tn = typeof tn == "number" && 0 < tn ? nn + tn : nn) : tn = nn, xn) { case 1: var We = -1; break; case 2: We = 250; break; case 5: We = 1073741823; break; case 4: We = 1e4; break; default: We = 5e3 }return We = tn + We, xn = { id: Oe++, callback: vn, priorityLevel: xn, startTime: tn, expirationTime: We, sortIndex: -1 }, tn > nn ? (xn.sortIndex = tn, t(Pe, xn), xe(De) === null && xn === xe(Pe) && (ze ? (Ge(un), un = -1) : ze = !0, In(Xe, tn - nn))) : (xn.sortIndex = We, t(De, xn), Fe || Ie || (Fe = !0, St || (St = !0, En()))), xn }, e.unstable_shouldYield = Tn, e.unstable_wrapCallback = function (xn) { var vn = Be; return function () { var tn = Be; Be = vn; try { return xn.apply(this, arguments) } finally { Be = tn } } } }(scheduler_production)), scheduler_production } var hasRequiredScheduler; function requireScheduler() { return hasRequiredScheduler || (hasRequiredScheduler = 1, scheduler.exports = requireScheduler_production()), scheduler.exports } var reactDom = { exports: {} }, reactDom_production = {};/**
 * @license React
 * react-dom.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDom_production; function requireReactDom_production() { if (hasRequiredReactDom_production) return reactDom_production; hasRequiredReactDom_production = 1; var e = requireReact(); function t(De) { var Pe = "https://react.dev/errors/" + De; if (1 < arguments.length) { Pe += "?args[]=" + encodeURIComponent(arguments[1]); for (var Oe = 2; Oe < arguments.length; Oe++)Pe += "&args[]=" + encodeURIComponent(arguments[Oe]) } return "Minified React error #" + De + "; visit " + Pe + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function xe() { } var Ee = { d: { f: xe, r: function () { throw Error(t(522)) }, D: xe, C: xe, L: xe, m: xe, X: xe, S: xe, M: xe }, p: 0, findDOMNode: null }, _e = Symbol.for("react.portal"); function Re(De, Pe, Oe) { var je = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: _e, key: je == null ? null : "" + je, children: De, containerInfo: Pe, implementation: Oe } } var Ce = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE; function Me(De, Pe) { if (De === "font") return ""; if (typeof Pe == "string") return Pe === "use-credentials" ? Pe : "" } return reactDom_production.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = Ee, reactDom_production.createPortal = function (De, Pe) { var Oe = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Pe || Pe.nodeType !== 1 && Pe.nodeType !== 9 && Pe.nodeType !== 11) throw Error(t(299)); return Re(De, Pe, null, Oe) }, reactDom_production.flushSync = function (De) { var Pe = Ce.T, Oe = Ee.p; try { if (Ce.T = null, Ee.p = 2, De) return De() } finally { Ce.T = Pe, Ee.p = Oe, Ee.d.f() } }, reactDom_production.preconnect = function (De, Pe) { typeof De == "string" && (Pe ? (Pe = Pe.crossOrigin, Pe = typeof Pe == "string" ? Pe === "use-credentials" ? Pe : "" : void 0) : Pe = null, Ee.d.C(De, Pe)) }, reactDom_production.prefetchDNS = function (De) { typeof De == "string" && Ee.d.D(De) }, reactDom_production.preinit = function (De, Pe) { if (typeof De == "string" && Pe && typeof Pe.as == "string") { var Oe = Pe.as, je = Me(Oe, Pe.crossOrigin), Be = typeof Pe.integrity == "string" ? Pe.integrity : void 0, Ie = typeof Pe.fetchPriority == "string" ? Pe.fetchPriority : void 0; Oe === "style" ? Ee.d.S(De, typeof Pe.precedence == "string" ? Pe.precedence : void 0, { crossOrigin: je, integrity: Be, fetchPriority: Ie }) : Oe === "script" && Ee.d.X(De, { crossOrigin: je, integrity: Be, fetchPriority: Ie, nonce: typeof Pe.nonce == "string" ? Pe.nonce : void 0 }) } }, reactDom_production.preinitModule = function (De, Pe) { if (typeof De == "string") if (typeof Pe == "object" && Pe !== null) { if (Pe.as == null || Pe.as === "script") { var Oe = Me(Pe.as, Pe.crossOrigin); Ee.d.M(De, { crossOrigin: Oe, integrity: typeof Pe.integrity == "string" ? Pe.integrity : void 0, nonce: typeof Pe.nonce == "string" ? Pe.nonce : void 0 }) } } else Pe == null && Ee.d.M(De) }, reactDom_production.preload = function (De, Pe) { if (typeof De == "string" && typeof Pe == "object" && Pe !== null && typeof Pe.as == "string") { var Oe = Pe.as, je = Me(Oe, Pe.crossOrigin); Ee.d.L(De, Oe, { crossOrigin: je, integrity: typeof Pe.integrity == "string" ? Pe.integrity : void 0, nonce: typeof Pe.nonce == "string" ? Pe.nonce : void 0, type: typeof Pe.type == "string" ? Pe.type : void 0, fetchPriority: typeof Pe.fetchPriority == "string" ? Pe.fetchPriority : void 0, referrerPolicy: typeof Pe.referrerPolicy == "string" ? Pe.referrerPolicy : void 0, imageSrcSet: typeof Pe.imageSrcSet == "string" ? Pe.imageSrcSet : void 0, imageSizes: typeof Pe.imageSizes == "string" ? Pe.imageSizes : void 0, media: typeof Pe.media == "string" ? Pe.media : void 0 }) } }, reactDom_production.preloadModule = function (De, Pe) { if (typeof De == "string") if (Pe) { var Oe = Me(Pe.as, Pe.crossOrigin); Ee.d.m(De, { as: typeof Pe.as == "string" && Pe.as !== "script" ? Pe.as : void 0, crossOrigin: Oe, integrity: typeof Pe.integrity == "string" ? Pe.integrity : void 0 }) } else Ee.d.m(De) }, reactDom_production.requestFormReset = function (De) { Ee.d.r(De) }, reactDom_production.unstable_batchedUpdates = function (De, Pe) { return De(Pe) }, reactDom_production.useFormState = function (De, Pe, Oe) { return Ce.H.useFormState(De, Pe, Oe) }, reactDom_production.useFormStatus = function () { return Ce.H.useHostTransitionStatus() }, reactDom_production.version = "19.1.0", reactDom_production } var hasRequiredReactDom; function requireReactDom() { if (hasRequiredReactDom) return reactDom.exports; hasRequiredReactDom = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), reactDom.exports = requireReactDom_production(), reactDom.exports }/**
 * @license React
 * react-dom-client.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredReactDomClient_production; function requireReactDomClient_production() {
  if (hasRequiredReactDomClient_production) return reactDomClient_production; hasRequiredReactDomClient_production = 1; var e = requireScheduler(), t = requireReact(), xe = requireReactDom(); function Ee(Ae) { var Se = "https://react.dev/errors/" + Ae; if (1 < arguments.length) { Se += "?args[]=" + encodeURIComponent(arguments[1]); for (var Te = 2; Te < arguments.length; Te++)Se += "&args[]=" + encodeURIComponent(arguments[Te]) } return "Minified React error #" + Ae + "; visit " + Se + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } function _e(Ae) { return !(!Ae || Ae.nodeType !== 1 && Ae.nodeType !== 9 && Ae.nodeType !== 11) } function Re(Ae) { var Se = Ae, Te = Ae; if (Ae.alternate) for (; Se.return;)Se = Se.return; else { Ae = Se; do Se = Ae, (Se.flags & 4098) !== 0 && (Te = Se.return), Ae = Se.return; while (Ae) } return Se.tag === 3 ? Te : null } function Ce(Ae) { if (Ae.tag === 13) { var Se = Ae.memoizedState; if (Se === null && (Ae = Ae.alternate, Ae !== null && (Se = Ae.memoizedState)), Se !== null) return Se.dehydrated } return null } function Me(Ae) { if (Re(Ae) !== Ae) throw Error(Ee(188)) } function De(Ae) { var Se = Ae.alternate; if (!Se) { if (Se = Re(Ae), Se === null) throw Error(Ee(188)); return Se !== Ae ? null : Ae } for (var Te = Ae, ke = Se; ;) { var $e = Te.return; if ($e === null) break; var Ke = $e.alternate; if (Ke === null) { if (ke = $e.return, ke !== null) { Te = ke; continue } break } if ($e.child === Ke.child) { for (Ke = $e.child; Ke;) { if (Ke === Te) return Me($e), Ae; if (Ke === ke) return Me($e), Se; Ke = Ke.sibling } throw Error(Ee(188)) } if (Te.return !== ke.return) Te = $e, ke = Ke; else { for (var wn = !1, Mn = $e.child; Mn;) { if (Mn === Te) { wn = !0, Te = $e, ke = Ke; break } if (Mn === ke) { wn = !0, ke = $e, Te = Ke; break } Mn = Mn.sibling } if (!wn) { for (Mn = Ke.child; Mn;) { if (Mn === Te) { wn = !0, Te = Ke, ke = $e; break } if (Mn === ke) { wn = !0, ke = Ke, Te = $e; break } Mn = Mn.sibling } if (!wn) throw Error(Ee(189)) } } if (Te.alternate !== ke) throw Error(Ee(190)) } if (Te.tag !== 3) throw Error(Ee(188)); return Te.stateNode.current === Te ? Ae : Se } function Pe(Ae) { var Se = Ae.tag; if (Se === 5 || Se === 26 || Se === 27 || Se === 6) return Ae; for (Ae = Ae.child; Ae !== null;) { if (Se = Pe(Ae), Se !== null) return Se; Ae = Ae.sibling } return null } var Oe = Object.assign, je = Symbol.for("react.element"), Be = Symbol.for("react.transitional.element"), Ie = Symbol.for("react.portal"), Fe = Symbol.for("react.fragment"), ze = Symbol.for("react.strict_mode"), qe = Symbol.for("react.profiler"), He = Symbol.for("react.provider"), Ge = Symbol.for("react.consumer"), Ze = Symbol.for("react.context"), sn = Symbol.for("react.forward_ref"), Xe = Symbol.for("react.suspense"), St = Symbol.for("react.suspense_list"), un = Symbol.for("react.memo"), on = Symbol.for("react.lazy"), bn = Symbol.for("react.activity"), Tn = Symbol.for("react.memo_cache_sentinel"), fn = Symbol.iterator; function En(Ae) { return Ae === null || typeof Ae != "object" ? null : (Ae = fn && Ae[fn] || Ae["@@iterator"], typeof Ae == "function" ? Ae : null) } var Pn = Symbol.for("react.client.reference"); function Rn(Ae) { if (Ae == null) return null; if (typeof Ae == "function") return Ae.$$typeof === Pn ? null : Ae.displayName || Ae.name || null; if (typeof Ae == "string") return Ae; switch (Ae) { case Fe: return "Fragment"; case qe: return "Profiler"; case ze: return "StrictMode"; case Xe: return "Suspense"; case St: return "SuspenseList"; case bn: return "Activity" }if (typeof Ae == "object") switch (Ae.$$typeof) { case Ie: return "Portal"; case Ze: return (Ae.displayName || "Context") + ".Provider"; case Ge: return (Ae._context.displayName || "Context") + ".Consumer"; case sn: var Se = Ae.render; return Ae = Ae.displayName, Ae || (Ae = Se.displayName || Se.name || "", Ae = Ae !== "" ? "ForwardRef(" + Ae + ")" : "ForwardRef"), Ae; case un: return Se = Ae.displayName || null, Se !== null ? Se : Rn(Ae.type) || "Memo"; case on: Se = Ae._payload, Ae = Ae._init; try { return Rn(Ae(Se)) } catch { } }return null } var In = Array.isArray, xn = t.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, vn = xe.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, tn = { pending: !1, data: null, method: null, action: null }, nn = [], We = -1; function dn(Ae) { return { current: Ae } } function Je(Ae) { 0 > We || (Ae.current = nn[We], nn[We] = null, We--) } function rn(Ae, Se) { We++, nn[We] = Ae.current, Ae.current = Se } var hn = dn(null), mn = dn(null), Ye = dn(null), an = dn(null); function pn(Ae, Se) { switch (rn(Ye, Se), rn(mn, Ae), rn(hn, null), Se.nodeType) { case 9: case 11: Ae = (Ae = Se.documentElement) && (Ae = Ae.namespaceURI) ? sm(Ae) : 0; break; default: if (Ae = Se.tagName, Se = Se.namespaceURI) Se = sm(Se), Ae = am(Se, Ae); else switch (Ae) { case "svg": Ae = 1; break; case "math": Ae = 2; break; default: Ae = 0 } }Je(hn), rn(hn, Ae) } function yn() { Je(hn), Je(mn), Je(Ye) } function _n(Ae) { Ae.memoizedState !== null && rn(an, Ae); var Se = hn.current, Te = am(Se, Ae.type); Se !== Te && (rn(mn, Ae), rn(hn, Te)) } function On(Ae) { mn.current === Ae && (Je(hn), Je(mn)), an.current === Ae && (Je(an), Cd._currentValue = tn) } var kn = Object.prototype.hasOwnProperty, zn = e.unstable_scheduleCallback, sr = e.unstable_cancelCallback, Fn = e.unstable_shouldYield, Cn = e.unstable_requestPaint, Vn = e.unstable_now, Yn = e.unstable_getCurrentPriorityLevel, qn = e.unstable_ImmediatePriority, rr = e.unstable_UserBlockingPriority, hr = e.unstable_NormalPriority, ur = e.unstable_LowPriority, Er = e.unstable_IdlePriority, _r = e.log, Or = e.unstable_setDisableYieldValue, Ir = null, Dr = null; function Wr(Ae) { if (typeof _r == "function" && Or(Ae), Dr && typeof Dr.setStrictMode == "function") try { Dr.setStrictMode(Ir, Ae) } catch { } } var Cr = Math.clz32 ? Math.clz32 : wi, zr = Math.log, Tr = Math.LN2; function wi(Ae) { return Ae >>>= 0, Ae === 0 ? 32 : 31 - (zr(Ae) / Tr | 0) | 0 } var Jr = 256, mr = 4194304; function Kn(Ae) { var Se = Ae & 42; if (Se !== 0) return Se; switch (Ae & -Ae) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: return 64; case 128: return 128; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return Ae & 4194048; case 4194304: case 8388608: case 16777216: case 33554432: return Ae & 62914560; case 67108864: return 67108864; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 0; default: return Ae } } function Qn(Ae, Se, Te) { var ke = Ae.pendingLanes; if (ke === 0) return 0; var $e = 0, Ke = Ae.suspendedLanes, wn = Ae.pingedLanes; Ae = Ae.warmLanes; var Mn = ke & 134217727; return Mn !== 0 ? (ke = Mn & ~Ke, ke !== 0 ? $e = Kn(ke) : (wn &= Mn, wn !== 0 ? $e = Kn(wn) : Te || (Te = Mn & ~Ae, Te !== 0 && ($e = Kn(Te))))) : (Mn = ke & ~Ke, Mn !== 0 ? $e = Kn(Mn) : wn !== 0 ? $e = Kn(wn) : Te || (Te = ke & ~Ae, Te !== 0 && ($e = Kn(Te)))), $e === 0 ? 0 : Se !== 0 && Se !== $e && (Se & Ke) === 0 && (Ke = $e & -$e, Te = Se & -Se, Ke >= Te || Ke === 32 && (Te & 4194048) !== 0) ? Se : $e } function Rr(Ae, Se) { return (Ae.pendingLanes & ~(Ae.suspendedLanes & ~Ae.pingedLanes) & Se) === 0 } function kr(Ae, Se) { switch (Ae) { case 1: case 2: case 4: case 8: case 64: return Se + 250; case 16: case 32: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return Se + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: return -1; case 67108864: case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function di() { var Ae = Jr; return Jr <<= 1, (Jr & 4194048) === 0 && (Jr = 256), Ae } function ei() { var Ae = mr; return mr <<= 1, (mr & 62914560) === 0 && (mr = 4194304), Ae } function Wi(Ae) { for (var Se = [], Te = 0; 31 > Te; Te++)Se.push(Ae); return Se } function $i(Ae, Se) { Ae.pendingLanes |= Se, Se !== 268435456 && (Ae.suspendedLanes = 0, Ae.pingedLanes = 0, Ae.warmLanes = 0) } function xi(Ae, Se, Te, ke, $e, Ke) { var wn = Ae.pendingLanes; Ae.pendingLanes = Te, Ae.suspendedLanes = 0, Ae.pingedLanes = 0, Ae.warmLanes = 0, Ae.expiredLanes &= Te, Ae.entangledLanes &= Te, Ae.errorRecoveryDisabledLanes &= Te, Ae.shellSuspendCounter = 0; var Mn = Ae.entanglements, Hn = Ae.expirationTimes, or = Ae.hiddenUpdates; for (Te = wn & ~Te; 0 < Te;) { var gr = 31 - Cr(Te), wr = 1 << gr; Mn[gr] = 0, Hn[gr] = -1; var lr = or[gr]; if (lr !== null) for (or[gr] = null, gr = 0; gr < lr.length; gr++) { var cr = lr[gr]; cr !== null && (cr.lane &= -536870913) } Te &= ~wr } ke !== 0 && Ar(Ae, ke, 0), Ke !== 0 && $e === 0 && Ae.tag !== 0 && (Ae.suspendedLanes |= Ke & ~(wn & ~Se)) } function Ar(Ae, Se, Te) { Ae.pendingLanes |= Se, Ae.suspendedLanes &= ~Se; var ke = 31 - Cr(Se); Ae.entangledLanes |= Se, Ae.entanglements[ke] = Ae.entanglements[ke] | 1073741824 | Te & 4194090 } function Ur(Ae, Se) { var Te = Ae.entangledLanes |= Se; for (Ae = Ae.entanglements; Te;) { var ke = 31 - Cr(Te), $e = 1 << ke; $e & Se | Ae[ke] & Se && (Ae[ke] |= Se), Te &= ~$e } } function hi(Ae) { switch (Ae) { case 2: Ae = 1; break; case 8: Ae = 4; break; case 32: Ae = 16; break; case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: Ae = 128; break; case 268435456: Ae = 134217728; break; default: Ae = 0 }return Ae } function ii(Ae) { return Ae &= -Ae, 2 < Ae ? 8 < Ae ? (Ae & 134217727) !== 0 ? 32 : 268435456 : 8 : 2 } function fi() { var Ae = vn.p; return Ae !== 0 ? Ae : (Ae = window.event, Ae === void 0 ? 32 : _m(Ae.type)) } function yi(Ae, Se) { var Te = vn.p; try { return vn.p = Ae, Se() } finally { vn.p = Te } } var Lr = Math.random().toString(36).slice(2), pi = "__reactFiber$" + Lr, ni = "__reactProps$" + Lr, oi = "__reactContainer$" + Lr, si = "__reactEvents$" + Lr, bi = "__reactListeners$" + Lr, ms = "__reactHandles$" + Lr, Wo = "__reactResources$" + Lr, Ws = "__reactMarker$" + Lr; function Xs(Ae) { delete Ae[pi], delete Ae[ni], delete Ae[si], delete Ae[bi], delete Ae[ms] } function _s(Ae) { var Se = Ae[pi]; if (Se) return Se; for (var Te = Ae.parentNode; Te;) { if (Se = Te[oi] || Te[pi]) { if (Te = Se.alternate, Se.child !== null || Te !== null && Te.child !== null) for (Ae = um(Ae); Ae !== null;) { if (Te = Ae[pi]) return Te; Ae = um(Ae) } return Se } Ae = Te, Te = Ae.parentNode } return null } function Rs(Ae) { if (Ae = Ae[pi] || Ae[oi]) { var Se = Ae.tag; if (Se === 5 || Se === 6 || Se === 13 || Se === 26 || Se === 27 || Se === 3) return Ae } return null } function Bs(Ae) { var Se = Ae.tag; if (Se === 5 || Se === 26 || Se === 27 || Se === 6) return Ae.stateNode; throw Error(Ee(33)) } function ws(Ae) { var Se = Ae[Wo]; return Se || (Se = Ae[Wo] = { hoistableStyles: new Map, hoistableScripts: new Map }), Se } function Li(Ae) { Ae[Ws] = !0 } var po = new Set, Xo = {}; function ta(Ae, Se) { da(Ae, Se), da(Ae + "Capture", Se) } function da(Ae, Se) { for (Xo[Ae] = Se, Ae = 0; Ae < Se.length; Ae++)po.add(Se[Ae]) } var _l = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), vc = {}, eu = {}; function Uu(Ae) { return kn.call(eu, Ae) ? !0 : kn.call(vc, Ae) ? !1 : _l.test(Ae) ? eu[Ae] = !0 : (vc[Ae] = !0, !1) } function Ha(Ae, Se, Te) { if (Uu(Se)) if (Te === null) Ae.removeAttribute(Se); else { switch (typeof Te) { case "undefined": case "function": case "symbol": Ae.removeAttribute(Se); return; case "boolean": var ke = Se.toLowerCase().slice(0, 5); if (ke !== "data-" && ke !== "aria-") { Ae.removeAttribute(Se); return } }Ae.setAttribute(Se, "" + Te) } } function Yo(Ae, Se, Te) { if (Te === null) Ae.removeAttribute(Se); else { switch (typeof Te) { case "undefined": case "function": case "symbol": case "boolean": Ae.removeAttribute(Se); return }Ae.setAttribute(Se, "" + Te) } } function ha(Ae, Se, Te, ke) { if (ke === null) Ae.removeAttribute(Te); else { switch (typeof ke) { case "undefined": case "function": case "symbol": case "boolean": Ae.removeAttribute(Te); return }Ae.setAttributeNS(Se, Te, "" + ke) } } var Ko, tu; function qa(Ae) {
    if (Ko === void 0) try { throw Error() } catch (Te) {
      var Se = Te.stack.trim().match(/\n( *(at )?)/); Ko = Se && Se[1] || "", tu = -1 < Te.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < Te.stack.indexOf("@") ? "@unknown:0:0" : ""
    } return `
`+ Ko + Ae + tu
  } var bc = !1; function mo(Ae, Se) {
    if (!Ae || bc) return ""; bc = !0; var Te = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try {
      var ke = { DetermineComponentFrameRoot: function () { try { if (Se) { var wr = function () { throw Error() }; if (Object.defineProperty(wr.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(wr, []) } catch (cr) { var lr = cr } Reflect.construct(Ae, [], wr) } else { try { wr.call() } catch (cr) { lr = cr } Ae.call(wr.prototype) } } else { try { throw Error() } catch (cr) { lr = cr } (wr = Ae()) && typeof wr.catch == "function" && wr.catch(function () { }) } } catch (cr) { if (cr && lr && typeof cr.stack == "string") return [cr.stack, lr.stack] } return [null, null] } }; ke.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot"; var $e = Object.getOwnPropertyDescriptor(ke.DetermineComponentFrameRoot, "name"); $e && $e.configurable && Object.defineProperty(ke.DetermineComponentFrameRoot, "name", { value: "DetermineComponentFrameRoot" }); var Ke = ke.DetermineComponentFrameRoot(), wn = Ke[0], Mn = Ke[1]; if (wn && Mn) {
        var Hn = wn.split(`
`), or = Mn.split(`
`); for ($e = ke = 0; ke < Hn.length && !Hn[ke].includes("DetermineComponentFrameRoot");)ke++; for (; $e < or.length && !or[$e].includes("DetermineComponentFrameRoot");)$e++; if (ke === Hn.length || $e === or.length) for (ke = Hn.length - 1, $e = or.length - 1; 1 <= ke && 0 <= $e && Hn[ke] !== or[$e];)$e--; for (; 1 <= ke && 0 <= $e; ke--, $e--)if (Hn[ke] !== or[$e]) {
          if (ke !== 1 || $e !== 1) do if (ke--, $e--, 0 > $e || Hn[ke] !== or[$e]) {
            var gr = `
`+ Hn[ke].replace(" at new ", " at "); return Ae.displayName && gr.includes("<anonymous>") && (gr = gr.replace("<anonymous>", Ae.displayName)), gr
          } while (1 <= ke && 0 <= $e); break
        }
      }
    } finally { bc = !1, Error.prepareStackTrace = Te } return (Te = Ae ? Ae.displayName || Ae.name : "") ? qa(Te) : ""
  } function zu(Ae) { switch (Ae.tag) { case 26: case 27: case 5: return qa(Ae.type); case 16: return qa("Lazy"); case 13: return qa("Suspense"); case 19: return qa("SuspenseList"); case 0: case 15: return mo(Ae.type, !1); case 11: return mo(Ae.type.render, !1); case 1: return mo(Ae.type, !0); case 31: return qa("Activity"); default: return "" } } function Xi(Ae) {
    try { var Se = ""; do Se += zu(Ae), Ae = Ae.return; while (Ae); return Se } catch (Te) {
      return `
Error generating stack: `+ Te.message + `
`+ Te.stack
    }
  } function Ls(Ae) { switch (typeof Ae) { case "bigint": case "boolean": case "number": case "string": case "undefined": return Ae; case "object": return Ae; default: return "" } } function xc(Ae) { var Se = Ae.type; return (Ae = Ae.nodeName) && Ae.toLowerCase() === "input" && (Se === "checkbox" || Se === "radio") } function nu(Ae) { var Se = xc(Ae) ? "checked" : "value", Te = Object.getOwnPropertyDescriptor(Ae.constructor.prototype, Se), ke = "" + Ae[Se]; if (!Ae.hasOwnProperty(Se) && typeof Te < "u" && typeof Te.get == "function" && typeof Te.set == "function") { var $e = Te.get, Ke = Te.set; return Object.defineProperty(Ae, Se, { configurable: !0, get: function () { return $e.call(this) }, set: function (wn) { ke = "" + wn, Ke.call(this, wn) } }), Object.defineProperty(Ae, Se, { enumerable: Te.enumerable }), { getValue: function () { return ke }, setValue: function (wn) { ke = "" + wn }, stopTracking: function () { Ae._valueTracker = null, delete Ae[Se] } } } } function go(Ae) { Ae._valueTracker || (Ae._valueTracker = nu(Ae)) } function ru(Ae) { if (!Ae) return !1; var Se = Ae._valueTracker; if (!Se) return !0; var Te = Se.getValue(), ke = ""; return Ae && (ke = xc(Ae) ? Ae.checked ? "true" : "false" : Ae.value), Ae = ke, Ae !== Te ? (Se.setValue(Ae), !0) : !1 } function Us(Ae) { if (Ae = Ae || (typeof document < "u" ? document : void 0), typeof Ae > "u") return null; try { return Ae.activeElement || Ae.body } catch { return Ae.body } } var Rl = /[\n"\\]/g; function Bi(Ae) { return Ae.replace(Rl, function (Se) { return "\\" + Se.charCodeAt(0).toString(16) + " " }) } function Qo(Ae, Se, Te, ke, $e, Ke, wn, Mn) { Ae.name = "", wn != null && typeof wn != "function" && typeof wn != "symbol" && typeof wn != "boolean" ? Ae.type = wn : Ae.removeAttribute("type"), Se != null ? wn === "number" ? (Se === 0 && Ae.value === "" || Ae.value != Se) && (Ae.value = "" + Ls(Se)) : Ae.value !== "" + Ls(Se) && (Ae.value = "" + Ls(Se)) : wn !== "submit" && wn !== "reset" || Ae.removeAttribute("value"), Se != null ? Ec(Ae, wn, Ls(Se)) : Te != null ? Ec(Ae, wn, Ls(Te)) : ke != null && Ae.removeAttribute("value"), $e == null && Ke != null && (Ae.defaultChecked = !!Ke), $e != null && (Ae.checked = $e && typeof $e != "function" && typeof $e != "symbol"), Mn != null && typeof Mn != "function" && typeof Mn != "symbol" && typeof Mn != "boolean" ? Ae.name = "" + Ls(Mn) : Ae.removeAttribute("name") } function yc(Ae, Se, Te, ke, $e, Ke, wn, Mn) { if (Ke != null && typeof Ke != "function" && typeof Ke != "symbol" && typeof Ke != "boolean" && (Ae.type = Ke), Se != null || Te != null) { if (!(Ke !== "submit" && Ke !== "reset" || Se != null)) return; Te = Te != null ? "" + Ls(Te) : "", Se = Se != null ? "" + Ls(Se) : Te, Mn || Se === Ae.value || (Ae.value = Se), Ae.defaultValue = Se } ke = ke ?? $e, ke = typeof ke != "function" && typeof ke != "symbol" && !!ke, Ae.checked = Mn ? Ae.checked : !!ke, Ae.defaultChecked = !!ke, wn != null && typeof wn != "function" && typeof wn != "symbol" && typeof wn != "boolean" && (Ae.name = wn) } function Ec(Ae, Se, Te) { Se === "number" && Us(Ae.ownerDocument) === Ae || Ae.defaultValue === "" + Te || (Ae.defaultValue = "" + Te) } function $a(Ae, Se, Te, ke) { if (Ae = Ae.options, Se) { Se = {}; for (var $e = 0; $e < Te.length; $e++)Se["$" + Te[$e]] = !0; for (Te = 0; Te < Ae.length; Te++)$e = Se.hasOwnProperty("$" + Ae[Te].value), Ae[Te].selected !== $e && (Ae[Te].selected = $e), $e && ke && (Ae[Te].defaultSelected = !0) } else { for (Te = "" + Ls(Te), Se = null, $e = 0; $e < Ae.length; $e++) { if (Ae[$e].value === Te) { Ae[$e].selected = !0, ke && (Ae[$e].defaultSelected = !0); return } Se !== null || Ae[$e].disabled || (Se = Ae[$e]) } Se !== null && (Se.selected = !0) } } function iu(Ae, Se, Te) { if (Se != null && (Se = "" + Ls(Se), Se !== Ae.value && (Ae.value = Se), Te == null)) { Ae.defaultValue !== Se && (Ae.defaultValue = Se); return } Ae.defaultValue = Te != null ? "" + Ls(Te) : "" } function wc(Ae, Se, Te, ke) { if (Se == null) { if (ke != null) { if (Te != null) throw Error(Ee(92)); if (In(ke)) { if (1 < ke.length) throw Error(Ee(93)); ke = ke[0] } Te = ke } Te == null && (Te = ""), Se = Te } Te = Ls(Se), Ae.defaultValue = Te, ke = Ae.textContent, ke === Te && ke !== "" && ke !== null && (Ae.value = ke) } function vo(Ae, Se) { if (Se) { var Te = Ae.firstChild; if (Te && Te === Ae.lastChild && Te.nodeType === 3) { Te.nodeValue = Se; return } } Ae.textContent = Se } var Ac = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" ")); function su(Ae, Se, Te) { var ke = Se.indexOf("--") === 0; Te == null || typeof Te == "boolean" || Te === "" ? ke ? Ae.setProperty(Se, "") : Se === "float" ? Ae.cssFloat = "" : Ae[Se] = "" : ke ? Ae.setProperty(Se, Te) : typeof Te != "number" || Te === 0 || Ac.has(Se) ? Se === "float" ? Ae.cssFloat = Te : Ae[Se] = ("" + Te).trim() : Ae[Se] = Te + "px" } function au(Ae, Se, Te) { if (Se != null && typeof Se != "object") throw Error(Ee(62)); if (Ae = Ae.style, Te != null) { for (var ke in Te) !Te.hasOwnProperty(ke) || Se != null && Se.hasOwnProperty(ke) || (ke.indexOf("--") === 0 ? Ae.setProperty(ke, "") : ke === "float" ? Ae.cssFloat = "" : Ae[ke] = ""); for (var $e in Se) ke = Se[$e], Se.hasOwnProperty($e) && Te[$e] !== ke && su(Ae, $e, ke) } else for (var Ke in Se) Se.hasOwnProperty(Ke) && su(Ae, Ke, Se[Ke]) } function Sc(Ae) { if (Ae.indexOf("-") === -1) return !1; switch (Ae) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Va = new Map([["acceptCharset", "accept-charset"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"], ["crossOrigin", "crossorigin"], ["accentHeight", "accent-height"], ["alignmentBaseline", "alignment-baseline"], ["arabicForm", "arabic-form"], ["baselineShift", "baseline-shift"], ["capHeight", "cap-height"], ["clipPath", "clip-path"], ["clipRule", "clip-rule"], ["colorInterpolation", "color-interpolation"], ["colorInterpolationFilters", "color-interpolation-filters"], ["colorProfile", "color-profile"], ["colorRendering", "color-rendering"], ["dominantBaseline", "dominant-baseline"], ["enableBackground", "enable-background"], ["fillOpacity", "fill-opacity"], ["fillRule", "fill-rule"], ["floodColor", "flood-color"], ["floodOpacity", "flood-opacity"], ["fontFamily", "font-family"], ["fontSize", "font-size"], ["fontSizeAdjust", "font-size-adjust"], ["fontStretch", "font-stretch"], ["fontStyle", "font-style"], ["fontVariant", "font-variant"], ["fontWeight", "font-weight"], ["glyphName", "glyph-name"], ["glyphOrientationHorizontal", "glyph-orientation-horizontal"], ["glyphOrientationVertical", "glyph-orientation-vertical"], ["horizAdvX", "horiz-adv-x"], ["horizOriginX", "horiz-origin-x"], ["imageRendering", "image-rendering"], ["letterSpacing", "letter-spacing"], ["lightingColor", "lighting-color"], ["markerEnd", "marker-end"], ["markerMid", "marker-mid"], ["markerStart", "marker-start"], ["overlinePosition", "overline-position"], ["overlineThickness", "overline-thickness"], ["paintOrder", "paint-order"], ["panose-1", "panose-1"], ["pointerEvents", "pointer-events"], ["renderingIntent", "rendering-intent"], ["shapeRendering", "shape-rendering"], ["stopColor", "stop-color"], ["stopOpacity", "stop-opacity"], ["strikethroughPosition", "strikethrough-position"], ["strikethroughThickness", "strikethrough-thickness"], ["strokeDasharray", "stroke-dasharray"], ["strokeDashoffset", "stroke-dashoffset"], ["strokeLinecap", "stroke-linecap"], ["strokeLinejoin", "stroke-linejoin"], ["strokeMiterlimit", "stroke-miterlimit"], ["strokeOpacity", "stroke-opacity"], ["strokeWidth", "stroke-width"], ["textAnchor", "text-anchor"], ["textDecoration", "text-decoration"], ["textRendering", "text-rendering"], ["transformOrigin", "transform-origin"], ["underlinePosition", "underline-position"], ["underlineThickness", "underline-thickness"], ["unicodeBidi", "unicode-bidi"], ["unicodeRange", "unicode-range"], ["unitsPerEm", "units-per-em"], ["vAlphabetic", "v-alphabetic"], ["vHanging", "v-hanging"], ["vIdeographic", "v-ideographic"], ["vMathematical", "v-mathematical"], ["vectorEffect", "vector-effect"], ["vertAdvY", "vert-adv-y"], ["vertOriginX", "vert-origin-x"], ["vertOriginY", "vert-origin-y"], ["wordSpacing", "word-spacing"], ["writingMode", "writing-mode"], ["xmlnsXlink", "xmlns:xlink"], ["xHeight", "x-height"]]), Cl = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i; function Ga(Ae) { return Cl.test("" + Ae) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : Ae } var Tl = null; function gs(Ae) { return Ae = Ae.target || Ae.srcElement || window, Ae.correspondingUseElement && (Ae = Ae.correspondingUseElement), Ae.nodeType === 3 ? Ae.parentNode : Ae } var bo = null, Wa = null; function Yr(Ae) { var Se = Rs(Ae); if (Se && (Ae = Se.stateNode)) { var Te = Ae[ni] || null; e: switch (Ae = Se.stateNode, Se.type) { case "input": if (Qo(Ae, Te.value, Te.defaultValue, Te.defaultValue, Te.checked, Te.defaultChecked, Te.type, Te.name), Se = Te.name, Te.type === "radio" && Se != null) { for (Te = Ae; Te.parentNode;)Te = Te.parentNode; for (Te = Te.querySelectorAll('input[name="' + Bi("" + Se) + '"][type="radio"]'), Se = 0; Se < Te.length; Se++) { var ke = Te[Se]; if (ke !== Ae && ke.form === Ae.form) { var $e = ke[ni] || null; if (!$e) throw Error(Ee(90)); Qo(ke, $e.value, $e.defaultValue, $e.defaultValue, $e.checked, $e.defaultChecked, $e.type, $e.name) } } for (Se = 0; Se < Te.length; Se++)ke = Te[Se], ke.form === Ae.form && ru(ke) } break e; case "textarea": iu(Ae, Te.value, Te.defaultValue); break e; case "select": Se = Te.value, Se != null && $a(Ae, !!Te.multiple, Se, !1) } } } var _c = !1; function ou(Ae, Se, Te) { if (_c) return Ae(Se, Te); _c = !0; try { var ke = Ae(Se); return ke } finally { if (_c = !1, (bo !== null || Wa !== null) && (lh(), bo && (Se = bo, Ae = Wa, Wa = bo = null, Yr(Se), Ae))) for (Se = 0; Se < Ae.length; Se++)Yr(Ae[Se]) } } function zs(Ae, Se) { var Te = Ae.stateNode; if (Te === null) return null; var ke = Te[ni] || null; if (ke === null) return null; Te = ke[Se]; e: switch (Se) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (ke = !ke.disabled) || (Ae = Ae.type, ke = !(Ae === "button" || Ae === "input" || Ae === "select" || Ae === "textarea")), Ae = !ke; break e; default: Ae = !1 }if (Ae) return null; if (Te && typeof Te != "function") throw Error(Ee(231, Se, typeof Te)); return Te } var na = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Nl = !1; if (na) try { var Ca = {}; Object.defineProperty(Ca, "passive", { get: function () { Nl = !0 } }), window.addEventListener("test", Ca, Ca), window.removeEventListener("test", Ca, Ca) } catch { Nl = !1 } var ra = null, Rc = null, Pl = null; function lu() { if (Pl) return Pl; var Ae, Se = Rc, Te = Se.length, ke, $e = "value" in ra ? ra.value : ra.textContent, Ke = $e.length; for (Ae = 0; Ae < Te && Se[Ae] === $e[Ae]; Ae++); var wn = Te - Ae; for (ke = 1; ke <= wn && Se[Te - ke] === $e[Ke - ke]; ke++); return Pl = $e.slice(Ae, 1 < ke ? 1 - ke : void 0) } function xo(Ae) { var Se = Ae.keyCode; return "charCode" in Ae ? (Ae = Ae.charCode, Ae === 0 && Se === 13 && (Ae = 13)) : Ae = Se, Ae === 10 && (Ae = 13), 32 <= Ae || Ae === 13 ? Ae : 0 } function Ta() { return !0 } function Xa() { return !1 } function Cs(Ae) { function Se(Te, ke, $e, Ke, wn) { this._reactName = Te, this._targetInst = $e, this.type = ke, this.nativeEvent = Ke, this.target = wn, this.currentTarget = null; for (var Mn in Ae) Ae.hasOwnProperty(Mn) && (Te = Ae[Mn], this[Mn] = Te ? Te(Ke) : Ke[Mn]); return this.isDefaultPrevented = (Ke.defaultPrevented != null ? Ke.defaultPrevented : Ke.returnValue === !1) ? Ta : Xa, this.isPropagationStopped = Xa, this } return Oe(Se.prototype, { preventDefault: function () { this.defaultPrevented = !0; var Te = this.nativeEvent; Te && (Te.preventDefault ? Te.preventDefault() : typeof Te.returnValue != "unknown" && (Te.returnValue = !1), this.isDefaultPrevented = Ta) }, stopPropagation: function () { var Te = this.nativeEvent; Te && (Te.stopPropagation ? Te.stopPropagation() : typeof Te.cancelBubble != "unknown" && (Te.cancelBubble = !0), this.isPropagationStopped = Ta) }, persist: function () { }, isPersistent: Ta }), Se } var Ys = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (Ae) { return Ae.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, yo = Cs(Ys), Na = Oe({}, Ys, { view: 0, detail: 0 }), cu = Cs(Na), Ol, Ll, Eo, Ks = Oe({}, Na, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: kl, button: 0, buttons: 0, relatedTarget: function (Ae) { return Ae.relatedTarget === void 0 ? Ae.fromElement === Ae.srcElement ? Ae.toElement : Ae.fromElement : Ae.relatedTarget }, movementX: function (Ae) { return "movementX" in Ae ? Ae.movementX : (Ae !== Eo && (Eo && Ae.type === "mousemove" ? (Ol = Ae.screenX - Eo.screenX, Ll = Ae.screenY - Eo.screenY) : Ll = Ol = 0, Eo = Ae), Ol) }, movementY: function (Ae) { return "movementY" in Ae ? Ae.movementY : Ll } }), Pa = Cs(Ks), Hu = Oe({}, Ks, { dataTransfer: 0 }), wo = Cs(Hu), fa = Oe({}, Na, { relatedTarget: 0 }), Zo = Cs(fa), Jo = Oe({}, Ys, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), qu = Cs(Jo), jl = Oe({}, Ys, { clipboardData: function (Ae) { return "clipboardData" in Ae ? Ae.clipboardData : window.clipboardData } }), $u = Cs(jl), Cc = Oe({}, Ys, { data: 0 }), Ml = Cs(Cc), uu = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, Dl = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Tc = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function Nc(Ae) { var Se = this.nativeEvent; return Se.getModifierState ? Se.getModifierState(Ae) : (Ae = Tc[Ae]) ? !!Se[Ae] : !1 } function kl() { return Nc } var Vu = Oe({}, Na, { key: function (Ae) { if (Ae.key) { var Se = uu[Ae.key] || Ae.key; if (Se !== "Unidentified") return Se } return Ae.type === "keypress" ? (Ae = xo(Ae), Ae === 13 ? "Enter" : String.fromCharCode(Ae)) : Ae.type === "keydown" || Ae.type === "keyup" ? Dl[Ae.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: kl, charCode: function (Ae) { return Ae.type === "keypress" ? xo(Ae) : 0 }, keyCode: function (Ae) { return Ae.type === "keydown" || Ae.type === "keyup" ? Ae.keyCode : 0 }, which: function (Ae) { return Ae.type === "keypress" ? xo(Ae) : Ae.type === "keydown" || Ae.type === "keyup" ? Ae.keyCode : 0 } }), Il = Cs(Vu), el = Oe({}, Ks, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Fl = Cs(el), Ao = Oe({}, Na, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: kl }), Pc = Cs(Ao), Qe = Oe({}, Ys, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Sn = Cs(Qe), Un = Oe({}, Ks, { deltaX: function (Ae) { return "deltaX" in Ae ? Ae.deltaX : "wheelDeltaX" in Ae ? -Ae.wheelDeltaX : 0 }, deltaY: function (Ae) { return "deltaY" in Ae ? Ae.deltaY : "wheelDeltaY" in Ae ? -Ae.wheelDeltaY : "wheelDelta" in Ae ? -Ae.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), $n = Cs(Un), tr = Oe({}, Ys, { newState: 0, oldState: 0 }), fr = Cs(tr), Sr = [9, 13, 27, 32], jr = na && "CompositionEvent" in window, Br = null; na && "documentMode" in document && (Br = document.documentMode); var ti = na && "TextEvent" in window && !Br, Qr = na && (!jr || Br && 8 < Br && 11 >= Br), mi = " ", zi = !1; function Vi(Ae, Se) { switch (Ae) { case "keyup": return Sr.indexOf(Se.keyCode) !== -1; case "keydown": return Se.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Ji(Ae) { return Ae = Ae.detail, typeof Ae == "object" && "data" in Ae ? Ae.data : null } var es = !1; function vs(Ae, Se) { switch (Ae) { case "compositionend": return Ji(Se); case "keypress": return Se.which !== 32 ? null : (zi = !0, mi); case "textInput": return Ae = Se.data, Ae === mi && zi ? null : Ae; default: return null } } function pa(Ae, Se) { if (es) return Ae === "compositionend" || !jr && Vi(Ae, Se) ? (Ae = lu(), Pl = Rc = ra = null, es = !1, Ae) : null; switch (Ae) { case "paste": return null; case "keypress": if (!(Se.ctrlKey || Se.altKey || Se.metaKey) || Se.ctrlKey && Se.altKey) { if (Se.char && 1 < Se.char.length) return Se.char; if (Se.which) return String.fromCharCode(Se.which) } return null; case "compositionend": return Qr && Se.locale !== "ko" ? null : Se.data; default: return null } } var Qs = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function ma(Ae) { var Se = Ae && Ae.nodeName && Ae.nodeName.toLowerCase(); return Se === "input" ? !!Qs[Ae.type] : Se === "textarea" } function Oc(Ae, Se, Te, ke) { bo ? Wa ? Wa.push(ke) : Wa = [ke] : bo = ke, Se = ph(Se, "onChange"), 0 < Se.length && (Te = new yo("onChange", "change", null, Te, ke), Ae.push({ event: Te, listeners: Se })) } var Ya = null, Ka = null; function Bl(Ae) { em(Ae, 0) } function So(Ae) { var Se = Bs(Ae); if (ru(Se)) return Ae } function Ul(Ae, Se) { if (Ae === "change") return Se } var tl = !1; if (na) { var cs; if (na) { var _o = "oninput" in document; if (!_o) { var nl = document.createElement("div"); nl.setAttribute("oninput", "return;"), _o = typeof nl.oninput == "function" } cs = _o } else cs = !1; tl = cs && (!document.documentMode || 9 < document.documentMode) } function rl() { Ya && (Ya.detachEvent("onpropertychange", zl), Ka = Ya = null) } function zl(Ae) { if (Ae.propertyName === "value" && So(Ka)) { var Se = []; Oc(Se, Ka, Ae, gs(Ae)), ou(Bl, Se) } } function Hs(Ae, Se, Te) { Ae === "focusin" ? (rl(), Ya = Se, Ka = Te, Ya.attachEvent("onpropertychange", zl)) : Ae === "focusout" && rl() } function Gu(Ae) { if (Ae === "selectionchange" || Ae === "keyup" || Ae === "keydown") return So(Ka) } function Lc(Ae, Se) { if (Ae === "click") return So(Se) } function du(Ae, Se) { if (Ae === "input" || Ae === "change") return So(Se) } function ia(Ae, Se) { return Ae === Se && (Ae !== 0 || 1 / Ae === 1 / Se) || Ae !== Ae && Se !== Se } var bs = typeof Object.is == "function" ? Object.is : ia; function Ro(Ae, Se) { if (bs(Ae, Se)) return !0; if (typeof Ae != "object" || Ae === null || typeof Se != "object" || Se === null) return !1; var Te = Object.keys(Ae), ke = Object.keys(Se); if (Te.length !== ke.length) return !1; for (ke = 0; ke < Te.length; ke++) { var $e = Te[ke]; if (!kn.call(Se, $e) || !bs(Ae[$e], Se[$e])) return !1 } return !0 } function jc(Ae) { for (; Ae && Ae.firstChild;)Ae = Ae.firstChild; return Ae } function Qa(Ae, Se) { var Te = jc(Ae); Ae = 0; for (var ke; Te;) { if (Te.nodeType === 3) { if (ke = Ae + Te.textContent.length, Ae <= Se && ke >= Se) return { node: Te, offset: Se - Ae }; Ae = ke } e: { for (; Te;) { if (Te.nextSibling) { Te = Te.nextSibling; break e } Te = Te.parentNode } Te = void 0 } Te = jc(Te) } } function Co(Ae, Se) { return Ae && Se ? Ae === Se ? !0 : Ae && Ae.nodeType === 3 ? !1 : Se && Se.nodeType === 3 ? Co(Ae, Se.parentNode) : "contains" in Ae ? Ae.contains(Se) : Ae.compareDocumentPosition ? !!(Ae.compareDocumentPosition(Se) & 16) : !1 : !1 } function js(Ae) { Ae = Ae != null && Ae.ownerDocument != null && Ae.ownerDocument.defaultView != null ? Ae.ownerDocument.defaultView : window; for (var Se = Us(Ae.document); Se instanceof Ae.HTMLIFrameElement;) { try { var Te = typeof Se.contentWindow.location.href == "string" } catch { Te = !1 } if (Te) Ae = Se.contentWindow; else break; Se = Us(Ae.document) } return Se } function As(Ae) { var Se = Ae && Ae.nodeName && Ae.nodeName.toLowerCase(); return Se && (Se === "input" && (Ae.type === "text" || Ae.type === "search" || Ae.type === "tel" || Ae.type === "url" || Ae.type === "password") || Se === "textarea" || Ae.contentEditable === "true") } var To = na && "documentMode" in document && 11 >= document.documentMode, qs = null, ga = null, Oa = null, va = !1; function Yi(Ae, Se, Te) { var ke = Te.window === Te ? Te.document : Te.nodeType === 9 ? Te : Te.ownerDocument; va || qs == null || qs !== Us(ke) || (ke = qs, "selectionStart" in ke && As(ke) ? ke = { start: ke.selectionStart, end: ke.selectionEnd } : (ke = (ke.ownerDocument && ke.ownerDocument.defaultView || window).getSelection(), ke = { anchorNode: ke.anchorNode, anchorOffset: ke.anchorOffset, focusNode: ke.focusNode, focusOffset: ke.focusOffset }), Oa && Ro(Oa, ke) || (Oa = ke, ke = ph(ga, "onSelect"), 0 < ke.length && (Se = new yo("onSelect", "select", null, Se, Te), Ae.push({ event: Se, listeners: ke }), Se.target = qs))) } function ba(Ae, Se) { var Te = {}; return Te[Ae.toLowerCase()] = Se.toLowerCase(), Te["Webkit" + Ae] = "webkit" + Se, Te["Moz" + Ae] = "moz" + Se, Te } var ss = { animationend: ba("Animation", "AnimationEnd"), animationiteration: ba("Animation", "AnimationIteration"), animationstart: ba("Animation", "AnimationStart"), transitionrun: ba("Transition", "TransitionRun"), transitionstart: ba("Transition", "TransitionStart"), transitioncancel: ba("Transition", "TransitionCancel"), transitionend: ba("Transition", "TransitionEnd") }, $s = {}, il = {}; na && (il = document.createElement("div").style, "AnimationEvent" in window || (delete ss.animationend.animation, delete ss.animationiteration.animation, delete ss.animationstart.animation), "TransitionEvent" in window || delete ss.transitionend.transition); function La(Ae) { if ($s[Ae]) return $s[Ae]; if (!ss[Ae]) return Ae; var Se = ss[Ae], Te; for (Te in Se) if (Se.hasOwnProperty(Te) && Te in il) return $s[Ae] = Se[Te]; return Ae } var Hl = La("animationend"), No = La("animationiteration"), Po = La("animationstart"), Oo = La("transitionrun"), sl = La("transitionstart"), ql = La("transitioncancel"), Lo = La("transitionend"), Za = new Map, al = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); al.push("scrollEnd"); function Ki(Ae, Se) { Za.set(Ae, Se), ta(Se, [Ae]) } var Zs = new WeakMap; function li(Ae, Se) { if (typeof Ae == "object" && Ae !== null) { var Te = Zs.get(Ae); return Te !== void 0 ? Te : (Se = { value: Ae, source: Se, stack: Xi(Se) }, Zs.set(Ae, Se), Se) } return { value: Ae, source: Se, stack: Xi(Se) } } var ci = [], ki = 0, ts = 0; function sa() { for (var Ae = ki, Se = ts = ki = 0; Se < Ae;) { var Te = ci[Se]; ci[Se++] = null; var ke = ci[Se]; ci[Se++] = null; var $e = ci[Se]; ci[Se++] = null; var Ke = ci[Se]; if (ci[Se++] = null, ke !== null && $e !== null) { var wn = ke.pending; wn === null ? $e.next = $e : ($e.next = wn.next, wn.next = $e), ke.pending = $e } Ke !== 0 && hu(Te, $e, Ke) } } function jo(Ae, Se, Te, ke) { ci[ki++] = Ae, ci[ki++] = Se, ci[ki++] = Te, ci[ki++] = ke, ts |= ke, Ae.lanes |= ke, Ae = Ae.alternate, Ae !== null && (Ae.lanes |= ke) } function Mo(Ae, Se, Te, ke) { return jo(Ae, Se, Te, ke), ol(Ae) } function Ja(Ae, Se) { return jo(Ae, null, null, Se), ol(Ae) } function hu(Ae, Se, Te) { Ae.lanes |= Te; var ke = Ae.alternate; ke !== null && (ke.lanes |= Te); for (var $e = !1, Ke = Ae.return; Ke !== null;)Ke.childLanes |= Te, ke = Ke.alternate, ke !== null && (ke.childLanes |= Te), Ke.tag === 22 && (Ae = Ke.stateNode, Ae === null || Ae._visibility & 1 || ($e = !0)), Ae = Ke, Ke = Ke.return; return Ae.tag === 3 ? (Ke = Ae.stateNode, $e && Se !== null && ($e = 31 - Cr(Te), Ae = Ke.hiddenUpdates, ke = Ae[$e], ke === null ? Ae[$e] = [Se] : ke.push(Se), Se.lane = Te | 536870912), Ke) : null } function ol(Ae) { if (50 < xd) throw xd = 0, sf = null, Error(Ee(185)); for (var Se = Ae.return; Se !== null;)Ae = Se, Se = Ae.return; return Ae.tag === 3 ? Ae.stateNode : null } var xs = {}; function aa(Ae, Se, Te, ke) { this.tag = Ae, this.key = Te, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = Se, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = ke, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function Ts(Ae, Se, Te, ke) { return new aa(Ae, Se, Te, ke) } function $l(Ae) { return Ae = Ae.prototype, !(!Ae || !Ae.isReactComponent) } function ja(Ae, Se) { var Te = Ae.alternate; return Te === null ? (Te = Ts(Ae.tag, Se, Ae.key, Ae.mode), Te.elementType = Ae.elementType, Te.type = Ae.type, Te.stateNode = Ae.stateNode, Te.alternate = Ae, Ae.alternate = Te) : (Te.pendingProps = Se, Te.type = Ae.type, Te.flags = 0, Te.subtreeFlags = 0, Te.deletions = null), Te.flags = Ae.flags & 65011712, Te.childLanes = Ae.childLanes, Te.lanes = Ae.lanes, Te.child = Ae.child, Te.memoizedProps = Ae.memoizedProps, Te.memoizedState = Ae.memoizedState, Te.updateQueue = Ae.updateQueue, Se = Ae.dependencies, Te.dependencies = Se === null ? null : { lanes: Se.lanes, firstContext: Se.firstContext }, Te.sibling = Ae.sibling, Te.index = Ae.index, Te.ref = Ae.ref, Te.refCleanup = Ae.refCleanup, Te } function Mc(Ae, Se) { Ae.flags &= 65011714; var Te = Ae.alternate; return Te === null ? (Ae.childLanes = 0, Ae.lanes = Se, Ae.child = null, Ae.subtreeFlags = 0, Ae.memoizedProps = null, Ae.memoizedState = null, Ae.updateQueue = null, Ae.dependencies = null, Ae.stateNode = null) : (Ae.childLanes = Te.childLanes, Ae.lanes = Te.lanes, Ae.child = Te.child, Ae.subtreeFlags = 0, Ae.deletions = null, Ae.memoizedProps = Te.memoizedProps, Ae.memoizedState = Te.memoizedState, Ae.updateQueue = Te.updateQueue, Ae.type = Te.type, Se = Te.dependencies, Ae.dependencies = Se === null ? null : { lanes: Se.lanes, firstContext: Se.firstContext }), Ae } function ll(Ae, Se, Te, ke, $e, Ke) { var wn = 0; if (ke = Ae, typeof Ae == "function") $l(Ae) && (wn = 1); else if (typeof Ae == "string") wn = Eg(Ae, Te, hn.current) ? 26 : Ae === "html" || Ae === "head" || Ae === "body" ? 27 : 5; else e: switch (Ae) { case bn: return Ae = Ts(31, Te, Se, $e), Ae.elementType = bn, Ae.lanes = Ke, Ae; case Fe: return eo(Te.children, $e, Ke, Se); case ze: wn = 8, $e |= 24; break; case qe: return Ae = Ts(12, Te, Se, $e | 2), Ae.elementType = qe, Ae.lanes = Ke, Ae; case Xe: return Ae = Ts(13, Te, Se, $e), Ae.elementType = Xe, Ae.lanes = Ke, Ae; case St: return Ae = Ts(19, Te, Se, $e), Ae.elementType = St, Ae.lanes = Ke, Ae; default: if (typeof Ae == "object" && Ae !== null) switch (Ae.$$typeof) { case He: case Ze: wn = 10; break e; case Ge: wn = 9; break e; case sn: wn = 11; break e; case un: wn = 14; break e; case on: wn = 16, ke = null; break e }wn = 29, Te = Error(Ee(130, Ae === null ? "null" : typeof Ae, "")), ke = null }return Se = Ts(wn, Te, Se, $e), Se.elementType = Ae, Se.type = ke, Se.lanes = Ke, Se } function eo(Ae, Se, Te, ke) { return Ae = Ts(7, Ae, ke, Se), Ae.lanes = Te, Ae } function fu(Ae, Se, Te) { return Ae = Ts(6, Ae, null, Se), Ae.lanes = Te, Ae } function Dc(Ae, Se, Te) { return Se = Ts(4, Ae.children !== null ? Ae.children : [], Ae.key, Se), Se.lanes = Te, Se.stateNode = { containerInfo: Ae.containerInfo, pendingChildren: null, implementation: Ae.implementation }, Se } var Do = [], to = 0, Vl = null, pu = 0, oa = [], Js = 0, cl = null, no = 1, ro = ""; function ul(Ae, Se) { Do[to++] = pu, Do[to++] = Vl, Vl = Ae, pu = Se } function Ld(Ae, Se, Te) { oa[Js++] = no, oa[Js++] = ro, oa[Js++] = cl, cl = Ae; var ke = no; Ae = ro; var $e = 32 - Cr(ke) - 1; ke &= ~(1 << $e), Te += 1; var Ke = 32 - Cr(Se) + $e; if (30 < Ke) { var wn = $e - $e % 5; Ke = (ke & (1 << wn) - 1).toString(32), ke >>= wn, $e -= wn, no = 1 << 32 - Cr(Se) + $e | Te << $e | ke, ro = Ke + Ae } else no = 1 << Ke | Te << $e | ke, ro = Ae } function kc(Ae) { Ae.return !== null && (ul(Ae, 1), Ld(Ae, 1, 0)) } function Ic(Ae) { for (; Ae === Vl;)Vl = Do[--to], Do[to] = null, pu = Do[--to], Do[to] = null; for (; Ae === cl;)cl = oa[--Js], oa[Js] = null, ro = oa[--Js], oa[Js] = null, no = oa[--Js], oa[Js] = null } var us = null, Qi = null, Ri = !1, ko = null, Ma = !1, Wu = Error(Ee(519)); function dl(Ae) { var Se = Error(Ee(418, "")); throw Gl(li(Se, Ae)), Wu } function jd(Ae) { var Se = Ae.stateNode, Te = Ae.type, ke = Ae.memoizedProps; switch (Se[pi] = Ae, Se[ni] = ke, Te) { case "dialog": vi("cancel", Se), vi("close", Se); break; case "iframe": case "object": case "embed": vi("load", Se); break; case "video": case "audio": for (Te = 0; Te < Ed.length; Te++)vi(Ed[Te], Se); break; case "source": vi("error", Se); break; case "img": case "image": case "link": vi("error", Se), vi("load", Se); break; case "details": vi("toggle", Se); break; case "input": vi("invalid", Se), yc(Se, ke.value, ke.defaultValue, ke.checked, ke.defaultChecked, ke.type, ke.name, !0), go(Se); break; case "select": vi("invalid", Se); break; case "textarea": vi("invalid", Se), wc(Se, ke.value, ke.defaultValue, ke.children), go(Se) }Te = ke.children, typeof Te != "string" && typeof Te != "number" && typeof Te != "bigint" || Se.textContent === "" + Te || ke.suppressHydrationWarning === !0 || im(Se.textContent, Te) ? (ke.popover != null && (vi("beforetoggle", Se), vi("toggle", Se)), ke.onScroll != null && vi("scroll", Se), ke.onScrollEnd != null && vi("scrollend", Se), ke.onClick != null && (Se.onclick = mh), Se = !0) : Se = !1, Se || dl(Ae) } function io(Ae) { for (us = Ae.return; us;)switch (us.tag) { case 5: case 13: Ma = !1; return; case 27: case 3: Ma = !0; return; default: us = us.return } } function Ms(Ae) { if (Ae !== us) return !1; if (!Ri) return io(Ae), Ri = !0, !1; var Se = Ae.tag, Te; if ((Te = Se !== 3 && Se !== 27) && ((Te = Se === 5) && (Te = Ae.type, Te = !(Te !== "form" && Te !== "button") || Ef(Ae.type, Ae.memoizedProps)), Te = !Te), Te && Qi && dl(Ae), io(Ae), Se === 13) { if (Ae = Ae.memoizedState, Ae = Ae !== null ? Ae.dehydrated : null, !Ae) throw Error(Ee(317)); e: { for (Ae = Ae.nextSibling, Se = 0; Ae;) { if (Ae.nodeType === 8) if (Te = Ae.data, Te === "/$") { if (Se === 0) { Qi = fo(Ae.nextSibling); break e } Se-- } else Te !== "$" && Te !== "$!" && Te !== "$?" || Se++; Ae = Ae.nextSibling } Qi = null } } else Se === 27 ? (Se = Qi, dc(Ae.type) ? (Ae = _f, _f = null, Qi = Ae) : Qi = Se) : Qi = us ? fo(Ae.stateNode.nextSibling) : null; return !0 } function ea() { Qi = us = null, Ri = !1 } function Md() { var Ae = ko; return Ae !== null && (ua === null ? ua = Ae : ua.push.apply(ua, Ae), ko = null), Ae } function Gl(Ae) { ko === null ? ko = [Ae] : ko.push(Ae) } var Da = dn(null), ys = null, so = null; function Io(Ae, Se, Te) { rn(Da, Se._currentValue), Se._currentValue = Te } function ka(Ae) { Ae._currentValue = Da.current, Je(Da) } function mu(Ae, Se, Te) { for (; Ae !== null;) { var ke = Ae.alternate; if ((Ae.childLanes & Se) !== Se ? (Ae.childLanes |= Se, ke !== null && (ke.childLanes |= Se)) : ke !== null && (ke.childLanes & Se) !== Se && (ke.childLanes |= Se), Ae === Te) break; Ae = Ae.return } } function gu(Ae, Se, Te, ke) { var $e = Ae.child; for ($e !== null && ($e.return = Ae); $e !== null;) { var Ke = $e.dependencies; if (Ke !== null) { var wn = $e.child; Ke = Ke.firstContext; e: for (; Ke !== null;) { var Mn = Ke; Ke = $e; for (var Hn = 0; Hn < Se.length; Hn++)if (Mn.context === Se[Hn]) { Ke.lanes |= Te, Mn = Ke.alternate, Mn !== null && (Mn.lanes |= Te), mu(Ke.return, Te, Ae), ke || (wn = null); break e } Ke = Mn.next } } else if ($e.tag === 18) { if (wn = $e.return, wn === null) throw Error(Ee(341)); wn.lanes |= Te, Ke = wn.alternate, Ke !== null && (Ke.lanes |= Te), mu(wn, Te, Ae), wn = null } else wn = $e.child; if (wn !== null) wn.return = $e; else for (wn = $e; wn !== null;) { if (wn === Ae) { wn = null; break } if ($e = wn.sibling, $e !== null) { $e.return = wn.return, wn = $e; break } wn = wn.return } $e = wn } } function Wl(Ae, Se, Te, ke) { Ae = null; for (var $e = Se, Ke = !1; $e !== null;) { if (!Ke) { if (($e.flags & 524288) !== 0) Ke = !0; else if (($e.flags & 262144) !== 0) break } if ($e.tag === 10) { var wn = $e.alternate; if (wn === null) throw Error(Ee(387)); if (wn = wn.memoizedProps, wn !== null) { var Mn = $e.type; bs($e.pendingProps.value, wn.value) || (Ae !== null ? Ae.push(Mn) : Ae = [Mn]) } } else if ($e === an.current) { if (wn = $e.alternate, wn === null) throw Error(Ee(387)); wn.memoizedState.memoizedState !== $e.memoizedState.memoizedState && (Ae !== null ? Ae.push(Cd) : Ae = [Cd]) } $e = $e.return } Ae !== null && gu(Se, Ae, Te, ke), Se.flags |= 262144 } function vu(Ae) { for (Ae = Ae.firstContext; Ae !== null;) { if (!bs(Ae.context._currentValue, Ae.memoizedValue)) return !0; Ae = Ae.next } return !1 } function Ia(Ae) { ys = Ae, so = null, Ae = Ae.dependencies, Ae !== null && (Ae.firstContext = null) } function ds(Ae) { return bu(ys, Ae) } function Fo(Ae, Se) { return ys === null && Ia(Ae), bu(Ae, Se) } function bu(Ae, Se) { var Te = Se._currentValue; if (Se = { context: Se, memoizedValue: Te, next: null }, so === null) { if (Ae === null) throw Error(Ee(308)); so = Se, Ae.dependencies = { lanes: 0, firstContext: Se }, Ae.flags |= 524288 } else so = so.next = Se; return Te } var Nh = typeof AbortController < "u" ? AbortController : function () { var Ae = [], Se = this.signal = { aborted: !1, addEventListener: function (Te, ke) { Ae.push(ke) } }; this.abort = function () { Se.aborted = !0, Ae.forEach(function (Te) { return Te() }) } }, Dd = e.unstable_scheduleCallback, Ph = e.unstable_NormalPriority, hs = { $$typeof: Ze, Consumer: null, Provider: null, _currentValue: null, _currentValue2: null, _threadCount: 0 }; function Xu() { return { controller: new Nh, data: new Map, refCount: 0 } } function Fc(Ae) { Ae.refCount--, Ae.refCount === 0 && Dd(Ph, function () { Ae.controller.abort() }) } var Bc = null, Yu = 0, hl = 0, ao = null; function Oh(Ae, Se) { if (Bc === null) { var Te = Bc = []; Yu = 0, hl = hf(), ao = { status: "pending", value: void 0, then: function (ke) { Te.push(ke) } } } return Yu++, Se.then(kd, kd), Se } function kd() { if (--Yu === 0 && Bc !== null) { ao !== null && (ao.status = "fulfilled"); var Ae = Bc; Bc = null, hl = 0, ao = null; for (var Se = 0; Se < Ae.length; Se++)(0, Ae[Se])() } } function Id(Ae, Se) { var Te = [], ke = { status: "pending", value: null, reason: null, then: function ($e) { Te.push($e) } }; return Ae.then(function () { ke.status = "fulfilled", ke.value = Se; for (var $e = 0; $e < Te.length; $e++)(0, Te[$e])(Se) }, function ($e) { for (ke.status = "rejected", ke.reason = $e, $e = 0; $e < Te.length; $e++)(0, Te[$e])(void 0) }), ke } var Ue = xn.S; xn.S = function (Ae, Se) { typeof Se == "object" && Se !== null && typeof Se.then == "function" && Oh(Ae, Se), Ue !== null && Ue(Ae, Se) }; var Ve = dn(null); function en() { var Ae = Ve.current; return Ae !== null ? Ae : qi.pooledCache } function gn(Ae, Se) { Se === null ? rn(Ve, Ve.current) : rn(Ve, Se.pool) } function An() { var Ae = en(); return Ae === null ? null : { parent: hs._currentValue, pool: Ae } } var Nn = Error(Ee(460)), Ln = Error(Ee(474)), jn = Error(Ee(542)), Dn = { then: function () { } }; function Bn(Ae) { return Ae = Ae.status, Ae === "fulfilled" || Ae === "rejected" } function Gn() { } function ar(Ae, Se, Te) { switch (Te = Ae[Te], Te === void 0 ? Ae.push(Se) : Te !== Se && (Se.then(Gn, Gn), Se = Te), Se.status) { case "fulfilled": return Se.value; case "rejected": throw Ae = Se.reason, xr(Ae), Ae; default: if (typeof Se.status == "string") Se.then(Gn, Gn); else { if (Ae = qi, Ae !== null && 100 < Ae.shellSuspendCounter) throw Error(Ee(482)); Ae = Se, Ae.status = "pending", Ae.then(function (ke) { if (Se.status === "pending") { var $e = Se; $e.status = "fulfilled", $e.value = ke } }, function (ke) { if (Se.status === "pending") { var $e = Se; $e.status = "rejected", $e.reason = ke } }) } switch (Se.status) { case "fulfilled": return Se.value; case "rejected": throw Ae = Se.reason, xr(Ae), Ae }throw nr = Se, Nn } } var nr = null; function Jn() { if (nr === null) throw Error(Ee(459)); var Ae = nr; return nr = null, Ae } function xr(Ae) { if (Ae === Nn || Ae === jn) throw Error(Ee(483)) } var dr = !1; function Wn(Ae) { Ae.updateQueue = { baseState: Ae.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, lanes: 0, hiddenCallbacks: null }, callbacks: null } } function Zn(Ae, Se) { Ae = Ae.updateQueue, Se.updateQueue === Ae && (Se.updateQueue = { baseState: Ae.baseState, firstBaseUpdate: Ae.firstBaseUpdate, lastBaseUpdate: Ae.lastBaseUpdate, shared: Ae.shared, callbacks: null }) } function pr(Ae) { return { lane: Ae, tag: 0, payload: null, callback: null, next: null } } function yr(Ae, Se, Te) { var ke = Ae.updateQueue; if (ke === null) return null; if (ke = ke.shared, (Mi & 2) !== 0) { var $e = ke.pending; return $e === null ? Se.next = Se : (Se.next = $e.next, $e.next = Se), ke.pending = Se, Se = ol(Ae), hu(Ae, null, Te), Se } return jo(Ae, ke, Se, Te), ol(Ae) } function vr(Ae, Se, Te) { if (Se = Se.updateQueue, Se !== null && (Se = Se.shared, (Te & 4194048) !== 0)) { var ke = Se.lanes; ke &= Ae.pendingLanes, Te |= ke, Se.lanes = Te, Ur(Ae, Te) } } function Mr(Ae, Se) { var Te = Ae.updateQueue, ke = Ae.alternate; if (ke !== null && (ke = ke.updateQueue, Te === ke)) { var $e = null, Ke = null; if (Te = Te.firstBaseUpdate, Te !== null) { do { var wn = { lane: Te.lane, tag: Te.tag, payload: Te.payload, callback: null, next: null }; Ke === null ? $e = Ke = wn : Ke = Ke.next = wn, Te = Te.next } while (Te !== null); Ke === null ? $e = Ke = Se : Ke = Ke.next = Se } else $e = Ke = Se; Te = { baseState: ke.baseState, firstBaseUpdate: $e, lastBaseUpdate: Ke, shared: ke.shared, callbacks: ke.callbacks }, Ae.updateQueue = Te; return } Ae = Te.lastBaseUpdate, Ae === null ? Te.firstBaseUpdate = Se : Ae.next = Se, Te.lastBaseUpdate = Se } var Nr = !1; function Hr() { if (Nr) { var Ae = ao; if (Ae !== null) throw Ae } } function Pr(Ae, Se, Te, ke) { Nr = !1; var $e = Ae.updateQueue; dr = !1; var Ke = $e.firstBaseUpdate, wn = $e.lastBaseUpdate, Mn = $e.shared.pending; if (Mn !== null) { $e.shared.pending = null; var Hn = Mn, or = Hn.next; Hn.next = null, wn === null ? Ke = or : wn.next = or, wn = Hn; var gr = Ae.alternate; gr !== null && (gr = gr.updateQueue, Mn = gr.lastBaseUpdate, Mn !== wn && (Mn === null ? gr.firstBaseUpdate = or : Mn.next = or, gr.lastBaseUpdate = Hn)) } if (Ke !== null) { var wr = $e.baseState; wn = 0, gr = or = Hn = null, Mn = Ke; do { var lr = Mn.lane & -536870913, cr = lr !== Mn.lane; if (cr ? (_i & lr) === lr : (ke & lr) === lr) { lr !== 0 && lr === hl && (Nr = !0), gr !== null && (gr = gr.next = { lane: 0, tag: Mn.tag, payload: Mn.payload, callback: null, next: null }); e: { var Kr = Ae, Vr = Mn; lr = Se; var Fi = Te; switch (Vr.tag) { case 1: if (Kr = Vr.payload, typeof Kr == "function") { wr = Kr.call(Fi, wr, lr); break e } wr = Kr; break e; case 3: Kr.flags = Kr.flags & -65537 | 128; case 0: if (Kr = Vr.payload, lr = typeof Kr == "function" ? Kr.call(Fi, wr, lr) : Kr, lr == null) break e; wr = Oe({}, wr, lr); break e; case 2: dr = !0 } } lr = Mn.callback, lr !== null && (Ae.flags |= 64, cr && (Ae.flags |= 8192), cr = $e.callbacks, cr === null ? $e.callbacks = [lr] : cr.push(lr)) } else cr = { lane: lr, tag: Mn.tag, payload: Mn.payload, callback: Mn.callback, next: null }, gr === null ? (or = gr = cr, Hn = wr) : gr = gr.next = cr, wn |= lr; if (Mn = Mn.next, Mn === null) { if (Mn = $e.shared.pending, Mn === null) break; cr = Mn, Mn = cr.next, cr.next = null, $e.lastBaseUpdate = cr, $e.shared.pending = null } } while (!0); gr === null && (Hn = wr), $e.baseState = Hn, $e.firstBaseUpdate = or, $e.lastBaseUpdate = gr, Ke === null && ($e.shared.lanes = 0), ac |= wn, Ae.lanes = wn, Ae.memoizedState = wr } } function Ai(Ae, Se) { if (typeof Ae != "function") throw Error(Ee(191, Ae)); Ae.call(Se) } function Ci(Ae, Se) { var Te = Ae.callbacks; if (Te !== null) for (Ae.callbacks = null, Ae = 0; Ae < Te.length; Ae++)Ai(Te[Ae], Se) } var ai = dn(null), ri = dn(0); function Oi(Ae, Se) { Ae = Al, rn(ri, Ae), rn(ai, Se), Al = Ae | Se.baseLanes } function Ti() { rn(ri, Al), rn(ai, ai.current) } function Zr() { Al = ri.current, Je(ai), Je(ri) } var ji = 0, $r = null, Xr = null, Ei = null, Si = !1, Es = !1, fs = !1, ns = 0, rs = 0, as = null, la = 0; function Ni() { throw Error(Ee(321)) } function os(Ae, Se) { if (Se === null) return !1; for (var Te = 0; Te < Se.length && Te < Ae.length; Te++)if (!bs(Ae[Te], Se[Te])) return !1; return !0 } function xa(Ae, Se, Te, ke, $e, Ke) { return ji = Ke, $r = Se, Se.memoizedState = null, Se.updateQueue = null, Se.lanes = 0, xn.H = Ae === null || Ae.memoizedState === null ? Ff : Bf, fs = !1, Ke = Te(ke, $e), fs = !1, Es && (Ke = pl(Se, Te, ke, $e)), Bo(Ae), Ke } function Bo(Ae) { xn.H = Yd; var Se = Xr !== null && Xr.next !== null; if (ji = 0, Ei = Xr = $r = null, Si = !1, rs = 0, as = null, Se) throw Error(Ee(300)); Ae === null || Ns || (Ae = Ae.dependencies, Ae !== null && vu(Ae) && (Ns = !0)) } function pl(Ae, Se, Te, ke) { $r = Ae; var $e = 0; do { if (Es && (as = null), rs = 0, Es = !1, 25 <= $e) throw Error(Ee(301)); if ($e += 1, Ei = Xr = null, Ae.updateQueue != null) { var Ke = Ae.updateQueue; Ke.lastEffect = null, Ke.events = null, Ke.stores = null, Ke.memoCache != null && (Ke.memoCache.index = 0) } xn.H = Lm, Ke = Se(Te, ke) } while (Es); return Ke } function Uo() { var Ae = xn.H, Se = Ae.useState()[0]; return Se = typeof Se.then == "function" ? zo(Se) : Se, Ae = Ae.useState()[0], (Xr !== null ? Xr.memoizedState : null) !== Ae && ($r.flags |= 1024), Se } function Hi() { var Ae = ns !== 0; return ns = 0, Ae } function Uc(Ae, Se, Te) { Se.updateQueue = Ae.updateQueue, Se.flags &= -2053, Ae.lanes &= ~Te } function xu(Ae) { if (Si) { for (Ae = Ae.memoizedState; Ae !== null;) { var Se = Ae.queue; Se !== null && (Se.pending = null), Ae = Ae.next } Si = !1 } ji = 0, Ei = Xr = $r = null, Es = !1, rs = ns = 0, as = null } function Ds() { var Ae = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Ei === null ? $r.memoizedState = Ei = Ae : Ei = Ei.next = Ae, Ei } function Gi() { if (Xr === null) { var Ae = $r.alternate; Ae = Ae !== null ? Ae.memoizedState : null } else Ae = Xr.next; var Se = Ei === null ? $r.memoizedState : Ei.next; if (Se !== null) Ei = Se, Xr = Ae; else { if (Ae === null) throw $r.alternate === null ? Error(Ee(467)) : Error(Ee(310)); Xr = Ae, Ae = { memoizedState: Xr.memoizedState, baseState: Xr.baseState, baseQueue: Xr.baseQueue, queue: Xr.queue, next: null }, Ei === null ? $r.memoizedState = Ei = Ae : Ei = Ei.next = Ae } return Ei } function ml() { return { lastEffect: null, events: null, stores: null, memoCache: null } } function zo(Ae) { var Se = rs; return rs += 1, as === null && (as = []), Ae = ar(as, Ae, Se), Se = $r, (Ei === null ? Se.memoizedState : Ei.next) === null && (Se = Se.alternate, xn.H = Se === null || Se.memoizedState === null ? Ff : Bf), Ae } function Vs(Ae) { if (Ae !== null && typeof Ae == "object") { if (typeof Ae.then == "function") return zo(Ae); if (Ae.$$typeof === Ze) return ds(Ae) } throw Error(Ee(438, String(Ae))) } function Ho(Ae) { var Se = null, Te = $r.updateQueue; if (Te !== null && (Se = Te.memoCache), Se == null) { var ke = $r.alternate; ke !== null && (ke = ke.updateQueue, ke !== null && (ke = ke.memoCache, ke != null && (Se = { data: ke.data.map(function ($e) { return $e.slice() }), index: 0 }))) } if (Se == null && (Se = { data: [], index: 0 }), Te === null && (Te = ml(), $r.updateQueue = Te), Te.memoCache = Se, Te = Se.data[Se.index], Te === void 0) for (Te = Se.data[Se.index] = Array(Ae), ke = 0; ke < Ae; ke++)Te[ke] = Tn; return Se.index++, Te } function Gs(Ae, Se) { return typeof Se == "function" ? Se(Ae) : Se } function zc(Ae) { var Se = Gi(); return Xl(Se, Xr, Ae) } function Xl(Ae, Se, Te) { var ke = Ae.queue; if (ke === null) throw Error(Ee(311)); ke.lastRenderedReducer = Te; var $e = Ae.baseQueue, Ke = ke.pending; if (Ke !== null) { if ($e !== null) { var wn = $e.next; $e.next = Ke.next, Ke.next = wn } Se.baseQueue = $e = Ke, ke.pending = null } if (Ke = Ae.baseState, $e === null) Ae.memoizedState = Ke; else { Se = $e.next; var Mn = wn = null, Hn = null, or = Se, gr = !1; do { var wr = or.lane & -536870913; if (wr !== or.lane ? (_i & wr) === wr : (ji & wr) === wr) { var lr = or.revertLane; if (lr === 0) Hn !== null && (Hn = Hn.next = { lane: 0, revertLane: 0, action: or.action, hasEagerState: or.hasEagerState, eagerState: or.eagerState, next: null }), wr === hl && (gr = !0); else if ((ji & lr) === lr) { or = or.next, lr === hl && (gr = !0); continue } else wr = { lane: 0, revertLane: or.revertLane, action: or.action, hasEagerState: or.hasEagerState, eagerState: or.eagerState, next: null }, Hn === null ? (Mn = Hn = wr, wn = Ke) : Hn = Hn.next = wr, $r.lanes |= lr, ac |= lr; wr = or.action, fs && Te(Ke, wr), Ke = or.hasEagerState ? or.eagerState : Te(Ke, wr) } else lr = { lane: wr, revertLane: or.revertLane, action: or.action, hasEagerState: or.hasEagerState, eagerState: or.eagerState, next: null }, Hn === null ? (Mn = Hn = lr, wn = Ke) : Hn = Hn.next = lr, $r.lanes |= wr, ac |= wr; or = or.next } while (or !== null && or !== Se); if (Hn === null ? wn = Ke : Hn.next = Mn, !bs(Ke, Ae.memoizedState) && (Ns = !0, gr && (Te = ao, Te !== null))) throw Te; Ae.memoizedState = Ke, Ae.baseState = wn, Ae.baseQueue = Hn, ke.lastRenderedState = Ke } return $e === null && (ke.lanes = 0), [Ae.memoizedState, ke.dispatch] } function yu(Ae) { var Se = Gi(), Te = Se.queue; if (Te === null) throw Error(Ee(311)); Te.lastRenderedReducer = Ae; var ke = Te.dispatch, $e = Te.pending, Ke = Se.memoizedState; if ($e !== null) { Te.pending = null; var wn = $e = $e.next; do Ke = Ae(Ke, wn.action), wn = wn.next; while (wn !== $e); bs(Ke, Se.memoizedState) || (Ns = !0), Se.memoizedState = Ke, Se.baseQueue === null && (Se.baseState = Ke), Te.lastRenderedState = Ke } return [Ke, ke] } function Hc(Ae, Se, Te) { var ke = $r, $e = Gi(), Ke = Ri; if (Ke) { if (Te === void 0) throw Error(Ee(407)); Te = Te() } else Te = Se(); var wn = !bs((Xr || $e).memoizedState, Te); wn && ($e.memoizedState = Te, Ns = !0), $e = $e.queue; var Mn = Yl.bind(null, ke, $e, Ae); if (Zl(2048, 8, Mn, [Ae]), $e.getSnapshot !== Se || wn || Ei !== null && Ei.memoizedState.tag & 1) { if (ke.flags |= 2048, lo(9, Gc(), qc.bind(null, ke, $e, Te, Se), null), qi === null) throw Error(Ee(349)); Ke || (ji & 124) !== 0 || Eu(ke, Se, Te) } return Te } function Eu(Ae, Se, Te) { Ae.flags |= 16384, Ae = { getSnapshot: Se, value: Te }, Se = $r.updateQueue, Se === null ? (Se = ml(), $r.updateQueue = Se, Se.stores = [Ae]) : (Te = Se.stores, Te === null ? Se.stores = [Ae] : Te.push(Ae)) } function qc(Ae, Se, Te, ke) { Se.value = Te, Se.getSnapshot = ke, Fd(Se) && Bd(Ae) } function Yl(Ae, Se, Te) { return Te(function () { Fd(Se) && Bd(Ae) }) } function Fd(Ae) { var Se = Ae.getSnapshot; Ae = Ae.value; try { var Te = Se(); return !bs(Ae, Te) } catch { return !0 } } function Bd(Ae) { var Se = Ja(Ae, 2); Se !== null && Ra(Se, Ae, 2) } function $c(Ae) { var Se = Ds(); if (typeof Ae == "function") { var Te = Ae; if (Ae = Te(), fs) { Wr(!0); try { Te() } finally { Wr(!1) } } } return Se.memoizedState = Se.baseState = Ae, Se.queue = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Gs, lastRenderedState: Ae }, Se } function oo(Ae, Se, Te, ke) { return Ae.baseState = Te, Xl(Ae, Xr, typeof ke == "function" ? ke : Gs) } function Lh(Ae, Se, Te, ke, $e) { if (Xd(Ae)) throw Error(Ee(485)); if (Ae = Se.action, Ae !== null) { var Ke = { payload: $e, action: Ae, next: null, isTransition: !0, status: "pending", value: null, reason: null, listeners: [], then: function (wn) { Ke.listeners.push(wn) } }; xn.T !== null ? Te(!0) : Ke.isTransition = !1, ke(Ke), Te = Se.pending, Te === null ? (Ke.next = Se.pending = Ke, Ud(Se, Ke)) : (Ke.next = Te.next, Se.pending = Te.next = Ke) } } function Ud(Ae, Se) { var Te = Se.action, ke = Se.payload, $e = Ae.state; if (Se.isTransition) { var Ke = xn.T, wn = {}; xn.T = wn; try { var Mn = Te($e, ke), Hn = xn.S; Hn !== null && Hn(wn, Mn), zd(Ae, Se, Mn) } catch (or) { Kl(Ae, Se, or) } finally { xn.T = Ke } } else try { Ke = Te($e, ke), zd(Ae, Se, Ke) } catch (or) { Kl(Ae, Se, or) } } function zd(Ae, Se, Te) { Te !== null && typeof Te == "object" && typeof Te.then == "function" ? Te.then(function (ke) { Ku(Ae, Se, ke) }, function (ke) { return Kl(Ae, Se, ke) }) : Ku(Ae, Se, Te) } function Ku(Ae, Se, Te) { Se.status = "fulfilled", Se.value = Te, Qu(Se), Ae.state = Te, Se = Ae.pending, Se !== null && (Te = Se.next, Te === Se ? Ae.pending = null : (Te = Te.next, Se.next = Te, Ud(Ae, Te))) } function Kl(Ae, Se, Te) { var ke = Ae.pending; if (Ae.pending = null, ke !== null) { ke = ke.next; do Se.status = "rejected", Se.reason = Te, Qu(Se), Se = Se.next; while (Se !== ke) } Ae.action = null } function Qu(Ae) { Ae = Ae.listeners; for (var Se = 0; Se < Ae.length; Se++)(0, Ae[Se])() } function Zu(Ae, Se) { return Se } function Vc(Ae, Se) { if (Ri) { var Te = qi.formState; if (Te !== null) { e: { var ke = $r; if (Ri) { if (Qi) { t: { for (var $e = Qi, Ke = Ma; $e.nodeType !== 8;) { if (!Ke) { $e = null; break t } if ($e = fo($e.nextSibling), $e === null) { $e = null; break t } } Ke = $e.data, $e = Ke === "F!" || Ke === "F" ? $e : null } if ($e) { Qi = fo($e.nextSibling), ke = $e.data === "F!"; break e } } dl(ke) } ke = !1 } ke && (Se = Te[0]) } } return Te = Ds(), Te.memoizedState = Te.baseState = Se, ke = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Zu, lastRenderedState: Se }, Te.queue = ke, Te = Df.bind(null, $r, ke), ke.dispatch = Te, ke = $c(!1), Ke = jh.bind(null, $r, !1, ke.queue), ke = Ds(), $e = { state: Se, dispatch: null, action: Ae, pending: null }, ke.queue = $e, Te = Lh.bind(null, $r, $e, Ke, Te), $e.dispatch = Te, ke.memoizedState = Ae, [Se, Te, !1] } function wu(Ae) { var Se = Gi(); return Ql(Se, Xr, Ae) } function Ql(Ae, Se, Te) { if (Se = Xl(Ae, Se, Zu)[0], Ae = zc(Gs)[0], typeof Se == "object" && Se !== null && typeof Se.then == "function") try { var ke = zo(Se) } catch (wn) { throw wn === Nn ? jn : wn } else ke = Se; Se = Gi(); var $e = Se.queue, Ke = $e.dispatch; return Te !== Se.memoizedState && ($r.flags |= 2048, lo(9, Gc(), Hd.bind(null, $e, Te), null)), [ke, Ke, Ae] } function Hd(Ae, Se) { Ae.action = Se } function qd(Ae) { var Se = Gi(), Te = Xr; if (Te !== null) return Ql(Se, Te, Ae); Gi(), Se = Se.memoizedState, Te = Gi(); var ke = Te.queue.dispatch; return Te.memoizedState = Ae, [Se, ke, !1] } function lo(Ae, Se, Te, ke) { return Ae = { tag: Ae, create: Te, deps: ke, inst: Se, next: null }, Se = $r.updateQueue, Se === null && (Se = ml(), $r.updateQueue = Se), Te = Se.lastEffect, Te === null ? Se.lastEffect = Ae.next = Ae : (ke = Te.next, Te.next = Ae, Ae.next = ke, Se.lastEffect = Ae), Ae } function Gc() { return { destroy: void 0, resource: void 0 } } function Au() { return Gi().memoizedState } function ya(Ae, Se, Te, ke) { var $e = Ds(); ke = ke === void 0 ? null : ke, $r.flags |= Ae, $e.memoizedState = lo(1 | Se, Gc(), Te, ke) } function Zl(Ae, Se, Te, ke) { var $e = Gi(); ke = ke === void 0 ? null : ke; var Ke = $e.memoizedState.inst; Xr !== null && ke !== null && os(ke, Xr.memoizedState.deps) ? $e.memoizedState = lo(Se, Ke, Te, ke) : ($r.flags |= Ae, $e.memoizedState = lo(1 | Se, Ke, Te, ke)) } function Ju(Ae, Se) { ya(8390656, 8, Ae, Se) } function $d(Ae, Se) { Zl(2048, 8, Ae, Se) } function ed(Ae, Se) { return Zl(4, 2, Ae, Se) } function gl(Ae, Se) { return Zl(4, 4, Ae, Se) } function Vd(Ae, Se) { if (typeof Se == "function") { Ae = Ae(); var Te = Se(Ae); return function () { typeof Te == "function" ? Te() : Se(null) } } if (Se != null) return Ae = Ae(), Se.current = Ae, function () { Se.current = null } } function nd(Ae, Se, Te) { Te = Te != null ? Te.concat([Ae]) : null, Zl(4, 4, Vd.bind(null, Se, Ae), Te) } function rd() { } function id(Ae, Se) { var Te = Gi(); Se = Se === void 0 ? null : Se; var ke = Te.memoizedState; return Se !== null && os(Se, ke[1]) ? ke[0] : (Te.memoizedState = [Ae, Se], Ae) } function Gd(Ae, Se) { var Te = Gi(); Se = Se === void 0 ? null : Se; var ke = Te.memoizedState; if (Se !== null && os(Se, ke[1])) return ke[0]; if (ke = Ae(), fs) { Wr(!0); try { Ae() } finally { Wr(!1) } } return Te.memoizedState = [ke, Se], ke } function vl(Ae, Se, Te) { return Te === void 0 || (ji & 1073741824) !== 0 ? Ae.memoizedState = Se : (Ae.memoizedState = Te, Ae = Op(), $r.lanes |= Ae, ac |= Ae, Te) } function Su(Ae, Se, Te, ke) { return bs(Te, Se) ? Te : ai.current !== null ? (Ae = vl(Ae, Te, ke), bs(Ae, Se) || (Ns = !0), Ae) : (ji & 42) === 0 ? (Ns = !0, Ae.memoizedState = Te) : (Ae = Op(), $r.lanes |= Ae, ac |= Ae, Se) } function Wc(Ae, Se, Te, ke, $e) { var Ke = vn.p; vn.p = Ke !== 0 && 8 > Ke ? Ke : 8; var wn = xn.T, Mn = {}; xn.T = Mn, jh(Ae, !1, Se, Te); try { var Hn = $e(), or = xn.S; if (or !== null && or(Mn, Hn), Hn !== null && typeof Hn == "object" && typeof Hn.then == "function") { var gr = Id(Hn, ke); ld(Ae, Se, gr, Sa(Ae)) } else ld(Ae, Se, ke, Sa(Ae)) } catch (wr) { ld(Ae, Se, { then: function () { }, status: "rejected", reason: wr }, Sa()) } finally { vn.p = Ke, xn.T = wn } } function co() { } function Fa(Ae, Se, Te, ke) { if (Ae.tag !== 5) throw Error(Ee(476)); var $e = uo(Ae).queue; Wc(Ae, $e, Se, tn, Te === null ? co : function () { return Xc(Ae), Te(ke) }) } function uo(Ae) { var Se = Ae.memoizedState; if (Se !== null) return Se; Se = { memoizedState: tn, baseState: tn, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Gs, lastRenderedState: tn }, next: null }; var Te = {}; return Se.next = { memoizedState: Te, baseState: Te, baseQueue: null, queue: { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Gs, lastRenderedState: Te }, next: null }, Ae.memoizedState = Se, Ae = Ae.alternate, Ae !== null && (Ae.memoizedState = Se), Se } function Xc(Ae) { var Se = uo(Ae).next.queue; ld(Ae, Se, {}, Sa()) } function Yc() { return ds(Cd) } function sd() { return Gi().memoizedState } function Wd() { return Gi().memoizedState } function ad(Ae) { for (var Se = Ae.return; Se !== null;) { switch (Se.tag) { case 24: case 3: var Te = Sa(); Ae = pr(Te); var ke = yr(Se, Ae, Te); ke !== null && (Ra(ke, Se, Te), vr(ke, Se, Te)), Se = { cache: Xu() }, Ae.payload = Se; return }Se = Se.return } } function od(Ae, Se, Te) { var ke = Sa(); Te = { lane: ke, revertLane: 0, action: Te, hasEagerState: !1, eagerState: null, next: null }, Xd(Ae) ? kf(Se, Te) : (Te = Mo(Ae, Se, Te, ke), Te !== null && (Ra(Te, Ae, ke), If(Te, Se, ke))) } function Df(Ae, Se, Te) { var ke = Sa(); ld(Ae, Se, Te, ke) } function ld(Ae, Se, Te, ke) { var $e = { lane: ke, revertLane: 0, action: Te, hasEagerState: !1, eagerState: null, next: null }; if (Xd(Ae)) kf(Se, $e); else { var Ke = Ae.alternate; if (Ae.lanes === 0 && (Ke === null || Ke.lanes === 0) && (Ke = Se.lastRenderedReducer, Ke !== null)) try { var wn = Se.lastRenderedState, Mn = Ke(wn, Te); if ($e.hasEagerState = !0, $e.eagerState = Mn, bs(Mn, wn)) return jo(Ae, Se, $e, 0), qi === null && sa(), !1 } catch { } finally { } if (Te = Mo(Ae, Se, $e, ke), Te !== null) return Ra(Te, Ae, ke), If(Te, Se, ke), !0 } return !1 } function jh(Ae, Se, Te, ke) { if (ke = { lane: 2, revertLane: hf(), action: ke, hasEagerState: !1, eagerState: null, next: null }, Xd(Ae)) { if (Se) throw Error(Ee(479)) } else Se = Mo(Ae, Te, ke, 2), Se !== null && Ra(Se, Ae, 2) } function Xd(Ae) { var Se = Ae.alternate; return Ae === $r || Se !== null && Se === $r } function kf(Ae, Se) { Es = Si = !0; var Te = Ae.pending; Te === null ? Se.next = Se : (Se.next = Te.next, Te.next = Se), Ae.pending = Se } function If(Ae, Se, Te) { if ((Te & 4194048) !== 0) { var ke = Se.lanes; ke &= Ae.pendingLanes, Te |= ke, Se.lanes = Te, Ur(Ae, Te) } } var Yd = { readContext: ds, use: Vs, useCallback: Ni, useContext: Ni, useEffect: Ni, useImperativeHandle: Ni, useLayoutEffect: Ni, useInsertionEffect: Ni, useMemo: Ni, useReducer: Ni, useRef: Ni, useState: Ni, useDebugValue: Ni, useDeferredValue: Ni, useTransition: Ni, useSyncExternalStore: Ni, useId: Ni, useHostTransitionStatus: Ni, useFormState: Ni, useActionState: Ni, useOptimistic: Ni, useMemoCache: Ni, useCacheRefresh: Ni }, Ff = { readContext: ds, use: Vs, useCallback: function (Ae, Se) { return Ds().memoizedState = [Ae, Se === void 0 ? null : Se], Ae }, useContext: ds, useEffect: Ju, useImperativeHandle: function (Ae, Se, Te) { Te = Te != null ? Te.concat([Ae]) : null, ya(4194308, 4, Vd.bind(null, Se, Ae), Te) }, useLayoutEffect: function (Ae, Se) { return ya(4194308, 4, Ae, Se) }, useInsertionEffect: function (Ae, Se) { ya(4, 2, Ae, Se) }, useMemo: function (Ae, Se) { var Te = Ds(); Se = Se === void 0 ? null : Se; var ke = Ae(); if (fs) { Wr(!0); try { Ae() } finally { Wr(!1) } } return Te.memoizedState = [ke, Se], ke }, useReducer: function (Ae, Se, Te) { var ke = Ds(); if (Te !== void 0) { var $e = Te(Se); if (fs) { Wr(!0); try { Te(Se) } finally { Wr(!1) } } } else $e = Se; return ke.memoizedState = ke.baseState = $e, Ae = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: Ae, lastRenderedState: $e }, ke.queue = Ae, Ae = Ae.dispatch = od.bind(null, $r, Ae), [ke.memoizedState, Ae] }, useRef: function (Ae) { var Se = Ds(); return Ae = { current: Ae }, Se.memoizedState = Ae }, useState: function (Ae) { Ae = $c(Ae); var Se = Ae.queue, Te = Df.bind(null, $r, Se); return Se.dispatch = Te, [Ae.memoizedState, Te] }, useDebugValue: rd, useDeferredValue: function (Ae, Se) { var Te = Ds(); return vl(Te, Ae, Se) }, useTransition: function () { var Ae = $c(!1); return Ae = Wc.bind(null, $r, Ae.queue, !0, !1), Ds().memoizedState = Ae, [!1, Ae] }, useSyncExternalStore: function (Ae, Se, Te) { var ke = $r, $e = Ds(); if (Ri) { if (Te === void 0) throw Error(Ee(407)); Te = Te() } else { if (Te = Se(), qi === null) throw Error(Ee(349)); (_i & 124) !== 0 || Eu(ke, Se, Te) } $e.memoizedState = Te; var Ke = { value: Te, getSnapshot: Se }; return $e.queue = Ke, Ju(Yl.bind(null, ke, Ke, Ae), [Ae]), ke.flags |= 2048, lo(9, Gc(), qc.bind(null, ke, Ke, Te, Se), null), Te }, useId: function () { var Ae = Ds(), Se = qi.identifierPrefix; if (Ri) { var Te = ro, ke = no; Te = (ke & ~(1 << 32 - Cr(ke) - 1)).toString(32) + Te, Se = "«" + Se + "R" + Te, Te = ns++, 0 < Te && (Se += "H" + Te.toString(32)), Se += "»" } else Te = la++, Se = "«" + Se + "r" + Te.toString(32) + "»"; return Ae.memoizedState = Se }, useHostTransitionStatus: Yc, useFormState: Vc, useActionState: Vc, useOptimistic: function (Ae) { var Se = Ds(); Se.memoizedState = Se.baseState = Ae; var Te = { pending: null, lanes: 0, dispatch: null, lastRenderedReducer: null, lastRenderedState: null }; return Se.queue = Te, Se = jh.bind(null, $r, !0, Te), Te.dispatch = Se, [Ae, Se] }, useMemoCache: Ho, useCacheRefresh: function () { return Ds().memoizedState = ad.bind(null, $r) } }, Bf = { readContext: ds, use: Vs, useCallback: id, useContext: ds, useEffect: $d, useImperativeHandle: nd, useInsertionEffect: ed, useLayoutEffect: gl, useMemo: Gd, useReducer: zc, useRef: Au, useState: function () { return zc(Gs) }, useDebugValue: rd, useDeferredValue: function (Ae, Se) { var Te = Gi(); return Su(Te, Xr.memoizedState, Ae, Se) }, useTransition: function () { var Ae = zc(Gs)[0], Se = Gi().memoizedState; return [typeof Ae == "boolean" ? Ae : zo(Ae), Se] }, useSyncExternalStore: Hc, useId: sd, useHostTransitionStatus: Yc, useFormState: wu, useActionState: wu, useOptimistic: function (Ae, Se) { var Te = Gi(); return oo(Te, Xr, Ae, Se) }, useMemoCache: Ho, useCacheRefresh: Wd }, Lm = { readContext: ds, use: Vs, useCallback: id, useContext: ds, useEffect: $d, useImperativeHandle: nd, useInsertionEffect: ed, useLayoutEffect: gl, useMemo: Gd, useReducer: yu, useRef: Au, useState: function () { return yu(Gs) }, useDebugValue: rd, useDeferredValue: function (Ae, Se) { var Te = Gi(); return Xr === null ? vl(Te, Ae, Se) : Su(Te, Xr.memoizedState, Ae, Se) }, useTransition: function () { var Ae = yu(Gs)[0], Se = Gi().memoizedState; return [typeof Ae == "boolean" ? Ae : zo(Ae), Se] }, useSyncExternalStore: Hc, useId: sd, useHostTransitionStatus: Yc, useFormState: qd, useActionState: qd, useOptimistic: function (Ae, Se) { var Te = Gi(); return Xr !== null ? oo(Te, Xr, Ae, Se) : (Te.baseState = Ae, [Ae, Te.queue.dispatch]) }, useMemoCache: Ho, useCacheRefresh: Wd }, _u = null, cd = 0; function Kd(Ae) { var Se = cd; return cd += 1, _u === null && (_u = []), ar(_u, Ae, Se) } function ud(Ae, Se) { Se = Se.props.ref, Ae.ref = Se !== void 0 ? Se : null } function Qd(Ae, Se) { throw Se.$$typeof === je ? Error(Ee(525)) : (Ae = Object.prototype.toString.call(Se), Error(Ee(31, Ae === "[object Object]" ? "object with keys {" + Object.keys(Se).join(", ") + "}" : Ae))) } function Uf(Ae) { var Se = Ae._init; return Se(Ae._payload) } function zf(Ae) { function Se(er, Xn) { if (Ae) { var ir = er.deletions; ir === null ? (er.deletions = [Xn], er.flags |= 16) : ir.push(Xn) } } function Te(er, Xn) { if (!Ae) return null; for (; Xn !== null;)Se(er, Xn), Xn = Xn.sibling; return null } function ke(er) { for (var Xn = new Map; er !== null;)er.key !== null ? Xn.set(er.key, er) : Xn.set(er.index, er), er = er.sibling; return Xn } function $e(er, Xn) { return er = ja(er, Xn), er.index = 0, er.sibling = null, er } function Ke(er, Xn, ir) { return er.index = ir, Ae ? (ir = er.alternate, ir !== null ? (ir = ir.index, ir < Xn ? (er.flags |= 67108866, Xn) : ir) : (er.flags |= 67108866, Xn)) : (er.flags |= 1048576, Xn) } function wn(er) { return Ae && er.alternate === null && (er.flags |= 67108866), er } function Mn(er, Xn, ir, br) { return Xn === null || Xn.tag !== 6 ? (Xn = fu(ir, er.mode, br), Xn.return = er, Xn) : (Xn = $e(Xn, ir), Xn.return = er, Xn) } function Hn(er, Xn, ir, br) { var Fr = ir.type; return Fr === Fe ? gr(er, Xn, ir.props.children, br, ir.key) : Xn !== null && (Xn.elementType === Fr || typeof Fr == "object" && Fr !== null && Fr.$$typeof === on && Uf(Fr) === Xn.type) ? (Xn = $e(Xn, ir.props), ud(Xn, ir), Xn.return = er, Xn) : (Xn = ll(ir.type, ir.key, ir.props, null, er.mode, br), ud(Xn, ir), Xn.return = er, Xn) } function or(er, Xn, ir, br) { return Xn === null || Xn.tag !== 4 || Xn.stateNode.containerInfo !== ir.containerInfo || Xn.stateNode.implementation !== ir.implementation ? (Xn = Dc(ir, er.mode, br), Xn.return = er, Xn) : (Xn = $e(Xn, ir.children || []), Xn.return = er, Xn) } function gr(er, Xn, ir, br, Fr) { return Xn === null || Xn.tag !== 7 ? (Xn = eo(ir, er.mode, br, Fr), Xn.return = er, Xn) : (Xn = $e(Xn, ir), Xn.return = er, Xn) } function wr(er, Xn, ir) { if (typeof Xn == "string" && Xn !== "" || typeof Xn == "number" || typeof Xn == "bigint") return Xn = fu("" + Xn, er.mode, ir), Xn.return = er, Xn; if (typeof Xn == "object" && Xn !== null) { switch (Xn.$$typeof) { case Be: return ir = ll(Xn.type, Xn.key, Xn.props, null, er.mode, ir), ud(ir, Xn), ir.return = er, ir; case Ie: return Xn = Dc(Xn, er.mode, ir), Xn.return = er, Xn; case on: var br = Xn._init; return Xn = br(Xn._payload), wr(er, Xn, ir) }if (In(Xn) || En(Xn)) return Xn = eo(Xn, er.mode, ir, null), Xn.return = er, Xn; if (typeof Xn.then == "function") return wr(er, Kd(Xn), ir); if (Xn.$$typeof === Ze) return wr(er, Fo(er, Xn), ir); Qd(er, Xn) } return null } function lr(er, Xn, ir, br) { var Fr = Xn !== null ? Xn.key : null; if (typeof ir == "string" && ir !== "" || typeof ir == "number" || typeof ir == "bigint") return Fr !== null ? null : Mn(er, Xn, "" + ir, br); if (typeof ir == "object" && ir !== null) { switch (ir.$$typeof) { case Be: return ir.key === Fr ? Hn(er, Xn, ir, br) : null; case Ie: return ir.key === Fr ? or(er, Xn, ir, br) : null; case on: return Fr = ir._init, ir = Fr(ir._payload), lr(er, Xn, ir, br) }if (In(ir) || En(ir)) return Fr !== null ? null : gr(er, Xn, ir, br, null); if (typeof ir.then == "function") return lr(er, Xn, Kd(ir), br); if (ir.$$typeof === Ze) return lr(er, Xn, Fo(er, ir), br); Qd(er, ir) } return null } function cr(er, Xn, ir, br, Fr) { if (typeof br == "string" && br !== "" || typeof br == "number" || typeof br == "bigint") return er = er.get(ir) || null, Mn(Xn, er, "" + br, Fr); if (typeof br == "object" && br !== null) { switch (br.$$typeof) { case Be: return er = er.get(br.key === null ? ir : br.key) || null, Hn(Xn, er, br, Fr); case Ie: return er = er.get(br.key === null ? ir : br.key) || null, or(Xn, er, br, Fr); case on: var ui = br._init; return br = ui(br._payload), cr(er, Xn, ir, br, Fr) }if (In(br) || En(br)) return er = er.get(ir) || null, gr(Xn, er, br, Fr, null); if (typeof br.then == "function") return cr(er, Xn, ir, Kd(br), Fr); if (br.$$typeof === Ze) return cr(er, Xn, ir, Fo(Xn, br), Fr); Qd(Xn, br) } return null } function Kr(er, Xn, ir, br) { for (var Fr = null, ui = null, qr = Xn, Gr = Xn = 0, Os = null; qr !== null && Gr < ir.length; Gr++) { qr.index > Gr ? (Os = qr, qr = null) : Os = qr.sibling; var Pi = lr(er, qr, ir[Gr], br); if (Pi === null) { qr === null && (qr = Os); break } Ae && qr && Pi.alternate === null && Se(er, qr), Xn = Ke(Pi, Xn, Gr), ui === null ? Fr = Pi : ui.sibling = Pi, ui = Pi, qr = Os } if (Gr === ir.length) return Te(er, qr), Ri && ul(er, Gr), Fr; if (qr === null) { for (; Gr < ir.length; Gr++)qr = wr(er, ir[Gr], br), qr !== null && (Xn = Ke(qr, Xn, Gr), ui === null ? Fr = qr : ui.sibling = qr, ui = qr); return Ri && ul(er, Gr), Fr } for (qr = ke(qr); Gr < ir.length; Gr++)Os = cr(qr, er, Gr, ir[Gr], br), Os !== null && (Ae && Os.alternate !== null && qr.delete(Os.key === null ? Gr : Os.key), Xn = Ke(Os, Xn, Gr), ui === null ? Fr = Os : ui.sibling = Os, ui = Os); return Ae && qr.forEach(function (gc) { return Se(er, gc) }), Ri && ul(er, Gr), Fr } function Vr(er, Xn, ir, br) { if (ir == null) throw Error(Ee(151)); for (var Fr = null, ui = null, qr = Xn, Gr = Xn = 0, Os = null, Pi = ir.next(); qr !== null && !Pi.done; Gr++, Pi = ir.next()) { qr.index > Gr ? (Os = qr, qr = null) : Os = qr.sibling; var gc = lr(er, qr, Pi.value, br); if (gc === null) { qr === null && (qr = Os); break } Ae && qr && gc.alternate === null && Se(er, qr), Xn = Ke(gc, Xn, Gr), ui === null ? Fr = gc : ui.sibling = gc, ui = gc, qr = Os } if (Pi.done) return Te(er, qr), Ri && ul(er, Gr), Fr; if (qr === null) { for (; !Pi.done; Gr++, Pi = ir.next())Pi = wr(er, Pi.value, br), Pi !== null && (Xn = Ke(Pi, Xn, Gr), ui === null ? Fr = Pi : ui.sibling = Pi, ui = Pi); return Ri && ul(er, Gr), Fr } for (qr = ke(qr); !Pi.done; Gr++, Pi = ir.next())Pi = cr(qr, er, Gr, Pi.value, br), Pi !== null && (Ae && Pi.alternate !== null && qr.delete(Pi.key === null ? Gr : Pi.key), Xn = Ke(Pi, Xn, Gr), ui === null ? Fr = Pi : ui.sibling = Pi, ui = Pi); return Ae && qr.forEach(function (jg) { return Se(er, jg) }), Ri && ul(er, Gr), Fr } function Fi(er, Xn, ir, br) { if (typeof ir == "object" && ir !== null && ir.type === Fe && ir.key === null && (ir = ir.props.children), typeof ir == "object" && ir !== null) { switch (ir.$$typeof) { case Be: e: { for (var Fr = ir.key; Xn !== null;) { if (Xn.key === Fr) { if (Fr = ir.type, Fr === Fe) { if (Xn.tag === 7) { Te(er, Xn.sibling), br = $e(Xn, ir.props.children), br.return = er, er = br; break e } } else if (Xn.elementType === Fr || typeof Fr == "object" && Fr !== null && Fr.$$typeof === on && Uf(Fr) === Xn.type) { Te(er, Xn.sibling), br = $e(Xn, ir.props), ud(br, ir), br.return = er, er = br; break e } Te(er, Xn); break } else Se(er, Xn); Xn = Xn.sibling } ir.type === Fe ? (br = eo(ir.props.children, er.mode, br, ir.key), br.return = er, er = br) : (br = ll(ir.type, ir.key, ir.props, null, er.mode, br), ud(br, ir), br.return = er, er = br) } return wn(er); case Ie: e: { for (Fr = ir.key; Xn !== null;) { if (Xn.key === Fr) if (Xn.tag === 4 && Xn.stateNode.containerInfo === ir.containerInfo && Xn.stateNode.implementation === ir.implementation) { Te(er, Xn.sibling), br = $e(Xn, ir.children || []), br.return = er, er = br; break e } else { Te(er, Xn); break } else Se(er, Xn); Xn = Xn.sibling } br = Dc(ir, er.mode, br), br.return = er, er = br } return wn(er); case on: return Fr = ir._init, ir = Fr(ir._payload), Fi(er, Xn, ir, br) }if (In(ir)) return Kr(er, Xn, ir, br); if (En(ir)) { if (Fr = En(ir), typeof Fr != "function") throw Error(Ee(150)); return ir = Fr.call(ir), Vr(er, Xn, ir, br) } if (typeof ir.then == "function") return Fi(er, Xn, Kd(ir), br); if (ir.$$typeof === Ze) return Fi(er, Xn, Fo(er, ir), br); Qd(er, ir) } return typeof ir == "string" && ir !== "" || typeof ir == "number" || typeof ir == "bigint" ? (ir = "" + ir, Xn !== null && Xn.tag === 6 ? (Te(er, Xn.sibling), br = $e(Xn, ir), br.return = er, er = br) : (Te(er, Xn), br = fu(ir, er.mode, br), br.return = er, er = br), wn(er)) : Te(er, Xn) } return function (er, Xn, ir, br) { try { cd = 0; var Fr = Fi(er, Xn, ir, br); return _u = null, Fr } catch (qr) { if (qr === Nn || qr === jn) throw qr; var ui = Ts(29, qr, null, er.mode); return ui.lanes = br, ui.return = er, ui } finally { } } } var Ru = zf(!0), Hf = zf(!1), Ba = dn(null), qo = null; function Jl(Ae) { var Se = Ae.alternate; rn(Ss, Ss.current & 1), rn(Ba, Ae), qo === null && (Se === null || ai.current !== null || Se.memoizedState !== null) && (qo = Ae) } function qf(Ae) { if (Ae.tag === 22) { if (rn(Ss, Ss.current), rn(Ba, Ae), qo === null) { var Se = Ae.alternate; Se !== null && Se.memoizedState !== null && (qo = Ae) } } else tc() } function tc() { rn(Ss, Ss.current), rn(Ba, Ba.current) } function bl(Ae) { Je(Ba), qo === Ae && (qo = null), Je(Ss) } var Ss = dn(0); function Zd(Ae) { for (var Se = Ae; Se !== null;) { if (Se.tag === 13) { var Te = Se.memoizedState; if (Te !== null && (Te = Te.dehydrated, Te === null || Te.data === "$?" || Sf(Te))) return Se } else if (Se.tag === 19 && Se.memoizedProps.revealOrder !== void 0) { if ((Se.flags & 128) !== 0) return Se } else if (Se.child !== null) { Se.child.return = Se, Se = Se.child; continue } if (Se === Ae) break; for (; Se.sibling === null;) { if (Se.return === null || Se.return === Ae) return null; Se = Se.return } Se.sibling.return = Se.return, Se = Se.sibling } return null } function Mh(Ae, Se, Te, ke) { Se = Ae.memoizedState, Te = Te(ke, Se), Te = Te == null ? Se : Oe({}, Se, Te), Ae.memoizedState = Te, Ae.lanes === 0 && (Ae.updateQueue.baseState = Te) } var Dh = { enqueueSetState: function (Ae, Se, Te) { Ae = Ae._reactInternals; var ke = Sa(), $e = pr(ke); $e.payload = Se, Te != null && ($e.callback = Te), Se = yr(Ae, $e, ke), Se !== null && (Ra(Se, Ae, ke), vr(Se, Ae, ke)) }, enqueueReplaceState: function (Ae, Se, Te) { Ae = Ae._reactInternals; var ke = Sa(), $e = pr(ke); $e.tag = 1, $e.payload = Se, Te != null && ($e.callback = Te), Se = yr(Ae, $e, ke), Se !== null && (Ra(Se, Ae, ke), vr(Se, Ae, ke)) }, enqueueForceUpdate: function (Ae, Se) { Ae = Ae._reactInternals; var Te = Sa(), ke = pr(Te); ke.tag = 2, Se != null && (ke.callback = Se), Se = yr(Ae, ke, Te), Se !== null && (Ra(Se, Ae, Te), vr(Se, Ae, Te)) } }; function $f(Ae, Se, Te, ke, $e, Ke, wn) { return Ae = Ae.stateNode, typeof Ae.shouldComponentUpdate == "function" ? Ae.shouldComponentUpdate(ke, Ke, wn) : Se.prototype && Se.prototype.isPureReactComponent ? !Ro(Te, ke) || !Ro($e, Ke) : !0 } function Vf(Ae, Se, Te, ke) { Ae = Se.state, typeof Se.componentWillReceiveProps == "function" && Se.componentWillReceiveProps(Te, ke), typeof Se.UNSAFE_componentWillReceiveProps == "function" && Se.UNSAFE_componentWillReceiveProps(Te, ke), Se.state !== Ae && Dh.enqueueReplaceState(Se, Se.state, null) } function Kc(Ae, Se) { var Te = Se; if ("ref" in Se) { Te = {}; for (var ke in Se) ke !== "ref" && (Te[ke] = Se[ke]) } if (Ae = Ae.defaultProps) { Te === Se && (Te = Oe({}, Te)); for (var $e in Ae) Te[$e] === void 0 && (Te[$e] = Ae[$e]) } return Te } var Jd = typeof reportError == "function" ? reportError : function (Ae) { if (typeof window == "object" && typeof window.ErrorEvent == "function") { var Se = new window.ErrorEvent("error", { bubbles: !0, cancelable: !0, message: typeof Ae == "object" && Ae !== null && typeof Ae.message == "string" ? String(Ae.message) : String(Ae), error: Ae }); if (!window.dispatchEvent(Se)) return } else if (typeof process == "object" && typeof process.emit == "function") { process.emit("uncaughtException", Ae); return } console.error(Ae) }; function Gf(Ae) { Jd(Ae) } function Wf(Ae) { console.error(Ae) } function Xf(Ae) { Jd(Ae) } function eh(Ae, Se) { try { var Te = Ae.onUncaughtError; Te(Se.value, { componentStack: Se.stack }) } catch (ke) { setTimeout(function () { throw ke }) } } function Yf(Ae, Se, Te) { try { var ke = Ae.onCaughtError; ke(Te.value, { componentStack: Te.stack, errorBoundary: Se.tag === 1 ? Se.stateNode : null }) } catch ($e) { setTimeout(function () { throw $e }) } } function kh(Ae, Se, Te) { return Te = pr(Te), Te.tag = 3, Te.payload = { element: null }, Te.callback = function () { eh(Ae, Se) }, Te } function Kf(Ae) { return Ae = pr(Ae), Ae.tag = 3, Ae } function Qf(Ae, Se, Te, ke) { var $e = Te.type.getDerivedStateFromError; if (typeof $e == "function") { var Ke = ke.value; Ae.payload = function () { return $e(Ke) }, Ae.callback = function () { Yf(Se, Te, ke) } } var wn = Te.stateNode; wn !== null && typeof wn.componentDidCatch == "function" && (Ae.callback = function () { Yf(Se, Te, ke), typeof $e != "function" && (oc === null ? oc = new Set([this]) : oc.add(this)); var Mn = ke.stack; this.componentDidCatch(ke.value, { componentStack: Mn !== null ? Mn : "" }) }) } function jm(Ae, Se, Te, ke, $e) { if (Te.flags |= 32768, ke !== null && typeof ke == "object" && typeof ke.then == "function") { if (Se = Te.alternate, Se !== null && Wl(Se, Te, $e, !0), Te = Ba.current, Te !== null) { switch (Te.tag) { case 13: return qo === null ? of() : Te.alternate === null && ls === 0 && (ls = 3), Te.flags &= -257, Te.flags |= 65536, Te.lanes = $e, ke === Dn ? Te.flags |= 16384 : (Se = Te.updateQueue, Se === null ? Te.updateQueue = new Set([ke]) : Se.add(ke), cf(Ae, ke, $e)), !1; case 22: return Te.flags |= 65536, ke === Dn ? Te.flags |= 16384 : (Se = Te.updateQueue, Se === null ? (Se = { transitions: null, markerInstances: null, retryQueue: new Set([ke]) }, Te.updateQueue = Se) : (Te = Se.retryQueue, Te === null ? Se.retryQueue = new Set([ke]) : Te.add(ke)), cf(Ae, ke, $e)), !1 }throw Error(Ee(435, Te.tag)) } return cf(Ae, ke, $e), of(), !1 } if (Ri) return Se = Ba.current, Se !== null ? ((Se.flags & 65536) === 0 && (Se.flags |= 256), Se.flags |= 65536, Se.lanes = $e, ke !== Wu && (Ae = Error(Ee(422), { cause: ke }), Gl(li(Ae, Te)))) : (ke !== Wu && (Se = Error(Ee(423), { cause: ke }), Gl(li(Se, Te))), Ae = Ae.current.alternate, Ae.flags |= 65536, $e &= -$e, Ae.lanes |= $e, ke = li(ke, Te), $e = kh(Ae.stateNode, ke, $e), Mr(Ae, $e), ls !== 4 && (ls = 2)), !1; var Ke = Error(Ee(520), { cause: ke }); if (Ke = li(Ke, Te), bd === null ? bd = [Ke] : bd.push(Ke), ls !== 4 && (ls = 2), Se === null) return !0; ke = li(ke, Te), Te = Se; do { switch (Te.tag) { case 3: return Te.flags |= 65536, Ae = $e & -$e, Te.lanes |= Ae, Ae = kh(Te.stateNode, ke, Ae), Mr(Te, Ae), !1; case 1: if (Se = Te.type, Ke = Te.stateNode, (Te.flags & 128) === 0 && (typeof Se.getDerivedStateFromError == "function" || Ke !== null && typeof Ke.componentDidCatch == "function" && (oc === null || !oc.has(Ke)))) return Te.flags |= 65536, $e &= -$e, Te.lanes |= $e, $e = Kf($e), Qf($e, Ae, Te, ke), Mr(Te, $e), !1 }Te = Te.return } while (Te !== null); return !1 } var Zf = Error(Ee(461)), Ns = !1; function ks(Ae, Se, Te, ke) { Se.child = Ae === null ? Hf(Se, null, Te, ke) : Ru(Se, Ae.child, Te, ke) } function Jf(Ae, Se, Te, ke, $e) { Te = Te.render; var Ke = Se.ref; if ("ref" in ke) { var wn = {}; for (var Mn in ke) Mn !== "ref" && (wn[Mn] = ke[Mn]) } else wn = ke; return Ia(Se), ke = xa(Ae, Se, Te, wn, Ke, $e), Mn = Hi(), Ae !== null && !Ns ? (Uc(Ae, Se, $e), xl(Ae, Se, $e)) : (Ri && Mn && kc(Se), Se.flags |= 1, ks(Ae, Se, ke, $e), Se.child) } function ep(Ae, Se, Te, ke, $e) { if (Ae === null) { var Ke = Te.type; return typeof Ke == "function" && !$l(Ke) && Ke.defaultProps === void 0 && Te.compare === null ? (Se.tag = 15, Se.type = Ke, tp(Ae, Se, Ke, ke, $e)) : (Ae = ll(Te.type, null, ke, Se, Se.mode, $e), Ae.ref = Se.ref, Ae.return = Se, Se.child = Ae) } if (Ke = Ae.child, !$h(Ae, $e)) { var wn = Ke.memoizedProps; if (Te = Te.compare, Te = Te !== null ? Te : Ro, Te(wn, ke) && Ae.ref === Se.ref) return xl(Ae, Se, $e) } return Se.flags |= 1, Ae = ja(Ke, ke), Ae.ref = Se.ref, Ae.return = Se, Se.child = Ae } function tp(Ae, Se, Te, ke, $e) { if (Ae !== null) { var Ke = Ae.memoizedProps; if (Ro(Ke, ke) && Ae.ref === Se.ref) if (Ns = !1, Se.pendingProps = ke = Ke, $h(Ae, $e)) (Ae.flags & 131072) !== 0 && (Ns = !0); else return Se.lanes = Ae.lanes, xl(Ae, Se, $e) } return Ih(Ae, Se, Te, ke, $e) } function np(Ae, Se, Te) { var ke = Se.pendingProps, $e = ke.children, Ke = Ae !== null ? Ae.memoizedState : null; if (ke.mode === "hidden") { if ((Se.flags & 128) !== 0) { if (ke = Ke !== null ? Ke.baseLanes | Te : Te, Ae !== null) { for ($e = Se.child = Ae.child, Ke = 0; $e !== null;)Ke = Ke | $e.lanes | $e.childLanes, $e = $e.sibling; Se.childLanes = Ke & ~ke } else Se.childLanes = 0, Se.child = null; return rp(Ae, Se, ke, Te) } if ((Te & 536870912) !== 0) Se.memoizedState = { baseLanes: 0, cachePool: null }, Ae !== null && gn(Se, Ke !== null ? Ke.cachePool : null), Ke !== null ? Oi(Se, Ke) : Ti(), qf(Se); else return Se.lanes = Se.childLanes = 536870912, rp(Ae, Se, Ke !== null ? Ke.baseLanes | Te : Te, Te) } else Ke !== null ? (gn(Se, Ke.cachePool), Oi(Se, Ke), tc(), Se.memoizedState = null) : (Ae !== null && gn(Se, null), Ti(), tc()); return ks(Ae, Se, $e, Te), Se.child } function rp(Ae, Se, Te, ke) { var $e = en(); return $e = $e === null ? null : { parent: hs._currentValue, pool: $e }, Se.memoizedState = { baseLanes: Te, cachePool: $e }, Ae !== null && gn(Se, null), Ti(), qf(Se), Ae !== null && Wl(Ae, Se, ke, !0), null } function th(Ae, Se) { var Te = Se.ref; if (Te === null) Ae !== null && Ae.ref !== null && (Se.flags |= 4194816); else { if (typeof Te != "function" && typeof Te != "object") throw Error(Ee(284)); (Ae === null || Ae.ref !== Te) && (Se.flags |= 4194816) } } function Ih(Ae, Se, Te, ke, $e) { return Ia(Se), Te = xa(Ae, Se, Te, ke, void 0, $e), ke = Hi(), Ae !== null && !Ns ? (Uc(Ae, Se, $e), xl(Ae, Se, $e)) : (Ri && ke && kc(Se), Se.flags |= 1, ks(Ae, Se, Te, $e), Se.child) } function ip(Ae, Se, Te, ke, $e, Ke) { return Ia(Se), Se.updateQueue = null, Te = pl(Se, ke, Te, $e), Bo(Ae), ke = Hi(), Ae !== null && !Ns ? (Uc(Ae, Se, Ke), xl(Ae, Se, Ke)) : (Ri && ke && kc(Se), Se.flags |= 1, ks(Ae, Se, Te, Ke), Se.child) } function sp(Ae, Se, Te, ke, $e) { if (Ia(Se), Se.stateNode === null) { var Ke = xs, wn = Te.contextType; typeof wn == "object" && wn !== null && (Ke = ds(wn)), Ke = new Te(ke, Ke), Se.memoizedState = Ke.state !== null && Ke.state !== void 0 ? Ke.state : null, Ke.updater = Dh, Se.stateNode = Ke, Ke._reactInternals = Se, Ke = Se.stateNode, Ke.props = ke, Ke.state = Se.memoizedState, Ke.refs = {}, Wn(Se), wn = Te.contextType, Ke.context = typeof wn == "object" && wn !== null ? ds(wn) : xs, Ke.state = Se.memoizedState, wn = Te.getDerivedStateFromProps, typeof wn == "function" && (Mh(Se, Te, wn, ke), Ke.state = Se.memoizedState), typeof Te.getDerivedStateFromProps == "function" || typeof Ke.getSnapshotBeforeUpdate == "function" || typeof Ke.UNSAFE_componentWillMount != "function" && typeof Ke.componentWillMount != "function" || (wn = Ke.state, typeof Ke.componentWillMount == "function" && Ke.componentWillMount(), typeof Ke.UNSAFE_componentWillMount == "function" && Ke.UNSAFE_componentWillMount(), wn !== Ke.state && Dh.enqueueReplaceState(Ke, Ke.state, null), Pr(Se, ke, Ke, $e), Hr(), Ke.state = Se.memoizedState), typeof Ke.componentDidMount == "function" && (Se.flags |= 4194308), ke = !0 } else if (Ae === null) { Ke = Se.stateNode; var Mn = Se.memoizedProps, Hn = Kc(Te, Mn); Ke.props = Hn; var or = Ke.context, gr = Te.contextType; wn = xs, typeof gr == "object" && gr !== null && (wn = ds(gr)); var wr = Te.getDerivedStateFromProps; gr = typeof wr == "function" || typeof Ke.getSnapshotBeforeUpdate == "function", Mn = Se.pendingProps !== Mn, gr || typeof Ke.UNSAFE_componentWillReceiveProps != "function" && typeof Ke.componentWillReceiveProps != "function" || (Mn || or !== wn) && Vf(Se, Ke, ke, wn), dr = !1; var lr = Se.memoizedState; Ke.state = lr, Pr(Se, ke, Ke, $e), Hr(), or = Se.memoizedState, Mn || lr !== or || dr ? (typeof wr == "function" && (Mh(Se, Te, wr, ke), or = Se.memoizedState), (Hn = dr || $f(Se, Te, Hn, ke, lr, or, wn)) ? (gr || typeof Ke.UNSAFE_componentWillMount != "function" && typeof Ke.componentWillMount != "function" || (typeof Ke.componentWillMount == "function" && Ke.componentWillMount(), typeof Ke.UNSAFE_componentWillMount == "function" && Ke.UNSAFE_componentWillMount()), typeof Ke.componentDidMount == "function" && (Se.flags |= 4194308)) : (typeof Ke.componentDidMount == "function" && (Se.flags |= 4194308), Se.memoizedProps = ke, Se.memoizedState = or), Ke.props = ke, Ke.state = or, Ke.context = wn, ke = Hn) : (typeof Ke.componentDidMount == "function" && (Se.flags |= 4194308), ke = !1) } else { Ke = Se.stateNode, Zn(Ae, Se), wn = Se.memoizedProps, gr = Kc(Te, wn), Ke.props = gr, wr = Se.pendingProps, lr = Ke.context, or = Te.contextType, Hn = xs, typeof or == "object" && or !== null && (Hn = ds(or)), Mn = Te.getDerivedStateFromProps, (or = typeof Mn == "function" || typeof Ke.getSnapshotBeforeUpdate == "function") || typeof Ke.UNSAFE_componentWillReceiveProps != "function" && typeof Ke.componentWillReceiveProps != "function" || (wn !== wr || lr !== Hn) && Vf(Se, Ke, ke, Hn), dr = !1, lr = Se.memoizedState, Ke.state = lr, Pr(Se, ke, Ke, $e), Hr(); var cr = Se.memoizedState; wn !== wr || lr !== cr || dr || Ae !== null && Ae.dependencies !== null && vu(Ae.dependencies) ? (typeof Mn == "function" && (Mh(Se, Te, Mn, ke), cr = Se.memoizedState), (gr = dr || $f(Se, Te, gr, ke, lr, cr, Hn) || Ae !== null && Ae.dependencies !== null && vu(Ae.dependencies)) ? (or || typeof Ke.UNSAFE_componentWillUpdate != "function" && typeof Ke.componentWillUpdate != "function" || (typeof Ke.componentWillUpdate == "function" && Ke.componentWillUpdate(ke, cr, Hn), typeof Ke.UNSAFE_componentWillUpdate == "function" && Ke.UNSAFE_componentWillUpdate(ke, cr, Hn)), typeof Ke.componentDidUpdate == "function" && (Se.flags |= 4), typeof Ke.getSnapshotBeforeUpdate == "function" && (Se.flags |= 1024)) : (typeof Ke.componentDidUpdate != "function" || wn === Ae.memoizedProps && lr === Ae.memoizedState || (Se.flags |= 4), typeof Ke.getSnapshotBeforeUpdate != "function" || wn === Ae.memoizedProps && lr === Ae.memoizedState || (Se.flags |= 1024), Se.memoizedProps = ke, Se.memoizedState = cr), Ke.props = ke, Ke.state = cr, Ke.context = Hn, ke = gr) : (typeof Ke.componentDidUpdate != "function" || wn === Ae.memoizedProps && lr === Ae.memoizedState || (Se.flags |= 4), typeof Ke.getSnapshotBeforeUpdate != "function" || wn === Ae.memoizedProps && lr === Ae.memoizedState || (Se.flags |= 1024), ke = !1) } return Ke = ke, th(Ae, Se), ke = (Se.flags & 128) !== 0, Ke || ke ? (Ke = Se.stateNode, Te = ke && typeof Te.getDerivedStateFromError != "function" ? null : Ke.render(), Se.flags |= 1, Ae !== null && ke ? (Se.child = Ru(Se, Ae.child, null, $e), Se.child = Ru(Se, null, Te, $e)) : ks(Ae, Se, Te, $e), Se.memoizedState = Ke.state, Ae = Se.child) : Ae = xl(Ae, Se, $e), Ae } function ap(Ae, Se, Te, ke) { return ea(), Se.flags |= 256, ks(Ae, Se, Te, ke), Se.child } var Fh = { dehydrated: null, treeContext: null, retryLane: 0, hydrationErrors: null }; function Bh(Ae) { return { baseLanes: Ae, cachePool: An() } } function Uh(Ae, Se, Te) { return Ae = Ae !== null ? Ae.childLanes & ~Te : 0, Se && (Ae |= Ua), Ae } function op(Ae, Se, Te) { var ke = Se.pendingProps, $e = !1, Ke = (Se.flags & 128) !== 0, wn; if ((wn = Ke) || (wn = Ae !== null && Ae.memoizedState === null ? !1 : (Ss.current & 2) !== 0), wn && ($e = !0, Se.flags &= -129), wn = (Se.flags & 32) !== 0, Se.flags &= -33, Ae === null) { if (Ri) { if ($e ? Jl(Se) : tc(), Ri) { var Mn = Qi, Hn; if (Hn = Mn) { e: { for (Hn = Mn, Mn = Ma; Hn.nodeType !== 8;) { if (!Mn) { Mn = null; break e } if (Hn = fo(Hn.nextSibling), Hn === null) { Mn = null; break e } } Mn = Hn } Mn !== null ? (Se.memoizedState = { dehydrated: Mn, treeContext: cl !== null ? { id: no, overflow: ro } : null, retryLane: 536870912, hydrationErrors: null }, Hn = Ts(18, null, null, 0), Hn.stateNode = Mn, Hn.return = Se, Se.child = Hn, us = Se, Qi = null, Hn = !0) : Hn = !1 } Hn || dl(Se) } if (Mn = Se.memoizedState, Mn !== null && (Mn = Mn.dehydrated, Mn !== null)) return Sf(Mn) ? Se.lanes = 32 : Se.lanes = 536870912, null; bl(Se) } return Mn = ke.children, ke = ke.fallback, $e ? (tc(), $e = Se.mode, Mn = nh({ mode: "hidden", children: Mn }, $e), ke = eo(ke, $e, Te, null), Mn.return = Se, ke.return = Se, Mn.sibling = ke, Se.child = Mn, $e = Se.child, $e.memoizedState = Bh(Te), $e.childLanes = Uh(Ae, wn, Te), Se.memoizedState = Fh, ke) : (Jl(Se), zh(Se, Mn)) } if (Hn = Ae.memoizedState, Hn !== null && (Mn = Hn.dehydrated, Mn !== null)) { if (Ke) Se.flags & 256 ? (Jl(Se), Se.flags &= -257, Se = Hh(Ae, Se, Te)) : Se.memoizedState !== null ? (tc(), Se.child = Ae.child, Se.flags |= 128, Se = null) : (tc(), $e = ke.fallback, Mn = Se.mode, ke = nh({ mode: "visible", children: ke.children }, Mn), $e = eo($e, Mn, Te, null), $e.flags |= 2, ke.return = Se, $e.return = Se, ke.sibling = $e, Se.child = ke, Ru(Se, Ae.child, null, Te), ke = Se.child, ke.memoizedState = Bh(Te), ke.childLanes = Uh(Ae, wn, Te), Se.memoizedState = Fh, Se = $e); else if (Jl(Se), Sf(Mn)) { if (wn = Mn.nextSibling && Mn.nextSibling.dataset, wn) var or = wn.dgst; wn = or, ke = Error(Ee(419)), ke.stack = "", ke.digest = wn, Gl({ value: ke, source: null, stack: null }), Se = Hh(Ae, Se, Te) } else if (Ns || Wl(Ae, Se, Te, !1), wn = (Te & Ae.childLanes) !== 0, Ns || wn) { if (wn = qi, wn !== null && (ke = Te & -Te, ke = (ke & 42) !== 0 ? 1 : hi(ke), ke = (ke & (wn.suspendedLanes | Te)) !== 0 ? 0 : ke, ke !== 0 && ke !== Hn.retryLane)) throw Hn.retryLane = ke, Ja(Ae, ke), Ra(wn, Ae, ke), Zf; Mn.data === "$?" || of(), Se = Hh(Ae, Se, Te) } else Mn.data === "$?" ? (Se.flags |= 192, Se.child = Ae.child, Se = null) : (Ae = Hn.treeContext, Qi = fo(Mn.nextSibling), us = Se, Ri = !0, ko = null, Ma = !1, Ae !== null && (oa[Js++] = no, oa[Js++] = ro, oa[Js++] = cl, no = Ae.id, ro = Ae.overflow, cl = Se), Se = zh(Se, ke.children), Se.flags |= 4096); return Se } return $e ? (tc(), $e = ke.fallback, Mn = Se.mode, Hn = Ae.child, or = Hn.sibling, ke = ja(Hn, { mode: "hidden", children: ke.children }), ke.subtreeFlags = Hn.subtreeFlags & 65011712, or !== null ? $e = ja(or, $e) : ($e = eo($e, Mn, Te, null), $e.flags |= 2), $e.return = Se, ke.return = Se, ke.sibling = $e, Se.child = ke, ke = $e, $e = Se.child, Mn = Ae.child.memoizedState, Mn === null ? Mn = Bh(Te) : (Hn = Mn.cachePool, Hn !== null ? (or = hs._currentValue, Hn = Hn.parent !== or ? { parent: or, pool: or } : Hn) : Hn = An(), Mn = { baseLanes: Mn.baseLanes | Te, cachePool: Hn }), $e.memoizedState = Mn, $e.childLanes = Uh(Ae, wn, Te), Se.memoizedState = Fh, ke) : (Jl(Se), Te = Ae.child, Ae = Te.sibling, Te = ja(Te, { mode: "visible", children: ke.children }), Te.return = Se, Te.sibling = null, Ae !== null && (wn = Se.deletions, wn === null ? (Se.deletions = [Ae], Se.flags |= 16) : wn.push(Ae)), Se.child = Te, Se.memoizedState = null, Te) } function zh(Ae, Se) { return Se = nh({ mode: "visible", children: Se }, Ae.mode), Se.return = Ae, Ae.child = Se } function nh(Ae, Se) { return Ae = Ts(22, Ae, null, Se), Ae.lanes = 0, Ae.stateNode = { _visibility: 1, _pendingMarkers: null, _retryCache: null, _transitions: null }, Ae } function Hh(Ae, Se, Te) { return Ru(Se, Ae.child, null, Te), Ae = zh(Se, Se.pendingProps.children), Ae.flags |= 2, Se.memoizedState = null, Ae } function lp(Ae, Se, Te) { Ae.lanes |= Se; var ke = Ae.alternate; ke !== null && (ke.lanes |= Se), mu(Ae.return, Se, Te) } function qh(Ae, Se, Te, ke, $e) { var Ke = Ae.memoizedState; Ke === null ? Ae.memoizedState = { isBackwards: Se, rendering: null, renderingStartTime: 0, last: ke, tail: Te, tailMode: $e } : (Ke.isBackwards = Se, Ke.rendering = null, Ke.renderingStartTime = 0, Ke.last = ke, Ke.tail = Te, Ke.tailMode = $e) } function cp(Ae, Se, Te) { var ke = Se.pendingProps, $e = ke.revealOrder, Ke = ke.tail; if (ks(Ae, Se, ke.children, Te), ke = Ss.current, (ke & 2) !== 0) ke = ke & 1 | 2, Se.flags |= 128; else { if (Ae !== null && (Ae.flags & 128) !== 0) e: for (Ae = Se.child; Ae !== null;) { if (Ae.tag === 13) Ae.memoizedState !== null && lp(Ae, Te, Se); else if (Ae.tag === 19) lp(Ae, Te, Se); else if (Ae.child !== null) { Ae.child.return = Ae, Ae = Ae.child; continue } if (Ae === Se) break e; for (; Ae.sibling === null;) { if (Ae.return === null || Ae.return === Se) break e; Ae = Ae.return } Ae.sibling.return = Ae.return, Ae = Ae.sibling } ke &= 1 } switch (rn(Ss, ke), $e) { case "forwards": for (Te = Se.child, $e = null; Te !== null;)Ae = Te.alternate, Ae !== null && Zd(Ae) === null && ($e = Te), Te = Te.sibling; Te = $e, Te === null ? ($e = Se.child, Se.child = null) : ($e = Te.sibling, Te.sibling = null), qh(Se, !1, $e, Te, Ke); break; case "backwards": for (Te = null, $e = Se.child, Se.child = null; $e !== null;) { if (Ae = $e.alternate, Ae !== null && Zd(Ae) === null) { Se.child = $e; break } Ae = $e.sibling, $e.sibling = Te, Te = $e, $e = Ae } qh(Se, !0, Te, null, Ke); break; case "together": qh(Se, !1, null, null, void 0); break; default: Se.memoizedState = null }return Se.child } function xl(Ae, Se, Te) { if (Ae !== null && (Se.dependencies = Ae.dependencies), ac |= Se.lanes, (Te & Se.childLanes) === 0) if (Ae !== null) { if (Wl(Ae, Se, Te, !1), (Te & Se.childLanes) === 0) return null } else return null; if (Ae !== null && Se.child !== Ae.child) throw Error(Ee(153)); if (Se.child !== null) { for (Ae = Se.child, Te = ja(Ae, Ae.pendingProps), Se.child = Te, Te.return = Se; Ae.sibling !== null;)Ae = Ae.sibling, Te = Te.sibling = ja(Ae, Ae.pendingProps), Te.return = Se; Te.sibling = null } return Se.child } function $h(Ae, Se) { return (Ae.lanes & Se) !== 0 ? !0 : (Ae = Ae.dependencies, !!(Ae !== null && vu(Ae))) } function Mm(Ae, Se, Te) { switch (Se.tag) { case 3: pn(Se, Se.stateNode.containerInfo), Io(Se, hs, Ae.memoizedState.cache), ea(); break; case 27: case 5: _n(Se); break; case 4: pn(Se, Se.stateNode.containerInfo); break; case 10: Io(Se, Se.type, Se.memoizedProps.value); break; case 13: var ke = Se.memoizedState; if (ke !== null) return ke.dehydrated !== null ? (Jl(Se), Se.flags |= 128, null) : (Te & Se.child.childLanes) !== 0 ? op(Ae, Se, Te) : (Jl(Se), Ae = xl(Ae, Se, Te), Ae !== null ? Ae.sibling : null); Jl(Se); break; case 19: var $e = (Ae.flags & 128) !== 0; if (ke = (Te & Se.childLanes) !== 0, ke || (Wl(Ae, Se, Te, !1), ke = (Te & Se.childLanes) !== 0), $e) { if (ke) return cp(Ae, Se, Te); Se.flags |= 128 } if ($e = Se.memoizedState, $e !== null && ($e.rendering = null, $e.tail = null, $e.lastEffect = null), rn(Ss, Ss.current), ke) break; return null; case 22: case 23: return Se.lanes = 0, np(Ae, Se, Te); case 24: Io(Se, hs, Ae.memoizedState.cache) }return xl(Ae, Se, Te) } function up(Ae, Se, Te) { if (Ae !== null) if (Ae.memoizedProps !== Se.pendingProps) Ns = !0; else { if (!$h(Ae, Te) && (Se.flags & 128) === 0) return Ns = !1, Mm(Ae, Se, Te); Ns = (Ae.flags & 131072) !== 0 } else Ns = !1, Ri && (Se.flags & 1048576) !== 0 && Ld(Se, pu, Se.index); switch (Se.lanes = 0, Se.tag) { case 16: e: { Ae = Se.pendingProps; var ke = Se.elementType, $e = ke._init; if (ke = $e(ke._payload), Se.type = ke, typeof ke == "function") $l(ke) ? (Ae = Kc(ke, Ae), Se.tag = 1, Se = sp(null, Se, ke, Ae, Te)) : (Se.tag = 0, Se = Ih(null, Se, ke, Ae, Te)); else { if (ke != null) { if ($e = ke.$$typeof, $e === sn) { Se.tag = 11, Se = Jf(null, Se, ke, Ae, Te); break e } else if ($e === un) { Se.tag = 14, Se = ep(null, Se, ke, Ae, Te); break e } } throw Se = Rn(ke) || ke, Error(Ee(306, Se, "")) } } return Se; case 0: return Ih(Ae, Se, Se.type, Se.pendingProps, Te); case 1: return ke = Se.type, $e = Kc(ke, Se.pendingProps), sp(Ae, Se, ke, $e, Te); case 3: e: { if (pn(Se, Se.stateNode.containerInfo), Ae === null) throw Error(Ee(387)); ke = Se.pendingProps; var Ke = Se.memoizedState; $e = Ke.element, Zn(Ae, Se), Pr(Se, ke, null, Te); var wn = Se.memoizedState; if (ke = wn.cache, Io(Se, hs, ke), ke !== Ke.cache && gu(Se, [hs], Te, !0), Hr(), ke = wn.element, Ke.isDehydrated) if (Ke = { element: ke, isDehydrated: !1, cache: wn.cache }, Se.updateQueue.baseState = Ke, Se.memoizedState = Ke, Se.flags & 256) { Se = ap(Ae, Se, ke, Te); break e } else if (ke !== $e) { $e = li(Error(Ee(424)), Se), Gl($e), Se = ap(Ae, Se, ke, Te); break e } else { switch (Ae = Se.stateNode.containerInfo, Ae.nodeType) { case 9: Ae = Ae.body; break; default: Ae = Ae.nodeName === "HTML" ? Ae.ownerDocument.body : Ae }for (Qi = fo(Ae.firstChild), us = Se, Ri = !0, ko = null, Ma = !0, Te = Hf(Se, null, ke, Te), Se.child = Te; Te;)Te.flags = Te.flags & -3 | 4096, Te = Te.sibling } else { if (ea(), ke === $e) { Se = xl(Ae, Se, Te); break e } ks(Ae, Se, ke, Te) } Se = Se.child } return Se; case 26: return th(Ae, Se), Ae === null ? (Te = pm(Se.type, null, Se.pendingProps, null)) ? Se.memoizedState = Te : Ri || (Te = Se.type, Ae = Se.pendingProps, ke = gh(Ye.current).createElement(Te), ke[pi] = Se, ke[ni] = Ae, Fs(ke, Te, Ae), Li(ke), Se.stateNode = ke) : Se.memoizedState = pm(Se.type, Ae.memoizedProps, Se.pendingProps, Ae.memoizedState), null; case 27: return _n(Se), Ae === null && Ri && (ke = Se.stateNode = dm(Se.type, Se.pendingProps, Ye.current), us = Se, Ma = !0, $e = Qi, dc(Se.type) ? (_f = $e, Qi = fo(ke.firstChild)) : Qi = $e), ks(Ae, Se, Se.pendingProps.children, Te), th(Ae, Se), Ae === null && (Se.flags |= 4194304), Se.child; case 5: return Ae === null && Ri && (($e = ke = Qi) && (ke = lg(ke, Se.type, Se.pendingProps, Ma), ke !== null ? (Se.stateNode = ke, us = Se, Qi = fo(ke.firstChild), Ma = !1, $e = !0) : $e = !1), $e || dl(Se)), _n(Se), $e = Se.type, Ke = Se.pendingProps, wn = Ae !== null ? Ae.memoizedProps : null, ke = Ke.children, Ef($e, Ke) ? ke = null : wn !== null && Ef($e, wn) && (Se.flags |= 32), Se.memoizedState !== null && ($e = xa(Ae, Se, Uo, null, null, Te), Cd._currentValue = $e), th(Ae, Se), ks(Ae, Se, ke, Te), Se.child; case 6: return Ae === null && Ri && ((Ae = Te = Qi) && (Te = cg(Te, Se.pendingProps, Ma), Te !== null ? (Se.stateNode = Te, us = Se, Qi = null, Ae = !0) : Ae = !1), Ae || dl(Se)), null; case 13: return op(Ae, Se, Te); case 4: return pn(Se, Se.stateNode.containerInfo), ke = Se.pendingProps, Ae === null ? Se.child = Ru(Se, null, ke, Te) : ks(Ae, Se, ke, Te), Se.child; case 11: return Jf(Ae, Se, Se.type, Se.pendingProps, Te); case 7: return ks(Ae, Se, Se.pendingProps, Te), Se.child; case 8: return ks(Ae, Se, Se.pendingProps.children, Te), Se.child; case 12: return ks(Ae, Se, Se.pendingProps.children, Te), Se.child; case 10: return ke = Se.pendingProps, Io(Se, Se.type, ke.value), ks(Ae, Se, ke.children, Te), Se.child; case 9: return $e = Se.type._context, ke = Se.pendingProps.children, Ia(Se), $e = ds($e), ke = ke($e), Se.flags |= 1, ks(Ae, Se, ke, Te), Se.child; case 14: return ep(Ae, Se, Se.type, Se.pendingProps, Te); case 15: return tp(Ae, Se, Se.type, Se.pendingProps, Te); case 19: return cp(Ae, Se, Te); case 31: return ke = Se.pendingProps, Te = Se.mode, ke = { mode: ke.mode, children: ke.children }, Ae === null ? (Te = nh(ke, Te), Te.ref = Se.ref, Se.child = Te, Te.return = Se, Se = Te) : (Te = ja(Ae.child, ke), Te.ref = Se.ref, Se.child = Te, Te.return = Se, Se = Te), Se; case 22: return np(Ae, Se, Te); case 24: return Ia(Se), ke = ds(hs), Ae === null ? ($e = en(), $e === null && ($e = qi, Ke = Xu(), $e.pooledCache = Ke, Ke.refCount++, Ke !== null && ($e.pooledCacheLanes |= Te), $e = Ke), Se.memoizedState = { parent: ke, cache: $e }, Wn(Se), Io(Se, hs, $e)) : ((Ae.lanes & Te) !== 0 && (Zn(Ae, Se), Pr(Se, null, null, Te), Hr()), $e = Ae.memoizedState, Ke = Se.memoizedState, $e.parent !== ke ? ($e = { parent: ke, cache: ke }, Se.memoizedState = $e, Se.lanes === 0 && (Se.memoizedState = Se.updateQueue.baseState = $e), Io(Se, hs, ke)) : (ke = Ke.cache, Io(Se, hs, ke), ke !== $e.cache && gu(Se, [hs], Te, !0))), ks(Ae, Se, Se.pendingProps.children, Te), Se.child; case 29: throw Se.pendingProps }throw Error(Ee(156, Se.tag)) } function yl(Ae) { Ae.flags |= 4 } function dp(Ae, Se) { if (Se.type !== "stylesheet" || (Se.state.loading & 4) !== 0) Ae.flags &= -16777217; else if (Ae.flags |= 16777216, !xm(Se)) { if (Se = Ba.current, Se !== null && ((_i & 4194048) === _i ? qo !== null : (_i & 62914560) !== _i && (_i & 536870912) === 0 || Se !== qo)) throw nr = Dn, Ln; Ae.flags |= 8192 } } function rh(Ae, Se) { Se !== null && (Ae.flags |= 4), Ae.flags & 16384 && (Se = Ae.tag !== 22 ? ei() : 536870912, Ae.lanes |= Se, Pu |= Se) } function dd(Ae, Se) { if (!Ri) switch (Ae.tailMode) { case "hidden": Se = Ae.tail; for (var Te = null; Se !== null;)Se.alternate !== null && (Te = Se), Se = Se.sibling; Te === null ? Ae.tail = null : Te.sibling = null; break; case "collapsed": Te = Ae.tail; for (var ke = null; Te !== null;)Te.alternate !== null && (ke = Te), Te = Te.sibling; ke === null ? Se || Ae.tail === null ? Ae.tail = null : Ae.tail.sibling = null : ke.sibling = null } } function is(Ae) { var Se = Ae.alternate !== null && Ae.alternate.child === Ae.child, Te = 0, ke = 0; if (Se) for (var $e = Ae.child; $e !== null;)Te |= $e.lanes | $e.childLanes, ke |= $e.subtreeFlags & 65011712, ke |= $e.flags & 65011712, $e.return = Ae, $e = $e.sibling; else for ($e = Ae.child; $e !== null;)Te |= $e.lanes | $e.childLanes, ke |= $e.subtreeFlags, ke |= $e.flags, $e.return = Ae, $e = $e.sibling; return Ae.subtreeFlags |= ke, Ae.childLanes = Te, Se } function Dm(Ae, Se, Te) { var ke = Se.pendingProps; switch (Ic(Se), Se.tag) { case 31: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return is(Se), null; case 1: return is(Se), null; case 3: return Te = Se.stateNode, ke = null, Ae !== null && (ke = Ae.memoizedState.cache), Se.memoizedState.cache !== ke && (Se.flags |= 2048), ka(hs), yn(), Te.pendingContext && (Te.context = Te.pendingContext, Te.pendingContext = null), (Ae === null || Ae.child === null) && (Ms(Se) ? yl(Se) : Ae === null || Ae.memoizedState.isDehydrated && (Se.flags & 256) === 0 || (Se.flags |= 1024, Md())), is(Se), null; case 26: return Te = Se.memoizedState, Ae === null ? (yl(Se), Te !== null ? (is(Se), dp(Se, Te)) : (is(Se), Se.flags &= -16777217)) : Te ? Te !== Ae.memoizedState ? (yl(Se), is(Se), dp(Se, Te)) : (is(Se), Se.flags &= -16777217) : (Ae.memoizedProps !== ke && yl(Se), is(Se), Se.flags &= -16777217), null; case 27: On(Se), Te = Ye.current; var $e = Se.type; if (Ae !== null && Se.stateNode != null) Ae.memoizedProps !== ke && yl(Se); else { if (!ke) { if (Se.stateNode === null) throw Error(Ee(166)); return is(Se), null } Ae = hn.current, Ms(Se) ? jd(Se) : (Ae = dm($e, ke, Te), Se.stateNode = Ae, yl(Se)) } return is(Se), null; case 5: if (On(Se), Te = Se.type, Ae !== null && Se.stateNode != null) Ae.memoizedProps !== ke && yl(Se); else { if (!ke) { if (Se.stateNode === null) throw Error(Ee(166)); return is(Se), null } if (Ae = hn.current, Ms(Se)) jd(Se); else { switch ($e = gh(Ye.current), Ae) { case 1: Ae = $e.createElementNS("http://www.w3.org/2000/svg", Te); break; case 2: Ae = $e.createElementNS("http://www.w3.org/1998/Math/MathML", Te); break; default: switch (Te) { case "svg": Ae = $e.createElementNS("http://www.w3.org/2000/svg", Te); break; case "math": Ae = $e.createElementNS("http://www.w3.org/1998/Math/MathML", Te); break; case "script": Ae = $e.createElement("div"), Ae.innerHTML = "<script><\/script>", Ae = Ae.removeChild(Ae.firstChild); break; case "select": Ae = typeof ke.is == "string" ? $e.createElement("select", { is: ke.is }) : $e.createElement("select"), ke.multiple ? Ae.multiple = !0 : ke.size && (Ae.size = ke.size); break; default: Ae = typeof ke.is == "string" ? $e.createElement(Te, { is: ke.is }) : $e.createElement(Te) } }Ae[pi] = Se, Ae[ni] = ke; e: for ($e = Se.child; $e !== null;) { if ($e.tag === 5 || $e.tag === 6) Ae.appendChild($e.stateNode); else if ($e.tag !== 4 && $e.tag !== 27 && $e.child !== null) { $e.child.return = $e, $e = $e.child; continue } if ($e === Se) break e; for (; $e.sibling === null;) { if ($e.return === null || $e.return === Se) break e; $e = $e.return } $e.sibling.return = $e.return, $e = $e.sibling } Se.stateNode = Ae; e: switch (Fs(Ae, Te, ke), Te) { case "button": case "input": case "select": case "textarea": Ae = !!ke.autoFocus; break e; case "img": Ae = !0; break e; default: Ae = !1 }Ae && yl(Se) } } return is(Se), Se.flags &= -16777217, null; case 6: if (Ae && Se.stateNode != null) Ae.memoizedProps !== ke && yl(Se); else { if (typeof ke != "string" && Se.stateNode === null) throw Error(Ee(166)); if (Ae = Ye.current, Ms(Se)) { if (Ae = Se.stateNode, Te = Se.memoizedProps, ke = null, $e = us, $e !== null) switch ($e.tag) { case 27: case 5: ke = $e.memoizedProps }Ae[pi] = Se, Ae = !!(Ae.nodeValue === Te || ke !== null && ke.suppressHydrationWarning === !0 || im(Ae.nodeValue, Te)), Ae || dl(Se) } else Ae = gh(Ae).createTextNode(ke), Ae[pi] = Se, Se.stateNode = Ae } return is(Se), null; case 13: if (ke = Se.memoizedState, Ae === null || Ae.memoizedState !== null && Ae.memoizedState.dehydrated !== null) { if ($e = Ms(Se), ke !== null && ke.dehydrated !== null) { if (Ae === null) { if (!$e) throw Error(Ee(318)); if ($e = Se.memoizedState, $e = $e !== null ? $e.dehydrated : null, !$e) throw Error(Ee(317)); $e[pi] = Se } else ea(), (Se.flags & 128) === 0 && (Se.memoizedState = null), Se.flags |= 4; is(Se), $e = !1 } else $e = Md(), Ae !== null && Ae.memoizedState !== null && (Ae.memoizedState.hydrationErrors = $e), $e = !0; if (!$e) return Se.flags & 256 ? (bl(Se), Se) : (bl(Se), null) } if (bl(Se), (Se.flags & 128) !== 0) return Se.lanes = Te, Se; if (Te = ke !== null, Ae = Ae !== null && Ae.memoizedState !== null, Te) { ke = Se.child, $e = null, ke.alternate !== null && ke.alternate.memoizedState !== null && ke.alternate.memoizedState.cachePool !== null && ($e = ke.alternate.memoizedState.cachePool.pool); var Ke = null; ke.memoizedState !== null && ke.memoizedState.cachePool !== null && (Ke = ke.memoizedState.cachePool.pool), Ke !== $e && (ke.flags |= 2048) } return Te !== Ae && Te && (Se.child.flags |= 8192), rh(Se, Se.updateQueue), is(Se), null; case 4: return yn(), Ae === null && gf(Se.stateNode.containerInfo), is(Se), null; case 10: return ka(Se.type), is(Se), null; case 19: if (Je(Ss), $e = Se.memoizedState, $e === null) return is(Se), null; if (ke = (Se.flags & 128) !== 0, Ke = $e.rendering, Ke === null) if (ke) dd($e, !1); else { if (ls !== 0 || Ae !== null && (Ae.flags & 128) !== 0) for (Ae = Se.child; Ae !== null;) { if (Ke = Zd(Ae), Ke !== null) { for (Se.flags |= 128, dd($e, !1), Ae = Ke.updateQueue, Se.updateQueue = Ae, rh(Se, Ae), Se.subtreeFlags = 0, Ae = Te, Te = Se.child; Te !== null;)Mc(Te, Ae), Te = Te.sibling; return rn(Ss, Ss.current & 1 | 2), Se.child } Ae = Ae.sibling } $e.tail !== null && Vn() > ah && (Se.flags |= 128, ke = !0, dd($e, !1), Se.lanes = 4194304) } else { if (!ke) if (Ae = Zd(Ke), Ae !== null) { if (Se.flags |= 128, ke = !0, Ae = Ae.updateQueue, Se.updateQueue = Ae, rh(Se, Ae), dd($e, !0), $e.tail === null && $e.tailMode === "hidden" && !Ke.alternate && !Ri) return is(Se), null } else 2 * Vn() - $e.renderingStartTime > ah && Te !== 536870912 && (Se.flags |= 128, ke = !0, dd($e, !1), Se.lanes = 4194304); $e.isBackwards ? (Ke.sibling = Se.child, Se.child = Ke) : (Ae = $e.last, Ae !== null ? Ae.sibling = Ke : Se.child = Ke, $e.last = Ke) } return $e.tail !== null ? (Se = $e.tail, $e.rendering = Se, $e.tail = Se.sibling, $e.renderingStartTime = Vn(), Se.sibling = null, Ae = Ss.current, rn(Ss, ke ? Ae & 1 | 2 : Ae & 1), Se) : (is(Se), null); case 22: case 23: return bl(Se), Zr(), ke = Se.memoizedState !== null, Ae !== null ? Ae.memoizedState !== null !== ke && (Se.flags |= 8192) : ke && (Se.flags |= 8192), ke ? (Te & 536870912) !== 0 && (Se.flags & 128) === 0 && (is(Se), Se.subtreeFlags & 6 && (Se.flags |= 8192)) : is(Se), Te = Se.updateQueue, Te !== null && rh(Se, Te.retryQueue), Te = null, Ae !== null && Ae.memoizedState !== null && Ae.memoizedState.cachePool !== null && (Te = Ae.memoizedState.cachePool.pool), ke = null, Se.memoizedState !== null && Se.memoizedState.cachePool !== null && (ke = Se.memoizedState.cachePool.pool), ke !== Te && (Se.flags |= 2048), Ae !== null && Je(Ve), null; case 24: return Te = null, Ae !== null && (Te = Ae.memoizedState.cache), Se.memoizedState.cache !== Te && (Se.flags |= 2048), ka(hs), is(Se), null; case 25: return null; case 30: return null }throw Error(Ee(156, Se.tag)) } function km(Ae, Se) { switch (Ic(Se), Se.tag) { case 1: return Ae = Se.flags, Ae & 65536 ? (Se.flags = Ae & -65537 | 128, Se) : null; case 3: return ka(hs), yn(), Ae = Se.flags, (Ae & 65536) !== 0 && (Ae & 128) === 0 ? (Se.flags = Ae & -65537 | 128, Se) : null; case 26: case 27: case 5: return On(Se), null; case 13: if (bl(Se), Ae = Se.memoizedState, Ae !== null && Ae.dehydrated !== null) { if (Se.alternate === null) throw Error(Ee(340)); ea() } return Ae = Se.flags, Ae & 65536 ? (Se.flags = Ae & -65537 | 128, Se) : null; case 19: return Je(Ss), null; case 4: return yn(), null; case 10: return ka(Se.type), null; case 22: case 23: return bl(Se), Zr(), Ae !== null && Je(Ve), Ae = Se.flags, Ae & 65536 ? (Se.flags = Ae & -65537 | 128, Se) : null; case 24: return ka(hs), null; case 25: return null; default: return null } } function hp(Ae, Se) { switch (Ic(Se), Se.tag) { case 3: ka(hs), yn(); break; case 26: case 27: case 5: On(Se); break; case 4: yn(); break; case 13: bl(Se); break; case 19: Je(Ss); break; case 10: ka(Se.type); break; case 22: case 23: bl(Se), Zr(), Ae !== null && Je(Ve); break; case 24: ka(hs) } } function hd(Ae, Se) { try { var Te = Se.updateQueue, ke = Te !== null ? Te.lastEffect : null; if (ke !== null) { var $e = ke.next; Te = $e; do { if ((Te.tag & Ae) === Ae) { ke = void 0; var Ke = Te.create, wn = Te.inst; ke = Ke(), wn.destroy = ke } Te = Te.next } while (Te !== $e) } } catch (Mn) { Ui(Se, Se.return, Mn) } } function nc(Ae, Se, Te) { try { var ke = Se.updateQueue, $e = ke !== null ? ke.lastEffect : null; if ($e !== null) { var Ke = $e.next; ke = Ke; do { if ((ke.tag & Ae) === Ae) { var wn = ke.inst, Mn = wn.destroy; if (Mn !== void 0) { wn.destroy = void 0, $e = Se; var Hn = Te, or = Mn; try { or() } catch (gr) { Ui($e, Hn, gr) } } } ke = ke.next } while (ke !== Ke) } } catch (gr) { Ui(Se, Se.return, gr) } } function fp(Ae) { var Se = Ae.updateQueue; if (Se !== null) { var Te = Ae.stateNode; try { Ci(Se, Te) } catch (ke) { Ui(Ae, Ae.return, ke) } } } function pp(Ae, Se, Te) { Te.props = Kc(Ae.type, Ae.memoizedProps), Te.state = Ae.memoizedState; try { Te.componentWillUnmount() } catch (ke) { Ui(Ae, Se, ke) } } function pd(Ae, Se) { try { var Te = Ae.ref; if (Te !== null) { switch (Ae.tag) { case 26: case 27: case 5: var ke = Ae.stateNode; break; case 30: ke = Ae.stateNode; break; default: ke = Ae.stateNode }typeof Te == "function" ? Ae.refCleanup = Te(ke) : Te.current = ke } } catch ($e) { Ui(Ae, Se, $e) } } function $o(Ae, Se) { var Te = Ae.ref, ke = Ae.refCleanup; if (Te !== null) if (typeof ke == "function") try { ke() } catch ($e) { Ui(Ae, Se, $e) } finally { Ae.refCleanup = null, Ae = Ae.alternate, Ae != null && (Ae.refCleanup = null) } else if (typeof Te == "function") try { Te(null) } catch ($e) { Ui(Ae, Se, $e) } else Te.current = null } function mp(Ae) { var Se = Ae.type, Te = Ae.memoizedProps, ke = Ae.stateNode; try { e: switch (Se) { case "button": case "input": case "select": case "textarea": Te.autoFocus && ke.focus(); break e; case "img": Te.src ? ke.src = Te.src : Te.srcSet && (ke.srcset = Te.srcSet) } } catch ($e) { Ui(Ae, Ae.return, $e) } } function Vh(Ae, Se, Te) { try { var ke = Ae.stateNode; rg(ke, Ae.type, Te, Se), ke[ni] = Se } catch ($e) { Ui(Ae, Ae.return, $e) } } function gp(Ae) { return Ae.tag === 5 || Ae.tag === 3 || Ae.tag === 26 || Ae.tag === 27 && dc(Ae.type) || Ae.tag === 4 } function Gh(Ae) { e: for (; ;) { for (; Ae.sibling === null;) { if (Ae.return === null || gp(Ae.return)) return null; Ae = Ae.return } for (Ae.sibling.return = Ae.return, Ae = Ae.sibling; Ae.tag !== 5 && Ae.tag !== 6 && Ae.tag !== 18;) { if (Ae.tag === 27 && dc(Ae.type) || Ae.flags & 2 || Ae.child === null || Ae.tag === 4) continue e; Ae.child.return = Ae, Ae = Ae.child } if (!(Ae.flags & 2)) return Ae.stateNode } } function Wh(Ae, Se, Te) { var ke = Ae.tag; if (ke === 5 || ke === 6) Ae = Ae.stateNode, Se ? (Te.nodeType === 9 ? Te.body : Te.nodeName === "HTML" ? Te.ownerDocument.body : Te).insertBefore(Ae, Se) : (Se = Te.nodeType === 9 ? Te.body : Te.nodeName === "HTML" ? Te.ownerDocument.body : Te, Se.appendChild(Ae), Te = Te._reactRootContainer, Te != null || Se.onclick !== null || (Se.onclick = mh)); else if (ke !== 4 && (ke === 27 && dc(Ae.type) && (Te = Ae.stateNode, Se = null), Ae = Ae.child, Ae !== null)) for (Wh(Ae, Se, Te), Ae = Ae.sibling; Ae !== null;)Wh(Ae, Se, Te), Ae = Ae.sibling } function ih(Ae, Se, Te) { var ke = Ae.tag; if (ke === 5 || ke === 6) Ae = Ae.stateNode, Se ? Te.insertBefore(Ae, Se) : Te.appendChild(Ae); else if (ke !== 4 && (ke === 27 && dc(Ae.type) && (Te = Ae.stateNode), Ae = Ae.child, Ae !== null)) for (ih(Ae, Se, Te), Ae = Ae.sibling; Ae !== null;)ih(Ae, Se, Te), Ae = Ae.sibling } function vp(Ae) { var Se = Ae.stateNode, Te = Ae.memoizedProps; try { for (var ke = Ae.type, $e = Se.attributes; $e.length;)Se.removeAttributeNode($e[0]); Fs(Se, ke, Te), Se[pi] = Ae, Se[ni] = Te } catch (Ke) { Ui(Ae, Ae.return, Ke) } } var El = !1, ps = !1, Xh = !1, bp = typeof WeakSet == "function" ? WeakSet : Set, Ps = null; function Im(Ae, Se) { if (Ae = Ae.containerInfo, xf = wh, Ae = js(Ae), As(Ae)) { if ("selectionStart" in Ae) var Te = { start: Ae.selectionStart, end: Ae.selectionEnd }; else e: { Te = (Te = Ae.ownerDocument) && Te.defaultView || window; var ke = Te.getSelection && Te.getSelection(); if (ke && ke.rangeCount !== 0) { Te = ke.anchorNode; var $e = ke.anchorOffset, Ke = ke.focusNode; ke = ke.focusOffset; try { Te.nodeType, Ke.nodeType } catch { Te = null; break e } var wn = 0, Mn = -1, Hn = -1, or = 0, gr = 0, wr = Ae, lr = null; t: for (; ;) { for (var cr; wr !== Te || $e !== 0 && wr.nodeType !== 3 || (Mn = wn + $e), wr !== Ke || ke !== 0 && wr.nodeType !== 3 || (Hn = wn + ke), wr.nodeType === 3 && (wn += wr.nodeValue.length), (cr = wr.firstChild) !== null;)lr = wr, wr = cr; for (; ;) { if (wr === Ae) break t; if (lr === Te && ++or === $e && (Mn = wn), lr === Ke && ++gr === ke && (Hn = wn), (cr = wr.nextSibling) !== null) break; wr = lr, lr = wr.parentNode } wr = cr } Te = Mn === -1 || Hn === -1 ? null : { start: Mn, end: Hn } } else Te = null } Te = Te || { start: 0, end: 0 } } else Te = null; for (yf = { focusedElem: Ae, selectionRange: Te }, wh = !1, Ps = Se; Ps !== null;)if (Se = Ps, Ae = Se.child, (Se.subtreeFlags & 1024) !== 0 && Ae !== null) Ae.return = Se, Ps = Ae; else for (; Ps !== null;) { switch (Se = Ps, Ke = Se.alternate, Ae = Se.flags, Se.tag) { case 0: break; case 11: case 15: break; case 1: if ((Ae & 1024) !== 0 && Ke !== null) { Ae = void 0, Te = Se, $e = Ke.memoizedProps, Ke = Ke.memoizedState, ke = Te.stateNode; try { var Kr = Kc(Te.type, $e, Te.elementType === Te.type); Ae = ke.getSnapshotBeforeUpdate(Kr, Ke), ke.__reactInternalSnapshotBeforeUpdate = Ae } catch (Vr) { Ui(Te, Te.return, Vr) } } break; case 3: if ((Ae & 1024) !== 0) { if (Ae = Se.stateNode.containerInfo, Te = Ae.nodeType, Te === 9) Af(Ae); else if (Te === 1) switch (Ae.nodeName) { case "HEAD": case "HTML": case "BODY": Af(Ae); break; default: Ae.textContent = "" } } break; case 5: case 26: case 27: case 6: case 4: case 17: break; default: if ((Ae & 1024) !== 0) throw Error(Ee(163)) }if (Ae = Se.sibling, Ae !== null) { Ae.return = Se.return, Ps = Ae; break } Ps = Se.return } } function xp(Ae, Se, Te) { var ke = Te.flags; switch (Te.tag) { case 0: case 11: case 15: rc(Ae, Te), ke & 4 && hd(5, Te); break; case 1: if (rc(Ae, Te), ke & 4) if (Ae = Te.stateNode, Se === null) try { Ae.componentDidMount() } catch (wn) { Ui(Te, Te.return, wn) } else { var $e = Kc(Te.type, Se.memoizedProps); Se = Se.memoizedState; try { Ae.componentDidUpdate($e, Se, Ae.__reactInternalSnapshotBeforeUpdate) } catch (wn) { Ui(Te, Te.return, wn) } } ke & 64 && fp(Te), ke & 512 && pd(Te, Te.return); break; case 3: if (rc(Ae, Te), ke & 64 && (Ae = Te.updateQueue, Ae !== null)) { if (Se = null, Te.child !== null) switch (Te.child.tag) { case 27: case 5: Se = Te.child.stateNode; break; case 1: Se = Te.child.stateNode }try { Ci(Ae, Se) } catch (wn) { Ui(Te, Te.return, wn) } } break; case 27: Se === null && ke & 4 && vp(Te); case 26: case 5: rc(Ae, Te), Se === null && ke & 4 && mp(Te), ke & 512 && pd(Te, Te.return); break; case 12: rc(Ae, Te); break; case 13: rc(Ae, Te), ke & 4 && wp(Ae, Te), ke & 64 && (Ae = Te.memoizedState, Ae !== null && (Ae = Ae.dehydrated, Ae !== null && (Te = Gm.bind(null, Te), ug(Ae, Te)))); break; case 22: if (ke = Te.memoizedState !== null || El, !ke) { Se = Se !== null && Se.memoizedState !== null || ps, $e = El; var Ke = ps; El = ke, (ps = Se) && !Ke ? ic(Ae, Te, (Te.subtreeFlags & 8772) !== 0) : rc(Ae, Te), El = $e, ps = Ke } break; case 30: break; default: rc(Ae, Te) } } function yp(Ae) { var Se = Ae.alternate; Se !== null && (Ae.alternate = null, yp(Se)), Ae.child = null, Ae.deletions = null, Ae.sibling = null, Ae.tag === 5 && (Se = Ae.stateNode, Se !== null && Xs(Se)), Ae.stateNode = null, Ae.return = null, Ae.dependencies = null, Ae.memoizedProps = null, Ae.memoizedState = null, Ae.pendingProps = null, Ae.stateNode = null, Ae.updateQueue = null } var Zi = null, ca = !1; function wl(Ae, Se, Te) { for (Te = Te.child; Te !== null;)Ep(Ae, Se, Te), Te = Te.sibling } function Ep(Ae, Se, Te) { if (Dr && typeof Dr.onCommitFiberUnmount == "function") try { Dr.onCommitFiberUnmount(Ir, Te) } catch { } switch (Te.tag) { case 26: ps || $o(Te, Se), wl(Ae, Se, Te), Te.memoizedState ? Te.memoizedState.count-- : Te.stateNode && (Te = Te.stateNode, Te.parentNode.removeChild(Te)); break; case 27: ps || $o(Te, Se); var ke = Zi, $e = ca; dc(Te.type) && (Zi = Te.stateNode, ca = !1), wl(Ae, Se, Te), Ad(Te.stateNode), Zi = ke, ca = $e; break; case 5: ps || $o(Te, Se); case 6: if (ke = Zi, $e = ca, Zi = null, wl(Ae, Se, Te), Zi = ke, ca = $e, Zi !== null) if (ca) try { (Zi.nodeType === 9 ? Zi.body : Zi.nodeName === "HTML" ? Zi.ownerDocument.body : Zi).removeChild(Te.stateNode) } catch (Ke) { Ui(Te, Se, Ke) } else try { Zi.removeChild(Te.stateNode) } catch (Ke) { Ui(Te, Se, Ke) } break; case 18: Zi !== null && (ca ? (Ae = Zi, cm(Ae.nodeType === 9 ? Ae.body : Ae.nodeName === "HTML" ? Ae.ownerDocument.body : Ae, Te.stateNode), Od(Ae)) : cm(Zi, Te.stateNode)); break; case 4: ke = Zi, $e = ca, Zi = Te.stateNode.containerInfo, ca = !0, wl(Ae, Se, Te), Zi = ke, ca = $e; break; case 0: case 11: case 14: case 15: ps || nc(2, Te, Se), ps || nc(4, Te, Se), wl(Ae, Se, Te); break; case 1: ps || ($o(Te, Se), ke = Te.stateNode, typeof ke.componentWillUnmount == "function" && pp(Te, Se, ke)), wl(Ae, Se, Te); break; case 21: wl(Ae, Se, Te); break; case 22: ps = (ke = ps) || Te.memoizedState !== null, wl(Ae, Se, Te), ps = ke; break; default: wl(Ae, Se, Te) } } function wp(Ae, Se) { if (Se.memoizedState === null && (Ae = Se.alternate, Ae !== null && (Ae = Ae.memoizedState, Ae !== null && (Ae = Ae.dehydrated, Ae !== null)))) try { Od(Ae) } catch (Te) { Ui(Se, Se.return, Te) } } function Fm(Ae) { switch (Ae.tag) { case 13: case 19: var Se = Ae.stateNode; return Se === null && (Se = Ae.stateNode = new bp), Se; case 22: return Ae = Ae.stateNode, Se = Ae._retryCache, Se === null && (Se = Ae._retryCache = new bp), Se; default: throw Error(Ee(435, Ae.tag)) } } function Yh(Ae, Se) { var Te = Fm(Ae); Se.forEach(function (ke) { var $e = Wm.bind(null, Ae, ke); Te.has(ke) || (Te.add(ke), ke.then($e, $e)) }) } function Ea(Ae, Se) { var Te = Se.deletions; if (Te !== null) for (var ke = 0; ke < Te.length; ke++) { var $e = Te[ke], Ke = Ae, wn = Se, Mn = wn; e: for (; Mn !== null;) { switch (Mn.tag) { case 27: if (dc(Mn.type)) { Zi = Mn.stateNode, ca = !1; break e } break; case 5: Zi = Mn.stateNode, ca = !1; break e; case 3: case 4: Zi = Mn.stateNode.containerInfo, ca = !0; break e }Mn = Mn.return } if (Zi === null) throw Error(Ee(160)); Ep(Ke, wn, $e), Zi = null, ca = !1, Ke = $e.alternate, Ke !== null && (Ke.return = null), $e.return = null } if (Se.subtreeFlags & 13878) for (Se = Se.child; Se !== null;)Ap(Se, Ae), Se = Se.sibling } var ho = null; function Ap(Ae, Se) { var Te = Ae.alternate, ke = Ae.flags; switch (Ae.tag) { case 0: case 11: case 14: case 15: Ea(Se, Ae), wa(Ae), ke & 4 && (nc(3, Ae, Ae.return), hd(3, Ae), nc(5, Ae, Ae.return)); break; case 1: Ea(Se, Ae), wa(Ae), ke & 512 && (ps || Te === null || $o(Te, Te.return)), ke & 64 && El && (Ae = Ae.updateQueue, Ae !== null && (ke = Ae.callbacks, ke !== null && (Te = Ae.shared.hiddenCallbacks, Ae.shared.hiddenCallbacks = Te === null ? ke : Te.concat(ke)))); break; case 26: var $e = ho; if (Ea(Se, Ae), wa(Ae), ke & 512 && (ps || Te === null || $o(Te, Te.return)), ke & 4) { var Ke = Te !== null ? Te.memoizedState : null; if (ke = Ae.memoizedState, Te === null) if (ke === null) if (Ae.stateNode === null) { e: { ke = Ae.type, Te = Ae.memoizedProps, $e = $e.ownerDocument || $e; t: switch (ke) { case "title": Ke = $e.getElementsByTagName("title")[0], (!Ke || Ke[Ws] || Ke[pi] || Ke.namespaceURI === "http://www.w3.org/2000/svg" || Ke.hasAttribute("itemprop")) && (Ke = $e.createElement(ke), $e.head.insertBefore(Ke, $e.querySelector("head > title"))), Fs(Ke, ke, Te), Ke[pi] = Ae, Li(Ke), ke = Ke; break e; case "link": var wn = vm("link", "href", $e).get(ke + (Te.href || "")); if (wn) { for (var Mn = 0; Mn < wn.length; Mn++)if (Ke = wn[Mn], Ke.getAttribute("href") === (Te.href == null || Te.href === "" ? null : Te.href) && Ke.getAttribute("rel") === (Te.rel == null ? null : Te.rel) && Ke.getAttribute("title") === (Te.title == null ? null : Te.title) && Ke.getAttribute("crossorigin") === (Te.crossOrigin == null ? null : Te.crossOrigin)) { wn.splice(Mn, 1); break t } } Ke = $e.createElement(ke), Fs(Ke, ke, Te), $e.head.appendChild(Ke); break; case "meta": if (wn = vm("meta", "content", $e).get(ke + (Te.content || ""))) { for (Mn = 0; Mn < wn.length; Mn++)if (Ke = wn[Mn], Ke.getAttribute("content") === (Te.content == null ? null : "" + Te.content) && Ke.getAttribute("name") === (Te.name == null ? null : Te.name) && Ke.getAttribute("property") === (Te.property == null ? null : Te.property) && Ke.getAttribute("http-equiv") === (Te.httpEquiv == null ? null : Te.httpEquiv) && Ke.getAttribute("charset") === (Te.charSet == null ? null : Te.charSet)) { wn.splice(Mn, 1); break t } } Ke = $e.createElement(ke), Fs(Ke, ke, Te), $e.head.appendChild(Ke); break; default: throw Error(Ee(468, ke)) }Ke[pi] = Ae, Li(Ke), ke = Ke } Ae.stateNode = ke } else bm($e, Ae.type, Ae.stateNode); else Ae.stateNode = gm($e, ke, Ae.memoizedProps); else Ke !== ke ? (Ke === null ? Te.stateNode !== null && (Te = Te.stateNode, Te.parentNode.removeChild(Te)) : Ke.count--, ke === null ? bm($e, Ae.type, Ae.stateNode) : gm($e, ke, Ae.memoizedProps)) : ke === null && Ae.stateNode !== null && Vh(Ae, Ae.memoizedProps, Te.memoizedProps) } break; case 27: Ea(Se, Ae), wa(Ae), ke & 512 && (ps || Te === null || $o(Te, Te.return)), Te !== null && ke & 4 && Vh(Ae, Ae.memoizedProps, Te.memoizedProps); break; case 5: if (Ea(Se, Ae), wa(Ae), ke & 512 && (ps || Te === null || $o(Te, Te.return)), Ae.flags & 32) { $e = Ae.stateNode; try { vo($e, "") } catch (cr) { Ui(Ae, Ae.return, cr) } } ke & 4 && Ae.stateNode != null && ($e = Ae.memoizedProps, Vh(Ae, $e, Te !== null ? Te.memoizedProps : $e)), ke & 1024 && (Xh = !0); break; case 6: if (Ea(Se, Ae), wa(Ae), ke & 4) { if (Ae.stateNode === null) throw Error(Ee(162)); ke = Ae.memoizedProps, Te = Ae.stateNode; try { Te.nodeValue = ke } catch (cr) { Ui(Ae, Ae.return, cr) } } break; case 3: if (xh = null, $e = ho, ho = vh(Se.containerInfo), Ea(Se, Ae), ho = $e, wa(Ae), ke & 4 && Te !== null && Te.memoizedState.isDehydrated) try { Od(Se.containerInfo) } catch (cr) { Ui(Ae, Ae.return, cr) } Xh && (Xh = !1, Sp(Ae)); break; case 4: ke = ho, ho = vh(Ae.stateNode.containerInfo), Ea(Se, Ae), wa(Ae), ho = ke; break; case 12: Ea(Se, Ae), wa(Ae); break; case 13: Ea(Se, Ae), wa(Ae), Ae.child.flags & 8192 && Ae.memoizedState !== null != (Te !== null && Te.memoizedState !== null) && (tf = Vn()), ke & 4 && (ke = Ae.updateQueue, ke !== null && (Ae.updateQueue = null, Yh(Ae, ke))); break; case 22: $e = Ae.memoizedState !== null; var Hn = Te !== null && Te.memoizedState !== null, or = El, gr = ps; if (El = or || $e, ps = gr || Hn, Ea(Se, Ae), ps = gr, El = or, wa(Ae), ke & 8192) e: for (Se = Ae.stateNode, Se._visibility = $e ? Se._visibility & -2 : Se._visibility | 1, $e && (Te === null || Hn || El || ps || Qc(Ae)), Te = null, Se = Ae; ;) { if (Se.tag === 5 || Se.tag === 26) { if (Te === null) { Hn = Te = Se; try { if (Ke = Hn.stateNode, $e) wn = Ke.style, typeof wn.setProperty == "function" ? wn.setProperty("display", "none", "important") : wn.display = "none"; else { Mn = Hn.stateNode; var wr = Hn.memoizedProps.style, lr = wr != null && wr.hasOwnProperty("display") ? wr.display : null; Mn.style.display = lr == null || typeof lr == "boolean" ? "" : ("" + lr).trim() } } catch (cr) { Ui(Hn, Hn.return, cr) } } } else if (Se.tag === 6) { if (Te === null) { Hn = Se; try { Hn.stateNode.nodeValue = $e ? "" : Hn.memoizedProps } catch (cr) { Ui(Hn, Hn.return, cr) } } } else if ((Se.tag !== 22 && Se.tag !== 23 || Se.memoizedState === null || Se === Ae) && Se.child !== null) { Se.child.return = Se, Se = Se.child; continue } if (Se === Ae) break e; for (; Se.sibling === null;) { if (Se.return === null || Se.return === Ae) break e; Te === Se && (Te = null), Se = Se.return } Te === Se && (Te = null), Se.sibling.return = Se.return, Se = Se.sibling } ke & 4 && (ke = Ae.updateQueue, ke !== null && (Te = ke.retryQueue, Te !== null && (ke.retryQueue = null, Yh(Ae, Te)))); break; case 19: Ea(Se, Ae), wa(Ae), ke & 4 && (ke = Ae.updateQueue, ke !== null && (Ae.updateQueue = null, Yh(Ae, ke))); break; case 30: break; case 21: break; default: Ea(Se, Ae), wa(Ae) } } function wa(Ae) { var Se = Ae.flags; if (Se & 2) { try { for (var Te, ke = Ae.return; ke !== null;) { if (gp(ke)) { Te = ke; break } ke = ke.return } if (Te == null) throw Error(Ee(160)); switch (Te.tag) { case 27: var $e = Te.stateNode, Ke = Gh(Ae); ih(Ae, Ke, $e); break; case 5: var wn = Te.stateNode; Te.flags & 32 && (vo(wn, ""), Te.flags &= -33); var Mn = Gh(Ae); ih(Ae, Mn, wn); break; case 3: case 4: var Hn = Te.stateNode.containerInfo, or = Gh(Ae); Wh(Ae, or, Hn); break; default: throw Error(Ee(161)) } } catch (gr) { Ui(Ae, Ae.return, gr) } Ae.flags &= -3 } Se & 4096 && (Ae.flags &= -4097) } function Sp(Ae) { if (Ae.subtreeFlags & 1024) for (Ae = Ae.child; Ae !== null;) { var Se = Ae; Sp(Se), Se.tag === 5 && Se.flags & 1024 && Se.stateNode.reset(), Ae = Ae.sibling } } function rc(Ae, Se) { if (Se.subtreeFlags & 8772) for (Se = Se.child; Se !== null;)xp(Ae, Se.alternate, Se), Se = Se.sibling } function Qc(Ae) { for (Ae = Ae.child; Ae !== null;) { var Se = Ae; switch (Se.tag) { case 0: case 11: case 14: case 15: nc(4, Se, Se.return), Qc(Se); break; case 1: $o(Se, Se.return); var Te = Se.stateNode; typeof Te.componentWillUnmount == "function" && pp(Se, Se.return, Te), Qc(Se); break; case 27: Ad(Se.stateNode); case 26: case 5: $o(Se, Se.return), Qc(Se); break; case 22: Se.memoizedState === null && Qc(Se); break; case 30: Qc(Se); break; default: Qc(Se) }Ae = Ae.sibling } } function ic(Ae, Se, Te) { for (Te = Te && (Se.subtreeFlags & 8772) !== 0, Se = Se.child; Se !== null;) { var ke = Se.alternate, $e = Ae, Ke = Se, wn = Ke.flags; switch (Ke.tag) { case 0: case 11: case 15: ic($e, Ke, Te), hd(4, Ke); break; case 1: if (ic($e, Ke, Te), ke = Ke, $e = ke.stateNode, typeof $e.componentDidMount == "function") try { $e.componentDidMount() } catch (or) { Ui(ke, ke.return, or) } if (ke = Ke, $e = ke.updateQueue, $e !== null) { var Mn = ke.stateNode; try { var Hn = $e.shared.hiddenCallbacks; if (Hn !== null) for ($e.shared.hiddenCallbacks = null, $e = 0; $e < Hn.length; $e++)Ai(Hn[$e], Mn) } catch (or) { Ui(ke, ke.return, or) } } Te && wn & 64 && fp(Ke), pd(Ke, Ke.return); break; case 27: vp(Ke); case 26: case 5: ic($e, Ke, Te), Te && ke === null && wn & 4 && mp(Ke), pd(Ke, Ke.return); break; case 12: ic($e, Ke, Te); break; case 13: ic($e, Ke, Te), Te && wn & 4 && wp($e, Ke); break; case 22: Ke.memoizedState === null && ic($e, Ke, Te), pd(Ke, Ke.return); break; case 30: break; default: ic($e, Ke, Te) }Se = Se.sibling } } function Kh(Ae, Se) { var Te = null; Ae !== null && Ae.memoizedState !== null && Ae.memoizedState.cachePool !== null && (Te = Ae.memoizedState.cachePool.pool), Ae = null, Se.memoizedState !== null && Se.memoizedState.cachePool !== null && (Ae = Se.memoizedState.cachePool.pool), Ae !== Te && (Ae != null && Ae.refCount++, Te != null && Fc(Te)) } function Qh(Ae, Se) { Ae = null, Se.alternate !== null && (Ae = Se.alternate.memoizedState.cache), Se = Se.memoizedState.cache, Se !== Ae && (Se.refCount++, Ae != null && Fc(Ae)) } function Vo(Ae, Se, Te, ke) { if (Se.subtreeFlags & 10256) for (Se = Se.child; Se !== null;)_p(Ae, Se, Te, ke), Se = Se.sibling } function _p(Ae, Se, Te, ke) { var $e = Se.flags; switch (Se.tag) { case 0: case 11: case 15: Vo(Ae, Se, Te, ke), $e & 2048 && hd(9, Se); break; case 1: Vo(Ae, Se, Te, ke); break; case 3: Vo(Ae, Se, Te, ke), $e & 2048 && (Ae = null, Se.alternate !== null && (Ae = Se.alternate.memoizedState.cache), Se = Se.memoizedState.cache, Se !== Ae && (Se.refCount++, Ae != null && Fc(Ae))); break; case 12: if ($e & 2048) { Vo(Ae, Se, Te, ke), Ae = Se.stateNode; try { var Ke = Se.memoizedProps, wn = Ke.id, Mn = Ke.onPostCommit; typeof Mn == "function" && Mn(wn, Se.alternate === null ? "mount" : "update", Ae.passiveEffectDuration, -0) } catch (Hn) { Ui(Se, Se.return, Hn) } } else Vo(Ae, Se, Te, ke); break; case 13: Vo(Ae, Se, Te, ke); break; case 23: break; case 22: Ke = Se.stateNode, wn = Se.alternate, Se.memoizedState !== null ? Ke._visibility & 2 ? Vo(Ae, Se, Te, ke) : md(Ae, Se) : Ke._visibility & 2 ? Vo(Ae, Se, Te, ke) : (Ke._visibility |= 2, Cu(Ae, Se, Te, ke, (Se.subtreeFlags & 10256) !== 0)), $e & 2048 && Kh(wn, Se); break; case 24: Vo(Ae, Se, Te, ke), $e & 2048 && Qh(Se.alternate, Se); break; default: Vo(Ae, Se, Te, ke) } } function Cu(Ae, Se, Te, ke, $e) { for ($e = $e && (Se.subtreeFlags & 10256) !== 0, Se = Se.child; Se !== null;) { var Ke = Ae, wn = Se, Mn = Te, Hn = ke, or = wn.flags; switch (wn.tag) { case 0: case 11: case 15: Cu(Ke, wn, Mn, Hn, $e), hd(8, wn); break; case 23: break; case 22: var gr = wn.stateNode; wn.memoizedState !== null ? gr._visibility & 2 ? Cu(Ke, wn, Mn, Hn, $e) : md(Ke, wn) : (gr._visibility |= 2, Cu(Ke, wn, Mn, Hn, $e)), $e && or & 2048 && Kh(wn.alternate, wn); break; case 24: Cu(Ke, wn, Mn, Hn, $e), $e && or & 2048 && Qh(wn.alternate, wn); break; default: Cu(Ke, wn, Mn, Hn, $e) }Se = Se.sibling } } function md(Ae, Se) { if (Se.subtreeFlags & 10256) for (Se = Se.child; Se !== null;) { var Te = Ae, ke = Se, $e = ke.flags; switch (ke.tag) { case 22: md(Te, ke), $e & 2048 && Kh(ke.alternate, ke); break; case 24: md(Te, ke), $e & 2048 && Qh(ke.alternate, ke); break; default: md(Te, ke) }Se = Se.sibling } } var gd = 8192; function Tu(Ae) { if (Ae.subtreeFlags & gd) for (Ae = Ae.child; Ae !== null;)Rp(Ae), Ae = Ae.sibling } function Rp(Ae) { switch (Ae.tag) { case 26: Tu(Ae), Ae.flags & gd && Ae.memoizedState !== null && Ag(ho, Ae.memoizedState, Ae.memoizedProps); break; case 5: Tu(Ae); break; case 3: case 4: var Se = ho; ho = vh(Ae.stateNode.containerInfo), Tu(Ae), ho = Se; break; case 22: Ae.memoizedState === null && (Se = Ae.alternate, Se !== null && Se.memoizedState !== null ? (Se = gd, gd = 16777216, Tu(Ae), gd = Se) : Tu(Ae)); break; default: Tu(Ae) } } function Cp(Ae) { var Se = Ae.alternate; if (Se !== null && (Ae = Se.child, Ae !== null)) { Se.child = null; do Se = Ae.sibling, Ae.sibling = null, Ae = Se; while (Ae !== null) } } function vd(Ae) { var Se = Ae.deletions; if ((Ae.flags & 16) !== 0) { if (Se !== null) for (var Te = 0; Te < Se.length; Te++) { var ke = Se[Te]; Ps = ke, Np(ke, Ae) } Cp(Ae) } if (Ae.subtreeFlags & 10256) for (Ae = Ae.child; Ae !== null;)Tp(Ae), Ae = Ae.sibling } function Tp(Ae) { switch (Ae.tag) { case 0: case 11: case 15: vd(Ae), Ae.flags & 2048 && nc(9, Ae, Ae.return); break; case 3: vd(Ae); break; case 12: vd(Ae); break; case 22: var Se = Ae.stateNode; Ae.memoizedState !== null && Se._visibility & 2 && (Ae.return === null || Ae.return.tag !== 13) ? (Se._visibility &= -3, sh(Ae)) : vd(Ae); break; default: vd(Ae) } } function sh(Ae) { var Se = Ae.deletions; if ((Ae.flags & 16) !== 0) { if (Se !== null) for (var Te = 0; Te < Se.length; Te++) { var ke = Se[Te]; Ps = ke, Np(ke, Ae) } Cp(Ae) } for (Ae = Ae.child; Ae !== null;) { switch (Se = Ae, Se.tag) { case 0: case 11: case 15: nc(8, Se, Se.return), sh(Se); break; case 22: Te = Se.stateNode, Te._visibility & 2 && (Te._visibility &= -3, sh(Se)); break; default: sh(Se) }Ae = Ae.sibling } } function Np(Ae, Se) { for (; Ps !== null;) { var Te = Ps; switch (Te.tag) { case 0: case 11: case 15: nc(8, Te, Se); break; case 23: case 22: if (Te.memoizedState !== null && Te.memoizedState.cachePool !== null) { var ke = Te.memoizedState.cachePool.pool; ke != null && ke.refCount++ } break; case 24: Fc(Te.memoizedState.cache) }if (ke = Te.child, ke !== null) ke.return = Te, Ps = ke; else e: for (Te = Ae; Ps !== null;) { ke = Ps; var $e = ke.sibling, Ke = ke.return; if (yp(ke), ke === Te) { Ps = null; break e } if ($e !== null) { $e.return = Ke, Ps = $e; break e } Ps = Ke } } } var Bm = { getCacheForType: function (Ae) { var Se = ds(hs), Te = Se.data.get(Ae); return Te === void 0 && (Te = Ae(), Se.data.set(Ae, Te)), Te } }, Um = typeof WeakMap == "function" ? WeakMap : Map, Mi = 0, qi = null, gi = null, _i = 0, Di = 0, Aa = null, sc = !1, Nu = !1, Zh = !1, Al = 0, ls = 0, ac = 0, Zc = 0, Jh = 0, Ua = 0, Pu = 0, bd = null, ua = null, ef = !1, tf = 0, ah = 1 / 0, oh = null, oc = null, Is = 0, cc = null, Ou = null, Lu = 0, nf = 0, rf = null, Pp = null, xd = 0, sf = null; function Sa() { if ((Mi & 2) !== 0 && _i !== 0) return _i & -_i; if (xn.T !== null) { var Ae = hl; return Ae !== 0 ? Ae : hf() } return fi() } function Op() { Ua === 0 && (Ua = (_i & 536870912) === 0 || Ri ? di() : 536870912); var Ae = Ba.current; return Ae !== null && (Ae.flags |= 32), Ua } function Ra(Ae, Se, Te) { (Ae === qi && (Di === 2 || Di === 9) || Ae.cancelPendingCommit !== null) && (ju(Ae, 0), uc(Ae, _i, Ua, !1)), $i(Ae, Te), ((Mi & 2) === 0 || Ae !== qi) && (Ae === qi && ((Mi & 2) === 0 && (Zc |= Te), ls === 4 && uc(Ae, _i, Ua, !1)), Go(Ae)) } function Lp(Ae, Se, Te) { if ((Mi & 6) !== 0) throw Error(Ee(327)); var ke = !Te && (Se & 124) === 0 && (Se & Ae.expiredLanes) === 0 || Rr(Ae, Se), $e = ke ? qm(Ae, Se) : lf(Ae, Se, !0), Ke = ke; do { if ($e === 0) { Nu && !ke && uc(Ae, Se, 0, !1); break } else { if (Te = Ae.current.alternate, Ke && !zm(Te)) { $e = lf(Ae, Se, !1), Ke = !1; continue } if ($e === 2) { if (Ke = Se, Ae.errorRecoveryDisabledLanes & Ke) var wn = 0; else wn = Ae.pendingLanes & -536870913, wn = wn !== 0 ? wn : wn & 536870912 ? 536870912 : 0; if (wn !== 0) { Se = wn; e: { var Mn = Ae; $e = bd; var Hn = Mn.current.memoizedState.isDehydrated; if (Hn && (ju(Mn, wn).flags |= 256), wn = lf(Mn, wn, !1), wn !== 2) { if (Zh && !Hn) { Mn.errorRecoveryDisabledLanes |= Ke, Zc |= Ke, $e = 4; break e } Ke = ua, ua = $e, Ke !== null && (ua === null ? ua = Ke : ua.push.apply(ua, Ke)) } $e = wn } if (Ke = !1, $e !== 2) continue } } if ($e === 1) { ju(Ae, 0), uc(Ae, Se, 0, !0); break } e: { switch (ke = Ae, Ke = $e, Ke) { case 0: case 1: throw Error(Ee(345)); case 4: if ((Se & 4194048) !== Se) break; case 6: uc(ke, Se, Ua, !sc); break e; case 2: ua = null; break; case 3: case 5: break; default: throw Error(Ee(329)) }if ((Se & 62914560) === Se && ($e = tf + 300 - Vn(), 10 < $e)) { if (uc(ke, Se, Ua, !sc), Qn(ke, 0, !0) !== 0) break e; ke.timeoutHandle = om(jp.bind(null, ke, Te, ua, oh, ef, Se, Ua, Zc, Pu, sc, Ke, 2, -0, 0), $e); break e } jp(ke, Te, ua, oh, ef, Se, Ua, Zc, Pu, sc, Ke, 0, -0, 0) } } break } while (!0); Go(Ae) } function jp(Ae, Se, Te, ke, $e, Ke, wn, Mn, Hn, or, gr, wr, lr, cr) { if (Ae.timeoutHandle = -1, wr = Se.subtreeFlags, (wr & 8192 || (wr & 16785408) === 16785408) && (Rd = { stylesheets: null, count: 0, unsuspend: wg }, Rp(Se), wr = Sg(), wr !== null)) { Ae.cancelPendingCommit = wr(Up.bind(null, Ae, Se, Ke, Te, ke, $e, wn, Mn, Hn, gr, 1, lr, cr)), uc(Ae, Ke, wn, !or); return } Up(Ae, Se, Ke, Te, ke, $e, wn, Mn, Hn) } function zm(Ae) { for (var Se = Ae; ;) { var Te = Se.tag; if ((Te === 0 || Te === 11 || Te === 15) && Se.flags & 16384 && (Te = Se.updateQueue, Te !== null && (Te = Te.stores, Te !== null))) for (var ke = 0; ke < Te.length; ke++) { var $e = Te[ke], Ke = $e.getSnapshot; $e = $e.value; try { if (!bs(Ke(), $e)) return !1 } catch { return !1 } } if (Te = Se.child, Se.subtreeFlags & 16384 && Te !== null) Te.return = Se, Se = Te; else { if (Se === Ae) break; for (; Se.sibling === null;) { if (Se.return === null || Se.return === Ae) return !0; Se = Se.return } Se.sibling.return = Se.return, Se = Se.sibling } } return !0 } function uc(Ae, Se, Te, ke) { Se &= ~Jh, Se &= ~Zc, Ae.suspendedLanes |= Se, Ae.pingedLanes &= ~Se, ke && (Ae.warmLanes |= Se), ke = Ae.expirationTimes; for (var $e = Se; 0 < $e;) { var Ke = 31 - Cr($e), wn = 1 << Ke; ke[Ke] = -1, $e &= ~wn } Te !== 0 && Ar(Ae, Te, Se) } function lh() { return (Mi & 6) === 0 ? (yd(0), !1) : !0 } function af() { if (gi !== null) { if (Di === 0) var Ae = gi.return; else Ae = gi, so = ys = null, xu(Ae), _u = null, cd = 0, Ae = gi; for (; Ae !== null;)hp(Ae.alternate, Ae), Ae = Ae.return; gi = null } } function ju(Ae, Se) { var Te = Ae.timeoutHandle; Te !== -1 && (Ae.timeoutHandle = -1, sg(Te)), Te = Ae.cancelPendingCommit, Te !== null && (Ae.cancelPendingCommit = null, Te()), af(), qi = Ae, gi = Te = ja(Ae.current, null), _i = Se, Di = 0, Aa = null, sc = !1, Nu = Rr(Ae, Se), Zh = !1, Pu = Ua = Jh = Zc = ac = ls = 0, ua = bd = null, ef = !1, (Se & 8) !== 0 && (Se |= Se & 32); var ke = Ae.entangledLanes; if (ke !== 0) for (Ae = Ae.entanglements, ke &= Se; 0 < ke;) { var $e = 31 - Cr(ke), Ke = 1 << $e; Se |= Ae[$e], ke &= ~Ke } return Al = Se, sa(), Te } function Mp(Ae, Se) { $r = null, xn.H = Yd, Se === Nn || Se === jn ? (Se = Jn(), Di = 3) : Se === Ln ? (Se = Jn(), Di = 4) : Di = Se === Zf ? 8 : Se !== null && typeof Se == "object" && typeof Se.then == "function" ? 6 : 1, Aa = Se, gi === null && (ls = 1, eh(Ae, li(Se, Ae.current))) } function Dp() { var Ae = xn.H; return xn.H = Yd, Ae === null ? Yd : Ae } function kp() { var Ae = xn.A; return xn.A = Bm, Ae } function of() { ls = 4, sc || (_i & 4194048) !== _i && Ba.current !== null || (Nu = !0), (ac & 134217727) === 0 && (Zc & 134217727) === 0 || qi === null || uc(qi, _i, Ua, !1) } function lf(Ae, Se, Te) { var ke = Mi; Mi |= 2; var $e = Dp(), Ke = kp(); (qi !== Ae || _i !== Se) && (oh = null, ju(Ae, Se)), Se = !1; var wn = ls; e: do try { if (Di !== 0 && gi !== null) { var Mn = gi, Hn = Aa; switch (Di) { case 8: af(), wn = 6; break e; case 3: case 2: case 9: case 6: Ba.current === null && (Se = !0); var or = Di; if (Di = 0, Aa = null, Mu(Ae, Mn, Hn, or), Te && Nu) { wn = 0; break e } break; default: or = Di, Di = 0, Aa = null, Mu(Ae, Mn, Hn, or) } } Hm(), wn = ls; break } catch (gr) { Mp(Ae, gr) } while (!0); return Se && Ae.shellSuspendCounter++, so = ys = null, Mi = ke, xn.H = $e, xn.A = Ke, gi === null && (qi = null, _i = 0, sa()), wn } function Hm() { for (; gi !== null;)Ip(gi) } function qm(Ae, Se) { var Te = Mi; Mi |= 2; var ke = Dp(), $e = kp(); qi !== Ae || _i !== Se ? (oh = null, ah = Vn() + 500, ju(Ae, Se)) : Nu = Rr(Ae, Se); e: do try { if (Di !== 0 && gi !== null) { Se = gi; var Ke = Aa; t: switch (Di) { case 1: Di = 0, Aa = null, Mu(Ae, Se, Ke, 1); break; case 2: case 9: if (Bn(Ke)) { Di = 0, Aa = null, Fp(Se); break } Se = function () { Di !== 2 && Di !== 9 || qi !== Ae || (Di = 7), Go(Ae) }, Ke.then(Se, Se); break e; case 3: Di = 7; break e; case 4: Di = 5; break e; case 7: Bn(Ke) ? (Di = 0, Aa = null, Fp(Se)) : (Di = 0, Aa = null, Mu(Ae, Se, Ke, 7)); break; case 5: var wn = null; switch (gi.tag) { case 26: wn = gi.memoizedState; case 5: case 27: var Mn = gi; if (!wn || xm(wn)) { Di = 0, Aa = null; var Hn = Mn.sibling; if (Hn !== null) gi = Hn; else { var or = Mn.return; or !== null ? (gi = or, ch(or)) : gi = null } break t } }Di = 0, Aa = null, Mu(Ae, Se, Ke, 5); break; case 6: Di = 0, Aa = null, Mu(Ae, Se, Ke, 6); break; case 8: af(), ls = 6; break e; default: throw Error(Ee(462)) } } $m(); break } catch (gr) { Mp(Ae, gr) } while (!0); return so = ys = null, xn.H = ke, xn.A = $e, Mi = Te, gi !== null ? 0 : (qi = null, _i = 0, sa(), ls) } function $m() { for (; gi !== null && !Fn();)Ip(gi) } function Ip(Ae) { var Se = up(Ae.alternate, Ae, Al); Ae.memoizedProps = Ae.pendingProps, Se === null ? ch(Ae) : gi = Se } function Fp(Ae) { var Se = Ae, Te = Se.alternate; switch (Se.tag) { case 15: case 0: Se = ip(Te, Se, Se.pendingProps, Se.type, void 0, _i); break; case 11: Se = ip(Te, Se, Se.pendingProps, Se.type.render, Se.ref, _i); break; case 5: xu(Se); default: hp(Te, Se), Se = gi = Mc(Se, Al), Se = up(Te, Se, Al) }Ae.memoizedProps = Ae.pendingProps, Se === null ? ch(Ae) : gi = Se } function Mu(Ae, Se, Te, ke) { so = ys = null, xu(Se), _u = null, cd = 0; var $e = Se.return; try { if (jm(Ae, $e, Se, Te, _i)) { ls = 1, eh(Ae, li(Te, Ae.current)), gi = null; return } } catch (Ke) { if ($e !== null) throw gi = $e, Ke; ls = 1, eh(Ae, li(Te, Ae.current)), gi = null; return } Se.flags & 32768 ? (Ri || ke === 1 ? Ae = !0 : Nu || (_i & 536870912) !== 0 ? Ae = !1 : (sc = Ae = !0, (ke === 2 || ke === 9 || ke === 3 || ke === 6) && (ke = Ba.current, ke !== null && ke.tag === 13 && (ke.flags |= 16384))), Bp(Se, Ae)) : ch(Se) } function ch(Ae) { var Se = Ae; do { if ((Se.flags & 32768) !== 0) { Bp(Se, sc); return } Ae = Se.return; var Te = Dm(Se.alternate, Se, Al); if (Te !== null) { gi = Te; return } if (Se = Se.sibling, Se !== null) { gi = Se; return } gi = Se = Ae } while (Se !== null); ls === 0 && (ls = 5) } function Bp(Ae, Se) { do { var Te = km(Ae.alternate, Ae); if (Te !== null) { Te.flags &= 32767, gi = Te; return } if (Te = Ae.return, Te !== null && (Te.flags |= 32768, Te.subtreeFlags = 0, Te.deletions = null), !Se && (Ae = Ae.sibling, Ae !== null)) { gi = Ae; return } gi = Ae = Te } while (Ae !== null); ls = 6, gi = null } function Up(Ae, Se, Te, ke, $e, Ke, wn, Mn, Hn) { Ae.cancelPendingCommit = null; do uh(); while (Is !== 0); if ((Mi & 6) !== 0) throw Error(Ee(327)); if (Se !== null) { if (Se === Ae.current) throw Error(Ee(177)); if (Ke = Se.lanes | Se.childLanes, Ke |= ts, xi(Ae, Te, Ke, wn, Mn, Hn), Ae === qi && (gi = qi = null, _i = 0), Ou = Se, cc = Ae, Lu = Te, nf = Ke, rf = $e, Pp = ke, (Se.subtreeFlags & 10256) !== 0 || (Se.flags & 10256) !== 0 ? (Ae.callbackNode = null, Ae.callbackPriority = 0, Xm(hr, function () { return Vp(), null })) : (Ae.callbackNode = null, Ae.callbackPriority = 0), ke = (Se.flags & 13878) !== 0, (Se.subtreeFlags & 13878) !== 0 || ke) { ke = xn.T, xn.T = null, $e = vn.p, vn.p = 2, wn = Mi, Mi |= 4; try { Im(Ae, Se, Te) } finally { Mi = wn, vn.p = $e, xn.T = ke } } Is = 1, zp(), Hp(), qp() } } function zp() { if (Is === 1) { Is = 0; var Ae = cc, Se = Ou, Te = (Se.flags & 13878) !== 0; if ((Se.subtreeFlags & 13878) !== 0 || Te) { Te = xn.T, xn.T = null; var ke = vn.p; vn.p = 2; var $e = Mi; Mi |= 4; try { Ap(Se, Ae); var Ke = yf, wn = js(Ae.containerInfo), Mn = Ke.focusedElem, Hn = Ke.selectionRange; if (wn !== Mn && Mn && Mn.ownerDocument && Co(Mn.ownerDocument.documentElement, Mn)) { if (Hn !== null && As(Mn)) { var or = Hn.start, gr = Hn.end; if (gr === void 0 && (gr = or), "selectionStart" in Mn) Mn.selectionStart = or, Mn.selectionEnd = Math.min(gr, Mn.value.length); else { var wr = Mn.ownerDocument || document, lr = wr && wr.defaultView || window; if (lr.getSelection) { var cr = lr.getSelection(), Kr = Mn.textContent.length, Vr = Math.min(Hn.start, Kr), Fi = Hn.end === void 0 ? Vr : Math.min(Hn.end, Kr); !cr.extend && Vr > Fi && (wn = Fi, Fi = Vr, Vr = wn); var er = Qa(Mn, Vr), Xn = Qa(Mn, Fi); if (er && Xn && (cr.rangeCount !== 1 || cr.anchorNode !== er.node || cr.anchorOffset !== er.offset || cr.focusNode !== Xn.node || cr.focusOffset !== Xn.offset)) { var ir = wr.createRange(); ir.setStart(er.node, er.offset), cr.removeAllRanges(), Vr > Fi ? (cr.addRange(ir), cr.extend(Xn.node, Xn.offset)) : (ir.setEnd(Xn.node, Xn.offset), cr.addRange(ir)) } } } } for (wr = [], cr = Mn; cr = cr.parentNode;)cr.nodeType === 1 && wr.push({ element: cr, left: cr.scrollLeft, top: cr.scrollTop }); for (typeof Mn.focus == "function" && Mn.focus(), Mn = 0; Mn < wr.length; Mn++) { var br = wr[Mn]; br.element.scrollLeft = br.left, br.element.scrollTop = br.top } } wh = !!xf, yf = xf = null } finally { Mi = $e, vn.p = ke, xn.T = Te } } Ae.current = Se, Is = 2 } } function Hp() { if (Is === 2) { Is = 0; var Ae = cc, Se = Ou, Te = (Se.flags & 8772) !== 0; if ((Se.subtreeFlags & 8772) !== 0 || Te) { Te = xn.T, xn.T = null; var ke = vn.p; vn.p = 2; var $e = Mi; Mi |= 4; try { xp(Ae, Se.alternate, Se) } finally { Mi = $e, vn.p = ke, xn.T = Te } } Is = 3 } } function qp() { if (Is === 4 || Is === 3) { Is = 0, Cn(); var Ae = cc, Se = Ou, Te = Lu, ke = Pp; (Se.subtreeFlags & 10256) !== 0 || (Se.flags & 10256) !== 0 ? Is = 5 : (Is = 0, Ou = cc = null, $p(Ae, Ae.pendingLanes)); var $e = Ae.pendingLanes; if ($e === 0 && (oc = null), ii(Te), Se = Se.stateNode, Dr && typeof Dr.onCommitFiberRoot == "function") try { Dr.onCommitFiberRoot(Ir, Se, void 0, (Se.current.flags & 128) === 128) } catch { } if (ke !== null) { Se = xn.T, $e = vn.p, vn.p = 2, xn.T = null; try { for (var Ke = Ae.onRecoverableError, wn = 0; wn < ke.length; wn++) { var Mn = ke[wn]; Ke(Mn.value, { componentStack: Mn.stack }) } } finally { xn.T = Se, vn.p = $e } } (Lu & 3) !== 0 && uh(), Go(Ae), $e = Ae.pendingLanes, (Te & 4194090) !== 0 && ($e & 42) !== 0 ? Ae === sf ? xd++ : (xd = 0, sf = Ae) : xd = 0, yd(0) } } function $p(Ae, Se) { (Ae.pooledCacheLanes &= Se) === 0 && (Se = Ae.pooledCache, Se != null && (Ae.pooledCache = null, Fc(Se))) } function uh(Ae) { return zp(), Hp(), qp(), Vp() } function Vp() { if (Is !== 5) return !1; var Ae = cc, Se = nf; nf = 0; var Te = ii(Lu), ke = xn.T, $e = vn.p; try { vn.p = 32 > Te ? 32 : Te, xn.T = null, Te = rf, rf = null; var Ke = cc, wn = Lu; if (Is = 0, Ou = cc = null, Lu = 0, (Mi & 6) !== 0) throw Error(Ee(331)); var Mn = Mi; if (Mi |= 4, Tp(Ke.current), _p(Ke, Ke.current, wn, Te), Mi = Mn, yd(0, !1), Dr && typeof Dr.onPostCommitFiberRoot == "function") try { Dr.onPostCommitFiberRoot(Ir, Ke) } catch { } return !0 } finally { vn.p = $e, xn.T = ke, $p(Ae, Se) } } function Gp(Ae, Se, Te) { Se = li(Te, Se), Se = kh(Ae.stateNode, Se, 2), Ae = yr(Ae, Se, 2), Ae !== null && ($i(Ae, 2), Go(Ae)) } function Ui(Ae, Se, Te) { if (Ae.tag === 3) Gp(Ae, Ae, Te); else for (; Se !== null;) { if (Se.tag === 3) { Gp(Se, Ae, Te); break } else if (Se.tag === 1) { var ke = Se.stateNode; if (typeof Se.type.getDerivedStateFromError == "function" || typeof ke.componentDidCatch == "function" && (oc === null || !oc.has(ke))) { Ae = li(Te, Ae), Te = Kf(2), ke = yr(Se, Te, 2), ke !== null && (Qf(Te, ke, Se, Ae), $i(ke, 2), Go(ke)); break } } Se = Se.return } } function cf(Ae, Se, Te) { var ke = Ae.pingCache; if (ke === null) { ke = Ae.pingCache = new Um; var $e = new Set; ke.set(Se, $e) } else $e = ke.get(Se), $e === void 0 && ($e = new Set, ke.set(Se, $e)); $e.has(Te) || (Zh = !0, $e.add(Te), Ae = Vm.bind(null, Ae, Se, Te), Se.then(Ae, Ae)) } function Vm(Ae, Se, Te) { var ke = Ae.pingCache; ke !== null && ke.delete(Se), Ae.pingedLanes |= Ae.suspendedLanes & Te, Ae.warmLanes &= ~Te, qi === Ae && (_i & Te) === Te && (ls === 4 || ls === 3 && (_i & 62914560) === _i && 300 > Vn() - tf ? (Mi & 2) === 0 && ju(Ae, 0) : Jh |= Te, Pu === _i && (Pu = 0)), Go(Ae) } function Wp(Ae, Se) { Se === 0 && (Se = ei()), Ae = Ja(Ae, Se), Ae !== null && ($i(Ae, Se), Go(Ae)) } function Gm(Ae) { var Se = Ae.memoizedState, Te = 0; Se !== null && (Te = Se.retryLane), Wp(Ae, Te) } function Wm(Ae, Se) { var Te = 0; switch (Ae.tag) { case 13: var ke = Ae.stateNode, $e = Ae.memoizedState; $e !== null && (Te = $e.retryLane); break; case 19: ke = Ae.stateNode; break; case 22: ke = Ae.stateNode._retryCache; break; default: throw Error(Ee(314)) }ke !== null && ke.delete(Se), Wp(Ae, Te) } function Xm(Ae, Se) { return zn(Ae, Se) } var dh = null, Du = null, uf = !1, hh = !1, df = !1, Jc = 0; function Go(Ae) { Ae !== Du && Ae.next === null && (Du === null ? dh = Du = Ae : Du = Du.next = Ae), hh = !0, uf || (uf = !0, Km()) } function yd(Ae, Se) { if (!df && hh) { df = !0; do for (var Te = !1, ke = dh; ke !== null;) { if (Ae !== 0) { var $e = ke.pendingLanes; if ($e === 0) var Ke = 0; else { var wn = ke.suspendedLanes, Mn = ke.pingedLanes; Ke = (1 << 31 - Cr(42 | Ae) + 1) - 1, Ke &= $e & ~(wn & ~Mn), Ke = Ke & 201326741 ? Ke & 201326741 | 1 : Ke ? Ke | 2 : 0 } Ke !== 0 && (Te = !0, Qp(ke, Ke)) } else Ke = _i, Ke = Qn(ke, ke === qi ? Ke : 0, ke.cancelPendingCommit !== null || ke.timeoutHandle !== -1), (Ke & 3) === 0 || Rr(ke, Ke) || (Te = !0, Qp(ke, Ke)); ke = ke.next } while (Te); df = !1 } } function Ym() { Xp() } function Xp() { hh = uf = !1; var Ae = 0; Jc !== 0 && (ig() && (Ae = Jc), Jc = 0); for (var Se = Vn(), Te = null, ke = dh; ke !== null;) { var $e = ke.next, Ke = Yp(ke, Se); Ke === 0 ? (ke.next = null, Te === null ? dh = $e : Te.next = $e, $e === null && (Du = Te)) : (Te = ke, (Ae !== 0 || (Ke & 3) !== 0) && (hh = !0)), ke = $e } yd(Ae) } function Yp(Ae, Se) { for (var Te = Ae.suspendedLanes, ke = Ae.pingedLanes, $e = Ae.expirationTimes, Ke = Ae.pendingLanes & -62914561; 0 < Ke;) { var wn = 31 - Cr(Ke), Mn = 1 << wn, Hn = $e[wn]; Hn === -1 ? ((Mn & Te) === 0 || (Mn & ke) !== 0) && ($e[wn] = kr(Mn, Se)) : Hn <= Se && (Ae.expiredLanes |= Mn), Ke &= ~Mn } if (Se = qi, Te = _i, Te = Qn(Ae, Ae === Se ? Te : 0, Ae.cancelPendingCommit !== null || Ae.timeoutHandle !== -1), ke = Ae.callbackNode, Te === 0 || Ae === Se && (Di === 2 || Di === 9) || Ae.cancelPendingCommit !== null) return ke !== null && ke !== null && sr(ke), Ae.callbackNode = null, Ae.callbackPriority = 0; if ((Te & 3) === 0 || Rr(Ae, Te)) { if (Se = Te & -Te, Se === Ae.callbackPriority) return Se; switch (ke !== null && sr(ke), ii(Te)) { case 2: case 8: Te = rr; break; case 32: Te = hr; break; case 268435456: Te = Er; break; default: Te = hr }return ke = Kp.bind(null, Ae), Te = zn(Te, ke), Ae.callbackPriority = Se, Ae.callbackNode = Te, Se } return ke !== null && ke !== null && sr(ke), Ae.callbackPriority = 2, Ae.callbackNode = null, 2 } function Kp(Ae, Se) { if (Is !== 0 && Is !== 5) return Ae.callbackNode = null, Ae.callbackPriority = 0, null; var Te = Ae.callbackNode; if (uh() && Ae.callbackNode !== Te) return null; var ke = _i; return ke = Qn(Ae, Ae === qi ? ke : 0, Ae.cancelPendingCommit !== null || Ae.timeoutHandle !== -1), ke === 0 ? null : (Lp(Ae, ke, Se), Yp(Ae, Vn()), Ae.callbackNode != null && Ae.callbackNode === Te ? Kp.bind(null, Ae) : null) } function Qp(Ae, Se) { if (uh()) return null; Lp(Ae, Se, !0) } function Km() { ag(function () { (Mi & 6) !== 0 ? zn(qn, Ym) : Xp() }) } function hf() { return Jc === 0 && (Jc = di()), Jc } function Zp(Ae) { return Ae == null || typeof Ae == "symbol" || typeof Ae == "boolean" ? null : typeof Ae == "function" ? Ae : Ga("" + Ae) } function Jp(Ae, Se) { var Te = Se.ownerDocument.createElement("input"); return Te.name = Se.name, Te.value = Se.value, Ae.id && Te.setAttribute("form", Ae.id), Se.parentNode.insertBefore(Te, Se), Ae = new FormData(Ae), Te.parentNode.removeChild(Te), Ae } function Qm(Ae, Se, Te, ke, $e) { if (Se === "submit" && Te && Te.stateNode === $e) { var Ke = Zp(($e[ni] || null).action), wn = ke.submitter; wn && (Se = (Se = wn[ni] || null) ? Zp(Se.formAction) : wn.getAttribute("formAction"), Se !== null && (Ke = Se, wn = null)); var Mn = new yo("action", "action", null, ke, $e); Ae.push({ event: Mn, listeners: [{ instance: null, listener: function () { if (ke.defaultPrevented) { if (Jc !== 0) { var Hn = wn ? Jp($e, wn) : new FormData($e); Fa(Te, { pending: !0, data: Hn, method: $e.method, action: Ke }, null, Hn) } } else typeof Ke == "function" && (Mn.preventDefault(), Hn = wn ? Jp($e, wn) : new FormData($e), Fa(Te, { pending: !0, data: Hn, method: $e.method, action: Ke }, Ke, Hn)) }, currentTarget: $e }] }) } } for (var ff = 0; ff < al.length; ff++) { var pf = al[ff], Zm = pf.toLowerCase(), Jm = pf[0].toUpperCase() + pf.slice(1); Ki(Zm, "on" + Jm) } Ki(Hl, "onAnimationEnd"), Ki(No, "onAnimationIteration"), Ki(Po, "onAnimationStart"), Ki("dblclick", "onDoubleClick"), Ki("focusin", "onFocus"), Ki("focusout", "onBlur"), Ki(Oo, "onTransitionRun"), Ki(sl, "onTransitionStart"), Ki(ql, "onTransitionCancel"), Ki(Lo, "onTransitionEnd"), da("onMouseEnter", ["mouseout", "mouseover"]), da("onMouseLeave", ["mouseout", "mouseover"]), da("onPointerEnter", ["pointerout", "pointerover"]), da("onPointerLeave", ["pointerout", "pointerover"]), ta("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), ta("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), ta("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), ta("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), ta("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), ta("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var Ed = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), eg = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(Ed)); function em(Ae, Se) { Se = (Se & 4) !== 0; for (var Te = 0; Te < Ae.length; Te++) { var ke = Ae[Te], $e = ke.event; ke = ke.listeners; e: { var Ke = void 0; if (Se) for (var wn = ke.length - 1; 0 <= wn; wn--) { var Mn = ke[wn], Hn = Mn.instance, or = Mn.currentTarget; if (Mn = Mn.listener, Hn !== Ke && $e.isPropagationStopped()) break e; Ke = Mn, $e.currentTarget = or; try { Ke($e) } catch (gr) { Jd(gr) } $e.currentTarget = null, Ke = Hn } else for (wn = 0; wn < ke.length; wn++) { if (Mn = ke[wn], Hn = Mn.instance, or = Mn.currentTarget, Mn = Mn.listener, Hn !== Ke && $e.isPropagationStopped()) break e; Ke = Mn, $e.currentTarget = or; try { Ke($e) } catch (gr) { Jd(gr) } $e.currentTarget = null, Ke = Hn } } } } function vi(Ae, Se) { var Te = Se[si]; Te === void 0 && (Te = Se[si] = new Set); var ke = Ae + "__bubble"; Te.has(ke) || (tm(Se, Ae, 2, !1), Te.add(ke)) } function mf(Ae, Se, Te) { var ke = 0; Se && (ke |= 4), tm(Te, Ae, ke, Se) } var fh = "_reactListening" + Math.random().toString(36).slice(2); function gf(Ae) { if (!Ae[fh]) { Ae[fh] = !0, po.forEach(function (Te) { Te !== "selectionchange" && (eg.has(Te) || mf(Te, !1, Ae), mf(Te, !0, Ae)) }); var Se = Ae.nodeType === 9 ? Ae : Ae.ownerDocument; Se === null || Se[fh] || (Se[fh] = !0, mf("selectionchange", !1, Se)) } } function tm(Ae, Se, Te, ke) { switch (_m(Se)) { case 2: var $e = Cg; break; case 8: $e = Tg; break; default: $e = Pf }Te = $e.bind(null, Se, Te, Ae), $e = void 0, !Nl || Se !== "touchstart" && Se !== "touchmove" && Se !== "wheel" || ($e = !0), ke ? $e !== void 0 ? Ae.addEventListener(Se, Te, { capture: !0, passive: $e }) : Ae.addEventListener(Se, Te, !0) : $e !== void 0 ? Ae.addEventListener(Se, Te, { passive: $e }) : Ae.addEventListener(Se, Te, !1) } function vf(Ae, Se, Te, ke, $e) { var Ke = ke; if ((Se & 1) === 0 && (Se & 2) === 0 && ke !== null) e: for (; ;) { if (ke === null) return; var wn = ke.tag; if (wn === 3 || wn === 4) { var Mn = ke.stateNode.containerInfo; if (Mn === $e) break; if (wn === 4) for (wn = ke.return; wn !== null;) { var Hn = wn.tag; if ((Hn === 3 || Hn === 4) && wn.stateNode.containerInfo === $e) return; wn = wn.return } for (; Mn !== null;) { if (wn = _s(Mn), wn === null) return; if (Hn = wn.tag, Hn === 5 || Hn === 6 || Hn === 26 || Hn === 27) { ke = Ke = wn; continue e } Mn = Mn.parentNode } } ke = ke.return } ou(function () { var or = Ke, gr = gs(Te), wr = []; e: { var lr = Za.get(Ae); if (lr !== void 0) { var cr = yo, Kr = Ae; switch (Ae) { case "keypress": if (xo(Te) === 0) break e; case "keydown": case "keyup": cr = Il; break; case "focusin": Kr = "focus", cr = Zo; break; case "focusout": Kr = "blur", cr = Zo; break; case "beforeblur": case "afterblur": cr = Zo; break; case "click": if (Te.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": cr = Pa; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": cr = wo; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": cr = Pc; break; case Hl: case No: case Po: cr = qu; break; case Lo: cr = Sn; break; case "scroll": case "scrollend": cr = cu; break; case "wheel": cr = $n; break; case "copy": case "cut": case "paste": cr = $u; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": cr = Fl; break; case "toggle": case "beforetoggle": cr = fr }var Vr = (Se & 4) !== 0, Fi = !Vr && (Ae === "scroll" || Ae === "scrollend"), er = Vr ? lr !== null ? lr + "Capture" : null : lr; Vr = []; for (var Xn = or, ir; Xn !== null;) { var br = Xn; if (ir = br.stateNode, br = br.tag, br !== 5 && br !== 26 && br !== 27 || ir === null || er === null || (br = zs(Xn, er), br != null && Vr.push(wd(Xn, br, ir))), Fi) break; Xn = Xn.return } 0 < Vr.length && (lr = new cr(lr, Kr, null, Te, gr), wr.push({ event: lr, listeners: Vr })) } } if ((Se & 7) === 0) { e: { if (lr = Ae === "mouseover" || Ae === "pointerover", cr = Ae === "mouseout" || Ae === "pointerout", lr && Te !== Tl && (Kr = Te.relatedTarget || Te.fromElement) && (_s(Kr) || Kr[oi])) break e; if ((cr || lr) && (lr = gr.window === gr ? gr : (lr = gr.ownerDocument) ? lr.defaultView || lr.parentWindow : window, cr ? (Kr = Te.relatedTarget || Te.toElement, cr = or, Kr = Kr ? _s(Kr) : null, Kr !== null && (Fi = Re(Kr), Vr = Kr.tag, Kr !== Fi || Vr !== 5 && Vr !== 27 && Vr !== 6) && (Kr = null)) : (cr = null, Kr = or), cr !== Kr)) { if (Vr = Pa, br = "onMouseLeave", er = "onMouseEnter", Xn = "mouse", (Ae === "pointerout" || Ae === "pointerover") && (Vr = Fl, br = "onPointerLeave", er = "onPointerEnter", Xn = "pointer"), Fi = cr == null ? lr : Bs(cr), ir = Kr == null ? lr : Bs(Kr), lr = new Vr(br, Xn + "leave", cr, Te, gr), lr.target = Fi, lr.relatedTarget = ir, br = null, _s(gr) === or && (Vr = new Vr(er, Xn + "enter", Kr, Te, gr), Vr.target = ir, Vr.relatedTarget = Fi, br = Vr), Fi = br, cr && Kr) t: { for (Vr = cr, er = Kr, Xn = 0, ir = Vr; ir; ir = ku(ir))Xn++; for (ir = 0, br = er; br; br = ku(br))ir++; for (; 0 < Xn - ir;)Vr = ku(Vr), Xn--; for (; 0 < ir - Xn;)er = ku(er), ir--; for (; Xn--;) { if (Vr === er || er !== null && Vr === er.alternate) break t; Vr = ku(Vr), er = ku(er) } Vr = null } else Vr = null; cr !== null && nm(wr, lr, cr, Vr, !1), Kr !== null && Fi !== null && nm(wr, Fi, Kr, Vr, !0) } } e: { if (lr = or ? Bs(or) : window, cr = lr.nodeName && lr.nodeName.toLowerCase(), cr === "select" || cr === "input" && lr.type === "file") var Fr = Ul; else if (ma(lr)) if (tl) Fr = du; else { Fr = Gu; var ui = Hs } else cr = lr.nodeName, !cr || cr.toLowerCase() !== "input" || lr.type !== "checkbox" && lr.type !== "radio" ? or && Sc(or.elementType) && (Fr = Ul) : Fr = Lc; if (Fr && (Fr = Fr(Ae, or))) { Oc(wr, Fr, Te, gr); break e } ui && ui(Ae, lr, or), Ae === "focusout" && or && lr.type === "number" && or.memoizedProps.value != null && Ec(lr, "number", lr.value) } switch (ui = or ? Bs(or) : window, Ae) { case "focusin": (ma(ui) || ui.contentEditable === "true") && (qs = ui, ga = or, Oa = null); break; case "focusout": Oa = ga = qs = null; break; case "mousedown": va = !0; break; case "contextmenu": case "mouseup": case "dragend": va = !1, Yi(wr, Te, gr); break; case "selectionchange": if (To) break; case "keydown": case "keyup": Yi(wr, Te, gr) }var qr; if (jr) e: { switch (Ae) { case "compositionstart": var Gr = "onCompositionStart"; break e; case "compositionend": Gr = "onCompositionEnd"; break e; case "compositionupdate": Gr = "onCompositionUpdate"; break e }Gr = void 0 } else es ? Vi(Ae, Te) && (Gr = "onCompositionEnd") : Ae === "keydown" && Te.keyCode === 229 && (Gr = "onCompositionStart"); Gr && (Qr && Te.locale !== "ko" && (es || Gr !== "onCompositionStart" ? Gr === "onCompositionEnd" && es && (qr = lu()) : (ra = gr, Rc = "value" in ra ? ra.value : ra.textContent, es = !0)), ui = ph(or, Gr), 0 < ui.length && (Gr = new Ml(Gr, Ae, null, Te, gr), wr.push({ event: Gr, listeners: ui }), qr ? Gr.data = qr : (qr = Ji(Te), qr !== null && (Gr.data = qr)))), (qr = ti ? vs(Ae, Te) : pa(Ae, Te)) && (Gr = ph(or, "onBeforeInput"), 0 < Gr.length && (ui = new Ml("onBeforeInput", "beforeinput", null, Te, gr), wr.push({ event: ui, listeners: Gr }), ui.data = qr)), Qm(wr, Ae, or, Te, gr) } em(wr, Se) }) } function wd(Ae, Se, Te) { return { instance: Ae, listener: Se, currentTarget: Te } } function ph(Ae, Se) { for (var Te = Se + "Capture", ke = []; Ae !== null;) { var $e = Ae, Ke = $e.stateNode; if ($e = $e.tag, $e !== 5 && $e !== 26 && $e !== 27 || Ke === null || ($e = zs(Ae, Te), $e != null && ke.unshift(wd(Ae, $e, Ke)), $e = zs(Ae, Se), $e != null && ke.push(wd(Ae, $e, Ke))), Ae.tag === 3) return ke; Ae = Ae.return } return [] } function ku(Ae) { if (Ae === null) return null; do Ae = Ae.return; while (Ae && Ae.tag !== 5 && Ae.tag !== 27); return Ae || null } function nm(Ae, Se, Te, ke, $e) { for (var Ke = Se._reactName, wn = []; Te !== null && Te !== ke;) { var Mn = Te, Hn = Mn.alternate, or = Mn.stateNode; if (Mn = Mn.tag, Hn !== null && Hn === ke) break; Mn !== 5 && Mn !== 26 && Mn !== 27 || or === null || (Hn = or, $e ? (or = zs(Te, Ke), or != null && wn.unshift(wd(Te, or, Hn))) : $e || (or = zs(Te, Ke), or != null && wn.push(wd(Te, or, Hn)))), Te = Te.return } wn.length !== 0 && Ae.push({ event: Se, listeners: wn }) } var tg = /\r\n?/g, ng = /\u0000|\uFFFD/g; function rm(Ae) {
    return (typeof Ae == "string" ? Ae : "" + Ae).replace(tg, `
`).replace(ng, "")
  } function im(Ae, Se) { return Se = rm(Se), rm(Ae) === Se } function mh() { } function Ii(Ae, Se, Te, ke, $e, Ke) { switch (Te) { case "children": typeof ke == "string" ? Se === "body" || Se === "textarea" && ke === "" || vo(Ae, ke) : (typeof ke == "number" || typeof ke == "bigint") && Se !== "body" && vo(Ae, "" + ke); break; case "className": Yo(Ae, "class", ke); break; case "tabIndex": Yo(Ae, "tabindex", ke); break; case "dir": case "role": case "viewBox": case "width": case "height": Yo(Ae, Te, ke); break; case "style": au(Ae, ke, Ke); break; case "data": if (Se !== "object") { Yo(Ae, "data", ke); break } case "src": case "href": if (ke === "" && (Se !== "a" || Te !== "href")) { Ae.removeAttribute(Te); break } if (ke == null || typeof ke == "function" || typeof ke == "symbol" || typeof ke == "boolean") { Ae.removeAttribute(Te); break } ke = Ga("" + ke), Ae.setAttribute(Te, ke); break; case "action": case "formAction": if (typeof ke == "function") { Ae.setAttribute(Te, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')"); break } else typeof Ke == "function" && (Te === "formAction" ? (Se !== "input" && Ii(Ae, Se, "name", $e.name, $e, null), Ii(Ae, Se, "formEncType", $e.formEncType, $e, null), Ii(Ae, Se, "formMethod", $e.formMethod, $e, null), Ii(Ae, Se, "formTarget", $e.formTarget, $e, null)) : (Ii(Ae, Se, "encType", $e.encType, $e, null), Ii(Ae, Se, "method", $e.method, $e, null), Ii(Ae, Se, "target", $e.target, $e, null))); if (ke == null || typeof ke == "symbol" || typeof ke == "boolean") { Ae.removeAttribute(Te); break } ke = Ga("" + ke), Ae.setAttribute(Te, ke); break; case "onClick": ke != null && (Ae.onclick = mh); break; case "onScroll": ke != null && vi("scroll", Ae); break; case "onScrollEnd": ke != null && vi("scrollend", Ae); break; case "dangerouslySetInnerHTML": if (ke != null) { if (typeof ke != "object" || !("__html" in ke)) throw Error(Ee(61)); if (Te = ke.__html, Te != null) { if ($e.children != null) throw Error(Ee(60)); Ae.innerHTML = Te } } break; case "multiple": Ae.multiple = ke && typeof ke != "function" && typeof ke != "symbol"; break; case "muted": Ae.muted = ke && typeof ke != "function" && typeof ke != "symbol"; break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "defaultValue": case "defaultChecked": case "innerHTML": case "ref": break; case "autoFocus": break; case "xlinkHref": if (ke == null || typeof ke == "function" || typeof ke == "boolean" || typeof ke == "symbol") { Ae.removeAttribute("xlink:href"); break } Te = Ga("" + ke), Ae.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", Te); break; case "contentEditable": case "spellCheck": case "draggable": case "value": case "autoReverse": case "externalResourcesRequired": case "focusable": case "preserveAlpha": ke != null && typeof ke != "function" && typeof ke != "symbol" ? Ae.setAttribute(Te, "" + ke) : Ae.removeAttribute(Te); break; case "inert": case "allowFullScreen": case "async": case "autoPlay": case "controls": case "default": case "defer": case "disabled": case "disablePictureInPicture": case "disableRemotePlayback": case "formNoValidate": case "hidden": case "loop": case "noModule": case "noValidate": case "open": case "playsInline": case "readOnly": case "required": case "reversed": case "scoped": case "seamless": case "itemScope": ke && typeof ke != "function" && typeof ke != "symbol" ? Ae.setAttribute(Te, "") : Ae.removeAttribute(Te); break; case "capture": case "download": ke === !0 ? Ae.setAttribute(Te, "") : ke !== !1 && ke != null && typeof ke != "function" && typeof ke != "symbol" ? Ae.setAttribute(Te, ke) : Ae.removeAttribute(Te); break; case "cols": case "rows": case "size": case "span": ke != null && typeof ke != "function" && typeof ke != "symbol" && !isNaN(ke) && 1 <= ke ? Ae.setAttribute(Te, ke) : Ae.removeAttribute(Te); break; case "rowSpan": case "start": ke == null || typeof ke == "function" || typeof ke == "symbol" || isNaN(ke) ? Ae.removeAttribute(Te) : Ae.setAttribute(Te, ke); break; case "popover": vi("beforetoggle", Ae), vi("toggle", Ae), Ha(Ae, "popover", ke); break; case "xlinkActuate": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:actuate", ke); break; case "xlinkArcrole": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:arcrole", ke); break; case "xlinkRole": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:role", ke); break; case "xlinkShow": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:show", ke); break; case "xlinkTitle": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:title", ke); break; case "xlinkType": ha(Ae, "http://www.w3.org/1999/xlink", "xlink:type", ke); break; case "xmlBase": ha(Ae, "http://www.w3.org/XML/1998/namespace", "xml:base", ke); break; case "xmlLang": ha(Ae, "http://www.w3.org/XML/1998/namespace", "xml:lang", ke); break; case "xmlSpace": ha(Ae, "http://www.w3.org/XML/1998/namespace", "xml:space", ke); break; case "is": Ha(Ae, "is", ke); break; case "innerText": case "textContent": break; default: (!(2 < Te.length) || Te[0] !== "o" && Te[0] !== "O" || Te[1] !== "n" && Te[1] !== "N") && (Te = Va.get(Te) || Te, Ha(Ae, Te, ke)) } } function bf(Ae, Se, Te, ke, $e, Ke) { switch (Te) { case "style": au(Ae, ke, Ke); break; case "dangerouslySetInnerHTML": if (ke != null) { if (typeof ke != "object" || !("__html" in ke)) throw Error(Ee(61)); if (Te = ke.__html, Te != null) { if ($e.children != null) throw Error(Ee(60)); Ae.innerHTML = Te } } break; case "children": typeof ke == "string" ? vo(Ae, ke) : (typeof ke == "number" || typeof ke == "bigint") && vo(Ae, "" + ke); break; case "onScroll": ke != null && vi("scroll", Ae); break; case "onScrollEnd": ke != null && vi("scrollend", Ae); break; case "onClick": ke != null && (Ae.onclick = mh); break; case "suppressContentEditableWarning": case "suppressHydrationWarning": case "innerHTML": case "ref": break; case "innerText": case "textContent": break; default: if (!Xo.hasOwnProperty(Te)) e: { if (Te[0] === "o" && Te[1] === "n" && ($e = Te.endsWith("Capture"), Se = Te.slice(2, $e ? Te.length - 7 : void 0), Ke = Ae[ni] || null, Ke = Ke != null ? Ke[Te] : null, typeof Ke == "function" && Ae.removeEventListener(Se, Ke, $e), typeof ke == "function")) { typeof Ke != "function" && Ke !== null && (Te in Ae ? Ae[Te] = null : Ae.hasAttribute(Te) && Ae.removeAttribute(Te)), Ae.addEventListener(Se, ke, $e); break e } Te in Ae ? Ae[Te] = ke : ke === !0 ? Ae.setAttribute(Te, "") : Ha(Ae, Te, ke) } } } function Fs(Ae, Se, Te) { switch (Se) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "img": vi("error", Ae), vi("load", Ae); var ke = !1, $e = !1, Ke; for (Ke in Te) if (Te.hasOwnProperty(Ke)) { var wn = Te[Ke]; if (wn != null) switch (Ke) { case "src": ke = !0; break; case "srcSet": $e = !0; break; case "children": case "dangerouslySetInnerHTML": throw Error(Ee(137, Se)); default: Ii(Ae, Se, Ke, wn, Te, null) } } $e && Ii(Ae, Se, "srcSet", Te.srcSet, Te, null), ke && Ii(Ae, Se, "src", Te.src, Te, null); return; case "input": vi("invalid", Ae); var Mn = Ke = wn = $e = null, Hn = null, or = null; for (ke in Te) if (Te.hasOwnProperty(ke)) { var gr = Te[ke]; if (gr != null) switch (ke) { case "name": $e = gr; break; case "type": wn = gr; break; case "checked": Hn = gr; break; case "defaultChecked": or = gr; break; case "value": Ke = gr; break; case "defaultValue": Mn = gr; break; case "children": case "dangerouslySetInnerHTML": if (gr != null) throw Error(Ee(137, Se)); break; default: Ii(Ae, Se, ke, gr, Te, null) } } yc(Ae, Ke, Mn, Hn, or, wn, $e, !1), go(Ae); return; case "select": vi("invalid", Ae), ke = wn = Ke = null; for ($e in Te) if (Te.hasOwnProperty($e) && (Mn = Te[$e], Mn != null)) switch ($e) { case "value": Ke = Mn; break; case "defaultValue": wn = Mn; break; case "multiple": ke = Mn; default: Ii(Ae, Se, $e, Mn, Te, null) }Se = Ke, Te = wn, Ae.multiple = !!ke, Se != null ? $a(Ae, !!ke, Se, !1) : Te != null && $a(Ae, !!ke, Te, !0); return; case "textarea": vi("invalid", Ae), Ke = $e = ke = null; for (wn in Te) if (Te.hasOwnProperty(wn) && (Mn = Te[wn], Mn != null)) switch (wn) { case "value": ke = Mn; break; case "defaultValue": $e = Mn; break; case "children": Ke = Mn; break; case "dangerouslySetInnerHTML": if (Mn != null) throw Error(Ee(91)); break; default: Ii(Ae, Se, wn, Mn, Te, null) }wc(Ae, ke, $e, Ke), go(Ae); return; case "option": for (Hn in Te) if (Te.hasOwnProperty(Hn) && (ke = Te[Hn], ke != null)) switch (Hn) { case "selected": Ae.selected = ke && typeof ke != "function" && typeof ke != "symbol"; break; default: Ii(Ae, Se, Hn, ke, Te, null) }return; case "dialog": vi("beforetoggle", Ae), vi("toggle", Ae), vi("cancel", Ae), vi("close", Ae); break; case "iframe": case "object": vi("load", Ae); break; case "video": case "audio": for (ke = 0; ke < Ed.length; ke++)vi(Ed[ke], Ae); break; case "image": vi("error", Ae), vi("load", Ae); break; case "details": vi("toggle", Ae); break; case "embed": case "source": case "link": vi("error", Ae), vi("load", Ae); case "area": case "base": case "br": case "col": case "hr": case "keygen": case "meta": case "param": case "track": case "wbr": case "menuitem": for (or in Te) if (Te.hasOwnProperty(or) && (ke = Te[or], ke != null)) switch (or) { case "children": case "dangerouslySetInnerHTML": throw Error(Ee(137, Se)); default: Ii(Ae, Se, or, ke, Te, null) }return; default: if (Sc(Se)) { for (gr in Te) Te.hasOwnProperty(gr) && (ke = Te[gr], ke !== void 0 && bf(Ae, Se, gr, ke, Te, void 0)); return } }for (Mn in Te) Te.hasOwnProperty(Mn) && (ke = Te[Mn], ke != null && Ii(Ae, Se, Mn, ke, Te, null)) } function rg(Ae, Se, Te, ke) { switch (Se) { case "div": case "span": case "svg": case "path": case "a": case "g": case "p": case "li": break; case "input": var $e = null, Ke = null, wn = null, Mn = null, Hn = null, or = null, gr = null; for (cr in Te) { var wr = Te[cr]; if (Te.hasOwnProperty(cr) && wr != null) switch (cr) { case "checked": break; case "value": break; case "defaultValue": Hn = wr; default: ke.hasOwnProperty(cr) || Ii(Ae, Se, cr, null, ke, wr) } } for (var lr in ke) { var cr = ke[lr]; if (wr = Te[lr], ke.hasOwnProperty(lr) && (cr != null || wr != null)) switch (lr) { case "type": Ke = cr; break; case "name": $e = cr; break; case "checked": or = cr; break; case "defaultChecked": gr = cr; break; case "value": wn = cr; break; case "defaultValue": Mn = cr; break; case "children": case "dangerouslySetInnerHTML": if (cr != null) throw Error(Ee(137, Se)); break; default: cr !== wr && Ii(Ae, Se, lr, cr, ke, wr) } } Qo(Ae, wn, Mn, Hn, or, gr, Ke, $e); return; case "select": cr = wn = Mn = lr = null; for (Ke in Te) if (Hn = Te[Ke], Te.hasOwnProperty(Ke) && Hn != null) switch (Ke) { case "value": break; case "multiple": cr = Hn; default: ke.hasOwnProperty(Ke) || Ii(Ae, Se, Ke, null, ke, Hn) }for ($e in ke) if (Ke = ke[$e], Hn = Te[$e], ke.hasOwnProperty($e) && (Ke != null || Hn != null)) switch ($e) { case "value": lr = Ke; break; case "defaultValue": Mn = Ke; break; case "multiple": wn = Ke; default: Ke !== Hn && Ii(Ae, Se, $e, Ke, ke, Hn) }Se = Mn, Te = wn, ke = cr, lr != null ? $a(Ae, !!Te, lr, !1) : !!ke != !!Te && (Se != null ? $a(Ae, !!Te, Se, !0) : $a(Ae, !!Te, Te ? [] : "", !1)); return; case "textarea": cr = lr = null; for (Mn in Te) if ($e = Te[Mn], Te.hasOwnProperty(Mn) && $e != null && !ke.hasOwnProperty(Mn)) switch (Mn) { case "value": break; case "children": break; default: Ii(Ae, Se, Mn, null, ke, $e) }for (wn in ke) if ($e = ke[wn], Ke = Te[wn], ke.hasOwnProperty(wn) && ($e != null || Ke != null)) switch (wn) { case "value": lr = $e; break; case "defaultValue": cr = $e; break; case "children": break; case "dangerouslySetInnerHTML": if ($e != null) throw Error(Ee(91)); break; default: $e !== Ke && Ii(Ae, Se, wn, $e, ke, Ke) }iu(Ae, lr, cr); return; case "option": for (var Kr in Te) if (lr = Te[Kr], Te.hasOwnProperty(Kr) && lr != null && !ke.hasOwnProperty(Kr)) switch (Kr) { case "selected": Ae.selected = !1; break; default: Ii(Ae, Se, Kr, null, ke, lr) }for (Hn in ke) if (lr = ke[Hn], cr = Te[Hn], ke.hasOwnProperty(Hn) && lr !== cr && (lr != null || cr != null)) switch (Hn) { case "selected": Ae.selected = lr && typeof lr != "function" && typeof lr != "symbol"; break; default: Ii(Ae, Se, Hn, lr, ke, cr) }return; case "img": case "link": case "area": case "base": case "br": case "col": case "embed": case "hr": case "keygen": case "meta": case "param": case "source": case "track": case "wbr": case "menuitem": for (var Vr in Te) lr = Te[Vr], Te.hasOwnProperty(Vr) && lr != null && !ke.hasOwnProperty(Vr) && Ii(Ae, Se, Vr, null, ke, lr); for (or in ke) if (lr = ke[or], cr = Te[or], ke.hasOwnProperty(or) && lr !== cr && (lr != null || cr != null)) switch (or) { case "children": case "dangerouslySetInnerHTML": if (lr != null) throw Error(Ee(137, Se)); break; default: Ii(Ae, Se, or, lr, ke, cr) }return; default: if (Sc(Se)) { for (var Fi in Te) lr = Te[Fi], Te.hasOwnProperty(Fi) && lr !== void 0 && !ke.hasOwnProperty(Fi) && bf(Ae, Se, Fi, void 0, ke, lr); for (gr in ke) lr = ke[gr], cr = Te[gr], !ke.hasOwnProperty(gr) || lr === cr || lr === void 0 && cr === void 0 || bf(Ae, Se, gr, lr, ke, cr); return } }for (var er in Te) lr = Te[er], Te.hasOwnProperty(er) && lr != null && !ke.hasOwnProperty(er) && Ii(Ae, Se, er, null, ke, lr); for (wr in ke) lr = ke[wr], cr = Te[wr], !ke.hasOwnProperty(wr) || lr === cr || lr == null && cr == null || Ii(Ae, Se, wr, lr, ke, cr) } var xf = null, yf = null; function gh(Ae) { return Ae.nodeType === 9 ? Ae : Ae.ownerDocument } function sm(Ae) { switch (Ae) { case "http://www.w3.org/2000/svg": return 1; case "http://www.w3.org/1998/Math/MathML": return 2; default: return 0 } } function am(Ae, Se) { if (Ae === 0) switch (Se) { case "svg": return 1; case "math": return 2; default: return 0 }return Ae === 1 && Se === "foreignObject" ? 0 : Ae } function Ef(Ae, Se) { return Ae === "textarea" || Ae === "noscript" || typeof Se.children == "string" || typeof Se.children == "number" || typeof Se.children == "bigint" || typeof Se.dangerouslySetInnerHTML == "object" && Se.dangerouslySetInnerHTML !== null && Se.dangerouslySetInnerHTML.__html != null } var wf = null; function ig() { var Ae = window.event; return Ae && Ae.type === "popstate" ? Ae === wf ? !1 : (wf = Ae, !0) : (wf = null, !1) } var om = typeof setTimeout == "function" ? setTimeout : void 0, sg = typeof clearTimeout == "function" ? clearTimeout : void 0, lm = typeof Promise == "function" ? Promise : void 0, ag = typeof queueMicrotask == "function" ? queueMicrotask : typeof lm < "u" ? function (Ae) { return lm.resolve(null).then(Ae).catch(og) } : om; function og(Ae) { setTimeout(function () { throw Ae }) } function dc(Ae) { return Ae === "head" } function cm(Ae, Se) { var Te = Se, ke = 0, $e = 0; do { var Ke = Te.nextSibling; if (Ae.removeChild(Te), Ke && Ke.nodeType === 8) if (Te = Ke.data, Te === "/$") { if (0 < ke && 8 > ke) { Te = ke; var wn = Ae.ownerDocument; if (Te & 1 && Ad(wn.documentElement), Te & 2 && Ad(wn.body), Te & 4) for (Te = wn.head, Ad(Te), wn = Te.firstChild; wn;) { var Mn = wn.nextSibling, Hn = wn.nodeName; wn[Ws] || Hn === "SCRIPT" || Hn === "STYLE" || Hn === "LINK" && wn.rel.toLowerCase() === "stylesheet" || Te.removeChild(wn), wn = Mn } } if ($e === 0) { Ae.removeChild(Ke), Od(Se); return } $e-- } else Te === "$" || Te === "$?" || Te === "$!" ? $e++ : ke = Te.charCodeAt(0) - 48; else ke = 0; Te = Ke } while (Te); Od(Se) } function Af(Ae) { var Se = Ae.firstChild; for (Se && Se.nodeType === 10 && (Se = Se.nextSibling); Se;) { var Te = Se; switch (Se = Se.nextSibling, Te.nodeName) { case "HTML": case "HEAD": case "BODY": Af(Te), Xs(Te); continue; case "SCRIPT": case "STYLE": continue; case "LINK": if (Te.rel.toLowerCase() === "stylesheet") continue }Ae.removeChild(Te) } } function lg(Ae, Se, Te, ke) { for (; Ae.nodeType === 1;) { var $e = Te; if (Ae.nodeName.toLowerCase() !== Se.toLowerCase()) { if (!ke && (Ae.nodeName !== "INPUT" || Ae.type !== "hidden")) break } else if (ke) { if (!Ae[Ws]) switch (Se) { case "meta": if (!Ae.hasAttribute("itemprop")) break; return Ae; case "link": if (Ke = Ae.getAttribute("rel"), Ke === "stylesheet" && Ae.hasAttribute("data-precedence")) break; if (Ke !== $e.rel || Ae.getAttribute("href") !== ($e.href == null || $e.href === "" ? null : $e.href) || Ae.getAttribute("crossorigin") !== ($e.crossOrigin == null ? null : $e.crossOrigin) || Ae.getAttribute("title") !== ($e.title == null ? null : $e.title)) break; return Ae; case "style": if (Ae.hasAttribute("data-precedence")) break; return Ae; case "script": if (Ke = Ae.getAttribute("src"), (Ke !== ($e.src == null ? null : $e.src) || Ae.getAttribute("type") !== ($e.type == null ? null : $e.type) || Ae.getAttribute("crossorigin") !== ($e.crossOrigin == null ? null : $e.crossOrigin)) && Ke && Ae.hasAttribute("async") && !Ae.hasAttribute("itemprop")) break; return Ae; default: return Ae } } else if (Se === "input" && Ae.type === "hidden") { var Ke = $e.name == null ? null : "" + $e.name; if ($e.type === "hidden" && Ae.getAttribute("name") === Ke) return Ae } else return Ae; if (Ae = fo(Ae.nextSibling), Ae === null) break } return null } function cg(Ae, Se, Te) { if (Se === "") return null; for (; Ae.nodeType !== 3;)if ((Ae.nodeType !== 1 || Ae.nodeName !== "INPUT" || Ae.type !== "hidden") && !Te || (Ae = fo(Ae.nextSibling), Ae === null)) return null; return Ae } function Sf(Ae) { return Ae.data === "$!" || Ae.data === "$?" && Ae.ownerDocument.readyState === "complete" } function ug(Ae, Se) { var Te = Ae.ownerDocument; if (Ae.data !== "$?" || Te.readyState === "complete") Se(); else { var ke = function () { Se(), Te.removeEventListener("DOMContentLoaded", ke) }; Te.addEventListener("DOMContentLoaded", ke), Ae._reactRetry = ke } } function fo(Ae) { for (; Ae != null; Ae = Ae.nextSibling) { var Se = Ae.nodeType; if (Se === 1 || Se === 3) break; if (Se === 8) { if (Se = Ae.data, Se === "$" || Se === "$!" || Se === "$?" || Se === "F!" || Se === "F") break; if (Se === "/$") return null } } return Ae } var _f = null; function um(Ae) { Ae = Ae.previousSibling; for (var Se = 0; Ae;) { if (Ae.nodeType === 8) { var Te = Ae.data; if (Te === "$" || Te === "$!" || Te === "$?") { if (Se === 0) return Ae; Se-- } else Te === "/$" && Se++ } Ae = Ae.previousSibling } return null } function dm(Ae, Se, Te) { switch (Se = gh(Te), Ae) { case "html": if (Ae = Se.documentElement, !Ae) throw Error(Ee(452)); return Ae; case "head": if (Ae = Se.head, !Ae) throw Error(Ee(453)); return Ae; case "body": if (Ae = Se.body, !Ae) throw Error(Ee(454)); return Ae; default: throw Error(Ee(451)) } } function Ad(Ae) { for (var Se = Ae.attributes; Se.length;)Ae.removeAttributeNode(Se[0]); Xs(Ae) } var za = new Map, hm = new Set; function vh(Ae) { return typeof Ae.getRootNode == "function" ? Ae.getRootNode() : Ae.nodeType === 9 ? Ae : Ae.ownerDocument } var Sl = vn.d; vn.d = { f: dg, r: hg, D: fg, C: pg, L: mg, m: gg, X: bg, S: vg, M: xg }; function dg() { var Ae = Sl.f(), Se = lh(); return Ae || Se } function hg(Ae) { var Se = Rs(Ae); Se !== null && Se.tag === 5 && Se.type === "form" ? Xc(Se) : Sl.r(Ae) } var Iu = typeof document > "u" ? null : document; function fm(Ae, Se, Te) { var ke = Iu; if (ke && typeof Se == "string" && Se) { var $e = Bi(Se); $e = 'link[rel="' + Ae + '"][href="' + $e + '"]', typeof Te == "string" && ($e += '[crossorigin="' + Te + '"]'), hm.has($e) || (hm.add($e), Ae = { rel: Ae, crossOrigin: Te, href: Se }, ke.querySelector($e) === null && (Se = ke.createElement("link"), Fs(Se, "link", Ae), Li(Se), ke.head.appendChild(Se))) } } function fg(Ae) { Sl.D(Ae), fm("dns-prefetch", Ae, null) } function pg(Ae, Se) { Sl.C(Ae, Se), fm("preconnect", Ae, Se) } function mg(Ae, Se, Te) { Sl.L(Ae, Se, Te); var ke = Iu; if (ke && Ae && Se) { var $e = 'link[rel="preload"][as="' + Bi(Se) + '"]'; Se === "image" && Te && Te.imageSrcSet ? ($e += '[imagesrcset="' + Bi(Te.imageSrcSet) + '"]', typeof Te.imageSizes == "string" && ($e += '[imagesizes="' + Bi(Te.imageSizes) + '"]')) : $e += '[href="' + Bi(Ae) + '"]'; var Ke = $e; switch (Se) { case "style": Ke = Fu(Ae); break; case "script": Ke = Bu(Ae) }za.has(Ke) || (Ae = Oe({ rel: "preload", href: Se === "image" && Te && Te.imageSrcSet ? void 0 : Ae, as: Se }, Te), za.set(Ke, Ae), ke.querySelector($e) !== null || Se === "style" && ke.querySelector(Sd(Ke)) || Se === "script" && ke.querySelector(_d(Ke)) || (Se = ke.createElement("link"), Fs(Se, "link", Ae), Li(Se), ke.head.appendChild(Se))) } } function gg(Ae, Se) { Sl.m(Ae, Se); var Te = Iu; if (Te && Ae) { var ke = Se && typeof Se.as == "string" ? Se.as : "script", $e = 'link[rel="modulepreload"][as="' + Bi(ke) + '"][href="' + Bi(Ae) + '"]', Ke = $e; switch (ke) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": Ke = Bu(Ae) }if (!za.has(Ke) && (Ae = Oe({ rel: "modulepreload", href: Ae }, Se), za.set(Ke, Ae), Te.querySelector($e) === null)) { switch (ke) { case "audioworklet": case "paintworklet": case "serviceworker": case "sharedworker": case "worker": case "script": if (Te.querySelector(_d(Ke))) return }ke = Te.createElement("link"), Fs(ke, "link", Ae), Li(ke), Te.head.appendChild(ke) } } } function vg(Ae, Se, Te) { Sl.S(Ae, Se, Te); var ke = Iu; if (ke && Ae) { var $e = ws(ke).hoistableStyles, Ke = Fu(Ae); Se = Se || "default"; var wn = $e.get(Ke); if (!wn) { var Mn = { loading: 0, preload: null }; if (wn = ke.querySelector(Sd(Ke))) Mn.loading = 5; else { Ae = Oe({ rel: "stylesheet", href: Ae, "data-precedence": Se }, Te), (Te = za.get(Ke)) && Rf(Ae, Te); var Hn = wn = ke.createElement("link"); Li(Hn), Fs(Hn, "link", Ae), Hn._p = new Promise(function (or, gr) { Hn.onload = or, Hn.onerror = gr }), Hn.addEventListener("load", function () { Mn.loading |= 1 }), Hn.addEventListener("error", function () { Mn.loading |= 2 }), Mn.loading |= 4, bh(wn, Se, ke) } wn = { type: "stylesheet", instance: wn, count: 1, state: Mn }, $e.set(Ke, wn) } } } function bg(Ae, Se) { Sl.X(Ae, Se); var Te = Iu; if (Te && Ae) { var ke = ws(Te).hoistableScripts, $e = Bu(Ae), Ke = ke.get($e); Ke || (Ke = Te.querySelector(_d($e)), Ke || (Ae = Oe({ src: Ae, async: !0 }, Se), (Se = za.get($e)) && Cf(Ae, Se), Ke = Te.createElement("script"), Li(Ke), Fs(Ke, "link", Ae), Te.head.appendChild(Ke)), Ke = { type: "script", instance: Ke, count: 1, state: null }, ke.set($e, Ke)) } } function xg(Ae, Se) { Sl.M(Ae, Se); var Te = Iu; if (Te && Ae) { var ke = ws(Te).hoistableScripts, $e = Bu(Ae), Ke = ke.get($e); Ke || (Ke = Te.querySelector(_d($e)), Ke || (Ae = Oe({ src: Ae, async: !0, type: "module" }, Se), (Se = za.get($e)) && Cf(Ae, Se), Ke = Te.createElement("script"), Li(Ke), Fs(Ke, "link", Ae), Te.head.appendChild(Ke)), Ke = { type: "script", instance: Ke, count: 1, state: null }, ke.set($e, Ke)) } } function pm(Ae, Se, Te, ke) { var $e = ($e = Ye.current) ? vh($e) : null; if (!$e) throw Error(Ee(446)); switch (Ae) { case "meta": case "title": return null; case "style": return typeof Te.precedence == "string" && typeof Te.href == "string" ? (Se = Fu(Te.href), Te = ws($e).hoistableStyles, ke = Te.get(Se), ke || (ke = { type: "style", instance: null, count: 0, state: null }, Te.set(Se, ke)), ke) : { type: "void", instance: null, count: 0, state: null }; case "link": if (Te.rel === "stylesheet" && typeof Te.href == "string" && typeof Te.precedence == "string") { Ae = Fu(Te.href); var Ke = ws($e).hoistableStyles, wn = Ke.get(Ae); if (wn || ($e = $e.ownerDocument || $e, wn = { type: "stylesheet", instance: null, count: 0, state: { loading: 0, preload: null } }, Ke.set(Ae, wn), (Ke = $e.querySelector(Sd(Ae))) && !Ke._p && (wn.instance = Ke, wn.state.loading = 5), za.has(Ae) || (Te = { rel: "preload", as: "style", href: Te.href, crossOrigin: Te.crossOrigin, integrity: Te.integrity, media: Te.media, hrefLang: Te.hrefLang, referrerPolicy: Te.referrerPolicy }, za.set(Ae, Te), Ke || yg($e, Ae, Te, wn.state))), Se && ke === null) throw Error(Ee(528, "")); return wn } if (Se && ke !== null) throw Error(Ee(529, "")); return null; case "script": return Se = Te.async, Te = Te.src, typeof Te == "string" && Se && typeof Se != "function" && typeof Se != "symbol" ? (Se = Bu(Te), Te = ws($e).hoistableScripts, ke = Te.get(Se), ke || (ke = { type: "script", instance: null, count: 0, state: null }, Te.set(Se, ke)), ke) : { type: "void", instance: null, count: 0, state: null }; default: throw Error(Ee(444, Ae)) } } function Fu(Ae) { return 'href="' + Bi(Ae) + '"' } function Sd(Ae) { return 'link[rel="stylesheet"][' + Ae + "]" } function mm(Ae) { return Oe({}, Ae, { "data-precedence": Ae.precedence, precedence: null }) } function yg(Ae, Se, Te, ke) { Ae.querySelector('link[rel="preload"][as="style"][' + Se + "]") ? ke.loading = 1 : (Se = Ae.createElement("link"), ke.preload = Se, Se.addEventListener("load", function () { return ke.loading |= 1 }), Se.addEventListener("error", function () { return ke.loading |= 2 }), Fs(Se, "link", Te), Li(Se), Ae.head.appendChild(Se)) } function Bu(Ae) { return '[src="' + Bi(Ae) + '"]' } function _d(Ae) { return "script[async]" + Ae } function gm(Ae, Se, Te) { if (Se.count++, Se.instance === null) switch (Se.type) { case "style": var ke = Ae.querySelector('style[data-href~="' + Bi(Te.href) + '"]'); if (ke) return Se.instance = ke, Li(ke), ke; var $e = Oe({}, Te, { "data-href": Te.href, "data-precedence": Te.precedence, href: null, precedence: null }); return ke = (Ae.ownerDocument || Ae).createElement("style"), Li(ke), Fs(ke, "style", $e), bh(ke, Te.precedence, Ae), Se.instance = ke; case "stylesheet": $e = Fu(Te.href); var Ke = Ae.querySelector(Sd($e)); if (Ke) return Se.state.loading |= 4, Se.instance = Ke, Li(Ke), Ke; ke = mm(Te), ($e = za.get($e)) && Rf(ke, $e), Ke = (Ae.ownerDocument || Ae).createElement("link"), Li(Ke); var wn = Ke; return wn._p = new Promise(function (Mn, Hn) { wn.onload = Mn, wn.onerror = Hn }), Fs(Ke, "link", ke), Se.state.loading |= 4, bh(Ke, Te.precedence, Ae), Se.instance = Ke; case "script": return Ke = Bu(Te.src), ($e = Ae.querySelector(_d(Ke))) ? (Se.instance = $e, Li($e), $e) : (ke = Te, ($e = za.get(Ke)) && (ke = Oe({}, Te), Cf(ke, $e)), Ae = Ae.ownerDocument || Ae, $e = Ae.createElement("script"), Li($e), Fs($e, "link", ke), Ae.head.appendChild($e), Se.instance = $e); case "void": return null; default: throw Error(Ee(443, Se.type)) } else Se.type === "stylesheet" && (Se.state.loading & 4) === 0 && (ke = Se.instance, Se.state.loading |= 4, bh(ke, Te.precedence, Ae)); return Se.instance } function bh(Ae, Se, Te) { for (var ke = Te.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), $e = ke.length ? ke[ke.length - 1] : null, Ke = $e, wn = 0; wn < ke.length; wn++) { var Mn = ke[wn]; if (Mn.dataset.precedence === Se) Ke = Mn; else if (Ke !== $e) break } Ke ? Ke.parentNode.insertBefore(Ae, Ke.nextSibling) : (Se = Te.nodeType === 9 ? Te.head : Te, Se.insertBefore(Ae, Se.firstChild)) } function Rf(Ae, Se) { Ae.crossOrigin == null && (Ae.crossOrigin = Se.crossOrigin), Ae.referrerPolicy == null && (Ae.referrerPolicy = Se.referrerPolicy), Ae.title == null && (Ae.title = Se.title) } function Cf(Ae, Se) { Ae.crossOrigin == null && (Ae.crossOrigin = Se.crossOrigin), Ae.referrerPolicy == null && (Ae.referrerPolicy = Se.referrerPolicy), Ae.integrity == null && (Ae.integrity = Se.integrity) } var xh = null; function vm(Ae, Se, Te) { if (xh === null) { var ke = new Map, $e = xh = new Map; $e.set(Te, ke) } else $e = xh, ke = $e.get(Te), ke || (ke = new Map, $e.set(Te, ke)); if (ke.has(Ae)) return ke; for (ke.set(Ae, null), Te = Te.getElementsByTagName(Ae), $e = 0; $e < Te.length; $e++) { var Ke = Te[$e]; if (!(Ke[Ws] || Ke[pi] || Ae === "link" && Ke.getAttribute("rel") === "stylesheet") && Ke.namespaceURI !== "http://www.w3.org/2000/svg") { var wn = Ke.getAttribute(Se) || ""; wn = Ae + wn; var Mn = ke.get(wn); Mn ? Mn.push(Ke) : ke.set(wn, [Ke]) } } return ke } function bm(Ae, Se, Te) { Ae = Ae.ownerDocument || Ae, Ae.head.insertBefore(Te, Se === "title" ? Ae.querySelector("head > title") : null) } function Eg(Ae, Se, Te) { if (Te === 1 || Se.itemProp != null) return !1; switch (Ae) { case "meta": case "title": return !0; case "style": if (typeof Se.precedence != "string" || typeof Se.href != "string" || Se.href === "") break; return !0; case "link": if (typeof Se.rel != "string" || typeof Se.href != "string" || Se.href === "" || Se.onLoad || Se.onError) break; switch (Se.rel) { case "stylesheet": return Ae = Se.disabled, typeof Se.precedence == "string" && Ae == null; default: return !0 }case "script": if (Se.async && typeof Se.async != "function" && typeof Se.async != "symbol" && !Se.onLoad && !Se.onError && Se.src && typeof Se.src == "string") return !0 }return !1 } function xm(Ae) { return !(Ae.type === "stylesheet" && (Ae.state.loading & 3) === 0) } var Rd = null; function wg() { } function Ag(Ae, Se, Te) { if (Rd === null) throw Error(Ee(475)); var ke = Rd; if (Se.type === "stylesheet" && (typeof Te.media != "string" || matchMedia(Te.media).matches !== !1) && (Se.state.loading & 4) === 0) { if (Se.instance === null) { var $e = Fu(Te.href), Ke = Ae.querySelector(Sd($e)); if (Ke) { Ae = Ke._p, Ae !== null && typeof Ae == "object" && typeof Ae.then == "function" && (ke.count++, ke = yh.bind(ke), Ae.then(ke, ke)), Se.state.loading |= 4, Se.instance = Ke, Li(Ke); return } Ke = Ae.ownerDocument || Ae, Te = mm(Te), ($e = za.get($e)) && Rf(Te, $e), Ke = Ke.createElement("link"), Li(Ke); var wn = Ke; wn._p = new Promise(function (Mn, Hn) { wn.onload = Mn, wn.onerror = Hn }), Fs(Ke, "link", Te), Se.instance = Ke } ke.stylesheets === null && (ke.stylesheets = new Map), ke.stylesheets.set(Se, Ae), (Ae = Se.state.preload) && (Se.state.loading & 3) === 0 && (ke.count++, Se = yh.bind(ke), Ae.addEventListener("load", Se), Ae.addEventListener("error", Se)) } } function Sg() { if (Rd === null) throw Error(Ee(475)); var Ae = Rd; return Ae.stylesheets && Ae.count === 0 && Tf(Ae, Ae.stylesheets), 0 < Ae.count ? function (Se) { var Te = setTimeout(function () { if (Ae.stylesheets && Tf(Ae, Ae.stylesheets), Ae.unsuspend) { var ke = Ae.unsuspend; Ae.unsuspend = null, ke() } }, 6e4); return Ae.unsuspend = Se, function () { Ae.unsuspend = null, clearTimeout(Te) } } : null } function yh() { if (this.count--, this.count === 0) { if (this.stylesheets) Tf(this, this.stylesheets); else if (this.unsuspend) { var Ae = this.unsuspend; this.unsuspend = null, Ae() } } } var Eh = null; function Tf(Ae, Se) { Ae.stylesheets = null, Ae.unsuspend !== null && (Ae.count++, Eh = new Map, Se.forEach(_g, Ae), Eh = null, yh.call(Ae)) } function _g(Ae, Se) { if (!(Se.state.loading & 4)) { var Te = Eh.get(Ae); if (Te) var ke = Te.get(null); else { Te = new Map, Eh.set(Ae, Te); for (var $e = Ae.querySelectorAll("link[data-precedence],style[data-precedence]"), Ke = 0; Ke < $e.length; Ke++) { var wn = $e[Ke]; (wn.nodeName === "LINK" || wn.getAttribute("media") !== "not all") && (Te.set(wn.dataset.precedence, wn), ke = wn) } ke && Te.set(null, ke) } $e = Se.instance, wn = $e.getAttribute("data-precedence"), Ke = Te.get(wn) || ke, Ke === ke && Te.set(null, $e), Te.set(wn, $e), this.count++, ke = yh.bind(this), $e.addEventListener("load", ke), $e.addEventListener("error", ke), Ke ? Ke.parentNode.insertBefore($e, Ke.nextSibling) : (Ae = Ae.nodeType === 9 ? Ae.head : Ae, Ae.insertBefore($e, Ae.firstChild)), Se.state.loading |= 4 } } var Cd = { $$typeof: Ze, Provider: null, Consumer: null, _currentValue: tn, _currentValue2: tn, _threadCount: 0 }; function Rg(Ae, Se, Te, ke, $e, Ke, wn, Mn) { this.tag = 1, this.containerInfo = Ae, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = Wi(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Wi(0), this.hiddenUpdates = Wi(null), this.identifierPrefix = ke, this.onUncaughtError = $e, this.onCaughtError = Ke, this.onRecoverableError = wn, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = Mn, this.incompleteTransitions = new Map } function ym(Ae, Se, Te, ke, $e, Ke, wn, Mn, Hn, or, gr, wr) { return Ae = new Rg(Ae, Se, Te, wn, Mn, Hn, or, wr), Se = 1, Ke === !0 && (Se |= 24), Ke = Ts(3, null, null, Se), Ae.current = Ke, Ke.stateNode = Ae, Se = Xu(), Se.refCount++, Ae.pooledCache = Se, Se.refCount++, Ke.memoizedState = { element: ke, isDehydrated: Te, cache: Se }, Wn(Ke), Ae } function Em(Ae) { return Ae ? (Ae = xs, Ae) : xs } function wm(Ae, Se, Te, ke, $e, Ke) { $e = Em($e), ke.context === null ? ke.context = $e : ke.pendingContext = $e, ke = pr(Se), ke.payload = { element: Te }, Ke = Ke === void 0 ? null : Ke, Ke !== null && (ke.callback = Ke), Te = yr(Ae, ke, Se), Te !== null && (Ra(Te, Ae, Se), vr(Te, Ae, Se)) } function Am(Ae, Se) { if (Ae = Ae.memoizedState, Ae !== null && Ae.dehydrated !== null) { var Te = Ae.retryLane; Ae.retryLane = Te !== 0 && Te < Se ? Te : Se } } function Nf(Ae, Se) { Am(Ae, Se), (Ae = Ae.alternate) && Am(Ae, Se) } function Sm(Ae) { if (Ae.tag === 13) { var Se = Ja(Ae, 67108864); Se !== null && Ra(Se, Ae, 67108864), Nf(Ae, 67108864) } } var wh = !0; function Cg(Ae, Se, Te, ke) { var $e = xn.T; xn.T = null; var Ke = vn.p; try { vn.p = 2, Pf(Ae, Se, Te, ke) } finally { vn.p = Ke, xn.T = $e } } function Tg(Ae, Se, Te, ke) { var $e = xn.T; xn.T = null; var Ke = vn.p; try { vn.p = 8, Pf(Ae, Se, Te, ke) } finally { vn.p = Ke, xn.T = $e } } function Pf(Ae, Se, Te, ke) { if (wh) { var $e = Of(ke); if ($e === null) vf(Ae, Se, ke, Ah, Te), Rm(Ae, ke); else if (Pg($e, Ae, Se, Te, ke)) ke.stopPropagation(); else if (Rm(Ae, ke), Se & 4 && -1 < Ng.indexOf(Ae)) { for (; $e !== null;) { var Ke = Rs($e); if (Ke !== null) switch (Ke.tag) { case 3: if (Ke = Ke.stateNode, Ke.current.memoizedState.isDehydrated) { var wn = Kn(Ke.pendingLanes); if (wn !== 0) { var Mn = Ke; for (Mn.pendingLanes |= 2, Mn.entangledLanes |= 2; wn;) { var Hn = 1 << 31 - Cr(wn); Mn.entanglements[1] |= Hn, wn &= ~Hn } Go(Ke), (Mi & 6) === 0 && (ah = Vn() + 500, yd(0)) } } break; case 13: Mn = Ja(Ke, 2), Mn !== null && Ra(Mn, Ke, 2), lh(), Nf(Ke, 2) }if (Ke = Of(ke), Ke === null && vf(Ae, Se, ke, Ah, Te), Ke === $e) break; $e = Ke } $e !== null && ke.stopPropagation() } else vf(Ae, Se, ke, null, Te) } } function Of(Ae) { return Ae = gs(Ae), Lf(Ae) } var Ah = null; function Lf(Ae) { if (Ah = null, Ae = _s(Ae), Ae !== null) { var Se = Re(Ae); if (Se === null) Ae = null; else { var Te = Se.tag; if (Te === 13) { if (Ae = Ce(Se), Ae !== null) return Ae; Ae = null } else if (Te === 3) { if (Se.stateNode.current.memoizedState.isDehydrated) return Se.tag === 3 ? Se.stateNode.containerInfo : null; Ae = null } else Se !== Ae && (Ae = null) } } return Ah = Ae, null } function _m(Ae) { switch (Ae) { case "beforetoggle": case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "toggle": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 2; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 8; case "message": switch (Yn()) { case qn: return 2; case rr: return 8; case hr: case ur: return 32; case Er: return 268435456; default: return 32 }default: return 32 } } var jf = !1, hc = null, fc = null, pc = null, Td = new Map, Nd = new Map, mc = [], Ng = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" "); function Rm(Ae, Se) { switch (Ae) { case "focusin": case "focusout": hc = null; break; case "dragenter": case "dragleave": fc = null; break; case "mouseover": case "mouseout": pc = null; break; case "pointerover": case "pointerout": Td.delete(Se.pointerId); break; case "gotpointercapture": case "lostpointercapture": Nd.delete(Se.pointerId) } } function Pd(Ae, Se, Te, ke, $e, Ke) { return Ae === null || Ae.nativeEvent !== Ke ? (Ae = { blockedOn: Se, domEventName: Te, eventSystemFlags: ke, nativeEvent: Ke, targetContainers: [$e] }, Se !== null && (Se = Rs(Se), Se !== null && Sm(Se)), Ae) : (Ae.eventSystemFlags |= ke, Se = Ae.targetContainers, $e !== null && Se.indexOf($e) === -1 && Se.push($e), Ae) } function Pg(Ae, Se, Te, ke, $e) { switch (Se) { case "focusin": return hc = Pd(hc, Ae, Se, Te, ke, $e), !0; case "dragenter": return fc = Pd(fc, Ae, Se, Te, ke, $e), !0; case "mouseover": return pc = Pd(pc, Ae, Se, Te, ke, $e), !0; case "pointerover": var Ke = $e.pointerId; return Td.set(Ke, Pd(Td.get(Ke) || null, Ae, Se, Te, ke, $e)), !0; case "gotpointercapture": return Ke = $e.pointerId, Nd.set(Ke, Pd(Nd.get(Ke) || null, Ae, Se, Te, ke, $e)), !0 }return !1 } function Cm(Ae) { var Se = _s(Ae.target); if (Se !== null) { var Te = Re(Se); if (Te !== null) { if (Se = Te.tag, Se === 13) { if (Se = Ce(Te), Se !== null) { Ae.blockedOn = Se, yi(Ae.priority, function () { if (Te.tag === 13) { var ke = Sa(); ke = hi(ke); var $e = Ja(Te, ke); $e !== null && Ra($e, Te, ke), Nf(Te, ke) } }); return } } else if (Se === 3 && Te.stateNode.current.memoizedState.isDehydrated) { Ae.blockedOn = Te.tag === 3 ? Te.stateNode.containerInfo : null; return } } } Ae.blockedOn = null } function Sh(Ae) { if (Ae.blockedOn !== null) return !1; for (var Se = Ae.targetContainers; 0 < Se.length;) { var Te = Of(Ae.nativeEvent); if (Te === null) { Te = Ae.nativeEvent; var ke = new Te.constructor(Te.type, Te); Tl = ke, Te.target.dispatchEvent(ke), Tl = null } else return Se = Rs(Te), Se !== null && Sm(Se), Ae.blockedOn = Te, !1; Se.shift() } return !0 } function Tm(Ae, Se, Te) { Sh(Ae) && Te.delete(Se) } function Og() { jf = !1, hc !== null && Sh(hc) && (hc = null), fc !== null && Sh(fc) && (fc = null), pc !== null && Sh(pc) && (pc = null), Td.forEach(Tm), Nd.forEach(Tm) } function _h(Ae, Se) { Ae.blockedOn === Se && (Ae.blockedOn = null, jf || (jf = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, Og))) } var Rh = null; function Nm(Ae) { Rh !== Ae && (Rh = Ae, e.unstable_scheduleCallback(e.unstable_NormalPriority, function () { Rh === Ae && (Rh = null); for (var Se = 0; Se < Ae.length; Se += 3) { var Te = Ae[Se], ke = Ae[Se + 1], $e = Ae[Se + 2]; if (typeof ke != "function") { if (Lf(ke || Te) === null) continue; break } var Ke = Rs(Te); Ke !== null && (Ae.splice(Se, 3), Se -= 3, Fa(Ke, { pending: !0, data: $e, method: Te.method, action: ke }, ke, $e)) } })) } function Od(Ae) { function Se(Hn) { return _h(Hn, Ae) } hc !== null && _h(hc, Ae), fc !== null && _h(fc, Ae), pc !== null && _h(pc, Ae), Td.forEach(Se), Nd.forEach(Se); for (var Te = 0; Te < mc.length; Te++) { var ke = mc[Te]; ke.blockedOn === Ae && (ke.blockedOn = null) } for (; 0 < mc.length && (Te = mc[0], Te.blockedOn === null);)Cm(Te), Te.blockedOn === null && mc.shift(); if (Te = (Ae.ownerDocument || Ae).$$reactFormReplay, Te != null) for (ke = 0; ke < Te.length; ke += 3) { var $e = Te[ke], Ke = Te[ke + 1], wn = $e[ni] || null; if (typeof Ke == "function") wn || Nm(Te); else if (wn) { var Mn = null; if (Ke && Ke.hasAttribute("formAction")) { if ($e = Ke, wn = Ke[ni] || null) Mn = wn.formAction; else if (Lf($e) !== null) continue } else Mn = wn.action; typeof Mn == "function" ? Te[ke + 1] = Mn : (Te.splice(ke, 3), ke -= 3), Nm(Te) } } } function Mf(Ae) { this._internalRoot = Ae } Ch.prototype.render = Mf.prototype.render = function (Ae) { var Se = this._internalRoot; if (Se === null) throw Error(Ee(409)); var Te = Se.current, ke = Sa(); wm(Te, ke, Ae, Se, null, null) }, Ch.prototype.unmount = Mf.prototype.unmount = function () { var Ae = this._internalRoot; if (Ae !== null) { this._internalRoot = null; var Se = Ae.containerInfo; wm(Ae.current, 2, null, Ae, null, null), lh(), Se[oi] = null } }; function Ch(Ae) { this._internalRoot = Ae } Ch.prototype.unstable_scheduleHydration = function (Ae) { if (Ae) { var Se = fi(); Ae = { blockedOn: null, target: Ae, priority: Se }; for (var Te = 0; Te < mc.length && Se !== 0 && Se < mc[Te].priority; Te++); mc.splice(Te, 0, Ae), Te === 0 && Cm(Ae) } }; var Pm = t.version; if (Pm !== "19.1.0") throw Error(Ee(527, Pm, "19.1.0")); vn.findDOMNode = function (Ae) { var Se = Ae._reactInternals; if (Se === void 0) throw typeof Ae.render == "function" ? Error(Ee(188)) : (Ae = Object.keys(Ae).join(","), Error(Ee(268, Ae))); return Ae = De(Se), Ae = Ae !== null ? Pe(Ae) : null, Ae = Ae === null ? null : Ae.stateNode, Ae }; var Lg = { bundleType: 0, version: "19.1.0", rendererPackageName: "react-dom", currentDispatcherRef: xn, reconcilerVersion: "19.1.0" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var Th = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!Th.isDisabled && Th.supportsFiber) try { Ir = Th.inject(Lg), Dr = Th } catch { } } return reactDomClient_production.createRoot = function (Ae, Se) { if (!_e(Ae)) throw Error(Ee(299)); var Te = !1, ke = "", $e = Gf, Ke = Wf, wn = Xf, Mn = null; return Se != null && (Se.unstable_strictMode === !0 && (Te = !0), Se.identifierPrefix !== void 0 && (ke = Se.identifierPrefix), Se.onUncaughtError !== void 0 && ($e = Se.onUncaughtError), Se.onCaughtError !== void 0 && (Ke = Se.onCaughtError), Se.onRecoverableError !== void 0 && (wn = Se.onRecoverableError), Se.unstable_transitionCallbacks !== void 0 && (Mn = Se.unstable_transitionCallbacks)), Se = ym(Ae, 1, !1, null, null, Te, ke, $e, Ke, wn, Mn, null), Ae[oi] = Se.current, gf(Ae), new Mf(Se) }, reactDomClient_production.hydrateRoot = function (Ae, Se, Te) { if (!_e(Ae)) throw Error(Ee(299)); var ke = !1, $e = "", Ke = Gf, wn = Wf, Mn = Xf, Hn = null, or = null; return Te != null && (Te.unstable_strictMode === !0 && (ke = !0), Te.identifierPrefix !== void 0 && ($e = Te.identifierPrefix), Te.onUncaughtError !== void 0 && (Ke = Te.onUncaughtError), Te.onCaughtError !== void 0 && (wn = Te.onCaughtError), Te.onRecoverableError !== void 0 && (Mn = Te.onRecoverableError), Te.unstable_transitionCallbacks !== void 0 && (Hn = Te.unstable_transitionCallbacks), Te.formState !== void 0 && (or = Te.formState)), Se = ym(Ae, 1, !0, Se, Te ?? null, ke, $e, Ke, wn, Mn, Hn, or), Se.context = Em(null), Te = Se.current, ke = Sa(), ke = hi(ke), $e = pr(ke), $e.callback = null, yr(Te, $e, ke), Te = ke, Se.current.lanes = Te, $i(Se, Te), Go(Se), Ae[oi] = Se.current, gf(Ae), new Ch(Se) }, reactDomClient_production.version = "19.1.0", reactDomClient_production
} var hasRequiredClient; function requireClient() { if (hasRequiredClient) return client.exports; hasRequiredClient = 1; function e() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e) } catch (t) { console.error(t) } } return e(), client.exports = requireReactDomClient_production(), client.exports } var clientExports = requireClient(); const ReactDOM$1 = getDefaultExportFromCjs(clientExports); var Subscribable = class { constructor() { this.listeners = new Set, this.subscribe = this.subscribe.bind(this) } subscribe(e) { return this.listeners.add(e), this.onSubscribe(), () => { this.listeners.delete(e), this.onUnsubscribe() } } hasListeners() { return this.listeners.size > 0 } onSubscribe() { } onUnsubscribe() { } }, isServer = typeof window > "u" || "Deno" in globalThis; function noop$2() { } function functionalUpdate(e, t) { return typeof e == "function" ? e(t) : e } function isValidTimeout(e) { return typeof e == "number" && e >= 0 && e !== 1 / 0 } function timeUntilStale(e, t) { return Math.max(e + (t || 0) - Date.now(), 0) } function resolveStaleTime(e, t) { return typeof e == "function" ? e(t) : e } function resolveEnabled(e, t) { return typeof e == "function" ? e(t) : e } function matchQuery(e, t) { const { type: xe = "all", exact: Ee, fetchStatus: _e, predicate: Re, queryKey: Ce, stale: Me } = e; if (Ce) { if (Ee) { if (t.queryHash !== hashQueryKeyByOptions(Ce, t.options)) return !1 } else if (!partialMatchKey(t.queryKey, Ce)) return !1 } if (xe !== "all") { const De = t.isActive(); if (xe === "active" && !De || xe === "inactive" && De) return !1 } return !(typeof Me == "boolean" && t.isStale() !== Me || _e && _e !== t.state.fetchStatus || Re && !Re(t)) } function matchMutation(e, t) { const { exact: xe, status: Ee, predicate: _e, mutationKey: Re } = e; if (Re) { if (!t.options.mutationKey) return !1; if (xe) { if (hashKey(t.options.mutationKey) !== hashKey(Re)) return !1 } else if (!partialMatchKey(t.options.mutationKey, Re)) return !1 } return !(Ee && t.state.status !== Ee || _e && !_e(t)) } function hashQueryKeyByOptions(e, t) { return (t?.queryKeyHashFn || hashKey)(e) } function hashKey(e) { return JSON.stringify(e, (t, xe) => isPlainObject$2(xe) ? Object.keys(xe).sort().reduce((Ee, _e) => (Ee[_e] = xe[_e], Ee), {}) : xe) } function partialMatchKey(e, t) { return e === t ? !0 : typeof e != typeof t ? !1 : e && t && typeof e == "object" && typeof t == "object" ? Object.keys(t).every(xe => partialMatchKey(e[xe], t[xe])) : !1 } function replaceEqualDeep(e, t) { if (e === t) return e; const xe = isPlainArray(e) && isPlainArray(t); if (xe || isPlainObject$2(e) && isPlainObject$2(t)) { const Ee = xe ? e : Object.keys(e), _e = Ee.length, Re = xe ? t : Object.keys(t), Ce = Re.length, Me = xe ? [] : {}, De = new Set(Ee); let Pe = 0; for (let Oe = 0; Oe < Ce; Oe++) { const je = xe ? Oe : Re[Oe]; (!xe && De.has(je) || xe) && e[je] === void 0 && t[je] === void 0 ? (Me[je] = void 0, Pe++) : (Me[je] = replaceEqualDeep(e[je], t[je]), Me[je] === e[je] && e[je] !== void 0 && Pe++) } return _e === Ce && Pe === _e ? e : Me } return t } function shallowEqualObjects(e, t) { if (!t || Object.keys(e).length !== Object.keys(t).length) return !1; for (const xe in e) if (e[xe] !== t[xe]) return !1; return !0 } function isPlainArray(e) { return Array.isArray(e) && e.length === Object.keys(e).length } function isPlainObject$2(e) { if (!hasObjectPrototype(e)) return !1; const t = e.constructor; if (t === void 0) return !0; const xe = t.prototype; return !(!hasObjectPrototype(xe) || !xe.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(e) !== Object.prototype) } function hasObjectPrototype(e) { return Object.prototype.toString.call(e) === "[object Object]" } function sleep(e) { return new Promise(t => { setTimeout(t, e) }) } function replaceData(e, t, xe) { return typeof xe.structuralSharing == "function" ? xe.structuralSharing(e, t) : xe.structuralSharing !== !1 ? replaceEqualDeep(e, t) : t } function addToEnd(e, t, xe = 0) { const Ee = [...e, t]; return xe && Ee.length > xe ? Ee.slice(1) : Ee } function addToStart(e, t, xe = 0) { const Ee = [t, ...e]; return xe && Ee.length > xe ? Ee.slice(0, -1) : Ee } var skipToken = Symbol(); function ensureQueryFn(e, t) { return !e.queryFn && t?.initialPromise ? () => t.initialPromise : !e.queryFn || e.queryFn === skipToken ? () => Promise.reject(new Error(`Missing queryFn: '${e.queryHash}'`)) : e.queryFn } function shouldThrowError(e, t) { return typeof e == "function" ? e(...t) : !!e } var FocusManager = class extends Subscribable { #e; #t; #n; constructor() { super(), this.#n = e => { if (!isServer && window.addEventListener) { const t = () => e(); return window.addEventListener("visibilitychange", t, !1), () => { window.removeEventListener("visibilitychange", t) } } } } onSubscribe() { this.#t || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#t?.(), this.#t = void 0) } setEventListener(e) { this.#n = e, this.#t?.(), this.#t = e(t => { typeof t == "boolean" ? this.setFocused(t) : this.onFocus() }) } setFocused(e) { this.#e !== e && (this.#e = e, this.onFocus()) } onFocus() { const e = this.isFocused(); this.listeners.forEach(t => { t(e) }) } isFocused() { return typeof this.#e == "boolean" ? this.#e : globalThis.document?.visibilityState !== "hidden" } }, focusManager = new FocusManager, OnlineManager = class extends Subscribable { #e = !0; #t; #n; constructor() { super(), this.#n = e => { if (!isServer && window.addEventListener) { const t = () => e(!0), xe = () => e(!1); return window.addEventListener("online", t, !1), window.addEventListener("offline", xe, !1), () => { window.removeEventListener("online", t), window.removeEventListener("offline", xe) } } } } onSubscribe() { this.#t || this.setEventListener(this.#n) } onUnsubscribe() { this.hasListeners() || (this.#t?.(), this.#t = void 0) } setEventListener(e) { this.#n = e, this.#t?.(), this.#t = e(this.setOnline.bind(this)) } setOnline(e) { this.#e !== e && (this.#e = e, this.listeners.forEach(xe => { xe(e) })) } isOnline() { return this.#e } }, onlineManager = new OnlineManager; function pendingThenable() { let e, t; const xe = new Promise((_e, Re) => { e = _e, t = Re }); xe.status = "pending", xe.catch(() => { }); function Ee(_e) { Object.assign(xe, _e), delete xe.resolve, delete xe.reject } return xe.resolve = _e => { Ee({ status: "fulfilled", value: _e }), e(_e) }, xe.reject = _e => { Ee({ status: "rejected", reason: _e }), t(_e) }, xe } function defaultRetryDelay(e) { return Math.min(1e3 * 2 ** e, 3e4) } function canFetch(e) { return (e ?? "online") === "online" ? onlineManager.isOnline() : !0 } var CancelledError = class extends Error { constructor(e) { super("CancelledError"), this.revert = e?.revert, this.silent = e?.silent } }; function isCancelledError(e) { return e instanceof CancelledError } function createRetryer(e) { let t = !1, xe = 0, Ee = !1, _e; const Re = pendingThenable(), Ce = ze => { Ee || (Be(new CancelledError(ze)), e.abort?.()) }, Me = () => { t = !0 }, De = () => { t = !1 }, Pe = () => focusManager.isFocused() && (e.networkMode === "always" || onlineManager.isOnline()) && e.canRun(), Oe = () => canFetch(e.networkMode) && e.canRun(), je = ze => { Ee || (Ee = !0, e.onSuccess?.(ze), _e?.(), Re.resolve(ze)) }, Be = ze => { Ee || (Ee = !0, e.onError?.(ze), _e?.(), Re.reject(ze)) }, Ie = () => new Promise(ze => { _e = qe => { (Ee || Pe()) && ze(qe) }, e.onPause?.() }).then(() => { _e = void 0, Ee || e.onContinue?.() }), Fe = () => { if (Ee) return; let ze; const qe = xe === 0 ? e.initialPromise : void 0; try { ze = qe ?? e.fn() } catch (He) { ze = Promise.reject(He) } Promise.resolve(ze).then(je).catch(He => { if (Ee) return; const Ge = e.retry ?? (isServer ? 0 : 3), Ze = e.retryDelay ?? defaultRetryDelay, sn = typeof Ze == "function" ? Ze(xe, He) : Ze, Xe = Ge === !0 || typeof Ge == "number" && xe < Ge || typeof Ge == "function" && Ge(xe, He); if (t || !Xe) { Be(He); return } xe++, e.onFail?.(xe, He), sleep(sn).then(() => Pe() ? void 0 : Ie()).then(() => { t ? Be(He) : Fe() }) }) }; return { promise: Re, cancel: Ce, continue: () => (_e?.(), Re), cancelRetry: Me, continueRetry: De, canStart: Oe, start: () => (Oe() ? Fe() : Ie().then(Fe), Re) } } var defaultScheduler = e => setTimeout(e, 0); function createNotifyManager() { let e = [], t = 0, xe = Me => { Me() }, Ee = Me => { Me() }, _e = defaultScheduler; const Re = Me => { t ? e.push(Me) : _e(() => { xe(Me) }) }, Ce = () => { const Me = e; e = [], Me.length && _e(() => { Ee(() => { Me.forEach(De => { xe(De) }) }) }) }; return { batch: Me => { let De; t++; try { De = Me() } finally { t--, t || Ce() } return De }, batchCalls: Me => (...De) => { Re(() => { Me(...De) }) }, schedule: Re, setNotifyFunction: Me => { xe = Me }, setBatchNotifyFunction: Me => { Ee = Me }, setScheduler: Me => { _e = Me } } } var notifyManager = createNotifyManager(), Removable = class { #e; destroy() { this.clearGcTimeout() } scheduleGc() { this.clearGcTimeout(), isValidTimeout(this.gcTime) && (this.#e = setTimeout(() => { this.optionalRemove() }, this.gcTime)) } updateGcTime(e) { this.gcTime = Math.max(this.gcTime || 0, e ?? (isServer ? 1 / 0 : 300 * 1e3)) } clearGcTimeout() { this.#e && (clearTimeout(this.#e), this.#e = void 0) } }, Query = class extends Removable { #e; #t; #n; #r; #a; #o; #s; constructor(e) { super(), this.#s = !1, this.#o = e.defaultOptions, this.setOptions(e.options), this.observers = [], this.#r = e.client, this.#n = this.#r.getQueryCache(), this.queryKey = e.queryKey, this.queryHash = e.queryHash, this.#e = getDefaultState$1(this.options), this.state = e.state ?? this.#e, this.scheduleGc() } get meta() { return this.options.meta } get promise() { return this.#a?.promise } setOptions(e) { this.options = { ...this.#o, ...e }, this.updateGcTime(this.options.gcTime) } optionalRemove() { !this.observers.length && this.state.fetchStatus === "idle" && this.#n.remove(this) } setData(e, t) { const xe = replaceData(this.state.data, e, this.options); return this.#l({ data: xe, type: "success", dataUpdatedAt: t?.updatedAt, manual: t?.manual }), xe } setState(e, t) { this.#l({ type: "setState", state: e, setStateOptions: t }) } cancel(e) { const t = this.#a?.promise; return this.#a?.cancel(e), t ? t.then(noop$2).catch(noop$2) : Promise.resolve() } destroy() { super.destroy(), this.cancel({ silent: !0 }) } reset() { this.destroy(), this.setState(this.#e) } isActive() { return this.observers.some(e => resolveEnabled(e.options.enabled, this) !== !1) } isDisabled() { return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === skipToken || this.state.dataUpdateCount + this.state.errorUpdateCount === 0 } isStatic() { return this.getObserversCount() > 0 ? this.observers.some(e => resolveStaleTime(e.options.staleTime, this) === "static") : !1 } isStale() { return this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated } isStaleByTime(e = 0) { return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !timeUntilStale(this.state.dataUpdatedAt, e) } onFocus() { this.observers.find(t => t.shouldFetchOnWindowFocus())?.refetch({ cancelRefetch: !1 }), this.#a?.continue() } onOnline() { this.observers.find(t => t.shouldFetchOnReconnect())?.refetch({ cancelRefetch: !1 }), this.#a?.continue() } addObserver(e) { this.observers.includes(e) || (this.observers.push(e), this.clearGcTimeout(), this.#n.notify({ type: "observerAdded", query: this, observer: e })) } removeObserver(e) { this.observers.includes(e) && (this.observers = this.observers.filter(t => t !== e), this.observers.length || (this.#a && (this.#s ? this.#a.cancel({ revert: !0 }) : this.#a.cancelRetry()), this.scheduleGc()), this.#n.notify({ type: "observerRemoved", query: this, observer: e })) } getObserversCount() { return this.observers.length } invalidate() { this.state.isInvalidated || this.#l({ type: "invalidate" }) } fetch(e, t) { if (this.state.fetchStatus !== "idle") { if (this.state.data !== void 0 && t?.cancelRefetch) this.cancel({ silent: !0 }); else if (this.#a) return this.#a.continueRetry(), this.#a.promise } if (e && this.setOptions(e), !this.options.queryFn) { const De = this.observers.find(Pe => Pe.options.queryFn); De && this.setOptions(De.options) } const xe = new AbortController, Ee = De => { Object.defineProperty(De, "signal", { enumerable: !0, get: () => (this.#s = !0, xe.signal) }) }, _e = () => { const De = ensureQueryFn(this.options, t), Oe = (() => { const je = { client: this.#r, queryKey: this.queryKey, meta: this.meta }; return Ee(je), je })(); return this.#s = !1, this.options.persister ? this.options.persister(De, Oe, this) : De(Oe) }, Ce = (() => { const De = { fetchOptions: t, options: this.options, queryKey: this.queryKey, client: this.#r, state: this.state, fetchFn: _e }; return Ee(De), De })(); this.options.behavior?.onFetch(Ce, this), this.#t = this.state, (this.state.fetchStatus === "idle" || this.state.fetchMeta !== Ce.fetchOptions?.meta) && this.#l({ type: "fetch", meta: Ce.fetchOptions?.meta }); const Me = De => { isCancelledError(De) && De.silent || this.#l({ type: "error", error: De }), isCancelledError(De) || (this.#n.config.onError?.(De, this), this.#n.config.onSettled?.(this.state.data, De, this)), this.scheduleGc() }; return this.#a = createRetryer({ initialPromise: t?.initialPromise, fn: Ce.fetchFn, abort: xe.abort.bind(xe), onSuccess: De => { if (De === void 0) { Me(new Error(`${this.queryHash} data is undefined`)); return } try { this.setData(De) } catch (Pe) { Me(Pe); return } this.#n.config.onSuccess?.(De, this), this.#n.config.onSettled?.(De, this.state.error, this), this.scheduleGc() }, onError: Me, onFail: (De, Pe) => { this.#l({ type: "failed", failureCount: De, error: Pe }) }, onPause: () => { this.#l({ type: "pause" }) }, onContinue: () => { this.#l({ type: "continue" }) }, retry: Ce.options.retry, retryDelay: Ce.options.retryDelay, networkMode: Ce.options.networkMode, canRun: () => !0 }), this.#a.start() } #l(e) { const t = xe => { switch (e.type) { case "failed": return { ...xe, fetchFailureCount: e.failureCount, fetchFailureReason: e.error }; case "pause": return { ...xe, fetchStatus: "paused" }; case "continue": return { ...xe, fetchStatus: "fetching" }; case "fetch": return { ...xe, ...fetchState(xe.data, this.options), fetchMeta: e.meta ?? null }; case "success": return this.#t = void 0, { ...xe, data: e.data, dataUpdateCount: xe.dataUpdateCount + 1, dataUpdatedAt: e.dataUpdatedAt ?? Date.now(), error: null, isInvalidated: !1, status: "success", ...!e.manual && { fetchStatus: "idle", fetchFailureCount: 0, fetchFailureReason: null } }; case "error": const Ee = e.error; return isCancelledError(Ee) && Ee.revert && this.#t ? { ...this.#t, fetchStatus: "idle" } : { ...xe, error: Ee, errorUpdateCount: xe.errorUpdateCount + 1, errorUpdatedAt: Date.now(), fetchFailureCount: xe.fetchFailureCount + 1, fetchFailureReason: Ee, fetchStatus: "idle", status: "error" }; case "invalidate": return { ...xe, isInvalidated: !0 }; case "setState": return { ...xe, ...e.state } } }; this.state = t(this.state), notifyManager.batch(() => { this.observers.forEach(xe => { xe.onQueryUpdate() }), this.#n.notify({ query: this, type: "updated", action: e }) }) } }; function fetchState(e, t) { return { fetchFailureCount: 0, fetchFailureReason: null, fetchStatus: canFetch(t.networkMode) ? "fetching" : "paused", ...e === void 0 && { error: null, status: "pending" } } } function getDefaultState$1(e) { const t = typeof e.initialData == "function" ? e.initialData() : e.initialData, xe = t !== void 0, Ee = xe ? typeof e.initialDataUpdatedAt == "function" ? e.initialDataUpdatedAt() : e.initialDataUpdatedAt : 0; return { data: t, dataUpdateCount: 0, dataUpdatedAt: xe ? Ee ?? Date.now() : 0, error: null, errorUpdateCount: 0, errorUpdatedAt: 0, fetchFailureCount: 0, fetchFailureReason: null, fetchMeta: null, isInvalidated: !1, status: xe ? "success" : "pending", fetchStatus: "idle" } } var QueryCache = class extends Subscribable { constructor(e = {}) { super(), this.config = e, this.#e = new Map } #e; build(e, t, xe) { const Ee = t.queryKey, _e = t.queryHash ?? hashQueryKeyByOptions(Ee, t); let Re = this.get(_e); return Re || (Re = new Query({ client: e, queryKey: Ee, queryHash: _e, options: e.defaultQueryOptions(t), state: xe, defaultOptions: e.getQueryDefaults(Ee) }), this.add(Re)), Re } add(e) { this.#e.has(e.queryHash) || (this.#e.set(e.queryHash, e), this.notify({ type: "added", query: e })) } remove(e) { const t = this.#e.get(e.queryHash); t && (e.destroy(), t === e && this.#e.delete(e.queryHash), this.notify({ type: "removed", query: e })) } clear() { notifyManager.batch(() => { this.getAll().forEach(e => { this.remove(e) }) }) } get(e) { return this.#e.get(e) } getAll() { return [...this.#e.values()] } find(e) { const t = { exact: !0, ...e }; return this.getAll().find(xe => matchQuery(t, xe)) } findAll(e = {}) { const t = this.getAll(); return Object.keys(e).length > 0 ? t.filter(xe => matchQuery(e, xe)) : t } notify(e) { notifyManager.batch(() => { this.listeners.forEach(t => { t(e) }) }) } onFocus() { notifyManager.batch(() => { this.getAll().forEach(e => { e.onFocus() }) }) } onOnline() { notifyManager.batch(() => { this.getAll().forEach(e => { e.onOnline() }) }) } }, Mutation = class extends Removable { #e; #t; #n; constructor(e) { super(), this.mutationId = e.mutationId, this.#t = e.mutationCache, this.#e = [], this.state = e.state || getDefaultState(), this.setOptions(e.options), this.scheduleGc() } setOptions(e) { this.options = e, this.updateGcTime(this.options.gcTime) } get meta() { return this.options.meta } addObserver(e) { this.#e.includes(e) || (this.#e.push(e), this.clearGcTimeout(), this.#t.notify({ type: "observerAdded", mutation: this, observer: e })) } removeObserver(e) { this.#e = this.#e.filter(t => t !== e), this.scheduleGc(), this.#t.notify({ type: "observerRemoved", mutation: this, observer: e }) } optionalRemove() { this.#e.length || (this.state.status === "pending" ? this.scheduleGc() : this.#t.remove(this)) } continue() { return this.#n?.continue() ?? this.execute(this.state.variables) } async execute(e) { const t = () => { this.#r({ type: "continue" }) }; this.#n = createRetryer({ fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")), onFail: (_e, Re) => { this.#r({ type: "failed", failureCount: _e, error: Re }) }, onPause: () => { this.#r({ type: "pause" }) }, onContinue: t, retry: this.options.retry ?? 0, retryDelay: this.options.retryDelay, networkMode: this.options.networkMode, canRun: () => this.#t.canRun(this) }); const xe = this.state.status === "pending", Ee = !this.#n.canStart(); try { if (xe) t(); else { this.#r({ type: "pending", variables: e, isPaused: Ee }), await this.#t.config.onMutate?.(e, this); const Re = await this.options.onMutate?.(e); Re !== this.state.context && this.#r({ type: "pending", context: Re, variables: e, isPaused: Ee }) } const _e = await this.#n.start(); return await this.#t.config.onSuccess?.(_e, e, this.state.context, this), await this.options.onSuccess?.(_e, e, this.state.context), await this.#t.config.onSettled?.(_e, null, this.state.variables, this.state.context, this), await this.options.onSettled?.(_e, null, e, this.state.context), this.#r({ type: "success", data: _e }), _e } catch (_e) { try { throw await this.#t.config.onError?.(_e, e, this.state.context, this), await this.options.onError?.(_e, e, this.state.context), await this.#t.config.onSettled?.(void 0, _e, this.state.variables, this.state.context, this), await this.options.onSettled?.(void 0, _e, e, this.state.context), _e } finally { this.#r({ type: "error", error: _e }) } } finally { this.#t.runNext(this) } } #r(e) { const t = xe => { switch (e.type) { case "failed": return { ...xe, failureCount: e.failureCount, failureReason: e.error }; case "pause": return { ...xe, isPaused: !0 }; case "continue": return { ...xe, isPaused: !1 }; case "pending": return { ...xe, context: e.context, data: void 0, failureCount: 0, failureReason: null, error: null, isPaused: e.isPaused, status: "pending", variables: e.variables, submittedAt: Date.now() }; case "success": return { ...xe, data: e.data, failureCount: 0, failureReason: null, error: null, status: "success", isPaused: !1 }; case "error": return { ...xe, data: void 0, error: e.error, failureCount: xe.failureCount + 1, failureReason: e.error, isPaused: !1, status: "error" } } }; this.state = t(this.state), notifyManager.batch(() => { this.#e.forEach(xe => { xe.onMutationUpdate(e) }), this.#t.notify({ mutation: this, type: "updated", action: e }) }) } }; function getDefaultState() { return { context: void 0, data: void 0, error: null, failureCount: 0, failureReason: null, isPaused: !1, status: "idle", variables: void 0, submittedAt: 0 } } var MutationCache = class extends Subscribable { constructor(e = {}) { super(), this.config = e, this.#e = new Set, this.#t = new Map, this.#n = 0 } #e; #t; #n; build(e, t, xe) { const Ee = new Mutation({ mutationCache: this, mutationId: ++this.#n, options: e.defaultMutationOptions(t), state: xe }); return this.add(Ee), Ee } add(e) { this.#e.add(e); const t = scopeFor(e); if (typeof t == "string") { const xe = this.#t.get(t); xe ? xe.push(e) : this.#t.set(t, [e]) } this.notify({ type: "added", mutation: e }) } remove(e) { if (this.#e.delete(e)) { const t = scopeFor(e); if (typeof t == "string") { const xe = this.#t.get(t); if (xe) if (xe.length > 1) { const Ee = xe.indexOf(e); Ee !== -1 && xe.splice(Ee, 1) } else xe[0] === e && this.#t.delete(t) } } this.notify({ type: "removed", mutation: e }) } canRun(e) { const t = scopeFor(e); if (typeof t == "string") { const Ee = this.#t.get(t)?.find(_e => _e.state.status === "pending"); return !Ee || Ee === e } else return !0 } runNext(e) { const t = scopeFor(e); return typeof t == "string" ? this.#t.get(t)?.find(Ee => Ee !== e && Ee.state.isPaused)?.continue() ?? Promise.resolve() : Promise.resolve() } clear() { notifyManager.batch(() => { this.#e.forEach(e => { this.notify({ type: "removed", mutation: e }) }), this.#e.clear(), this.#t.clear() }) } getAll() { return Array.from(this.#e) } find(e) { const t = { exact: !0, ...e }; return this.getAll().find(xe => matchMutation(t, xe)) } findAll(e = {}) { return this.getAll().filter(t => matchMutation(e, t)) } notify(e) { notifyManager.batch(() => { this.listeners.forEach(t => { t(e) }) }) } resumePausedMutations() { const e = this.getAll().filter(t => t.state.isPaused); return notifyManager.batch(() => Promise.all(e.map(t => t.continue().catch(noop$2)))) } }; function scopeFor(e) { return e.options.scope?.id } function infiniteQueryBehavior(e) { return { onFetch: (t, xe) => { const Ee = t.options, _e = t.fetchOptions?.meta?.fetchMore?.direction, Re = t.state.data?.pages || [], Ce = t.state.data?.pageParams || []; let Me = { pages: [], pageParams: [] }, De = 0; const Pe = async () => { let Oe = !1; const je = Fe => { Object.defineProperty(Fe, "signal", { enumerable: !0, get: () => (t.signal.aborted ? Oe = !0 : t.signal.addEventListener("abort", () => { Oe = !0 }), t.signal) }) }, Be = ensureQueryFn(t.options, t.fetchOptions), Ie = async (Fe, ze, qe) => { if (Oe) return Promise.reject(); if (ze == null && Fe.pages.length) return Promise.resolve(Fe); const Ge = (() => { const St = { client: t.client, queryKey: t.queryKey, pageParam: ze, direction: qe ? "backward" : "forward", meta: t.options.meta }; return je(St), St })(), Ze = await Be(Ge), { maxPages: sn } = t.options, Xe = qe ? addToStart : addToEnd; return { pages: Xe(Fe.pages, Ze, sn), pageParams: Xe(Fe.pageParams, ze, sn) } }; if (_e && Re.length) { const Fe = _e === "backward", ze = Fe ? getPreviousPageParam : getNextPageParam, qe = { pages: Re, pageParams: Ce }, He = ze(Ee, qe); Me = await Ie(qe, He, Fe) } else { const Fe = e ?? Re.length; do { const ze = De === 0 ? Ce[0] ?? Ee.initialPageParam : getNextPageParam(Ee, Me); if (De > 0 && ze == null) break; Me = await Ie(Me, ze), De++ } while (De < Fe) } return Me }; t.options.persister ? t.fetchFn = () => t.options.persister?.(Pe, { client: t.client, queryKey: t.queryKey, meta: t.options.meta, signal: t.signal }, xe) : t.fetchFn = Pe } } } function getNextPageParam(e, { pages: t, pageParams: xe }) { const Ee = t.length - 1; return t.length > 0 ? e.getNextPageParam(t[Ee], t, xe[Ee], xe) : void 0 } function getPreviousPageParam(e, { pages: t, pageParams: xe }) { return t.length > 0 ? e.getPreviousPageParam?.(t[0], t, xe[0], xe) : void 0 } var QueryClient = class { #e; #t; #n; #r; #a; #o; #s; #l; constructor(e = {}) { this.#e = e.queryCache || new QueryCache, this.#t = e.mutationCache || new MutationCache, this.#n = e.defaultOptions || {}, this.#r = new Map, this.#a = new Map, this.#o = 0 } mount() { this.#o++, this.#o === 1 && (this.#s = focusManager.subscribe(async e => { e && (await this.resumePausedMutations(), this.#e.onFocus()) }), this.#l = onlineManager.subscribe(async e => { e && (await this.resumePausedMutations(), this.#e.onOnline()) })) } unmount() { this.#o--, this.#o === 0 && (this.#s?.(), this.#s = void 0, this.#l?.(), this.#l = void 0) } isFetching(e) { return this.#e.findAll({ ...e, fetchStatus: "fetching" }).length } isMutating(e) { return this.#t.findAll({ ...e, status: "pending" }).length } getQueryData(e) { const t = this.defaultQueryOptions({ queryKey: e }); return this.#e.get(t.queryHash)?.state.data } ensureQueryData(e) { const t = this.defaultQueryOptions(e), xe = this.#e.build(this, t), Ee = xe.state.data; return Ee === void 0 ? this.fetchQuery(e) : (e.revalidateIfStale && xe.isStaleByTime(resolveStaleTime(t.staleTime, xe)) && this.prefetchQuery(t), Promise.resolve(Ee)) } getQueriesData(e) { return this.#e.findAll(e).map(({ queryKey: t, state: xe }) => { const Ee = xe.data; return [t, Ee] }) } setQueryData(e, t, xe) { const Ee = this.defaultQueryOptions({ queryKey: e }), Re = this.#e.get(Ee.queryHash)?.state.data, Ce = functionalUpdate(t, Re); if (Ce !== void 0) return this.#e.build(this, Ee).setData(Ce, { ...xe, manual: !0 }) } setQueriesData(e, t, xe) { return notifyManager.batch(() => this.#e.findAll(e).map(({ queryKey: Ee }) => [Ee, this.setQueryData(Ee, t, xe)])) } getQueryState(e) { const t = this.defaultQueryOptions({ queryKey: e }); return this.#e.get(t.queryHash)?.state } removeQueries(e) { const t = this.#e; notifyManager.batch(() => { t.findAll(e).forEach(xe => { t.remove(xe) }) }) } resetQueries(e, t) { const xe = this.#e; return notifyManager.batch(() => (xe.findAll(e).forEach(Ee => { Ee.reset() }), this.refetchQueries({ type: "active", ...e }, t))) } cancelQueries(e, t = {}) { const xe = { revert: !0, ...t }, Ee = notifyManager.batch(() => this.#e.findAll(e).map(_e => _e.cancel(xe))); return Promise.all(Ee).then(noop$2).catch(noop$2) } invalidateQueries(e, t = {}) { return notifyManager.batch(() => (this.#e.findAll(e).forEach(xe => { xe.invalidate() }), e?.refetchType === "none" ? Promise.resolve() : this.refetchQueries({ ...e, type: e?.refetchType ?? e?.type ?? "active" }, t))) } refetchQueries(e, t = {}) { const xe = { ...t, cancelRefetch: t.cancelRefetch ?? !0 }, Ee = notifyManager.batch(() => this.#e.findAll(e).filter(_e => !_e.isDisabled() && !_e.isStatic()).map(_e => { let Re = _e.fetch(void 0, xe); return xe.throwOnError || (Re = Re.catch(noop$2)), _e.state.fetchStatus === "paused" ? Promise.resolve() : Re })); return Promise.all(Ee).then(noop$2) } fetchQuery(e) { const t = this.defaultQueryOptions(e); t.retry === void 0 && (t.retry = !1); const xe = this.#e.build(this, t); return xe.isStaleByTime(resolveStaleTime(t.staleTime, xe)) ? xe.fetch(t) : Promise.resolve(xe.state.data) } prefetchQuery(e) { return this.fetchQuery(e).then(noop$2).catch(noop$2) } fetchInfiniteQuery(e) { return e.behavior = infiniteQueryBehavior(e.pages), this.fetchQuery(e) } prefetchInfiniteQuery(e) { return this.fetchInfiniteQuery(e).then(noop$2).catch(noop$2) } ensureInfiniteQueryData(e) { return e.behavior = infiniteQueryBehavior(e.pages), this.ensureQueryData(e) } resumePausedMutations() { return onlineManager.isOnline() ? this.#t.resumePausedMutations() : Promise.resolve() } getQueryCache() { return this.#e } getMutationCache() { return this.#t } getDefaultOptions() { return this.#n } setDefaultOptions(e) { this.#n = e } setQueryDefaults(e, t) { this.#r.set(hashKey(e), { queryKey: e, defaultOptions: t }) } getQueryDefaults(e) { const t = [...this.#r.values()], xe = {}; return t.forEach(Ee => { partialMatchKey(e, Ee.queryKey) && Object.assign(xe, Ee.defaultOptions) }), xe } setMutationDefaults(e, t) { this.#a.set(hashKey(e), { mutationKey: e, defaultOptions: t }) } getMutationDefaults(e) { const t = [...this.#a.values()], xe = {}; return t.forEach(Ee => { partialMatchKey(e, Ee.mutationKey) && Object.assign(xe, Ee.defaultOptions) }), xe } defaultQueryOptions(e) { if (e._defaulted) return e; const t = { ...this.#n.queries, ...this.getQueryDefaults(e.queryKey), ...e, _defaulted: !0 }; return t.queryHash || (t.queryHash = hashQueryKeyByOptions(t.queryKey, t)), t.refetchOnReconnect === void 0 && (t.refetchOnReconnect = t.networkMode !== "always"), t.throwOnError === void 0 && (t.throwOnError = !!t.suspense), !t.networkMode && t.persister && (t.networkMode = "offlineFirst"), t.queryFn === skipToken && (t.enabled = !1), t } defaultMutationOptions(e) { return e?._defaulted ? e : { ...this.#n.mutations, ...e?.mutationKey && this.getMutationDefaults(e.mutationKey), ...e, _defaulted: !0 } } clear() { this.#e.clear(), this.#t.clear() } }, QueryObserver = class extends Subscribable { constructor(e, t) { super(), this.options = t, this.#e = e, this.#l = null, this.#s = pendingThenable(), this.options.experimental_prefetchInRender || this.#s.reject(new Error("experimental_prefetchInRender feature flag is not enabled")), this.bindMethods(), this.setOptions(t) } #e; #t = void 0; #n = void 0; #r = void 0; #a; #o; #s; #l; #c; #i; #p; #u; #h; #f; #v = new Set; bindMethods() { this.refetch = this.refetch.bind(this) } onSubscribe() { this.listeners.size === 1 && (this.#t.addObserver(this), shouldFetchOnMount(this.#t, this.options) ? this.#m() : this.updateResult(), this.#y()) } onUnsubscribe() { this.hasListeners() || this.destroy() } shouldFetchOnReconnect() { return shouldFetchOn(this.#t, this.options, this.options.refetchOnReconnect) } shouldFetchOnWindowFocus() { return shouldFetchOn(this.#t, this.options, this.options.refetchOnWindowFocus) } destroy() { this.listeners = new Set, this.#x(), this.#S(), this.#t.removeObserver(this) } setOptions(e) { const t = this.options, xe = this.#t; if (this.options = this.#e.defaultQueryOptions(e), this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof resolveEnabled(this.options.enabled, this.#t) != "boolean") throw new Error("Expected enabled to be a boolean or a callback that returns a boolean"); this.#_(), this.#t.setOptions(this.options), t._defaulted && !shallowEqualObjects(this.options, t) && this.#e.getQueryCache().notify({ type: "observerOptionsUpdated", query: this.#t, observer: this }); const Ee = this.hasListeners(); Ee && shouldFetchOptionally(this.#t, xe, this.options, t) && this.#m(), this.updateResult(), Ee && (this.#t !== xe || resolveEnabled(this.options.enabled, this.#t) !== resolveEnabled(t.enabled, this.#t) || resolveStaleTime(this.options.staleTime, this.#t) !== resolveStaleTime(t.staleTime, this.#t)) && this.#g(); const _e = this.#d(); Ee && (this.#t !== xe || resolveEnabled(this.options.enabled, this.#t) !== resolveEnabled(t.enabled, this.#t) || _e !== this.#f) && this.#b(_e) } getOptimisticResult(e) { const t = this.#e.getQueryCache().build(this.#e, e), xe = this.createResult(t, e); return shouldAssignObserverCurrentProperties(this, xe) && (this.#r = xe, this.#o = this.options, this.#a = this.#t.state), xe } getCurrentResult() { return this.#r } trackResult(e, t) { return new Proxy(e, { get: (xe, Ee) => (this.trackProp(Ee), t?.(Ee), Reflect.get(xe, Ee)) }) } trackProp(e) { this.#v.add(e) } getCurrentQuery() { return this.#t } refetch({ ...e } = {}) { return this.fetch({ ...e }) } fetchOptimistic(e) { const t = this.#e.defaultQueryOptions(e), xe = this.#e.getQueryCache().build(this.#e, t); return xe.fetch().then(() => this.createResult(xe, t)) } fetch(e) { return this.#m({ ...e, cancelRefetch: e.cancelRefetch ?? !0 }).then(() => (this.updateResult(), this.#r)) } #m(e) { this.#_(); let t = this.#t.fetch(this.options, e); return e?.throwOnError || (t = t.catch(noop$2)), t } #g() { this.#x(); const e = resolveStaleTime(this.options.staleTime, this.#t); if (isServer || this.#r.isStale || !isValidTimeout(e)) return; const xe = timeUntilStale(this.#r.dataUpdatedAt, e) + 1; this.#u = setTimeout(() => { this.#r.isStale || this.updateResult() }, xe) } #d() { return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(this.#t) : this.options.refetchInterval) ?? !1 } #b(e) { this.#S(), this.#f = e, !(isServer || resolveEnabled(this.options.enabled, this.#t) === !1 || !isValidTimeout(this.#f) || this.#f === 0) && (this.#h = setInterval(() => { (this.options.refetchIntervalInBackground || focusManager.isFocused()) && this.#m() }, this.#f)) } #y() { this.#g(), this.#b(this.#d()) } #x() { this.#u && (clearTimeout(this.#u), this.#u = void 0) } #S() { this.#h && (clearInterval(this.#h), this.#h = void 0) } createResult(e, t) { const xe = this.#t, Ee = this.options, _e = this.#r, Re = this.#a, Ce = this.#o, De = e !== xe ? e.state : this.#n, { state: Pe } = e; let Oe = { ...Pe }, je = !1, Be; if (t._optimisticResults) { const on = this.hasListeners(), bn = !on && shouldFetchOnMount(e, t), Tn = on && shouldFetchOptionally(e, xe, t, Ee); (bn || Tn) && (Oe = { ...Oe, ...fetchState(Pe.data, e.options) }), t._optimisticResults === "isRestoring" && (Oe.fetchStatus = "idle") } let { error: Ie, errorUpdatedAt: Fe, status: ze } = Oe; Be = Oe.data; let qe = !1; if (t.placeholderData !== void 0 && Be === void 0 && ze === "pending") { let on; _e?.isPlaceholderData && t.placeholderData === Ce?.placeholderData ? (on = _e.data, qe = !0) : on = typeof t.placeholderData == "function" ? t.placeholderData(this.#p?.state.data, this.#p) : t.placeholderData, on !== void 0 && (ze = "success", Be = replaceData(_e?.data, on, t), je = !0) } if (t.select && Be !== void 0 && !qe) if (_e && Be === Re?.data && t.select === this.#c) Be = this.#i; else try { this.#c = t.select, Be = t.select(Be), Be = replaceData(_e?.data, Be, t), this.#i = Be, this.#l = null } catch (on) { this.#l = on } this.#l && (Ie = this.#l, Be = this.#i, Fe = Date.now(), ze = "error"); const He = Oe.fetchStatus === "fetching", Ge = ze === "pending", Ze = ze === "error", sn = Ge && He, Xe = Be !== void 0, un = { status: ze, fetchStatus: Oe.fetchStatus, isPending: Ge, isSuccess: ze === "success", isError: Ze, isInitialLoading: sn, isLoading: sn, data: Be, dataUpdatedAt: Oe.dataUpdatedAt, error: Ie, errorUpdatedAt: Fe, failureCount: Oe.fetchFailureCount, failureReason: Oe.fetchFailureReason, errorUpdateCount: Oe.errorUpdateCount, isFetched: Oe.dataUpdateCount > 0 || Oe.errorUpdateCount > 0, isFetchedAfterMount: Oe.dataUpdateCount > De.dataUpdateCount || Oe.errorUpdateCount > De.errorUpdateCount, isFetching: He, isRefetching: He && !Ge, isLoadingError: Ze && !Xe, isPaused: Oe.fetchStatus === "paused", isPlaceholderData: je, isRefetchError: Ze && Xe, isStale: isStale(e, t), refetch: this.refetch, promise: this.#s, isEnabled: resolveEnabled(t.enabled, e) !== !1 }; if (this.options.experimental_prefetchInRender) { const on = fn => { un.status === "error" ? fn.reject(un.error) : un.data !== void 0 && fn.resolve(un.data) }, bn = () => { const fn = this.#s = un.promise = pendingThenable(); on(fn) }, Tn = this.#s; switch (Tn.status) { case "pending": e.queryHash === xe.queryHash && on(Tn); break; case "fulfilled": (un.status === "error" || un.data !== Tn.value) && bn(); break; case "rejected": (un.status !== "error" || un.error !== Tn.reason) && bn(); break } } return un } updateResult() { const e = this.#r, t = this.createResult(this.#t, this.options); if (this.#a = this.#t.state, this.#o = this.options, this.#a.data !== void 0 && (this.#p = this.#t), shallowEqualObjects(t, e)) return; this.#r = t; const xe = () => { if (!e) return !0; const { notifyOnChangeProps: Ee } = this.options, _e = typeof Ee == "function" ? Ee() : Ee; if (_e === "all" || !_e && !this.#v.size) return !0; const Re = new Set(_e ?? this.#v); return this.options.throwOnError && Re.add("error"), Object.keys(this.#r).some(Ce => { const Me = Ce; return this.#r[Me] !== e[Me] && Re.has(Me) }) }; this.#N({ listeners: xe() }) } #_() { const e = this.#e.getQueryCache().build(this.#e, this.options); if (e === this.#t) return; const t = this.#t; this.#t = e, this.#n = e.state, this.hasListeners() && (t?.removeObserver(this), e.addObserver(this)) } onQueryUpdate() { this.updateResult(), this.hasListeners() && this.#y() } #N(e) { notifyManager.batch(() => { e.listeners && this.listeners.forEach(t => { t(this.#r) }), this.#e.getQueryCache().notify({ query: this.#t, type: "observerResultsUpdated" }) }) } }; function shouldLoadOnMount(e, t) { return resolveEnabled(t.enabled, e) !== !1 && e.state.data === void 0 && !(e.state.status === "error" && t.retryOnMount === !1) } function shouldFetchOnMount(e, t) { return shouldLoadOnMount(e, t) || e.state.data !== void 0 && shouldFetchOn(e, t, t.refetchOnMount) } function shouldFetchOn(e, t, xe) { if (resolveEnabled(t.enabled, e) !== !1 && resolveStaleTime(t.staleTime, e) !== "static") { const Ee = typeof xe == "function" ? xe(e) : xe; return Ee === "always" || Ee !== !1 && isStale(e, t) } return !1 } function shouldFetchOptionally(e, t, xe, Ee) { return (e !== t || resolveEnabled(Ee.enabled, e) === !1) && (!xe.suspense || e.state.status !== "error") && isStale(e, xe) } function isStale(e, t) { return resolveEnabled(t.enabled, e) !== !1 && e.isStaleByTime(resolveStaleTime(t.staleTime, e)) } function shouldAssignObserverCurrentProperties(e, t) { return !shallowEqualObjects(e.getCurrentResult(), t) } var MutationObserver$1 = class extends Subscribable { #e; #t = void 0; #n; #r; constructor(t, xe) { super(), this.#e = t, this.setOptions(xe), this.bindMethods(), this.#a() } bindMethods() { this.mutate = this.mutate.bind(this), this.reset = this.reset.bind(this) } setOptions(t) { const xe = this.options; this.options = this.#e.defaultMutationOptions(t), shallowEqualObjects(this.options, xe) || this.#e.getMutationCache().notify({ type: "observerOptionsUpdated", mutation: this.#n, observer: this }), xe?.mutationKey && this.options.mutationKey && hashKey(xe.mutationKey) !== hashKey(this.options.mutationKey) ? this.reset() : this.#n?.state.status === "pending" && this.#n.setOptions(this.options) } onUnsubscribe() { this.hasListeners() || this.#n?.removeObserver(this) } onMutationUpdate(t) { this.#a(), this.#o(t) } getCurrentResult() { return this.#t } reset() { this.#n?.removeObserver(this), this.#n = void 0, this.#a(), this.#o() } mutate(t, xe) { return this.#r = xe, this.#n?.removeObserver(this), this.#n = this.#e.getMutationCache().build(this.#e, this.options), this.#n.addObserver(this), this.#n.execute(t) } #a() { const t = this.#n?.state ?? getDefaultState(); this.#t = { ...t, isPending: t.status === "pending", isSuccess: t.status === "success", isError: t.status === "error", isIdle: t.status === "idle", mutate: this.mutate, reset: this.reset } } #o(t) { notifyManager.batch(() => { if (this.#r && this.hasListeners()) { const xe = this.#t.variables, Ee = this.#t.context; t?.type === "success" ? (this.#r.onSuccess?.(t.data, xe, Ee), this.#r.onSettled?.(t.data, null, xe, Ee)) : t?.type === "error" && (this.#r.onError?.(t.error, xe, Ee), this.#r.onSettled?.(void 0, t.error, xe, Ee)) } this.listeners.forEach(xe => { xe(this.#t) }) }) } }, QueryClientContext = reactExports.createContext(void 0), useQueryClient = e => { const t = reactExports.useContext(QueryClientContext); if (!t) throw new Error("No QueryClient set, use QueryClientProvider to set one"); return t }, QueryClientProvider = ({ client: e, children: t }) => (reactExports.useEffect(() => (e.mount(), () => { e.unmount() }), [e]), jsxRuntimeExports.jsx(QueryClientContext.Provider, { value: e, children: t })), IsRestoringContext = reactExports.createContext(!1), useIsRestoring = () => reactExports.useContext(IsRestoringContext); IsRestoringContext.Provider; function createValue() { let e = !1; return { clearReset: () => { e = !1 }, reset: () => { e = !0 }, isReset: () => e } } var QueryErrorResetBoundaryContext = reactExports.createContext(createValue()), useQueryErrorResetBoundary = () => reactExports.useContext(QueryErrorResetBoundaryContext), ensurePreventErrorBoundaryRetry = (e, t) => { (e.suspense || e.throwOnError || e.experimental_prefetchInRender) && (t.isReset() || (e.retryOnMount = !1)) }, useClearResetErrorBoundary = e => { reactExports.useEffect(() => { e.clearReset() }, [e]) }, getHasError = ({ result: e, errorResetBoundary: t, throwOnError: xe, query: Ee, suspense: _e }) => e.isError && !t.isReset() && !e.isFetching && Ee && (_e && e.data === void 0 || shouldThrowError(xe, [e.error, Ee])), ensureSuspenseTimers = e => { if (e.suspense) { const t = Ee => Ee === "static" ? Ee : Math.max(Ee ?? 1e3, 1e3), xe = e.staleTime; e.staleTime = typeof xe == "function" ? (...Ee) => t(xe(...Ee)) : t(xe), typeof e.gcTime == "number" && (e.gcTime = Math.max(e.gcTime, 1e3)) } }, willFetch = (e, t) => e.isLoading && e.isFetching && !t, shouldSuspend = (e, t) => e?.suspense && t.isPending, fetchOptimistic = (e, t, xe) => t.fetchOptimistic(e).catch(() => { xe.clearReset() }); function useBaseQuery(e, t, xe) { const Ee = useIsRestoring(), _e = useQueryErrorResetBoundary(), Re = useQueryClient(), Ce = Re.defaultQueryOptions(e); Re.getDefaultOptions().queries?._experimental_beforeQuery?.(Ce), Ce._optimisticResults = Ee ? "isRestoring" : "optimistic", ensureSuspenseTimers(Ce), ensurePreventErrorBoundaryRetry(Ce, _e), useClearResetErrorBoundary(_e); const Me = !Re.getQueryCache().get(Ce.queryHash), [De] = reactExports.useState(() => new t(Re, Ce)), Pe = De.getOptimisticResult(Ce), Oe = !Ee && e.subscribed !== !1; if (reactExports.useSyncExternalStore(reactExports.useCallback(je => { const Be = Oe ? De.subscribe(notifyManager.batchCalls(je)) : noop$2; return De.updateResult(), Be }, [De, Oe]), () => De.getCurrentResult(), () => De.getCurrentResult()), reactExports.useEffect(() => { De.setOptions(Ce) }, [Ce, De]), shouldSuspend(Ce, Pe)) throw fetchOptimistic(Ce, De, _e); if (getHasError({ result: Pe, errorResetBoundary: _e, throwOnError: Ce.throwOnError, query: Re.getQueryCache().get(Ce.queryHash), suspense: Ce.suspense })) throw Pe.error; return Re.getDefaultOptions().queries?._experimental_afterQuery?.(Ce, Pe), Ce.experimental_prefetchInRender && !isServer && willFetch(Pe, Ee) && (Me ? fetchOptimistic(Ce, De, _e) : Re.getQueryCache().get(Ce.queryHash)?.promise)?.catch(noop$2).finally(() => { De.updateResult() }), Ce.notifyOnChangeProps ? Pe : De.trackResult(Pe) } function useQuery(e, t) { return useBaseQuery(e, QueryObserver) } function useMutation(e, t) { const xe = useQueryClient(), [Ee] = reactExports.useState(() => new MutationObserver$1(xe, e)); reactExports.useEffect(() => { Ee.setOptions(e) }, [Ee, e]); const _e = reactExports.useSyncExternalStore(reactExports.useCallback(Ce => Ee.subscribe(notifyManager.batchCalls(Ce)), [Ee]), () => Ee.getCurrentResult(), () => Ee.getCurrentResult()), Re = reactExports.useCallback((Ce, Me) => { Ee.mutate(Ce, Me).catch(noop$2) }, [Ee]); if (_e.error && shouldThrowError(Ee.options.throwOnError, [_e.error])) throw _e.error; return { ..._e, mutate: Re, mutateAsync: _e.mutate } } function bind(e, t) { return function () { return e.apply(t, arguments) } } const { toString } = Object.prototype, { getPrototypeOf } = Object, { iterator, toStringTag } = Symbol, kindOf = (e => t => { const xe = toString.call(t); return e[xe] || (e[xe] = xe.slice(8, -1).toLowerCase()) })(Object.create(null)), kindOfTest = e => (e = e.toLowerCase(), t => kindOf(t) === e), typeOfTest = e => t => typeof t === e, { isArray } = Array, isUndefined$1 = typeOfTest("undefined"); function isBuffer(e) { return e !== null && !isUndefined$1(e) && e.constructor !== null && !isUndefined$1(e.constructor) && isFunction$3(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const isArrayBuffer$1 = kindOfTest("ArrayBuffer"); function isArrayBufferView(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && isArrayBuffer$1(e.buffer), t } const isString$1 = typeOfTest("string"), isFunction$3 = typeOfTest("function"), isNumber$2 = typeOfTest("number"), isObject$1 = e => e !== null && typeof e == "object", isBoolean = e => e === !0 || e === !1, isPlainObject$1 = e => { if (kindOf(e) !== "object") return !1; const t = getPrototypeOf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(toStringTag in e) && !(iterator in e) }, isEmptyObject = e => { if (!isObject$1(e) || isBuffer(e)) return !1; try { return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype } catch { return !1 } }, isDate = kindOfTest("Date"), isFile$1 = kindOfTest("File"), isBlob$1 = kindOfTest("Blob"), isFileList = kindOfTest("FileList"), isStream = e => isObject$1(e) && isFunction$3(e.pipe), isFormData = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || isFunction$3(e.append) && ((t = kindOf(e)) === "formdata" || t === "object" && isFunction$3(e.toString) && e.toString() === "[object FormData]")) }, isURLSearchParams = kindOfTest("URLSearchParams"), [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest), trim = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function forEach$1(e, t, { allOwnKeys: xe = !1 } = {}) { if (e === null || typeof e > "u") return; let Ee, _e; if (typeof e != "object" && (e = [e]), isArray(e)) for (Ee = 0, _e = e.length; Ee < _e; Ee++)t.call(null, e[Ee], Ee, e); else { if (isBuffer(e)) return; const Re = xe ? Object.getOwnPropertyNames(e) : Object.keys(e), Ce = Re.length; let Me; for (Ee = 0; Ee < Ce; Ee++)Me = Re[Ee], t.call(null, e[Me], Me, e) } } function findKey(e, t) { if (isBuffer(e)) return null; t = t.toLowerCase(); const xe = Object.keys(e); let Ee = xe.length, _e; for (; Ee-- > 0;)if (_e = xe[Ee], t === _e.toLowerCase()) return _e; return null } const _global = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, isContextDefined = e => !isUndefined$1(e) && e !== _global; function merge() { const { caseless: e } = isContextDefined(this) && this || {}, t = {}, xe = (Ee, _e) => { const Re = e && findKey(t, _e) || _e; isPlainObject$1(t[Re]) && isPlainObject$1(Ee) ? t[Re] = merge(t[Re], Ee) : isPlainObject$1(Ee) ? t[Re] = merge({}, Ee) : isArray(Ee) ? t[Re] = Ee.slice() : t[Re] = Ee }; for (let Ee = 0, _e = arguments.length; Ee < _e; Ee++)arguments[Ee] && forEach$1(arguments[Ee], xe); return t } const extend = (e, t, xe, { allOwnKeys: Ee } = {}) => (forEach$1(t, (_e, Re) => { xe && isFunction$3(_e) ? e[Re] = bind(_e, xe) : e[Re] = _e }, { allOwnKeys: Ee }), e), stripBOM = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), inherits = (e, t, xe, Ee) => { e.prototype = Object.create(t.prototype, Ee), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), xe && Object.assign(e.prototype, xe) }, toFlatObject = (e, t, xe, Ee) => { let _e, Re, Ce; const Me = {}; if (t = t || {}, e == null) return t; do { for (_e = Object.getOwnPropertyNames(e), Re = _e.length; Re-- > 0;)Ce = _e[Re], (!Ee || Ee(Ce, e, t)) && !Me[Ce] && (t[Ce] = e[Ce], Me[Ce] = !0); e = xe !== !1 && getPrototypeOf(e) } while (e && (!xe || xe(e, t)) && e !== Object.prototype); return t }, endsWith = (e, t, xe) => { e = String(e), (xe === void 0 || xe > e.length) && (xe = e.length), xe -= t.length; const Ee = e.indexOf(t, xe); return Ee !== -1 && Ee === xe }, toArray$1 = e => { if (!e) return null; if (isArray(e)) return e; let t = e.length; if (!isNumber$2(t)) return null; const xe = new Array(t); for (; t-- > 0;)xe[t] = e[t]; return xe }, isTypedArray$1 = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && getPrototypeOf(Uint8Array)), forEachEntry = (e, t) => { const Ee = (e && e[iterator]).call(e); let _e; for (; (_e = Ee.next()) && !_e.done;) { const Re = _e.value; t.call(e, Re[0], Re[1]) } }, matchAll = (e, t) => { let xe; const Ee = []; for (; (xe = e.exec(t)) !== null;)Ee.push(xe); return Ee }, isHTMLForm = kindOfTest("HTMLFormElement"), toCamelCase$1 = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (xe, Ee, _e) { return Ee.toUpperCase() + _e }), hasOwnProperty$1 = (({ hasOwnProperty: e }) => (t, xe) => e.call(t, xe))(Object.prototype), isRegExp = kindOfTest("RegExp"), reduceDescriptors = (e, t) => { const xe = Object.getOwnPropertyDescriptors(e), Ee = {}; forEach$1(xe, (_e, Re) => { let Ce; (Ce = t(_e, Re, e)) !== !1 && (Ee[Re] = Ce || _e) }), Object.defineProperties(e, Ee) }, freezeMethods = e => { reduceDescriptors(e, (t, xe) => { if (isFunction$3(e) && ["arguments", "caller", "callee"].indexOf(xe) !== -1) return !1; const Ee = e[xe]; if (isFunction$3(Ee)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + xe + "'") }) } }) }, toObjectSet = (e, t) => { const xe = {}, Ee = _e => { _e.forEach(Re => { xe[Re] = !0 }) }; return isArray(e) ? Ee(e) : Ee(String(e).split(t)), xe }, noop$1 = () => { }, toFiniteNumber = (e, t) => e != null && Number.isFinite(e = +e) ? e : t; function isSpecCompliantForm(e) { return !!(e && isFunction$3(e.append) && e[toStringTag] === "FormData" && e[iterator]) } const toJSONObject = e => { const t = new Array(10), xe = (Ee, _e) => { if (isObject$1(Ee)) { if (t.indexOf(Ee) >= 0) return; if (isBuffer(Ee)) return Ee; if (!("toJSON" in Ee)) { t[_e] = Ee; const Re = isArray(Ee) ? [] : {}; return forEach$1(Ee, (Ce, Me) => { const De = xe(Ce, _e + 1); !isUndefined$1(De) && (Re[Me] = De) }), t[_e] = void 0, Re } } return Ee }; return xe(e, 0) }, isAsyncFn = kindOfTest("AsyncFunction"), isThenable = e => e && (isObject$1(e) || isFunction$3(e)) && isFunction$3(e.then) && isFunction$3(e.catch), _setImmediate = ((e, t) => e ? setImmediate : t ? ((xe, Ee) => (_global.addEventListener("message", ({ source: _e, data: Re }) => { _e === _global && Re === xe && Ee.length && Ee.shift()() }, !1), _e => { Ee.push(_e), _global.postMessage(xe, "*") }))(`axios@${Math.random()}`, []) : xe => setTimeout(xe))(typeof setImmediate == "function", isFunction$3(_global.postMessage)), asap = typeof queueMicrotask < "u" ? queueMicrotask.bind(_global) : typeof process < "u" && process.nextTick || _setImmediate, isIterable = e => e != null && isFunction$3(e[iterator]), utils$1 = { isArray, isArrayBuffer: isArrayBuffer$1, isBuffer, isFormData, isArrayBufferView, isString: isString$1, isNumber: isNumber$2, isBoolean, isObject: isObject$1, isPlainObject: isPlainObject$1, isEmptyObject, isReadableStream, isRequest, isResponse, isHeaders, isUndefined: isUndefined$1, isDate, isFile: isFile$1, isBlob: isBlob$1, isRegExp, isFunction: isFunction$3, isStream, isURLSearchParams, isTypedArray: isTypedArray$1, isFileList, forEach: forEach$1, merge, extend, trim, stripBOM, inherits, toFlatObject, kindOf, kindOfTest, endsWith, toArray: toArray$1, forEachEntry, matchAll, isHTMLForm, hasOwnProperty: hasOwnProperty$1, hasOwnProp: hasOwnProperty$1, reduceDescriptors, freezeMethods, toObjectSet, toCamelCase: toCamelCase$1, noop: noop$1, toFiniteNumber, findKey, global: _global, isContextDefined, isSpecCompliantForm, toJSONObject, isAsyncFn, isThenable, setImmediate: _setImmediate, asap, isIterable }; function AxiosError$1(e, t, xe, Ee, _e) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), xe && (this.config = xe), Ee && (this.request = Ee), _e && (this.response = _e, this.status = _e.status ? _e.status : null) } utils$1.inherits(AxiosError$1, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: utils$1.toJSONObject(this.config), code: this.code, status: this.status } } }); const prototype$1 = AxiosError$1.prototype, descriptors = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { descriptors[e] = { value: e } }); Object.defineProperties(AxiosError$1, descriptors); Object.defineProperty(prototype$1, "isAxiosError", { value: !0 }); AxiosError$1.from = (e, t, xe, Ee, _e, Re) => { const Ce = Object.create(prototype$1); return utils$1.toFlatObject(e, Ce, function (De) { return De !== Error.prototype }, Me => Me !== "isAxiosError"), AxiosError$1.call(Ce, e.message, t, xe, Ee, _e), Ce.cause = e, Ce.name = e.name, Re && Object.assign(Ce, Re), Ce }; const httpAdapter = null; function isVisitable(e) { return utils$1.isPlainObject(e) || utils$1.isArray(e) } function removeBrackets(e) { return utils$1.endsWith(e, "[]") ? e.slice(0, -2) : e } function renderKey(e, t, xe) { return e ? e.concat(t).map(function (_e, Re) { return _e = removeBrackets(_e), !xe && Re ? "[" + _e + "]" : _e }).join(xe ? "." : "") : t } function isFlatArray(e) { return utils$1.isArray(e) && !e.some(isVisitable) } const predicates = utils$1.toFlatObject(utils$1, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function toFormData$1(e, t, xe) { if (!utils$1.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, xe = utils$1.toFlatObject(xe, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (ze, qe) { return !utils$1.isUndefined(qe[ze]) }); const Ee = xe.metaTokens, _e = xe.visitor || Oe, Re = xe.dots, Ce = xe.indexes, De = (xe.Blob || typeof Blob < "u" && Blob) && utils$1.isSpecCompliantForm(t); if (!utils$1.isFunction(_e)) throw new TypeError("visitor must be a function"); function Pe(Fe) { if (Fe === null) return ""; if (utils$1.isDate(Fe)) return Fe.toISOString(); if (utils$1.isBoolean(Fe)) return Fe.toString(); if (!De && utils$1.isBlob(Fe)) throw new AxiosError$1("Blob is not supported. Use a Buffer instead."); return utils$1.isArrayBuffer(Fe) || utils$1.isTypedArray(Fe) ? De && typeof Blob == "function" ? new Blob([Fe]) : Buffer.from(Fe) : Fe } function Oe(Fe, ze, qe) { let He = Fe; if (Fe && !qe && typeof Fe == "object") { if (utils$1.endsWith(ze, "{}")) ze = Ee ? ze : ze.slice(0, -2), Fe = JSON.stringify(Fe); else if (utils$1.isArray(Fe) && isFlatArray(Fe) || (utils$1.isFileList(Fe) || utils$1.endsWith(ze, "[]")) && (He = utils$1.toArray(Fe))) return ze = removeBrackets(ze), He.forEach(function (Ze, sn) { !(utils$1.isUndefined(Ze) || Ze === null) && t.append(Ce === !0 ? renderKey([ze], sn, Re) : Ce === null ? ze : ze + "[]", Pe(Ze)) }), !1 } return isVisitable(Fe) ? !0 : (t.append(renderKey(qe, ze, Re), Pe(Fe)), !1) } const je = [], Be = Object.assign(predicates, { defaultVisitor: Oe, convertValue: Pe, isVisitable }); function Ie(Fe, ze) { if (!utils$1.isUndefined(Fe)) { if (je.indexOf(Fe) !== -1) throw Error("Circular reference detected in " + ze.join(".")); je.push(Fe), utils$1.forEach(Fe, function (He, Ge) { (!(utils$1.isUndefined(He) || He === null) && _e.call(t, He, utils$1.isString(Ge) ? Ge.trim() : Ge, ze, Be)) === !0 && Ie(He, ze ? ze.concat(Ge) : [Ge]) }), je.pop() } } if (!utils$1.isObject(e)) throw new TypeError("data must be an object"); return Ie(e), t } function encode$1(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (Ee) { return t[Ee] }) } function AxiosURLSearchParams(e, t) { this._pairs = [], e && toFormData$1(e, this, t) } const prototype = AxiosURLSearchParams.prototype; prototype.append = function (t, xe) { this._pairs.push([t, xe]) }; prototype.toString = function (t) { const xe = t ? function (Ee) { return t.call(this, Ee, encode$1) } : encode$1; return this._pairs.map(function (_e) { return xe(_e[0]) + "=" + xe(_e[1]) }, "").join("&") }; function encode(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function buildURL(e, t, xe) { if (!t) return e; const Ee = xe && xe.encode || encode; utils$1.isFunction(xe) && (xe = { serialize: xe }); const _e = xe && xe.serialize; let Re; if (_e ? Re = _e(t, xe) : Re = utils$1.isURLSearchParams(t) ? t.toString() : new AxiosURLSearchParams(t, xe).toString(Ee), Re) { const Ce = e.indexOf("#"); Ce !== -1 && (e = e.slice(0, Ce)), e += (e.indexOf("?") === -1 ? "?" : "&") + Re } return e } class InterceptorManager { constructor() { this.handlers = [] } use(t, xe, Ee) { return this.handlers.push({ fulfilled: t, rejected: xe, synchronous: Ee ? Ee.synchronous : !1, runWhen: Ee ? Ee.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { utils$1.forEach(this.handlers, function (Ee) { Ee !== null && t(Ee) }) } } const transitionalDefaults = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, URLSearchParams$1 = typeof URLSearchParams < "u" ? URLSearchParams : AxiosURLSearchParams, FormData$1 = typeof FormData < "u" ? FormData : null, Blob$1 = typeof Blob < "u" ? Blob : null, platform$2 = { isBrowser: !0, classes: { URLSearchParams: URLSearchParams$1, FormData: FormData$1, Blob: Blob$1 }, protocols: ["http", "https", "file", "blob", "url", "data"] }, hasBrowserEnv = typeof window < "u" && typeof document < "u", _navigator = typeof navigator == "object" && navigator || void 0, hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0), hasStandardBrowserWebWorkerEnv = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", origin = hasBrowserEnv && window.location.href || "http://192.168.0.7", utils = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv, hasStandardBrowserEnv, hasStandardBrowserWebWorkerEnv, navigator: _navigator, origin }, Symbol.toStringTag, { value: "Module" })), platform$1 = { ...utils, ...platform$2 }; function toURLEncodedForm(e, t) { return toFormData$1(e, new platform$1.classes.URLSearchParams, { visitor: function (xe, Ee, _e, Re) { return platform$1.isNode && utils$1.isBuffer(xe) ? (this.append(Ee, xe.toString("base64")), !1) : Re.defaultVisitor.apply(this, arguments) }, ...t }) } function parsePropPath(e) { return utils$1.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function arrayToObject(e) { const t = {}, xe = Object.keys(e); let Ee; const _e = xe.length; let Re; for (Ee = 0; Ee < _e; Ee++)Re = xe[Ee], t[Re] = e[Re]; return t } function formDataToJSON(e) { function t(xe, Ee, _e, Re) { let Ce = xe[Re++]; if (Ce === "__proto__") return !0; const Me = Number.isFinite(+Ce), De = Re >= xe.length; return Ce = !Ce && utils$1.isArray(_e) ? _e.length : Ce, De ? (utils$1.hasOwnProp(_e, Ce) ? _e[Ce] = [_e[Ce], Ee] : _e[Ce] = Ee, !Me) : ((!_e[Ce] || !utils$1.isObject(_e[Ce])) && (_e[Ce] = []), t(xe, Ee, _e[Ce], Re) && utils$1.isArray(_e[Ce]) && (_e[Ce] = arrayToObject(_e[Ce])), !Me) } if (utils$1.isFormData(e) && utils$1.isFunction(e.entries)) { const xe = {}; return utils$1.forEachEntry(e, (Ee, _e) => { t(parsePropPath(Ee), _e, xe, 0) }), xe } return null } function stringifySafely(e, t, xe) { if (utils$1.isString(e)) try { return (t || JSON.parse)(e), utils$1.trim(e) } catch (Ee) { if (Ee.name !== "SyntaxError") throw Ee } return (xe || JSON.stringify)(e) } const defaults = { transitional: transitionalDefaults, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, xe) { const Ee = xe.getContentType() || "", _e = Ee.indexOf("application/json") > -1, Re = utils$1.isObject(t); if (Re && utils$1.isHTMLForm(t) && (t = new FormData(t)), utils$1.isFormData(t)) return _e ? JSON.stringify(formDataToJSON(t)) : t; if (utils$1.isArrayBuffer(t) || utils$1.isBuffer(t) || utils$1.isStream(t) || utils$1.isFile(t) || utils$1.isBlob(t) || utils$1.isReadableStream(t)) return t; if (utils$1.isArrayBufferView(t)) return t.buffer; if (utils$1.isURLSearchParams(t)) return xe.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let Me; if (Re) { if (Ee.indexOf("application/x-www-form-urlencoded") > -1) return toURLEncodedForm(t, this.formSerializer).toString(); if ((Me = utils$1.isFileList(t)) || Ee.indexOf("multipart/form-data") > -1) { const De = this.env && this.env.FormData; return toFormData$1(Me ? { "files[]": t } : t, De && new De, this.formSerializer) } } return Re || _e ? (xe.setContentType("application/json", !1), stringifySafely(t)) : t }], transformResponse: [function (t) { const xe = this.transitional || defaults.transitional, Ee = xe && xe.forcedJSONParsing, _e = this.responseType === "json"; if (utils$1.isResponse(t) || utils$1.isReadableStream(t)) return t; if (t && utils$1.isString(t) && (Ee && !this.responseType || _e)) { const Ce = !(xe && xe.silentJSONParsing) && _e; try { return JSON.parse(t) } catch (Me) { if (Ce) throw Me.name === "SyntaxError" ? AxiosError$1.from(Me, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response) : Me } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: platform$1.classes.FormData, Blob: platform$1.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; utils$1.forEach(["delete", "get", "head", "post", "put", "patch"], e => { defaults.headers[e] = {} }); const ignoreDuplicateOf = utils$1.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), parseHeaders = e => {
  const t = {}; let xe, Ee, _e; return e && e.split(`
`).forEach(function (Ce) { _e = Ce.indexOf(":"), xe = Ce.substring(0, _e).trim().toLowerCase(), Ee = Ce.substring(_e + 1).trim(), !(!xe || t[xe] && ignoreDuplicateOf[xe]) && (xe === "set-cookie" ? t[xe] ? t[xe].push(Ee) : t[xe] = [Ee] : t[xe] = t[xe] ? t[xe] + ", " + Ee : Ee) }), t
}, $internals = Symbol("internals"); function normalizeHeader(e) { return e && String(e).trim().toLowerCase() } function normalizeValue(e) { return e === !1 || e == null ? e : utils$1.isArray(e) ? e.map(normalizeValue) : String(e) } function parseTokens(e) { const t = Object.create(null), xe = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let Ee; for (; Ee = xe.exec(e);)t[Ee[1]] = Ee[2]; return t } const isValidHeaderName = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function matchHeaderValue(e, t, xe, Ee, _e) { if (utils$1.isFunction(Ee)) return Ee.call(this, t, xe); if (_e && (t = xe), !!utils$1.isString(t)) { if (utils$1.isString(Ee)) return t.indexOf(Ee) !== -1; if (utils$1.isRegExp(Ee)) return Ee.test(t) } } function formatHeader(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, xe, Ee) => xe.toUpperCase() + Ee) } function buildAccessors(e, t) { const xe = utils$1.toCamelCase(" " + t);["get", "set", "has"].forEach(Ee => { Object.defineProperty(e, Ee + xe, { value: function (_e, Re, Ce) { return this[Ee].call(this, t, _e, Re, Ce) }, configurable: !0 }) }) } let AxiosHeaders$1 = class {
  constructor(t) { t && this.set(t) } set(t, xe, Ee) { const _e = this; function Re(Me, De, Pe) { const Oe = normalizeHeader(De); if (!Oe) throw new Error("header name must be a non-empty string"); const je = utils$1.findKey(_e, Oe); (!je || _e[je] === void 0 || Pe === !0 || Pe === void 0 && _e[je] !== !1) && (_e[je || De] = normalizeValue(Me)) } const Ce = (Me, De) => utils$1.forEach(Me, (Pe, Oe) => Re(Pe, Oe, De)); if (utils$1.isPlainObject(t) || t instanceof this.constructor) Ce(t, xe); else if (utils$1.isString(t) && (t = t.trim()) && !isValidHeaderName(t)) Ce(parseHeaders(t), xe); else if (utils$1.isObject(t) && utils$1.isIterable(t)) { let Me = {}, De, Pe; for (const Oe of t) { if (!utils$1.isArray(Oe)) throw TypeError("Object iterator must return a key-value pair"); Me[Pe = Oe[0]] = (De = Me[Pe]) ? utils$1.isArray(De) ? [...De, Oe[1]] : [De, Oe[1]] : Oe[1] } Ce(Me, xe) } else t != null && Re(xe, t, Ee); return this } get(t, xe) { if (t = normalizeHeader(t), t) { const Ee = utils$1.findKey(this, t); if (Ee) { const _e = this[Ee]; if (!xe) return _e; if (xe === !0) return parseTokens(_e); if (utils$1.isFunction(xe)) return xe.call(this, _e, Ee); if (utils$1.isRegExp(xe)) return xe.exec(_e); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, xe) { if (t = normalizeHeader(t), t) { const Ee = utils$1.findKey(this, t); return !!(Ee && this[Ee] !== void 0 && (!xe || matchHeaderValue(this, this[Ee], Ee, xe))) } return !1 } delete(t, xe) { const Ee = this; let _e = !1; function Re(Ce) { if (Ce = normalizeHeader(Ce), Ce) { const Me = utils$1.findKey(Ee, Ce); Me && (!xe || matchHeaderValue(Ee, Ee[Me], Me, xe)) && (delete Ee[Me], _e = !0) } } return utils$1.isArray(t) ? t.forEach(Re) : Re(t), _e } clear(t) { const xe = Object.keys(this); let Ee = xe.length, _e = !1; for (; Ee--;) { const Re = xe[Ee]; (!t || matchHeaderValue(this, this[Re], Re, t, !0)) && (delete this[Re], _e = !0) } return _e } normalize(t) { const xe = this, Ee = {}; return utils$1.forEach(this, (_e, Re) => { const Ce = utils$1.findKey(Ee, Re); if (Ce) { xe[Ce] = normalizeValue(_e), delete xe[Re]; return } const Me = t ? formatHeader(Re) : String(Re).trim(); Me !== Re && delete xe[Re], xe[Me] = normalizeValue(_e), Ee[Me] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const xe = Object.create(null); return utils$1.forEach(this, (Ee, _e) => { Ee != null && Ee !== !1 && (xe[_e] = t && utils$1.isArray(Ee) ? Ee.join(", ") : Ee) }), xe } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([t, xe]) => t + ": " + xe).join(`
`)
  } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...xe) { const Ee = new this(t); return xe.forEach(_e => Ee.set(_e)), Ee } static accessor(t) { const Ee = (this[$internals] = this[$internals] = { accessors: {} }).accessors, _e = this.prototype; function Re(Ce) { const Me = normalizeHeader(Ce); Ee[Me] || (buildAccessors(_e, Ce), Ee[Me] = !0) } return utils$1.isArray(t) ? t.forEach(Re) : Re(t), this }
}; AxiosHeaders$1.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({ value: e }, t) => { let xe = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(Ee) { this[xe] = Ee } } }); utils$1.freezeMethods(AxiosHeaders$1); function transformData(e, t) { const xe = this || defaults, Ee = t || xe, _e = AxiosHeaders$1.from(Ee.headers); let Re = Ee.data; return utils$1.forEach(e, function (Me) { Re = Me.call(xe, Re, _e.normalize(), t ? t.status : void 0) }), _e.normalize(), Re } function isCancel$1(e) { return !!(e && e.__CANCEL__) } function CanceledError$1(e, t, xe) { AxiosError$1.call(this, e ?? "canceled", AxiosError$1.ERR_CANCELED, t, xe), this.name = "CanceledError" } utils$1.inherits(CanceledError$1, AxiosError$1, { __CANCEL__: !0 }); function settle(e, t, xe) { const Ee = xe.config.validateStatus; !xe.status || !Ee || Ee(xe.status) ? e(xe) : t(new AxiosError$1("Request failed with status code " + xe.status, [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(xe.status / 100) - 4], xe.config, xe.request, xe)) } function parseProtocol(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function speedometer(e, t) { e = e || 10; const xe = new Array(e), Ee = new Array(e); let _e = 0, Re = 0, Ce; return t = t !== void 0 ? t : 1e3, function (De) { const Pe = Date.now(), Oe = Ee[Re]; Ce || (Ce = Pe), xe[_e] = De, Ee[_e] = Pe; let je = Re, Be = 0; for (; je !== _e;)Be += xe[je++], je = je % e; if (_e = (_e + 1) % e, _e === Re && (Re = (Re + 1) % e), Pe - Ce < t) return; const Ie = Oe && Pe - Oe; return Ie ? Math.round(Be * 1e3 / Ie) : void 0 } } function throttle(e, t) { let xe = 0, Ee = 1e3 / t, _e, Re; const Ce = (Pe, Oe = Date.now()) => { xe = Oe, _e = null, Re && (clearTimeout(Re), Re = null), e(...Pe) }; return [(...Pe) => { const Oe = Date.now(), je = Oe - xe; je >= Ee ? Ce(Pe, Oe) : (_e = Pe, Re || (Re = setTimeout(() => { Re = null, Ce(_e) }, Ee - je))) }, () => _e && Ce(_e)] } const progressEventReducer = (e, t, xe = 3) => { let Ee = 0; const _e = speedometer(50, 250); return throttle(Re => { const Ce = Re.loaded, Me = Re.lengthComputable ? Re.total : void 0, De = Ce - Ee, Pe = _e(De), Oe = Ce <= Me; Ee = Ce; const je = { loaded: Ce, total: Me, progress: Me ? Ce / Me : void 0, bytes: De, rate: Pe || void 0, estimated: Pe && Me && Oe ? (Me - Ce) / Pe : void 0, event: Re, lengthComputable: Me != null, [t ? "download" : "upload"]: !0 }; e(je) }, xe) }, progressEventDecorator = (e, t) => { const xe = e != null; return [Ee => t[0]({ lengthComputable: xe, total: e, loaded: Ee }), t[1]] }, asyncDecorator = e => (...t) => utils$1.asap(() => e(...t)), isURLSameOrigin = platform$1.hasStandardBrowserEnv ? ((e, t) => xe => (xe = new URL(xe, platform$1.origin), e.protocol === xe.protocol && e.host === xe.host && (t || e.port === xe.port)))(new URL(platform$1.origin), platform$1.navigator && /(msie|trident)/i.test(platform$1.navigator.userAgent)) : () => !0, cookies = platform$1.hasStandardBrowserEnv ? { write(e, t, xe, Ee, _e, Re) { const Ce = [e + "=" + encodeURIComponent(t)]; utils$1.isNumber(xe) && Ce.push("expires=" + new Date(xe).toGMTString()), utils$1.isString(Ee) && Ce.push("path=" + Ee), utils$1.isString(_e) && Ce.push("domain=" + _e), Re === !0 && Ce.push("secure"), document.cookie = Ce.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function isAbsoluteURL(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function combineURLs(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function buildFullPath(e, t, xe) { let Ee = !isAbsoluteURL(t); return e && (Ee || xe == !1) ? combineURLs(e, t) : t } const headersToObject = e => e instanceof AxiosHeaders$1 ? { ...e } : e; function mergeConfig$1(e, t) { t = t || {}; const xe = {}; function Ee(Pe, Oe, je, Be) { return utils$1.isPlainObject(Pe) && utils$1.isPlainObject(Oe) ? utils$1.merge.call({ caseless: Be }, Pe, Oe) : utils$1.isPlainObject(Oe) ? utils$1.merge({}, Oe) : utils$1.isArray(Oe) ? Oe.slice() : Oe } function _e(Pe, Oe, je, Be) { if (utils$1.isUndefined(Oe)) { if (!utils$1.isUndefined(Pe)) return Ee(void 0, Pe, je, Be) } else return Ee(Pe, Oe, je, Be) } function Re(Pe, Oe) { if (!utils$1.isUndefined(Oe)) return Ee(void 0, Oe) } function Ce(Pe, Oe) { if (utils$1.isUndefined(Oe)) { if (!utils$1.isUndefined(Pe)) return Ee(void 0, Pe) } else return Ee(void 0, Oe) } function Me(Pe, Oe, je) { if (je in t) return Ee(Pe, Oe); if (je in e) return Ee(void 0, Pe) } const De = { url: Re, method: Re, data: Re, baseURL: Ce, transformRequest: Ce, transformResponse: Ce, paramsSerializer: Ce, timeout: Ce, timeoutMessage: Ce, withCredentials: Ce, withXSRFToken: Ce, adapter: Ce, responseType: Ce, xsrfCookieName: Ce, xsrfHeaderName: Ce, onUploadProgress: Ce, onDownloadProgress: Ce, decompress: Ce, maxContentLength: Ce, maxBodyLength: Ce, beforeRedirect: Ce, transport: Ce, httpAgent: Ce, httpsAgent: Ce, cancelToken: Ce, socketPath: Ce, responseEncoding: Ce, validateStatus: Me, headers: (Pe, Oe, je) => _e(headersToObject(Pe), headersToObject(Oe), je, !0) }; return utils$1.forEach(Object.keys({ ...e, ...t }), function (Oe) { const je = De[Oe] || _e, Be = je(e[Oe], t[Oe], Oe); utils$1.isUndefined(Be) && je !== Me || (xe[Oe] = Be) }), xe } const resolveConfig = e => { const t = mergeConfig$1({}, e); let { data: xe, withXSRFToken: Ee, xsrfHeaderName: _e, xsrfCookieName: Re, headers: Ce, auth: Me } = t; t.headers = Ce = AxiosHeaders$1.from(Ce), t.url = buildURL(buildFullPath(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), Me && Ce.set("Authorization", "Basic " + btoa((Me.username || "") + ":" + (Me.password ? unescape(encodeURIComponent(Me.password)) : ""))); let De; if (utils$1.isFormData(xe)) { if (platform$1.hasStandardBrowserEnv || platform$1.hasStandardBrowserWebWorkerEnv) Ce.setContentType(void 0); else if ((De = Ce.getContentType()) !== !1) { const [Pe, ...Oe] = De ? De.split(";").map(je => je.trim()).filter(Boolean) : []; Ce.setContentType([Pe || "multipart/form-data", ...Oe].join("; ")) } } if (platform$1.hasStandardBrowserEnv && (Ee && utils$1.isFunction(Ee) && (Ee = Ee(t)), Ee || Ee !== !1 && isURLSameOrigin(t.url))) { const Pe = _e && Re && cookies.read(Re); Pe && Ce.set(_e, Pe) } return t }, isXHRAdapterSupported = typeof XMLHttpRequest < "u", xhrAdapter = isXHRAdapterSupported && function (e) { return new Promise(function (xe, Ee) { const _e = resolveConfig(e); let Re = _e.data; const Ce = AxiosHeaders$1.from(_e.headers).normalize(); let { responseType: Me, onUploadProgress: De, onDownloadProgress: Pe } = _e, Oe, je, Be, Ie, Fe; function ze() { Ie && Ie(), Fe && Fe(), _e.cancelToken && _e.cancelToken.unsubscribe(Oe), _e.signal && _e.signal.removeEventListener("abort", Oe) } let qe = new XMLHttpRequest; qe.open(_e.method.toUpperCase(), _e.url, !0), qe.timeout = _e.timeout; function He() { if (!qe) return; const Ze = AxiosHeaders$1.from("getAllResponseHeaders" in qe && qe.getAllResponseHeaders()), Xe = { data: !Me || Me === "text" || Me === "json" ? qe.responseText : qe.response, status: qe.status, statusText: qe.statusText, headers: Ze, config: e, request: qe }; settle(function (un) { xe(un), ze() }, function (un) { Ee(un), ze() }, Xe), qe = null } "onloadend" in qe ? qe.onloadend = He : qe.onreadystatechange = function () { !qe || qe.readyState !== 4 || qe.status === 0 && !(qe.responseURL && qe.responseURL.indexOf("file:") === 0) || setTimeout(He) }, qe.onabort = function () { qe && (Ee(new AxiosError$1("Request aborted", AxiosError$1.ECONNABORTED, e, qe)), qe = null) }, qe.onerror = function () { Ee(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, e, qe)), qe = null }, qe.ontimeout = function () { let sn = _e.timeout ? "timeout of " + _e.timeout + "ms exceeded" : "timeout exceeded"; const Xe = _e.transitional || transitionalDefaults; _e.timeoutErrorMessage && (sn = _e.timeoutErrorMessage), Ee(new AxiosError$1(sn, Xe.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED, e, qe)), qe = null }, Re === void 0 && Ce.setContentType(null), "setRequestHeader" in qe && utils$1.forEach(Ce.toJSON(), function (sn, Xe) { qe.setRequestHeader(Xe, sn) }), utils$1.isUndefined(_e.withCredentials) || (qe.withCredentials = !!_e.withCredentials), Me && Me !== "json" && (qe.responseType = _e.responseType), Pe && ([Be, Fe] = progressEventReducer(Pe, !0), qe.addEventListener("progress", Be)), De && qe.upload && ([je, Ie] = progressEventReducer(De), qe.upload.addEventListener("progress", je), qe.upload.addEventListener("loadend", Ie)), (_e.cancelToken || _e.signal) && (Oe = Ze => { qe && (Ee(!Ze || Ze.type ? new CanceledError$1(null, e, qe) : Ze), qe.abort(), qe = null) }, _e.cancelToken && _e.cancelToken.subscribe(Oe), _e.signal && (_e.signal.aborted ? Oe() : _e.signal.addEventListener("abort", Oe))); const Ge = parseProtocol(_e.url); if (Ge && platform$1.protocols.indexOf(Ge) === -1) { Ee(new AxiosError$1("Unsupported protocol " + Ge + ":", AxiosError$1.ERR_BAD_REQUEST, e)); return } qe.send(Re || null) }) }, composeSignals = (e, t) => { const { length: xe } = e = e ? e.filter(Boolean) : []; if (t || xe) { let Ee = new AbortController, _e; const Re = function (Pe) { if (!_e) { _e = !0, Me(); const Oe = Pe instanceof Error ? Pe : this.reason; Ee.abort(Oe instanceof AxiosError$1 ? Oe : new CanceledError$1(Oe instanceof Error ? Oe.message : Oe)) } }; let Ce = t && setTimeout(() => { Ce = null, Re(new AxiosError$1(`timeout ${t} of ms exceeded`, AxiosError$1.ETIMEDOUT)) }, t); const Me = () => { e && (Ce && clearTimeout(Ce), Ce = null, e.forEach(Pe => { Pe.unsubscribe ? Pe.unsubscribe(Re) : Pe.removeEventListener("abort", Re) }), e = null) }; e.forEach(Pe => Pe.addEventListener("abort", Re)); const { signal: De } = Ee; return De.unsubscribe = () => utils$1.asap(Me), De } }, streamChunk = function* (e, t) { let xe = e.byteLength; if (xe < t) { yield e; return } let Ee = 0, _e; for (; Ee < xe;)_e = Ee + t, yield e.slice(Ee, _e), Ee = _e }, readBytes = async function* (e, t) { for await (const xe of readStream(e)) yield* streamChunk(xe, t) }, readStream = async function* (e) { if (e[Symbol.asyncIterator]) { yield* e; return } const t = e.getReader(); try { for (; ;) { const { done: xe, value: Ee } = await t.read(); if (xe) break; yield Ee } } finally { await t.cancel() } }, trackStream = (e, t, xe, Ee) => { const _e = readBytes(e, t); let Re = 0, Ce, Me = De => { Ce || (Ce = !0, Ee && Ee(De)) }; return new ReadableStream({ async pull(De) { try { const { done: Pe, value: Oe } = await _e.next(); if (Pe) { Me(), De.close(); return } let je = Oe.byteLength; if (xe) { let Be = Re += je; xe(Be) } De.enqueue(new Uint8Array(Oe)) } catch (Pe) { throw Me(Pe), Pe } }, cancel(De) { return Me(De), _e.return() } }, { highWaterMark: 2 }) }, isFetchSupported = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", isReadableStreamSupported = isFetchSupported && typeof ReadableStream == "function", encodeText = isFetchSupported && (typeof TextEncoder == "function" ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer())), test = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, supportsRequestStream = isReadableStreamSupported && test(() => { let e = !1; const t = new Request(platform$1.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), DEFAULT_CHUNK_SIZE = 64 * 1024, supportsResponseStream = isReadableStreamSupported && test(() => utils$1.isReadableStream(new Response("").body)), resolvers = { stream: supportsResponseStream && (e => e.body) }; isFetchSupported && (e => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(t => { !resolvers[t] && (resolvers[t] = utils$1.isFunction(e[t]) ? xe => xe[t]() : (xe, Ee) => { throw new AxiosError$1(`Response type '${t}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, Ee) }) }) })(new Response); const getBodyLength = async e => { if (e == null) return 0; if (utils$1.isBlob(e)) return e.size; if (utils$1.isSpecCompliantForm(e)) return (await new Request(platform$1.origin, { method: "POST", body: e }).arrayBuffer()).byteLength; if (utils$1.isArrayBufferView(e) || utils$1.isArrayBuffer(e)) return e.byteLength; if (utils$1.isURLSearchParams(e) && (e = e + ""), utils$1.isString(e)) return (await encodeText(e)).byteLength }, resolveBodyLength = async (e, t) => { const xe = utils$1.toFiniteNumber(e.getContentLength()); return xe ?? getBodyLength(t) }, fetchAdapter = isFetchSupported && (async e => { let { url: t, method: xe, data: Ee, signal: _e, cancelToken: Re, timeout: Ce, onDownloadProgress: Me, onUploadProgress: De, responseType: Pe, headers: Oe, withCredentials: je = "same-origin", fetchOptions: Be } = resolveConfig(e); Pe = Pe ? (Pe + "").toLowerCase() : "text"; let Ie = composeSignals([_e, Re && Re.toAbortSignal()], Ce), Fe; const ze = Ie && Ie.unsubscribe && (() => { Ie.unsubscribe() }); let qe; try { if (De && supportsRequestStream && xe !== "get" && xe !== "head" && (qe = await resolveBodyLength(Oe, Ee)) !== 0) { let Xe = new Request(t, { method: "POST", body: Ee, duplex: "half" }), St; if (utils$1.isFormData(Ee) && (St = Xe.headers.get("content-type")) && Oe.setContentType(St), Xe.body) { const [un, on] = progressEventDecorator(qe, progressEventReducer(asyncDecorator(De))); Ee = trackStream(Xe.body, DEFAULT_CHUNK_SIZE, un, on) } } utils$1.isString(je) || (je = je ? "include" : "omit"); const He = "credentials" in Request.prototype; Fe = new Request(t, { ...Be, signal: Ie, method: xe.toUpperCase(), headers: Oe.normalize().toJSON(), body: Ee, duplex: "half", credentials: He ? je : void 0 }); let Ge = await fetch(Fe, Be); const Ze = supportsResponseStream && (Pe === "stream" || Pe === "response"); if (supportsResponseStream && (Me || Ze && ze)) { const Xe = {};["status", "statusText", "headers"].forEach(bn => { Xe[bn] = Ge[bn] }); const St = utils$1.toFiniteNumber(Ge.headers.get("content-length")), [un, on] = Me && progressEventDecorator(St, progressEventReducer(asyncDecorator(Me), !0)) || []; Ge = new Response(trackStream(Ge.body, DEFAULT_CHUNK_SIZE, un, () => { on && on(), ze && ze() }), Xe) } Pe = Pe || "text"; let sn = await resolvers[utils$1.findKey(resolvers, Pe) || "text"](Ge, e); return !Ze && ze && ze(), await new Promise((Xe, St) => { settle(Xe, St, { data: sn, headers: AxiosHeaders$1.from(Ge.headers), status: Ge.status, statusText: Ge.statusText, config: e, request: Fe }) }) } catch (He) { throw ze && ze(), He && He.name === "TypeError" && /Load failed|fetch/i.test(He.message) ? Object.assign(new AxiosError$1("Network Error", AxiosError$1.ERR_NETWORK, e, Fe), { cause: He.cause || He }) : AxiosError$1.from(He, He && He.code, e, Fe) } }), knownAdapters = { http: httpAdapter, xhr: xhrAdapter, fetch: fetchAdapter }; utils$1.forEach(knownAdapters, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const renderReason = e => `- ${e}`, isResolvedHandle = e => utils$1.isFunction(e) || e === null || e === !1, adapters = {
  getAdapter: e => {
    e = utils$1.isArray(e) ? e : [e]; const { length: t } = e; let xe, Ee; const _e = {}; for (let Re = 0; Re < t; Re++) { xe = e[Re]; let Ce; if (Ee = xe, !isResolvedHandle(xe) && (Ee = knownAdapters[(Ce = String(xe)).toLowerCase()], Ee === void 0)) throw new AxiosError$1(`Unknown adapter '${Ce}'`); if (Ee) break; _e[Ce || "#" + Re] = Ee } if (!Ee) {
      const Re = Object.entries(_e).map(([Me, De]) => `adapter ${Me} ` + (De === !1 ? "is not supported by the environment" : "is not available in the build")); let Ce = t ? Re.length > 1 ? `since :
`+ Re.map(renderReason).join(`
`) : " " + renderReason(Re[0]) : "as no adapter specified"; throw new AxiosError$1("There is no suitable adapter to dispatch the request " + Ce, "ERR_NOT_SUPPORT")
    } return Ee
  }, adapters: knownAdapters
}; function throwIfCancellationRequested(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new CanceledError$1(null, e) } function dispatchRequest(e) { return throwIfCancellationRequested(e), e.headers = AxiosHeaders$1.from(e.headers), e.data = transformData.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), adapters.getAdapter(e.adapter || defaults.adapter)(e).then(function (Ee) { return throwIfCancellationRequested(e), Ee.data = transformData.call(e, e.transformResponse, Ee), Ee.headers = AxiosHeaders$1.from(Ee.headers), Ee }, function (Ee) { return isCancel$1(Ee) || (throwIfCancellationRequested(e), Ee && Ee.response && (Ee.response.data = transformData.call(e, e.transformResponse, Ee.response), Ee.response.headers = AxiosHeaders$1.from(Ee.response.headers))), Promise.reject(Ee) }) } const VERSION$1 = "1.11.0", validators$1 = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { validators$1[e] = function (Ee) { return typeof Ee === e || "a" + (t < 1 ? "n " : " ") + e } }); const deprecatedWarnings = {}; validators$1.transitional = function (t, xe, Ee) { function _e(Re, Ce) { return "[Axios v" + VERSION$1 + "] Transitional option '" + Re + "'" + Ce + (Ee ? ". " + Ee : "") } return (Re, Ce, Me) => { if (t === !1) throw new AxiosError$1(_e(Ce, " has been removed" + (xe ? " in " + xe : "")), AxiosError$1.ERR_DEPRECATED); return xe && !deprecatedWarnings[Ce] && (deprecatedWarnings[Ce] = !0, console.warn(_e(Ce, " has been deprecated since v" + xe + " and will be removed in the near future"))), t ? t(Re, Ce, Me) : !0 } }; validators$1.spelling = function (t) { return (xe, Ee) => (console.warn(`${Ee} is likely a misspelling of ${t}`), !0) }; function assertOptions(e, t, xe) { if (typeof e != "object") throw new AxiosError$1("options must be an object", AxiosError$1.ERR_BAD_OPTION_VALUE); const Ee = Object.keys(e); let _e = Ee.length; for (; _e-- > 0;) { const Re = Ee[_e], Ce = t[Re]; if (Ce) { const Me = e[Re], De = Me === void 0 || Ce(Me, Re, e); if (De !== !0) throw new AxiosError$1("option " + Re + " must be " + De, AxiosError$1.ERR_BAD_OPTION_VALUE); continue } if (xe !== !0) throw new AxiosError$1("Unknown option " + Re, AxiosError$1.ERR_BAD_OPTION) } } const validator = { assertOptions, validators: validators$1 }, validators = validator.validators; let Axios$1 = class {
  constructor(t) { this.defaults = t || {}, this.interceptors = { request: new InterceptorManager, response: new InterceptorManager } } async request(t, xe) {
    try { return await this._request(t, xe) } catch (Ee) {
      if (Ee instanceof Error) {
        let _e = {}; Error.captureStackTrace ? Error.captureStackTrace(_e) : _e = new Error; const Re = _e.stack ? _e.stack.replace(/^.+\n/, "") : ""; try {
          Ee.stack ? Re && !String(Ee.stack).endsWith(Re.replace(/^.+\n.+\n/, "")) && (Ee.stack += `
`+ Re) : Ee.stack = Re
        } catch { }
      } throw Ee
    }
  } _request(t, xe) { typeof t == "string" ? (xe = xe || {}, xe.url = t) : xe = t || {}, xe = mergeConfig$1(this.defaults, xe); const { transitional: Ee, paramsSerializer: _e, headers: Re } = xe; Ee !== void 0 && validator.assertOptions(Ee, { silentJSONParsing: validators.transitional(validators.boolean), forcedJSONParsing: validators.transitional(validators.boolean), clarifyTimeoutError: validators.transitional(validators.boolean) }, !1), _e != null && (utils$1.isFunction(_e) ? xe.paramsSerializer = { serialize: _e } : validator.assertOptions(_e, { encode: validators.function, serialize: validators.function }, !0)), xe.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? xe.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : xe.allowAbsoluteUrls = !0), validator.assertOptions(xe, { baseUrl: validators.spelling("baseURL"), withXsrfToken: validators.spelling("withXSRFToken") }, !0), xe.method = (xe.method || this.defaults.method || "get").toLowerCase(); let Ce = Re && utils$1.merge(Re.common, Re[xe.method]); Re && utils$1.forEach(["delete", "get", "head", "post", "put", "patch", "common"], Fe => { delete Re[Fe] }), xe.headers = AxiosHeaders$1.concat(Ce, Re); const Me = []; let De = !0; this.interceptors.request.forEach(function (ze) { typeof ze.runWhen == "function" && ze.runWhen(xe) === !1 || (De = De && ze.synchronous, Me.unshift(ze.fulfilled, ze.rejected)) }); const Pe = []; this.interceptors.response.forEach(function (ze) { Pe.push(ze.fulfilled, ze.rejected) }); let Oe, je = 0, Be; if (!De) { const Fe = [dispatchRequest.bind(this), void 0]; for (Fe.unshift(...Me), Fe.push(...Pe), Be = Fe.length, Oe = Promise.resolve(xe); je < Be;)Oe = Oe.then(Fe[je++], Fe[je++]); return Oe } Be = Me.length; let Ie = xe; for (je = 0; je < Be;) { const Fe = Me[je++], ze = Me[je++]; try { Ie = Fe(Ie) } catch (qe) { ze.call(this, qe); break } } try { Oe = dispatchRequest.call(this, Ie) } catch (Fe) { return Promise.reject(Fe) } for (je = 0, Be = Pe.length; je < Be;)Oe = Oe.then(Pe[je++], Pe[je++]); return Oe } getUri(t) { t = mergeConfig$1(this.defaults, t); const xe = buildFullPath(t.baseURL, t.url, t.allowAbsoluteUrls); return buildURL(xe, t.params, t.paramsSerializer) }
}; utils$1.forEach(["delete", "get", "head", "options"], function (t) { Axios$1.prototype[t] = function (xe, Ee) { return this.request(mergeConfig$1(Ee || {}, { method: t, url: xe, data: (Ee || {}).data })) } }); utils$1.forEach(["post", "put", "patch"], function (t) { function xe(Ee) { return function (Re, Ce, Me) { return this.request(mergeConfig$1(Me || {}, { method: t, headers: Ee ? { "Content-Type": "multipart/form-data" } : {}, url: Re, data: Ce })) } } Axios$1.prototype[t] = xe(), Axios$1.prototype[t + "Form"] = xe(!0) }); let CancelToken$1 = class Om { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let xe; this.promise = new Promise(function (Re) { xe = Re }); const Ee = this; this.promise.then(_e => { if (!Ee._listeners) return; let Re = Ee._listeners.length; for (; Re-- > 0;)Ee._listeners[Re](_e); Ee._listeners = null }), this.promise.then = _e => { let Re; const Ce = new Promise(Me => { Ee.subscribe(Me), Re = Me }).then(_e); return Ce.cancel = function () { Ee.unsubscribe(Re) }, Ce }, t(function (Re, Ce, Me) { Ee.reason || (Ee.reason = new CanceledError$1(Re, Ce, Me), xe(Ee.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const xe = this._listeners.indexOf(t); xe !== -1 && this._listeners.splice(xe, 1) } toAbortSignal() { const t = new AbortController, xe = Ee => { t.abort(Ee) }; return this.subscribe(xe), t.signal.unsubscribe = () => this.unsubscribe(xe), t.signal } static source() { let t; return { token: new Om(function (_e) { t = _e }), cancel: t } } }; function spread$1(e) { return function (xe) { return e.apply(null, xe) } } function isAxiosError$1(e) { return utils$1.isObject(e) && e.isAxiosError === !0 } const HttpStatusCode$1 = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(HttpStatusCode$1).forEach(([e, t]) => { HttpStatusCode$1[t] = e }); function createInstance(e) { const t = new Axios$1(e), xe = bind(Axios$1.prototype.request, t); return utils$1.extend(xe, Axios$1.prototype, t, { allOwnKeys: !0 }), utils$1.extend(xe, t, null, { allOwnKeys: !0 }), xe.create = function (_e) { return createInstance(mergeConfig$1(e, _e)) }, xe } const axios = createInstance(defaults); axios.Axios = Axios$1; axios.CanceledError = CanceledError$1; axios.CancelToken = CancelToken$1; axios.isCancel = isCancel$1; axios.VERSION = VERSION$1; axios.toFormData = toFormData$1; axios.AxiosError = AxiosError$1; axios.Cancel = axios.CanceledError; axios.all = function (t) { return Promise.all(t) }; axios.spread = spread$1; axios.isAxiosError = isAxiosError$1; axios.mergeConfig = mergeConfig$1; axios.AxiosHeaders = AxiosHeaders$1; axios.formToJSON = e => formDataToJSON(utils$1.isHTMLForm(e) ? new FormData(e) : e); axios.getAdapter = adapters.getAdapter; axios.HttpStatusCode = HttpStatusCode$1; axios.default = axios; const { Axios, AxiosError, CanceledError, isCancel, CancelToken, VERSION, all, Cancel, isAxiosError, spread, toFormData, AxiosHeaders, HttpStatusCode, formToJSON, getAdapter, mergeConfig } = axios, base = "https://192.168.0.7:5555", axiosInstance = axios.create({ baseURL: `${base}/api/v1` }); axiosInstance.interceptors.request.use(e => (e.data instanceof FormData ? delete e.headers["Content-Type"] : e.headers["Content-Type"] = "application/json", e)); axiosInstance.interceptors.request.use(e => { const t = localStorage.getItem("token"); return t && (e.headers.Authorization = `Bearer ${t}`), e }); axiosInstance.interceptors.response.use(e => e, e => (e.response?.status === 401 && (localStorage.removeItem("token"), localStorage.removeItem("user"), window.location.href = "/login"), Promise.reject(e))); const login = e => axiosInstance.post("/auth/login", e), requestPasswordReset = e => axiosInstance.post("/auth/password-reset", e), resetPassword = (e, t) => axiosInstance.post(`/auth/password-reset/${e}`, t), registerUser = e => axiosInstance.post("/user/register", e), selfRegister = e => axiosInstance.post("/user/self-register", e), reviewSelfRegistration = e => axiosInstance.post("/user/review-registration", e), toggleUserStatus = (e, t) => axiosInstance.put(`/user/status/${e}`, t), updateUserRoles = (e, t) => axiosInstance.put(`/user/roles/${e}`, t), getUsers = () => axiosInstance.get("/user"), updateUser = (e, t) => axiosInstance.put(`/user/${e}`, t), AuthContext = reactExports.createContext(), AuthProvider = ({ children: e }) => { const t = useQueryClient(), [xe, Ee] = reactExports.useState(JSON.parse(localStorage.getItem("user")) || null), _e = useMutation({ mutationFn: login, onSuccess: ({ data: Ce }) => { localStorage.setItem("token", Ce.data.token), localStorage.setItem("user", JSON.stringify(Ce.data.user)), Ee(Ce.data.user) } }), Re = useMutation({ mutationFn: () => { localStorage.removeItem("token"), localStorage.removeItem("user"), Ee(null), t.clear(), window.location.href = "/login" } }); return jsxRuntimeExports.jsx(AuthContext.Provider, { value: { user: xe, setUser: Ee, login: _e.mutate, logout: Re.mutate, isLoading: _e.isLoading || Re.isLoading, error: _e.error || Re.error }, children: e }) }, queryClient = new QueryClient({ defaultOptions: { queries: { retry: 1, refetchOnWindowFocus: !1 } } });/**
 * react-router v7.7.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */var PopStateEventType = "popstate"; function createBrowserHistory(e = {}) { function t(Ee, _e) { let { pathname: Re, search: Ce, hash: Me } = Ee.location; return createLocation("", { pathname: Re, search: Ce, hash: Me }, _e.state && _e.state.usr || null, _e.state && _e.state.key || "default") } function xe(Ee, _e) { return typeof _e == "string" ? _e : createPath(_e) } return getUrlBasedHistory(t, xe, null, e) } function invariant$1(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function warning$1(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function createKey() { return Math.random().toString(36).substring(2, 10) } function getHistoryState(e, t) { return { usr: e.state, key: e.key, idx: t } } function createLocation(e, t, xe = null, Ee) { return { pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "", ...typeof t == "string" ? parsePath(t) : t, state: xe, key: t && t.key || Ee || createKey() } } function createPath({ pathname: e = "/", search: t = "", hash: xe = "" }) { return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), xe && xe !== "#" && (e += xe.charAt(0) === "#" ? xe : "#" + xe), e } function parsePath(e) { let t = {}; if (e) { let xe = e.indexOf("#"); xe >= 0 && (t.hash = e.substring(xe), e = e.substring(0, xe)); let Ee = e.indexOf("?"); Ee >= 0 && (t.search = e.substring(Ee), e = e.substring(0, Ee)), e && (t.pathname = e) } return t } function getUrlBasedHistory(e, t, xe, Ee = {}) { let { window: _e = document.defaultView, v5Compat: Re = !1 } = Ee, Ce = _e.history, Me = "POP", De = null, Pe = Oe(); Pe == null && (Pe = 0, Ce.replaceState({ ...Ce.state, idx: Pe }, "")); function Oe() { return (Ce.state || { idx: null }).idx } function je() { Me = "POP"; let qe = Oe(), He = qe == null ? null : qe - Pe; Pe = qe, De && De({ action: Me, location: ze.location, delta: He }) } function Be(qe, He) { Me = "PUSH"; let Ge = createLocation(ze.location, qe, He); Pe = Oe() + 1; let Ze = getHistoryState(Ge, Pe), sn = ze.createHref(Ge); try { Ce.pushState(Ze, "", sn) } catch (Xe) { if (Xe instanceof DOMException && Xe.name === "DataCloneError") throw Xe; _e.location.assign(sn) } Re && De && De({ action: Me, location: ze.location, delta: 1 }) } function Ie(qe, He) { Me = "REPLACE"; let Ge = createLocation(ze.location, qe, He); Pe = Oe(); let Ze = getHistoryState(Ge, Pe), sn = ze.createHref(Ge); Ce.replaceState(Ze, "", sn), Re && De && De({ action: Me, location: ze.location, delta: 0 }) } function Fe(qe) { return createBrowserURLImpl(qe) } let ze = { get action() { return Me }, get location() { return e(_e, Ce) }, listen(qe) { if (De) throw new Error("A history only accepts one active listener"); return _e.addEventListener(PopStateEventType, je), De = qe, () => { _e.removeEventListener(PopStateEventType, je), De = null } }, createHref(qe) { return t(_e, qe) }, createURL: Fe, encodeLocation(qe) { let He = Fe(qe); return { pathname: He.pathname, search: He.search, hash: He.hash } }, push: Be, replace: Ie, go(qe) { return Ce.go(qe) } }; return ze } function createBrowserURLImpl(e, t = !1) { let xe = "http://192.168.0.7"; typeof window < "u" && (xe = window.location.origin !== "null" ? window.location.origin : window.location.href), invariant$1(xe, "No window.location.(origin|href) available to create URL"); let Ee = typeof e == "string" ? e : createPath(e); return Ee = Ee.replace(/ $/, "%20"), !t && Ee.startsWith("//") && (Ee = xe + Ee), new URL(Ee, xe) } function matchRoutes(e, t, xe = "/") { return matchRoutesImpl(e, t, xe, !1) } function matchRoutesImpl(e, t, xe, Ee) { let _e = typeof t == "string" ? parsePath(t) : t, Re = stripBasename(_e.pathname || "/", xe); if (Re == null) return null; let Ce = flattenRoutes(e); rankRouteBranches(Ce); let Me = null; for (let De = 0; Me == null && De < Ce.length; ++De) { let Pe = decodePath(Re); Me = matchRouteBranch(Ce[De], Pe, Ee) } return Me } function flattenRoutes(e, t = [], xe = [], Ee = "") { let _e = (Re, Ce, Me) => { let De = { relativePath: Me === void 0 ? Re.path || "" : Me, caseSensitive: Re.caseSensitive === !0, childrenIndex: Ce, route: Re }; De.relativePath.startsWith("/") && (invariant$1(De.relativePath.startsWith(Ee), `Absolute route path "${De.relativePath}" nested under path "${Ee}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), De.relativePath = De.relativePath.slice(Ee.length)); let Pe = joinPaths([Ee, De.relativePath]), Oe = xe.concat(De); Re.children && Re.children.length > 0 && (invariant$1(Re.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${Pe}".`), flattenRoutes(Re.children, t, Oe, Pe)), !(Re.path == null && !Re.index) && t.push({ path: Pe, score: computeScore(Pe, Re.index), routesMeta: Oe }) }; return e.forEach((Re, Ce) => { if (Re.path === "" || !Re.path?.includes("?")) _e(Re, Ce); else for (let Me of explodeOptionalSegments(Re.path)) _e(Re, Ce, Me) }), t } function explodeOptionalSegments(e) { let t = e.split("/"); if (t.length === 0) return []; let [xe, ...Ee] = t, _e = xe.endsWith("?"), Re = xe.replace(/\?$/, ""); if (Ee.length === 0) return _e ? [Re, ""] : [Re]; let Ce = explodeOptionalSegments(Ee.join("/")), Me = []; return Me.push(...Ce.map(De => De === "" ? Re : [Re, De].join("/"))), _e && Me.push(...Ce), Me.map(De => e.startsWith("/") && De === "" ? "/" : De) } function rankRouteBranches(e) { e.sort((t, xe) => t.score !== xe.score ? xe.score - t.score : compareIndexes(t.routesMeta.map(Ee => Ee.childrenIndex), xe.routesMeta.map(Ee => Ee.childrenIndex))) } var paramRe = /^:[\w-]+$/, dynamicSegmentValue = 3, indexRouteValue = 2, emptySegmentValue = 1, staticSegmentValue = 10, splatPenalty = -2, isSplat = e => e === "*"; function computeScore(e, t) { let xe = e.split("/"), Ee = xe.length; return xe.some(isSplat) && (Ee += splatPenalty), t && (Ee += indexRouteValue), xe.filter(_e => !isSplat(_e)).reduce((_e, Re) => _e + (paramRe.test(Re) ? dynamicSegmentValue : Re === "" ? emptySegmentValue : staticSegmentValue), Ee) } function compareIndexes(e, t) { return e.length === t.length && e.slice(0, -1).every((Ee, _e) => Ee === t[_e]) ? e[e.length - 1] - t[t.length - 1] : 0 } function matchRouteBranch(e, t, xe = !1) { let { routesMeta: Ee } = e, _e = {}, Re = "/", Ce = []; for (let Me = 0; Me < Ee.length; ++Me) { let De = Ee[Me], Pe = Me === Ee.length - 1, Oe = Re === "/" ? t : t.slice(Re.length) || "/", je = matchPath({ path: De.relativePath, caseSensitive: De.caseSensitive, end: Pe }, Oe), Be = De.route; if (!je && Pe && xe && !Ee[Ee.length - 1].route.index && (je = matchPath({ path: De.relativePath, caseSensitive: De.caseSensitive, end: !1 }, Oe)), !je) return null; Object.assign(_e, je.params), Ce.push({ params: _e, pathname: joinPaths([Re, je.pathname]), pathnameBase: normalizePathname(joinPaths([Re, je.pathnameBase])), route: Be }), je.pathnameBase !== "/" && (Re = joinPaths([Re, je.pathnameBase])) } return Ce } function matchPath(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [xe, Ee] = compilePath(e.path, e.caseSensitive, e.end), _e = t.match(xe); if (!_e) return null; let Re = _e[0], Ce = Re.replace(/(.)\/+$/, "$1"), Me = _e.slice(1); return { params: Ee.reduce((Pe, { paramName: Oe, isOptional: je }, Be) => { if (Oe === "*") { let Fe = Me[Be] || ""; Ce = Re.slice(0, Re.length - Fe.length).replace(/(.)\/+$/, "$1") } const Ie = Me[Be]; return je && !Ie ? Pe[Oe] = void 0 : Pe[Oe] = (Ie || "").replace(/%2F/g, "/"), Pe }, {}), pathname: Re, pathnameBase: Ce, pattern: e } } function compilePath(e, t = !1, xe = !0) { warning$1(e === "*" || !e.endsWith("*") || e.endsWith("/*"), `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`); let Ee = [], _e = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (Ce, Me, De) => (Ee.push({ paramName: Me, isOptional: De != null }), De ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (Ee.push({ paramName: "*" }), _e += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : xe ? _e += "\\/*$" : e !== "" && e !== "/" && (_e += "(?:(?=\\/|$))"), [new RegExp(_e, t ? void 0 : "i"), Ee] } function decodePath(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return warning$1(!1, `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`), e } } function stripBasename(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let xe = t.endsWith("/") ? t.length - 1 : t.length, Ee = e.charAt(xe); return Ee && Ee !== "/" ? null : e.slice(xe) || "/" } function resolvePath(e, t = "/") { let { pathname: xe, search: Ee = "", hash: _e = "" } = typeof e == "string" ? parsePath(e) : e; return { pathname: xe ? xe.startsWith("/") ? xe : resolvePathname(xe, t) : t, search: normalizeSearch(Ee), hash: normalizeHash(_e) } } function resolvePathname(e, t) { let xe = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(_e => { _e === ".." ? xe.length > 1 && xe.pop() : _e !== "." && xe.push(_e) }), xe.length > 1 ? xe.join("/") : "/" } function getInvalidPathError(e, t, xe, Ee) { return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(Ee)}].  Please separate it out to the \`to.${xe}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function getPathContributingMatches(e) { return e.filter((t, xe) => xe === 0 || t.route.path && t.route.path.length > 0) } function getResolveToMatches(e) { let t = getPathContributingMatches(e); return t.map((xe, Ee) => Ee === t.length - 1 ? xe.pathname : xe.pathnameBase) } function resolveTo(e, t, xe, Ee = !1) { let _e; typeof e == "string" ? _e = parsePath(e) : (_e = { ...e }, invariant$1(!_e.pathname || !_e.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", _e)), invariant$1(!_e.pathname || !_e.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", _e)), invariant$1(!_e.search || !_e.search.includes("#"), getInvalidPathError("#", "search", "hash", _e))); let Re = e === "" || _e.pathname === "", Ce = Re ? "/" : _e.pathname, Me; if (Ce == null) Me = xe; else { let je = t.length - 1; if (!Ee && Ce.startsWith("..")) { let Be = Ce.split("/"); for (; Be[0] === "..";)Be.shift(), je -= 1; _e.pathname = Be.join("/") } Me = je >= 0 ? t[je] : "/" } let De = resolvePath(_e, Me), Pe = Ce && Ce !== "/" && Ce.endsWith("/"), Oe = (Re || Ce === ".") && xe.endsWith("/"); return !De.pathname.endsWith("/") && (Pe || Oe) && (De.pathname += "/"), De } var joinPaths = e => e.join("/").replace(/\/\/+/g, "/"), normalizePathname = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), normalizeSearch = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, normalizeHash = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e; function isRouteErrorResponse(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } var validMutationMethodsArr = ["POST", "PUT", "PATCH", "DELETE"]; new Set(validMutationMethodsArr); var validRequestMethodsArr = ["GET", ...validMutationMethodsArr]; new Set(validRequestMethodsArr); var DataRouterContext = reactExports.createContext(null); DataRouterContext.displayName = "DataRouter"; var DataRouterStateContext = reactExports.createContext(null); DataRouterStateContext.displayName = "DataRouterState"; reactExports.createContext(!1); var ViewTransitionContext = reactExports.createContext({ isTransitioning: !1 }); ViewTransitionContext.displayName = "ViewTransition"; var FetchersContext = reactExports.createContext(new Map); FetchersContext.displayName = "Fetchers"; var AwaitContext = reactExports.createContext(null); AwaitContext.displayName = "Await"; var NavigationContext = reactExports.createContext(null); NavigationContext.displayName = "Navigation"; var LocationContext = reactExports.createContext(null); LocationContext.displayName = "Location"; var RouteContext = reactExports.createContext({ outlet: null, matches: [], isDataRoute: !1 }); RouteContext.displayName = "Route"; var RouteErrorContext = reactExports.createContext(null); RouteErrorContext.displayName = "RouteError"; function useHref(e, { relative: t } = {}) { invariant$1(useInRouterContext(), "useHref() may be used only in the context of a <Router> component."); let { basename: xe, navigator: Ee } = reactExports.useContext(NavigationContext), { hash: _e, pathname: Re, search: Ce } = useResolvedPath(e, { relative: t }), Me = Re; return xe !== "/" && (Me = Re === "/" ? xe : joinPaths([xe, Re])), Ee.createHref({ pathname: Me, search: Ce, hash: _e }) } function useInRouterContext() { return reactExports.useContext(LocationContext) != null } function useLocation() { return invariant$1(useInRouterContext(), "useLocation() may be used only in the context of a <Router> component."), reactExports.useContext(LocationContext).location } var navigateEffectWarning = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function useIsomorphicLayoutEffect$1(e) { reactExports.useContext(NavigationContext).static || reactExports.useLayoutEffect(e) } function useNavigate() { let { isDataRoute: e } = reactExports.useContext(RouteContext); return e ? useNavigateStable() : useNavigateUnstable() } function useNavigateUnstable() { invariant$1(useInRouterContext(), "useNavigate() may be used only in the context of a <Router> component."); let e = reactExports.useContext(DataRouterContext), { basename: t, navigator: xe } = reactExports.useContext(NavigationContext), { matches: Ee } = reactExports.useContext(RouteContext), { pathname: _e } = useLocation(), Re = JSON.stringify(getResolveToMatches(Ee)), Ce = reactExports.useRef(!1); return useIsomorphicLayoutEffect$1(() => { Ce.current = !0 }), reactExports.useCallback((De, Pe = {}) => { if (warning$1(Ce.current, navigateEffectWarning), !Ce.current) return; if (typeof De == "number") { xe.go(De); return } let Oe = resolveTo(De, JSON.parse(Re), _e, Pe.relative === "path"); e == null && t !== "/" && (Oe.pathname = Oe.pathname === "/" ? t : joinPaths([t, Oe.pathname])), (Pe.replace ? xe.replace : xe.push)(Oe, Pe.state, Pe) }, [t, xe, Re, _e, e]) } var OutletContext = reactExports.createContext(null); function useOutlet(e) { let t = reactExports.useContext(RouteContext).outlet; return t && reactExports.createElement(OutletContext.Provider, { value: e }, t) } function useParams() { let { matches: e } = reactExports.useContext(RouteContext), t = e[e.length - 1]; return t ? t.params : {} } function useResolvedPath(e, { relative: t } = {}) { let { matches: xe } = reactExports.useContext(RouteContext), { pathname: Ee } = useLocation(), _e = JSON.stringify(getResolveToMatches(xe)); return reactExports.useMemo(() => resolveTo(e, JSON.parse(_e), Ee, t === "path"), [e, _e, Ee, t]) } function useRoutes(e, t) { return useRoutesImpl(e, t) } function useRoutesImpl(e, t, xe, Ee) {
  invariant$1(useInRouterContext(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: _e } = reactExports.useContext(NavigationContext), { matches: Re } = reactExports.useContext(RouteContext), Ce = Re[Re.length - 1], Me = Ce ? Ce.params : {}, De = Ce ? Ce.pathname : "/", Pe = Ce ? Ce.pathnameBase : "/", Oe = Ce && Ce.route; {
    let He = Oe && Oe.path || ""; warningOnce(De, !Oe || He.endsWith("*") || He.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${De}" (under <Route path="${He}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${He}"> to <Route path="${He === "/" ? "*" : `${He}/*`}">.`)
  } let je = useLocation(), Be; if (t) { let He = typeof t == "string" ? parsePath(t) : t; invariant$1(Pe === "/" || He.pathname?.startsWith(Pe), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${Pe}" but pathname "${He.pathname}" was given in the \`location\` prop.`), Be = He } else Be = je; let Ie = Be.pathname || "/", Fe = Ie; if (Pe !== "/") { let He = Pe.replace(/^\//, "").split("/"); Fe = "/" + Ie.replace(/^\//, "").split("/").slice(He.length).join("/") } let ze = matchRoutes(e, { pathname: Fe }); warning$1(Oe || ze != null, `No routes matched location "${Be.pathname}${Be.search}${Be.hash}" `), warning$1(ze == null || ze[ze.length - 1].route.element !== void 0 || ze[ze.length - 1].route.Component !== void 0 || ze[ze.length - 1].route.lazy !== void 0, `Matched leaf route at location "${Be.pathname}${Be.search}${Be.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`); let qe = _renderMatches(ze && ze.map(He => Object.assign({}, He, { params: Object.assign({}, Me, He.params), pathname: joinPaths([Pe, _e.encodeLocation ? _e.encodeLocation(He.pathname).pathname : He.pathname]), pathnameBase: He.pathnameBase === "/" ? Pe : joinPaths([Pe, _e.encodeLocation ? _e.encodeLocation(He.pathnameBase).pathname : He.pathnameBase]) })), Re, xe, Ee); return t && qe ? reactExports.createElement(LocationContext.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...Be }, navigationType: "POP" } }, qe) : qe
} function DefaultErrorComponent() { let e = useRouteError(), t = isRouteErrorResponse(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), xe = e instanceof Error ? e.stack : null, Ee = "rgba(200,200,200, 0.5)", _e = { padding: "0.5rem", backgroundColor: Ee }, Re = { padding: "2px 4px", backgroundColor: Ee }, Ce = null; return console.error("Error handled by React Router default ErrorBoundary:", e), Ce = reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("p", null, "💿 Hey developer 👋"), reactExports.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", reactExports.createElement("code", { style: Re }, "ErrorBoundary"), " or", " ", reactExports.createElement("code", { style: Re }, "errorElement"), " prop on your route.")), reactExports.createElement(reactExports.Fragment, null, reactExports.createElement("h2", null, "Unexpected Application Error!"), reactExports.createElement("h3", { style: { fontStyle: "italic" } }, t), xe ? reactExports.createElement("pre", { style: _e }, xe) : null, Ce) } var defaultErrorElement = reactExports.createElement(DefaultErrorComponent, null), RenderErrorBoundary = class extends reactExports.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return this.state.error !== void 0 ? reactExports.createElement(RouteContext.Provider, { value: this.props.routeContext }, reactExports.createElement(RouteErrorContext.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } }; function RenderedRoute({ routeContext: e, match: t, children: xe }) { let Ee = reactExports.useContext(DataRouterContext); return Ee && Ee.static && Ee.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (Ee.staticContext._deepestRenderedBoundaryId = t.route.id), reactExports.createElement(RouteContext.Provider, { value: e }, xe) } function _renderMatches(e, t = [], xe = null, Ee = null) { if (e == null) { if (!xe) return null; if (xe.errors) e = xe.matches; else if (t.length === 0 && !xe.initialized && xe.matches.length > 0) e = xe.matches; else return null } let _e = e, Re = xe?.errors; if (Re != null) { let De = _e.findIndex(Pe => Pe.route.id && Re?.[Pe.route.id] !== void 0); invariant$1(De >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(Re).join(",")}`), _e = _e.slice(0, Math.min(_e.length, De + 1)) } let Ce = !1, Me = -1; if (xe) for (let De = 0; De < _e.length; De++) { let Pe = _e[De]; if ((Pe.route.HydrateFallback || Pe.route.hydrateFallbackElement) && (Me = De), Pe.route.id) { let { loaderData: Oe, errors: je } = xe, Be = Pe.route.loader && !Oe.hasOwnProperty(Pe.route.id) && (!je || je[Pe.route.id] === void 0); if (Pe.route.lazy || Be) { Ce = !0, Me >= 0 ? _e = _e.slice(0, Me + 1) : _e = [_e[0]]; break } } } return _e.reduceRight((De, Pe, Oe) => { let je, Be = !1, Ie = null, Fe = null; xe && (je = Re && Pe.route.id ? Re[Pe.route.id] : void 0, Ie = Pe.route.errorElement || defaultErrorElement, Ce && (Me < 0 && Oe === 0 ? (warningOnce("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), Be = !0, Fe = null) : Me === Oe && (Be = !0, Fe = Pe.route.hydrateFallbackElement || null))); let ze = t.concat(_e.slice(0, Oe + 1)), qe = () => { let He; return je ? He = Ie : Be ? He = Fe : Pe.route.Component ? He = reactExports.createElement(Pe.route.Component, null) : Pe.route.element ? He = Pe.route.element : He = De, reactExports.createElement(RenderedRoute, { match: Pe, routeContext: { outlet: De, matches: ze, isDataRoute: xe != null }, children: He }) }; return xe && (Pe.route.ErrorBoundary || Pe.route.errorElement || Oe === 0) ? reactExports.createElement(RenderErrorBoundary, { location: xe.location, revalidation: xe.revalidation, component: Ie, error: je, children: qe(), routeContext: { outlet: null, matches: ze, isDataRoute: !0 } }) : qe() }, null) } function getDataRouterConsoleError(e) { return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function useDataRouterContext(e) { let t = reactExports.useContext(DataRouterContext); return invariant$1(t, getDataRouterConsoleError(e)), t } function useDataRouterState(e) { let t = reactExports.useContext(DataRouterStateContext); return invariant$1(t, getDataRouterConsoleError(e)), t } function useRouteContext(e) { let t = reactExports.useContext(RouteContext); return invariant$1(t, getDataRouterConsoleError(e)), t } function useCurrentRouteId(e) { let t = useRouteContext(e), xe = t.matches[t.matches.length - 1]; return invariant$1(xe.route.id, `${e} can only be used on routes that contain a unique "id"`), xe.route.id } function useRouteId() { return useCurrentRouteId("useRouteId") } function useRouteError() { let e = reactExports.useContext(RouteErrorContext), t = useDataRouterState("useRouteError"), xe = useCurrentRouteId("useRouteError"); return e !== void 0 ? e : t.errors?.[xe] } function useNavigateStable() { let { router: e } = useDataRouterContext("useNavigate"), t = useCurrentRouteId("useNavigate"), xe = reactExports.useRef(!1); return useIsomorphicLayoutEffect$1(() => { xe.current = !0 }), reactExports.useCallback(async (_e, Re = {}) => { warning$1(xe.current, navigateEffectWarning), xe.current && (typeof _e == "number" ? e.navigate(_e) : await e.navigate(_e, { fromRouteId: t, ...Re })) }, [e, t]) } var alreadyWarned = {}; function warningOnce(e, t, xe) { !t && !alreadyWarned[e] && (alreadyWarned[e] = !0, warning$1(!1, xe)) } reactExports.memo(DataRoutes); function DataRoutes({ routes: e, future: t, state: xe }) { return useRoutesImpl(e, void 0, xe, t) } function Navigate({ to: e, replace: t, state: xe, relative: Ee }) { invariant$1(useInRouterContext(), "<Navigate> may be used only in the context of a <Router> component."); let { static: _e } = reactExports.useContext(NavigationContext); warning$1(!_e, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."); let { matches: Re } = reactExports.useContext(RouteContext), { pathname: Ce } = useLocation(), Me = useNavigate(), De = resolveTo(e, getResolveToMatches(Re), Ce, Ee === "path"), Pe = JSON.stringify(De); return reactExports.useEffect(() => { Me(JSON.parse(Pe), { replace: t, state: xe, relative: Ee }) }, [Me, Pe, Ee, t, xe]), null } function Outlet(e) { return useOutlet(e.context) } function Route(e) { invariant$1(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function Router({ basename: e = "/", children: t = null, location: xe, navigationType: Ee = "POP", navigator: _e, static: Re = !1 }) { invariant$1(!useInRouterContext(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let Ce = e.replace(/^\/*/, "/"), Me = reactExports.useMemo(() => ({ basename: Ce, navigator: _e, static: Re, future: {} }), [Ce, _e, Re]); typeof xe == "string" && (xe = parsePath(xe)); let { pathname: De = "/", search: Pe = "", hash: Oe = "", state: je = null, key: Be = "default" } = xe, Ie = reactExports.useMemo(() => { let Fe = stripBasename(De, Ce); return Fe == null ? null : { location: { pathname: Fe, search: Pe, hash: Oe, state: je, key: Be }, navigationType: Ee } }, [Ce, De, Pe, Oe, je, Be, Ee]); return warning$1(Ie != null, `<Router basename="${Ce}"> is not able to match the URL "${De}${Pe}${Oe}" because it does not start with the basename, so the <Router> won't render anything.`), Ie == null ? null : reactExports.createElement(NavigationContext.Provider, { value: Me }, reactExports.createElement(LocationContext.Provider, { children: t, value: Ie })) } function Routes({ children: e, location: t }) { return useRoutes(createRoutesFromChildren(e), t) } function createRoutesFromChildren(e, t = []) { let xe = []; return reactExports.Children.forEach(e, (Ee, _e) => { if (!reactExports.isValidElement(Ee)) return; let Re = [...t, _e]; if (Ee.type === reactExports.Fragment) { xe.push.apply(xe, createRoutesFromChildren(Ee.props.children, Re)); return } invariant$1(Ee.type === Route, `[${typeof Ee.type == "string" ? Ee.type : Ee.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), invariant$1(!Ee.props.index || !Ee.props.children, "An index route cannot have child routes."); let Ce = { id: Ee.props.id || Re.join("-"), caseSensitive: Ee.props.caseSensitive, element: Ee.props.element, Component: Ee.props.Component, index: Ee.props.index, path: Ee.props.path, loader: Ee.props.loader, action: Ee.props.action, hydrateFallbackElement: Ee.props.hydrateFallbackElement, HydrateFallback: Ee.props.HydrateFallback, errorElement: Ee.props.errorElement, ErrorBoundary: Ee.props.ErrorBoundary, hasErrorBoundary: Ee.props.hasErrorBoundary === !0 || Ee.props.ErrorBoundary != null || Ee.props.errorElement != null, shouldRevalidate: Ee.props.shouldRevalidate, handle: Ee.props.handle, lazy: Ee.props.lazy }; Ee.props.children && (Ce.children = createRoutesFromChildren(Ee.props.children, Re)), xe.push(Ce) }), xe } var defaultMethod = "get", defaultEncType = "application/x-www-form-urlencoded"; function isHtmlElement(e) { return e != null && typeof e.tagName == "string" } function isButtonElement(e) { return isHtmlElement(e) && e.tagName.toLowerCase() === "button" } function isFormElement(e) { return isHtmlElement(e) && e.tagName.toLowerCase() === "form" } function isInputElement(e) { return isHtmlElement(e) && e.tagName.toLowerCase() === "input" } function isModifiedEvent(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function shouldProcessLinkClick(e, t) { return e.button === 0 && (!t || t === "_self") && !isModifiedEvent(e) } var _formDataSupportsSubmitter = null; function isFormDataSubmitterSupported() { if (_formDataSupportsSubmitter === null) try { new FormData(document.createElement("form"), 0), _formDataSupportsSubmitter = !1 } catch { _formDataSupportsSubmitter = !0 } return _formDataSupportsSubmitter } var supportedFormEncTypes = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function getFormEncType(e) { return e != null && !supportedFormEncTypes.has(e) ? (warning$1(!1, `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${defaultEncType}"`), null) : e } function getFormSubmissionInfo(e, t) { let xe, Ee, _e, Re, Ce; if (isFormElement(e)) { let Me = e.getAttribute("action"); Ee = Me ? stripBasename(Me, t) : null, xe = e.getAttribute("method") || defaultMethod, _e = getFormEncType(e.getAttribute("enctype")) || defaultEncType, Re = new FormData(e) } else if (isButtonElement(e) || isInputElement(e) && (e.type === "submit" || e.type === "image")) { let Me = e.form; if (Me == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let De = e.getAttribute("formaction") || Me.getAttribute("action"); if (Ee = De ? stripBasename(De, t) : null, xe = e.getAttribute("formmethod") || Me.getAttribute("method") || defaultMethod, _e = getFormEncType(e.getAttribute("formenctype")) || getFormEncType(Me.getAttribute("enctype")) || defaultEncType, Re = new FormData(Me, e), !isFormDataSubmitterSupported()) { let { name: Pe, type: Oe, value: je } = e; if (Oe === "image") { let Be = Pe ? `${Pe}.` : ""; Re.append(`${Be}x`, "0"), Re.append(`${Be}y`, "0") } else Pe && Re.append(Pe, je) } } else { if (isHtmlElement(e)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); xe = defaultMethod, Ee = null, _e = defaultEncType, Ce = e } return Re && _e === "text/plain" && (Ce = Re, Re = void 0), { action: Ee, method: xe.toLowerCase(), encType: _e, formData: Re, body: Ce } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); function invariant2(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function singleFetchUrl(e, t, xe) { let Ee = typeof e == "string" ? new URL(e, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : e; return Ee.pathname === "/" ? Ee.pathname = `_root.${xe}` : t && stripBasename(Ee.pathname, t) === "/" ? Ee.pathname = `${t.replace(/\/$/, "")}/_root.${xe}` : Ee.pathname = `${Ee.pathname.replace(/\/$/, "")}.${xe}`, Ee } async function loadRouteModule(e, t) { if (e.id in t) return t[e.id]; try { let xe = await import(e.module); return t[e.id] = xe, xe } catch (xe) { return console.error(`Error loading route module \`${e.module}\`, reloading page...`), console.error(xe), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function isHtmlLinkDescriptor(e) { return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string" } async function getKeyedPrefetchLinks(e, t, xe) { let Ee = await Promise.all(e.map(async _e => { let Re = t.routes[_e.route.id]; if (Re) { let Ce = await loadRouteModule(Re, xe); return Ce.links ? Ce.links() : [] } return [] })); return dedupeLinkDescriptors(Ee.flat(1).filter(isHtmlLinkDescriptor).filter(_e => _e.rel === "stylesheet" || _e.rel === "preload").map(_e => _e.rel === "stylesheet" ? { ..._e, rel: "prefetch", as: "style" } : { ..._e, rel: "prefetch" })) } function getNewMatchesForLinks(e, t, xe, Ee, _e, Re) { let Ce = (De, Pe) => xe[Pe] ? De.route.id !== xe[Pe].route.id : !0, Me = (De, Pe) => xe[Pe].pathname !== De.pathname || xe[Pe].route.path?.endsWith("*") && xe[Pe].params["*"] !== De.params["*"]; return Re === "assets" ? t.filter((De, Pe) => Ce(De, Pe) || Me(De, Pe)) : Re === "data" ? t.filter((De, Pe) => { let Oe = Ee.routes[De.route.id]; if (!Oe || !Oe.hasLoader) return !1; if (Ce(De, Pe) || Me(De, Pe)) return !0; if (De.route.shouldRevalidate) { let je = De.route.shouldRevalidate({ currentUrl: new URL(_e.pathname + _e.search + _e.hash, window.origin), currentParams: xe[0]?.params || {}, nextUrl: new URL(e, window.origin), nextParams: De.params, defaultShouldRevalidate: !0 }); if (typeof je == "boolean") return je } return !0 }) : [] } function getModuleLinkHrefs(e, t, { includeHydrateFallback: xe } = {}) { return dedupeHrefs(e.map(Ee => { let _e = t.routes[Ee.route.id]; if (!_e) return []; let Re = [_e.module]; return _e.clientActionModule && (Re = Re.concat(_e.clientActionModule)), _e.clientLoaderModule && (Re = Re.concat(_e.clientLoaderModule)), xe && _e.hydrateFallbackModule && (Re = Re.concat(_e.hydrateFallbackModule)), _e.imports && (Re = Re.concat(_e.imports)), Re }).flat(1)) } function dedupeHrefs(e) { return [...new Set(e)] } function sortKeys(e) { let t = {}, xe = Object.keys(e).sort(); for (let Ee of xe) t[Ee] = e[Ee]; return t } function dedupeLinkDescriptors(e, t) { let xe = new Set; return new Set(t), e.reduce((Ee, _e) => { let Re = JSON.stringify(sortKeys(_e)); return xe.has(Re) || (xe.add(Re), Ee.push({ key: Re, link: _e })), Ee }, []) } function useDataRouterContext2() { let e = reactExports.useContext(DataRouterContext); return invariant2(e, "You must render this element inside a <DataRouterContext.Provider> element"), e } function useDataRouterStateContext() { let e = reactExports.useContext(DataRouterStateContext); return invariant2(e, "You must render this element inside a <DataRouterStateContext.Provider> element"), e } var FrameworkContext = reactExports.createContext(void 0); FrameworkContext.displayName = "FrameworkContext"; function useFrameworkContext() { let e = reactExports.useContext(FrameworkContext); return invariant2(e, "You must render this element inside a <HydratedRouter> element"), e } function usePrefetchBehavior(e, t) { let xe = reactExports.useContext(FrameworkContext), [Ee, _e] = reactExports.useState(!1), [Re, Ce] = reactExports.useState(!1), { onFocus: Me, onBlur: De, onMouseEnter: Pe, onMouseLeave: Oe, onTouchStart: je } = t, Be = reactExports.useRef(null); reactExports.useEffect(() => { if (e === "render" && Ce(!0), e === "viewport") { let ze = He => { He.forEach(Ge => { Ce(Ge.isIntersecting) }) }, qe = new IntersectionObserver(ze, { threshold: .5 }); return Be.current && qe.observe(Be.current), () => { qe.disconnect() } } }, [e]), reactExports.useEffect(() => { if (Ee) { let ze = setTimeout(() => { Ce(!0) }, 100); return () => { clearTimeout(ze) } } }, [Ee]); let Ie = () => { _e(!0) }, Fe = () => { _e(!1), Ce(!1) }; return xe ? e !== "intent" ? [Re, Be, {}] : [Re, Be, { onFocus: composeEventHandlers$1(Me, Ie), onBlur: composeEventHandlers$1(De, Fe), onMouseEnter: composeEventHandlers$1(Pe, Ie), onMouseLeave: composeEventHandlers$1(Oe, Fe), onTouchStart: composeEventHandlers$1(je, Ie) }] : [!1, Be, {}] } function composeEventHandlers$1(e, t) { return xe => { e && e(xe), xe.defaultPrevented || t(xe) } } function PrefetchPageLinks({ page: e, ...t }) { let { router: xe } = useDataRouterContext2(), Ee = reactExports.useMemo(() => matchRoutes(xe.routes, e, xe.basename), [xe.routes, e, xe.basename]); return Ee ? reactExports.createElement(PrefetchPageLinksImpl, { page: e, matches: Ee, ...t }) : null } function useKeyedPrefetchLinks(e) { let { manifest: t, routeModules: xe } = useFrameworkContext(), [Ee, _e] = reactExports.useState([]); return reactExports.useEffect(() => { let Re = !1; return getKeyedPrefetchLinks(e, t, xe).then(Ce => { Re || _e(Ce) }), () => { Re = !0 } }, [e, t, xe]), Ee } function PrefetchPageLinksImpl({ page: e, matches: t, ...xe }) { let Ee = useLocation(), { manifest: _e, routeModules: Re } = useFrameworkContext(), { basename: Ce } = useDataRouterContext2(), { loaderData: Me, matches: De } = useDataRouterStateContext(), Pe = reactExports.useMemo(() => getNewMatchesForLinks(e, t, De, _e, Ee, "data"), [e, t, De, _e, Ee]), Oe = reactExports.useMemo(() => getNewMatchesForLinks(e, t, De, _e, Ee, "assets"), [e, t, De, _e, Ee]), je = reactExports.useMemo(() => { if (e === Ee.pathname + Ee.search + Ee.hash) return []; let Fe = new Set, ze = !1; if (t.forEach(He => { let Ge = _e.routes[He.route.id]; !Ge || !Ge.hasLoader || (!Pe.some(Ze => Ze.route.id === He.route.id) && He.route.id in Me && Re[He.route.id]?.shouldRevalidate || Ge.hasClientLoader ? ze = !0 : Fe.add(He.route.id)) }), Fe.size === 0) return []; let qe = singleFetchUrl(e, Ce, "data"); return ze && Fe.size > 0 && qe.searchParams.set("_routes", t.filter(He => Fe.has(He.route.id)).map(He => He.route.id).join(",")), [qe.pathname + qe.search] }, [Ce, Me, Ee, _e, Pe, t, e, Re]), Be = reactExports.useMemo(() => getModuleLinkHrefs(Oe, _e), [Oe, _e]), Ie = useKeyedPrefetchLinks(Oe); return reactExports.createElement(reactExports.Fragment, null, je.map(Fe => reactExports.createElement("link", { key: Fe, rel: "prefetch", as: "fetch", href: Fe, ...xe })), Be.map(Fe => reactExports.createElement("link", { key: Fe, rel: "modulepreload", href: Fe, ...xe })), Ie.map(({ key: Fe, link: ze }) => reactExports.createElement("link", { key: Fe, ...ze }))) } function mergeRefs$1(...e) { return t => { e.forEach(xe => { typeof xe == "function" ? xe(t) : xe != null && (xe.current = t) }) } } var isBrowser$1 = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { isBrowser$1 && (window.__reactRouterVersion = "7.7.1") } catch { } function BrowserRouter({ basename: e, children: t, window: xe }) { let Ee = reactExports.useRef(); Ee.current == null && (Ee.current = createBrowserHistory({ window: xe, v5Compat: !0 })); let _e = Ee.current, [Re, Ce] = reactExports.useState({ action: _e.action, location: _e.location }), Me = reactExports.useCallback(De => { reactExports.startTransition(() => Ce(De)) }, [Ce]); return reactExports.useLayoutEffect(() => _e.listen(Me), [_e, Me]), reactExports.createElement(Router, { basename: e, children: t, location: Re.location, navigationType: Re.action, navigator: _e }) } var ABSOLUTE_URL_REGEX2 = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Link = reactExports.forwardRef(function ({ onClick: t, discover: xe = "render", prefetch: Ee = "none", relative: _e, reloadDocument: Re, replace: Ce, state: Me, target: De, to: Pe, preventScrollReset: Oe, viewTransition: je, ...Be }, Ie) { let { basename: Fe } = reactExports.useContext(NavigationContext), ze = typeof Pe == "string" && ABSOLUTE_URL_REGEX2.test(Pe), qe, He = !1; if (typeof Pe == "string" && ze && (qe = Pe, isBrowser$1)) try { let bn = new URL(window.location.href), Tn = Pe.startsWith("//") ? new URL(bn.protocol + Pe) : new URL(Pe), fn = stripBasename(Tn.pathname, Fe); Tn.origin === bn.origin && fn != null ? Pe = fn + Tn.search + Tn.hash : He = !0 } catch { warning$1(!1, `<Link to="${Pe}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } let Ge = useHref(Pe, { relative: _e }), [Ze, sn, Xe] = usePrefetchBehavior(Ee, Be), St = useLinkClickHandler(Pe, { replace: Ce, state: Me, target: De, preventScrollReset: Oe, relative: _e, viewTransition: je }); function un(bn) { t && t(bn), bn.defaultPrevented || St(bn) } let on = reactExports.createElement("a", { ...Be, ...Xe, href: qe || Ge, onClick: He || Re ? t : un, ref: mergeRefs$1(Ie, sn), target: De, "data-discover": !ze && xe === "render" ? "true" : void 0 }); return Ze && !ze ? reactExports.createElement(reactExports.Fragment, null, on, reactExports.createElement(PrefetchPageLinks, { page: Ge })) : on }); Link.displayName = "Link"; var NavLink = reactExports.forwardRef(function ({ "aria-current": t = "page", caseSensitive: xe = !1, className: Ee = "", end: _e = !1, style: Re, to: Ce, viewTransition: Me, children: De, ...Pe }, Oe) { let je = useResolvedPath(Ce, { relative: Pe.relative }), Be = useLocation(), Ie = reactExports.useContext(DataRouterStateContext), { navigator: Fe, basename: ze } = reactExports.useContext(NavigationContext), qe = Ie != null && useViewTransitionState(je) && Me === !0, He = Fe.encodeLocation ? Fe.encodeLocation(je).pathname : je.pathname, Ge = Be.pathname, Ze = Ie && Ie.navigation && Ie.navigation.location ? Ie.navigation.location.pathname : null; xe || (Ge = Ge.toLowerCase(), Ze = Ze ? Ze.toLowerCase() : null, He = He.toLowerCase()), Ze && ze && (Ze = stripBasename(Ze, ze) || Ze); const sn = He !== "/" && He.endsWith("/") ? He.length - 1 : He.length; let Xe = Ge === He || !_e && Ge.startsWith(He) && Ge.charAt(sn) === "/", St = Ze != null && (Ze === He || !_e && Ze.startsWith(He) && Ze.charAt(He.length) === "/"), un = { isActive: Xe, isPending: St, isTransitioning: qe }, on = Xe ? t : void 0, bn; typeof Ee == "function" ? bn = Ee(un) : bn = [Ee, Xe ? "active" : null, St ? "pending" : null, qe ? "transitioning" : null].filter(Boolean).join(" "); let Tn = typeof Re == "function" ? Re(un) : Re; return reactExports.createElement(Link, { ...Pe, "aria-current": on, className: bn, ref: Oe, style: Tn, to: Ce, viewTransition: Me }, typeof De == "function" ? De(un) : De) }); NavLink.displayName = "NavLink"; var Form = reactExports.forwardRef(({ discover: e = "render", fetcherKey: t, navigate: xe, reloadDocument: Ee, replace: _e, state: Re, method: Ce = defaultMethod, action: Me, onSubmit: De, relative: Pe, preventScrollReset: Oe, viewTransition: je, ...Be }, Ie) => { let Fe = useSubmit(), ze = useFormAction(Me, { relative: Pe }), qe = Ce.toLowerCase() === "get" ? "get" : "post", He = typeof Me == "string" && ABSOLUTE_URL_REGEX2.test(Me), Ge = Ze => { if (De && De(Ze), Ze.defaultPrevented) return; Ze.preventDefault(); let sn = Ze.nativeEvent.submitter, Xe = sn?.getAttribute("formmethod") || Ce; Fe(sn || Ze.currentTarget, { fetcherKey: t, method: Xe, navigate: xe, replace: _e, state: Re, relative: Pe, preventScrollReset: Oe, viewTransition: je }) }; return reactExports.createElement("form", { ref: Ie, method: qe, action: ze, onSubmit: Ee ? De : Ge, ...Be, "data-discover": !He && e === "render" ? "true" : void 0 }) }); Form.displayName = "Form"; function getDataRouterConsoleError2(e) { return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function useDataRouterContext3(e) { let t = reactExports.useContext(DataRouterContext); return invariant$1(t, getDataRouterConsoleError2(e)), t } function useLinkClickHandler(e, { target: t, replace: xe, state: Ee, preventScrollReset: _e, relative: Re, viewTransition: Ce } = {}) { let Me = useNavigate(), De = useLocation(), Pe = useResolvedPath(e, { relative: Re }); return reactExports.useCallback(Oe => { if (shouldProcessLinkClick(Oe, t)) { Oe.preventDefault(); let je = xe !== void 0 ? xe : createPath(De) === createPath(Pe); Me(e, { replace: je, state: Ee, preventScrollReset: _e, relative: Re, viewTransition: Ce }) } }, [De, Me, Pe, xe, Ee, t, e, _e, Re, Ce]) } var fetcherId = 0, getUniqueFetcherId = () => `__${String(++fetcherId)}__`; function useSubmit() { let { router: e } = useDataRouterContext3("useSubmit"), { basename: t } = reactExports.useContext(NavigationContext), xe = useRouteId(); return reactExports.useCallback(async (Ee, _e = {}) => { let { action: Re, method: Ce, encType: Me, formData: De, body: Pe } = getFormSubmissionInfo(Ee, t); if (_e.navigate === !1) { let Oe = _e.fetcherKey || getUniqueFetcherId(); await e.fetch(Oe, xe, _e.action || Re, { preventScrollReset: _e.preventScrollReset, formData: De, body: Pe, formMethod: _e.method || Ce, formEncType: _e.encType || Me, flushSync: _e.flushSync }) } else await e.navigate(_e.action || Re, { preventScrollReset: _e.preventScrollReset, formData: De, body: Pe, formMethod: _e.method || Ce, formEncType: _e.encType || Me, replace: _e.replace, state: _e.state, fromRouteId: xe, flushSync: _e.flushSync, viewTransition: _e.viewTransition }) }, [e, t, xe]) } function useFormAction(e, { relative: t } = {}) { let { basename: xe } = reactExports.useContext(NavigationContext), Ee = reactExports.useContext(RouteContext); invariant$1(Ee, "useFormAction must be used inside a RouteContext"); let [_e] = Ee.matches.slice(-1), Re = { ...useResolvedPath(e || ".", { relative: t }) }, Ce = useLocation(); if (e == null) { Re.search = Ce.search; let Me = new URLSearchParams(Re.search), De = Me.getAll("index"); if (De.some(Oe => Oe === "")) { Me.delete("index"), De.filter(je => je).forEach(je => Me.append("index", je)); let Oe = Me.toString(); Re.search = Oe ? `?${Oe}` : "" } } return (!e || e === ".") && _e.route.index && (Re.search = Re.search ? Re.search.replace(/^\?/, "?index&") : "?index"), xe !== "/" && (Re.pathname = Re.pathname === "/" ? xe : joinPaths([xe, Re.pathname])), createPath(Re) } function useViewTransitionState(e, { relative: t } = {}) { let xe = reactExports.useContext(ViewTransitionContext); invariant$1(xe != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: Ee } = useDataRouterContext3("useViewTransitionState"), _e = useResolvedPath(e, { relative: t }); if (!xe.isTransitioning) return !1; let Re = stripBasename(xe.currentLocation.pathname, Ee) || xe.currentLocation.pathname, Ce = stripBasename(xe.nextLocation.pathname, Ee) || xe.nextLocation.pathname; return matchPath(_e.pathname, Ce) != null || matchPath(_e.pathname, Re) != null } var reactDomExports = requireReactDom(); const ReactDOM = getDefaultExportFromCjs(reactDomExports); function setRef(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function composeRefs(...e) { return t => { let xe = !1; const Ee = e.map(_e => { const Re = setRef(_e, t); return !xe && typeof Re == "function" && (xe = !0), Re }); if (xe) return () => { for (let _e = 0; _e < Ee.length; _e++) { const Re = Ee[_e]; typeof Re == "function" ? Re() : setRef(e[_e], null) } } } } function useComposedRefs(...e) { return reactExports.useCallback(composeRefs(...e), e) } function createSlot(e) { const t = createSlotClone(e), xe = reactExports.forwardRef((Ee, _e) => { const { children: Re, ...Ce } = Ee, Me = reactExports.Children.toArray(Re), De = Me.find(isSlottable); if (De) { const Pe = De.props.children, Oe = Me.map(je => je === De ? reactExports.Children.count(Pe) > 1 ? reactExports.Children.only(null) : reactExports.isValidElement(Pe) ? Pe.props.children : null : je); return jsxRuntimeExports.jsx(t, { ...Ce, ref: _e, children: reactExports.isValidElement(Pe) ? reactExports.cloneElement(Pe, void 0, Oe) : null }) } return jsxRuntimeExports.jsx(t, { ...Ce, ref: _e, children: Re }) }); return xe.displayName = `${e}.Slot`, xe } var Slot$3 = createSlot("Slot"); function createSlotClone(e) { const t = reactExports.forwardRef((xe, Ee) => { const { children: _e, ...Re } = xe; if (reactExports.isValidElement(_e)) { const Ce = getElementRef$1(_e), Me = mergeProps(Re, _e.props); return _e.type !== reactExports.Fragment && (Me.ref = Ee ? composeRefs(Ee, Ce) : Ce), reactExports.cloneElement(_e, Me) } return reactExports.Children.count(_e) > 1 ? reactExports.Children.only(null) : null }); return t.displayName = `${e}.SlotClone`, t } var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable"); function createSlottable(e) { const t = ({ children: xe }) => jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: xe }); return t.displayName = `${e}.Slottable`, t.__radixId = SLOTTABLE_IDENTIFIER, t } function isSlottable(e) { return reactExports.isValidElement(e) && typeof e.type == "function" && "__radixId" in e.type && e.type.__radixId === SLOTTABLE_IDENTIFIER } function mergeProps(e, t) { const xe = { ...t }; for (const Ee in t) { const _e = e[Ee], Re = t[Ee]; /^on[A-Z]/.test(Ee) ? _e && Re ? xe[Ee] = (...Me) => { const De = Re(...Me); return _e(...Me), De } : _e && (xe[Ee] = _e) : Ee === "style" ? xe[Ee] = { ..._e, ...Re } : Ee === "className" && (xe[Ee] = [_e, Re].filter(Boolean).join(" ")) } return { ...e, ...xe } } function getElementRef$1(e) { let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, xe = t && "isReactWarning" in t && t.isReactWarning; return xe ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, xe = t && "isReactWarning" in t && t.isReactWarning, xe ? e.props.ref : e.props.ref || e.ref) } function r(e) { var t, xe, Ee = ""; if (typeof e == "string" || typeof e == "number") Ee += e; else if (typeof e == "object") if (Array.isArray(e)) { var _e = e.length; for (t = 0; t < _e; t++)e[t] && (xe = r(e[t])) && (Ee && (Ee += " "), Ee += xe) } else for (xe in e) e[xe] && (Ee && (Ee += " "), Ee += xe); return Ee } function clsx() { for (var e, t, xe = 0, Ee = "", _e = arguments.length; xe < _e; xe++)(e = arguments[xe]) && (t = r(e)) && (Ee && (Ee += " "), Ee += t); return Ee } const falsyToString = e => typeof e == "boolean" ? `${e}` : e === 0 ? "0" : e, cx = clsx, cva = (e, t) => xe => { var Ee; if (t?.variants == null) return cx(e, xe?.class, xe?.className); const { variants: _e, defaultVariants: Re } = t, Ce = Object.keys(_e).map(Pe => { const Oe = xe?.[Pe], je = Re?.[Pe]; if (Oe === null) return null; const Be = falsyToString(Oe) || falsyToString(je); return _e[Pe][Be] }), Me = xe && Object.entries(xe).reduce((Pe, Oe) => { let [je, Be] = Oe; return Be === void 0 || (Pe[je] = Be), Pe }, {}), De = t == null || (Ee = t.compoundVariants) === null || Ee === void 0 ? void 0 : Ee.reduce((Pe, Oe) => { let { class: je, className: Be, ...Ie } = Oe; return Object.entries(Ie).every(Fe => { let [ze, qe] = Fe; return Array.isArray(qe) ? qe.includes({ ...Re, ...Me }[ze]) : { ...Re, ...Me }[ze] === qe }) ? [...Pe, je, Be] : Pe }, []); return cx(e, Ce, De, xe?.class, xe?.className) }, CLASS_PART_SEPARATOR = "-", createClassGroupUtils = e => { const t = createClassMap(e), { conflictingClassGroups: xe, conflictingClassGroupModifiers: Ee } = e; return { getClassGroupId: Ce => { const Me = Ce.split(CLASS_PART_SEPARATOR); return Me[0] === "" && Me.length !== 1 && Me.shift(), getGroupRecursive(Me, t) || getGroupIdForArbitraryProperty(Ce) }, getConflictingClassGroupIds: (Ce, Me) => { const De = xe[Ce] || []; return Me && Ee[Ce] ? [...De, ...Ee[Ce]] : De } } }, getGroupRecursive = (e, t) => { if (e.length === 0) return t.classGroupId; const xe = e[0], Ee = t.nextPart.get(xe), _e = Ee ? getGroupRecursive(e.slice(1), Ee) : void 0; if (_e) return _e; if (t.validators.length === 0) return; const Re = e.join(CLASS_PART_SEPARATOR); return t.validators.find(({ validator: Ce }) => Ce(Re))?.classGroupId }, arbitraryPropertyRegex = /^\[(.+)\]$/, getGroupIdForArbitraryProperty = e => { if (arbitraryPropertyRegex.test(e)) { const t = arbitraryPropertyRegex.exec(e)[1], xe = t?.substring(0, t.indexOf(":")); if (xe) return "arbitrary.." + xe } }, createClassMap = e => { const { theme: t, classGroups: xe } = e, Ee = { nextPart: new Map, validators: [] }; for (const _e in xe) processClassesRecursively(xe[_e], Ee, _e, t); return Ee }, processClassesRecursively = (e, t, xe, Ee) => { e.forEach(_e => { if (typeof _e == "string") { const Re = _e === "" ? t : getPart(t, _e); Re.classGroupId = xe; return } if (typeof _e == "function") { if (isThemeGetter(_e)) { processClassesRecursively(_e(Ee), t, xe, Ee); return } t.validators.push({ validator: _e, classGroupId: xe }); return } Object.entries(_e).forEach(([Re, Ce]) => { processClassesRecursively(Ce, getPart(t, Re), xe, Ee) }) }) }, getPart = (e, t) => { let xe = e; return t.split(CLASS_PART_SEPARATOR).forEach(Ee => { xe.nextPart.has(Ee) || xe.nextPart.set(Ee, { nextPart: new Map, validators: [] }), xe = xe.nextPart.get(Ee) }), xe }, isThemeGetter = e => e.isThemeGetter, createLruCache = e => { if (e < 1) return { get: () => { }, set: () => { } }; let t = 0, xe = new Map, Ee = new Map; const _e = (Re, Ce) => { xe.set(Re, Ce), t++, t > e && (t = 0, Ee = xe, xe = new Map) }; return { get(Re) { let Ce = xe.get(Re); if (Ce !== void 0) return Ce; if ((Ce = Ee.get(Re)) !== void 0) return _e(Re, Ce), Ce }, set(Re, Ce) { xe.has(Re) ? xe.set(Re, Ce) : _e(Re, Ce) } } }, IMPORTANT_MODIFIER = "!", MODIFIER_SEPARATOR = ":", MODIFIER_SEPARATOR_LENGTH = MODIFIER_SEPARATOR.length, createParseClassName = e => { const { prefix: t, experimentalParseClassName: xe } = e; let Ee = _e => { const Re = []; let Ce = 0, Me = 0, De = 0, Pe; for (let Fe = 0; Fe < _e.length; Fe++) { let ze = _e[Fe]; if (Ce === 0 && Me === 0) { if (ze === MODIFIER_SEPARATOR) { Re.push(_e.slice(De, Fe)), De = Fe + MODIFIER_SEPARATOR_LENGTH; continue } if (ze === "/") { Pe = Fe; continue } } ze === "[" ? Ce++ : ze === "]" ? Ce-- : ze === "(" ? Me++ : ze === ")" && Me-- } const Oe = Re.length === 0 ? _e : _e.substring(De), je = stripImportantModifier(Oe), Be = je !== Oe, Ie = Pe && Pe > De ? Pe - De : void 0; return { modifiers: Re, hasImportantModifier: Be, baseClassName: je, maybePostfixModifierPosition: Ie } }; if (t) { const _e = t + MODIFIER_SEPARATOR, Re = Ee; Ee = Ce => Ce.startsWith(_e) ? Re(Ce.substring(_e.length)) : { isExternal: !0, modifiers: [], hasImportantModifier: !1, baseClassName: Ce, maybePostfixModifierPosition: void 0 } } if (xe) { const _e = Ee; Ee = Re => xe({ className: Re, parseClassName: _e }) } return Ee }, stripImportantModifier = e => e.endsWith(IMPORTANT_MODIFIER) ? e.substring(0, e.length - 1) : e.startsWith(IMPORTANT_MODIFIER) ? e.substring(1) : e, createSortModifiers = e => { const t = Object.fromEntries(e.orderSensitiveModifiers.map(Ee => [Ee, !0])); return Ee => { if (Ee.length <= 1) return Ee; const _e = []; let Re = []; return Ee.forEach(Ce => { Ce[0] === "[" || t[Ce] ? (_e.push(...Re.sort(), Ce), Re = []) : Re.push(Ce) }), _e.push(...Re.sort()), _e } }, createConfigUtils = e => ({ cache: createLruCache(e.cacheSize), parseClassName: createParseClassName(e), sortModifiers: createSortModifiers(e), ...createClassGroupUtils(e) }), SPLIT_CLASSES_REGEX = /\s+/, mergeClassList = (e, t) => { const { parseClassName: xe, getClassGroupId: Ee, getConflictingClassGroupIds: _e, sortModifiers: Re } = t, Ce = [], Me = e.trim().split(SPLIT_CLASSES_REGEX); let De = ""; for (let Pe = Me.length - 1; Pe >= 0; Pe -= 1) { const Oe = Me[Pe], { isExternal: je, modifiers: Be, hasImportantModifier: Ie, baseClassName: Fe, maybePostfixModifierPosition: ze } = xe(Oe); if (je) { De = Oe + (De.length > 0 ? " " + De : De); continue } let qe = !!ze, He = Ee(qe ? Fe.substring(0, ze) : Fe); if (!He) { if (!qe) { De = Oe + (De.length > 0 ? " " + De : De); continue } if (He = Ee(Fe), !He) { De = Oe + (De.length > 0 ? " " + De : De); continue } qe = !1 } const Ge = Re(Be).join(":"), Ze = Ie ? Ge + IMPORTANT_MODIFIER : Ge, sn = Ze + He; if (Ce.includes(sn)) continue; Ce.push(sn); const Xe = _e(He, qe); for (let St = 0; St < Xe.length; ++St) { const un = Xe[St]; Ce.push(Ze + un) } De = Oe + (De.length > 0 ? " " + De : De) } return De }; function twJoin() { let e = 0, t, xe, Ee = ""; for (; e < arguments.length;)(t = arguments[e++]) && (xe = toValue(t)) && (Ee && (Ee += " "), Ee += xe); return Ee } const toValue = e => { if (typeof e == "string") return e; let t, xe = ""; for (let Ee = 0; Ee < e.length; Ee++)e[Ee] && (t = toValue(e[Ee])) && (xe && (xe += " "), xe += t); return xe }; function createTailwindMerge(e, ...t) { let xe, Ee, _e, Re = Ce; function Ce(De) { const Pe = t.reduce((Oe, je) => je(Oe), e()); return xe = createConfigUtils(Pe), Ee = xe.cache.get, _e = xe.cache.set, Re = Me, Me(De) } function Me(De) { const Pe = Ee(De); if (Pe) return Pe; const Oe = mergeClassList(De, xe); return _e(De, Oe), Oe } return function () { return Re(twJoin.apply(null, arguments)) } } const fromTheme = e => { const t = xe => xe[e] || []; return t.isThemeGetter = !0, t }, arbitraryValueRegex = /^\[(?:(\w[\w-]*):)?(.+)\]$/i, arbitraryVariableRegex = /^\((?:(\w[\w-]*):)?(.+)\)$/i, fractionRegex = /^\d+\/\d+$/, tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/, lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/, colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch)|color-mix)\(.+\)$/, shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/, imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/, isFraction = e => fractionRegex.test(e), isNumber$1 = e => !!e && !Number.isNaN(Number(e)), isInteger = e => !!e && Number.isInteger(Number(e)), isPercent = e => e.endsWith("%") && isNumber$1(e.slice(0, -1)), isTshirtSize = e => tshirtUnitRegex.test(e), isAny = () => !0, isLengthOnly = e => lengthUnitRegex.test(e) && !colorFunctionRegex.test(e), isNever = () => !1, isShadow = e => shadowRegex.test(e), isImage = e => imageRegex.test(e), isAnyNonArbitrary = e => !isArbitraryValue(e) && !isArbitraryVariable(e), isArbitrarySize = e => getIsArbitraryValue(e, isLabelSize, isNever), isArbitraryValue = e => arbitraryValueRegex.test(e), isArbitraryLength = e => getIsArbitraryValue(e, isLabelLength, isLengthOnly), isArbitraryNumber = e => getIsArbitraryValue(e, isLabelNumber, isNumber$1), isArbitraryPosition = e => getIsArbitraryValue(e, isLabelPosition, isNever), isArbitraryImage = e => getIsArbitraryValue(e, isLabelImage, isImage), isArbitraryShadow = e => getIsArbitraryValue(e, isLabelShadow, isShadow), isArbitraryVariable = e => arbitraryVariableRegex.test(e), isArbitraryVariableLength = e => getIsArbitraryVariable(e, isLabelLength), isArbitraryVariableFamilyName = e => getIsArbitraryVariable(e, isLabelFamilyName), isArbitraryVariablePosition = e => getIsArbitraryVariable(e, isLabelPosition), isArbitraryVariableSize = e => getIsArbitraryVariable(e, isLabelSize), isArbitraryVariableImage = e => getIsArbitraryVariable(e, isLabelImage), isArbitraryVariableShadow = e => getIsArbitraryVariable(e, isLabelShadow, !0), getIsArbitraryValue = (e, t, xe) => { const Ee = arbitraryValueRegex.exec(e); return Ee ? Ee[1] ? t(Ee[1]) : xe(Ee[2]) : !1 }, getIsArbitraryVariable = (e, t, xe = !1) => { const Ee = arbitraryVariableRegex.exec(e); return Ee ? Ee[1] ? t(Ee[1]) : xe : !1 }, isLabelPosition = e => e === "position" || e === "percentage", isLabelImage = e => e === "image" || e === "url", isLabelSize = e => e === "length" || e === "size" || e === "bg-size", isLabelLength = e => e === "length", isLabelNumber = e => e === "number", isLabelFamilyName = e => e === "family-name", isLabelShadow = e => e === "shadow", getDefaultConfig = () => { const e = fromTheme("color"), t = fromTheme("font"), xe = fromTheme("text"), Ee = fromTheme("font-weight"), _e = fromTheme("tracking"), Re = fromTheme("leading"), Ce = fromTheme("breakpoint"), Me = fromTheme("container"), De = fromTheme("spacing"), Pe = fromTheme("radius"), Oe = fromTheme("shadow"), je = fromTheme("inset-shadow"), Be = fromTheme("text-shadow"), Ie = fromTheme("drop-shadow"), Fe = fromTheme("blur"), ze = fromTheme("perspective"), qe = fromTheme("aspect"), He = fromTheme("ease"), Ge = fromTheme("animate"), Ze = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], sn = () => ["center", "top", "bottom", "left", "right", "top-left", "left-top", "top-right", "right-top", "bottom-right", "right-bottom", "bottom-left", "left-bottom"], Xe = () => [...sn(), isArbitraryVariable, isArbitraryValue], St = () => ["auto", "hidden", "clip", "visible", "scroll"], un = () => ["auto", "contain", "none"], on = () => [isArbitraryVariable, isArbitraryValue, De], bn = () => [isFraction, "full", "auto", ...on()], Tn = () => [isInteger, "none", "subgrid", isArbitraryVariable, isArbitraryValue], fn = () => ["auto", { span: ["full", isInteger, isArbitraryVariable, isArbitraryValue] }, isInteger, isArbitraryVariable, isArbitraryValue], En = () => [isInteger, "auto", isArbitraryVariable, isArbitraryValue], Pn = () => ["auto", "min", "max", "fr", isArbitraryVariable, isArbitraryValue], Rn = () => ["start", "end", "center", "between", "around", "evenly", "stretch", "baseline", "center-safe", "end-safe"], In = () => ["start", "end", "center", "stretch", "center-safe", "end-safe"], xn = () => ["auto", ...on()], vn = () => [isFraction, "auto", "full", "dvw", "dvh", "lvw", "lvh", "svw", "svh", "min", "max", "fit", ...on()], tn = () => [e, isArbitraryVariable, isArbitraryValue], nn = () => [...sn(), isArbitraryVariablePosition, isArbitraryPosition, { position: [isArbitraryVariable, isArbitraryValue] }], We = () => ["no-repeat", { repeat: ["", "x", "y", "space", "round"] }], dn = () => ["auto", "cover", "contain", isArbitraryVariableSize, isArbitrarySize, { size: [isArbitraryVariable, isArbitraryValue] }], Je = () => [isPercent, isArbitraryVariableLength, isArbitraryLength], rn = () => ["", "none", "full", Pe, isArbitraryVariable, isArbitraryValue], hn = () => ["", isNumber$1, isArbitraryVariableLength, isArbitraryLength], mn = () => ["solid", "dashed", "dotted", "double"], Ye = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], an = () => [isNumber$1, isPercent, isArbitraryVariablePosition, isArbitraryPosition], pn = () => ["", "none", Fe, isArbitraryVariable, isArbitraryValue], yn = () => ["none", isNumber$1, isArbitraryVariable, isArbitraryValue], _n = () => ["none", isNumber$1, isArbitraryVariable, isArbitraryValue], On = () => [isNumber$1, isArbitraryVariable, isArbitraryValue], kn = () => [isFraction, "full", ...on()]; return { cacheSize: 500, theme: { animate: ["spin", "ping", "pulse", "bounce"], aspect: ["video"], blur: [isTshirtSize], breakpoint: [isTshirtSize], color: [isAny], container: [isTshirtSize], "drop-shadow": [isTshirtSize], ease: ["in", "out", "in-out"], font: [isAnyNonArbitrary], "font-weight": ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black"], "inset-shadow": [isTshirtSize], leading: ["none", "tight", "snug", "normal", "relaxed", "loose"], perspective: ["dramatic", "near", "normal", "midrange", "distant", "none"], radius: [isTshirtSize], shadow: [isTshirtSize], spacing: ["px", isNumber$1], text: [isTshirtSize], "text-shadow": [isTshirtSize], tracking: ["tighter", "tight", "normal", "wide", "wider", "widest"] }, classGroups: { aspect: [{ aspect: ["auto", "square", isFraction, isArbitraryValue, isArbitraryVariable, qe] }], container: ["container"], columns: [{ columns: [isNumber$1, isArbitraryValue, isArbitraryVariable, Me] }], "break-after": [{ "break-after": Ze() }], "break-before": [{ "break-before": Ze() }], "break-inside": [{ "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"] }], "box-decoration": [{ "box-decoration": ["slice", "clone"] }], box: [{ box: ["border", "content"] }], display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"], sr: ["sr-only", "not-sr-only"], float: [{ float: ["right", "left", "none", "start", "end"] }], clear: [{ clear: ["left", "right", "both", "none", "start", "end"] }], isolation: ["isolate", "isolation-auto"], "object-fit": [{ object: ["contain", "cover", "fill", "none", "scale-down"] }], "object-position": [{ object: Xe() }], overflow: [{ overflow: St() }], "overflow-x": [{ "overflow-x": St() }], "overflow-y": [{ "overflow-y": St() }], overscroll: [{ overscroll: un() }], "overscroll-x": [{ "overscroll-x": un() }], "overscroll-y": [{ "overscroll-y": un() }], position: ["static", "fixed", "absolute", "relative", "sticky"], inset: [{ inset: bn() }], "inset-x": [{ "inset-x": bn() }], "inset-y": [{ "inset-y": bn() }], start: [{ start: bn() }], end: [{ end: bn() }], top: [{ top: bn() }], right: [{ right: bn() }], bottom: [{ bottom: bn() }], left: [{ left: bn() }], visibility: ["visible", "invisible", "collapse"], z: [{ z: [isInteger, "auto", isArbitraryVariable, isArbitraryValue] }], basis: [{ basis: [isFraction, "full", "auto", Me, ...on()] }], "flex-direction": [{ flex: ["row", "row-reverse", "col", "col-reverse"] }], "flex-wrap": [{ flex: ["nowrap", "wrap", "wrap-reverse"] }], flex: [{ flex: [isNumber$1, isFraction, "auto", "initial", "none", isArbitraryValue] }], grow: [{ grow: ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], shrink: [{ shrink: ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], order: [{ order: [isInteger, "first", "last", "none", isArbitraryVariable, isArbitraryValue] }], "grid-cols": [{ "grid-cols": Tn() }], "col-start-end": [{ col: fn() }], "col-start": [{ "col-start": En() }], "col-end": [{ "col-end": En() }], "grid-rows": [{ "grid-rows": Tn() }], "row-start-end": [{ row: fn() }], "row-start": [{ "row-start": En() }], "row-end": [{ "row-end": En() }], "grid-flow": [{ "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"] }], "auto-cols": [{ "auto-cols": Pn() }], "auto-rows": [{ "auto-rows": Pn() }], gap: [{ gap: on() }], "gap-x": [{ "gap-x": on() }], "gap-y": [{ "gap-y": on() }], "justify-content": [{ justify: [...Rn(), "normal"] }], "justify-items": [{ "justify-items": [...In(), "normal"] }], "justify-self": [{ "justify-self": ["auto", ...In()] }], "align-content": [{ content: ["normal", ...Rn()] }], "align-items": [{ items: [...In(), { baseline: ["", "last"] }] }], "align-self": [{ self: ["auto", ...In(), { baseline: ["", "last"] }] }], "place-content": [{ "place-content": Rn() }], "place-items": [{ "place-items": [...In(), "baseline"] }], "place-self": [{ "place-self": ["auto", ...In()] }], p: [{ p: on() }], px: [{ px: on() }], py: [{ py: on() }], ps: [{ ps: on() }], pe: [{ pe: on() }], pt: [{ pt: on() }], pr: [{ pr: on() }], pb: [{ pb: on() }], pl: [{ pl: on() }], m: [{ m: xn() }], mx: [{ mx: xn() }], my: [{ my: xn() }], ms: [{ ms: xn() }], me: [{ me: xn() }], mt: [{ mt: xn() }], mr: [{ mr: xn() }], mb: [{ mb: xn() }], ml: [{ ml: xn() }], "space-x": [{ "space-x": on() }], "space-x-reverse": ["space-x-reverse"], "space-y": [{ "space-y": on() }], "space-y-reverse": ["space-y-reverse"], size: [{ size: vn() }], w: [{ w: [Me, "screen", ...vn()] }], "min-w": [{ "min-w": [Me, "screen", "none", ...vn()] }], "max-w": [{ "max-w": [Me, "screen", "none", "prose", { screen: [Ce] }, ...vn()] }], h: [{ h: ["screen", "lh", ...vn()] }], "min-h": [{ "min-h": ["screen", "lh", "none", ...vn()] }], "max-h": [{ "max-h": ["screen", "lh", ...vn()] }], "font-size": [{ text: ["base", xe, isArbitraryVariableLength, isArbitraryLength] }], "font-smoothing": ["antialiased", "subpixel-antialiased"], "font-style": ["italic", "not-italic"], "font-weight": [{ font: [Ee, isArbitraryVariable, isArbitraryNumber] }], "font-stretch": [{ "font-stretch": ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded", isPercent, isArbitraryValue] }], "font-family": [{ font: [isArbitraryVariableFamilyName, isArbitraryValue, t] }], "fvn-normal": ["normal-nums"], "fvn-ordinal": ["ordinal"], "fvn-slashed-zero": ["slashed-zero"], "fvn-figure": ["lining-nums", "oldstyle-nums"], "fvn-spacing": ["proportional-nums", "tabular-nums"], "fvn-fraction": ["diagonal-fractions", "stacked-fractions"], tracking: [{ tracking: [_e, isArbitraryVariable, isArbitraryValue] }], "line-clamp": [{ "line-clamp": [isNumber$1, "none", isArbitraryVariable, isArbitraryNumber] }], leading: [{ leading: [Re, ...on()] }], "list-image": [{ "list-image": ["none", isArbitraryVariable, isArbitraryValue] }], "list-style-position": [{ list: ["inside", "outside"] }], "list-style-type": [{ list: ["disc", "decimal", "none", isArbitraryVariable, isArbitraryValue] }], "text-alignment": [{ text: ["left", "center", "right", "justify", "start", "end"] }], "placeholder-color": [{ placeholder: tn() }], "text-color": [{ text: tn() }], "text-decoration": ["underline", "overline", "line-through", "no-underline"], "text-decoration-style": [{ decoration: [...mn(), "wavy"] }], "text-decoration-thickness": [{ decoration: [isNumber$1, "from-font", "auto", isArbitraryVariable, isArbitraryLength] }], "text-decoration-color": [{ decoration: tn() }], "underline-offset": [{ "underline-offset": [isNumber$1, "auto", isArbitraryVariable, isArbitraryValue] }], "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"], "text-overflow": ["truncate", "text-ellipsis", "text-clip"], "text-wrap": [{ text: ["wrap", "nowrap", "balance", "pretty"] }], indent: [{ indent: on() }], "vertical-align": [{ align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryVariable, isArbitraryValue] }], whitespace: [{ whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"] }], break: [{ break: ["normal", "words", "all", "keep"] }], wrap: [{ wrap: ["break-word", "anywhere", "normal"] }], hyphens: [{ hyphens: ["none", "manual", "auto"] }], content: [{ content: ["none", isArbitraryVariable, isArbitraryValue] }], "bg-attachment": [{ bg: ["fixed", "local", "scroll"] }], "bg-clip": [{ "bg-clip": ["border", "padding", "content", "text"] }], "bg-origin": [{ "bg-origin": ["border", "padding", "content"] }], "bg-position": [{ bg: nn() }], "bg-repeat": [{ bg: We() }], "bg-size": [{ bg: dn() }], "bg-image": [{ bg: ["none", { linear: [{ to: ["t", "tr", "r", "br", "b", "bl", "l", "tl"] }, isInteger, isArbitraryVariable, isArbitraryValue], radial: ["", isArbitraryVariable, isArbitraryValue], conic: [isInteger, isArbitraryVariable, isArbitraryValue] }, isArbitraryVariableImage, isArbitraryImage] }], "bg-color": [{ bg: tn() }], "gradient-from-pos": [{ from: Je() }], "gradient-via-pos": [{ via: Je() }], "gradient-to-pos": [{ to: Je() }], "gradient-from": [{ from: tn() }], "gradient-via": [{ via: tn() }], "gradient-to": [{ to: tn() }], rounded: [{ rounded: rn() }], "rounded-s": [{ "rounded-s": rn() }], "rounded-e": [{ "rounded-e": rn() }], "rounded-t": [{ "rounded-t": rn() }], "rounded-r": [{ "rounded-r": rn() }], "rounded-b": [{ "rounded-b": rn() }], "rounded-l": [{ "rounded-l": rn() }], "rounded-ss": [{ "rounded-ss": rn() }], "rounded-se": [{ "rounded-se": rn() }], "rounded-ee": [{ "rounded-ee": rn() }], "rounded-es": [{ "rounded-es": rn() }], "rounded-tl": [{ "rounded-tl": rn() }], "rounded-tr": [{ "rounded-tr": rn() }], "rounded-br": [{ "rounded-br": rn() }], "rounded-bl": [{ "rounded-bl": rn() }], "border-w": [{ border: hn() }], "border-w-x": [{ "border-x": hn() }], "border-w-y": [{ "border-y": hn() }], "border-w-s": [{ "border-s": hn() }], "border-w-e": [{ "border-e": hn() }], "border-w-t": [{ "border-t": hn() }], "border-w-r": [{ "border-r": hn() }], "border-w-b": [{ "border-b": hn() }], "border-w-l": [{ "border-l": hn() }], "divide-x": [{ "divide-x": hn() }], "divide-x-reverse": ["divide-x-reverse"], "divide-y": [{ "divide-y": hn() }], "divide-y-reverse": ["divide-y-reverse"], "border-style": [{ border: [...mn(), "hidden", "none"] }], "divide-style": [{ divide: [...mn(), "hidden", "none"] }], "border-color": [{ border: tn() }], "border-color-x": [{ "border-x": tn() }], "border-color-y": [{ "border-y": tn() }], "border-color-s": [{ "border-s": tn() }], "border-color-e": [{ "border-e": tn() }], "border-color-t": [{ "border-t": tn() }], "border-color-r": [{ "border-r": tn() }], "border-color-b": [{ "border-b": tn() }], "border-color-l": [{ "border-l": tn() }], "divide-color": [{ divide: tn() }], "outline-style": [{ outline: [...mn(), "none", "hidden"] }], "outline-offset": [{ "outline-offset": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "outline-w": [{ outline: ["", isNumber$1, isArbitraryVariableLength, isArbitraryLength] }], "outline-color": [{ outline: tn() }], shadow: [{ shadow: ["", "none", Oe, isArbitraryVariableShadow, isArbitraryShadow] }], "shadow-color": [{ shadow: tn() }], "inset-shadow": [{ "inset-shadow": ["none", je, isArbitraryVariableShadow, isArbitraryShadow] }], "inset-shadow-color": [{ "inset-shadow": tn() }], "ring-w": [{ ring: hn() }], "ring-w-inset": ["ring-inset"], "ring-color": [{ ring: tn() }], "ring-offset-w": [{ "ring-offset": [isNumber$1, isArbitraryLength] }], "ring-offset-color": [{ "ring-offset": tn() }], "inset-ring-w": [{ "inset-ring": hn() }], "inset-ring-color": [{ "inset-ring": tn() }], "text-shadow": [{ "text-shadow": ["none", Be, isArbitraryVariableShadow, isArbitraryShadow] }], "text-shadow-color": [{ "text-shadow": tn() }], opacity: [{ opacity: [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "mix-blend": [{ "mix-blend": [...Ye(), "plus-darker", "plus-lighter"] }], "bg-blend": [{ "bg-blend": Ye() }], "mask-clip": [{ "mask-clip": ["border", "padding", "content", "fill", "stroke", "view"] }, "mask-no-clip"], "mask-composite": [{ mask: ["add", "subtract", "intersect", "exclude"] }], "mask-image-linear-pos": [{ "mask-linear": [isNumber$1] }], "mask-image-linear-from-pos": [{ "mask-linear-from": an() }], "mask-image-linear-to-pos": [{ "mask-linear-to": an() }], "mask-image-linear-from-color": [{ "mask-linear-from": tn() }], "mask-image-linear-to-color": [{ "mask-linear-to": tn() }], "mask-image-t-from-pos": [{ "mask-t-from": an() }], "mask-image-t-to-pos": [{ "mask-t-to": an() }], "mask-image-t-from-color": [{ "mask-t-from": tn() }], "mask-image-t-to-color": [{ "mask-t-to": tn() }], "mask-image-r-from-pos": [{ "mask-r-from": an() }], "mask-image-r-to-pos": [{ "mask-r-to": an() }], "mask-image-r-from-color": [{ "mask-r-from": tn() }], "mask-image-r-to-color": [{ "mask-r-to": tn() }], "mask-image-b-from-pos": [{ "mask-b-from": an() }], "mask-image-b-to-pos": [{ "mask-b-to": an() }], "mask-image-b-from-color": [{ "mask-b-from": tn() }], "mask-image-b-to-color": [{ "mask-b-to": tn() }], "mask-image-l-from-pos": [{ "mask-l-from": an() }], "mask-image-l-to-pos": [{ "mask-l-to": an() }], "mask-image-l-from-color": [{ "mask-l-from": tn() }], "mask-image-l-to-color": [{ "mask-l-to": tn() }], "mask-image-x-from-pos": [{ "mask-x-from": an() }], "mask-image-x-to-pos": [{ "mask-x-to": an() }], "mask-image-x-from-color": [{ "mask-x-from": tn() }], "mask-image-x-to-color": [{ "mask-x-to": tn() }], "mask-image-y-from-pos": [{ "mask-y-from": an() }], "mask-image-y-to-pos": [{ "mask-y-to": an() }], "mask-image-y-from-color": [{ "mask-y-from": tn() }], "mask-image-y-to-color": [{ "mask-y-to": tn() }], "mask-image-radial": [{ "mask-radial": [isArbitraryVariable, isArbitraryValue] }], "mask-image-radial-from-pos": [{ "mask-radial-from": an() }], "mask-image-radial-to-pos": [{ "mask-radial-to": an() }], "mask-image-radial-from-color": [{ "mask-radial-from": tn() }], "mask-image-radial-to-color": [{ "mask-radial-to": tn() }], "mask-image-radial-shape": [{ "mask-radial": ["circle", "ellipse"] }], "mask-image-radial-size": [{ "mask-radial": [{ closest: ["side", "corner"], farthest: ["side", "corner"] }] }], "mask-image-radial-pos": [{ "mask-radial-at": sn() }], "mask-image-conic-pos": [{ "mask-conic": [isNumber$1] }], "mask-image-conic-from-pos": [{ "mask-conic-from": an() }], "mask-image-conic-to-pos": [{ "mask-conic-to": an() }], "mask-image-conic-from-color": [{ "mask-conic-from": tn() }], "mask-image-conic-to-color": [{ "mask-conic-to": tn() }], "mask-mode": [{ mask: ["alpha", "luminance", "match"] }], "mask-origin": [{ "mask-origin": ["border", "padding", "content", "fill", "stroke", "view"] }], "mask-position": [{ mask: nn() }], "mask-repeat": [{ mask: We() }], "mask-size": [{ mask: dn() }], "mask-type": [{ "mask-type": ["alpha", "luminance"] }], "mask-image": [{ mask: ["none", isArbitraryVariable, isArbitraryValue] }], filter: [{ filter: ["", "none", isArbitraryVariable, isArbitraryValue] }], blur: [{ blur: pn() }], brightness: [{ brightness: [isNumber$1, isArbitraryVariable, isArbitraryValue] }], contrast: [{ contrast: [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "drop-shadow": [{ "drop-shadow": ["", "none", Ie, isArbitraryVariableShadow, isArbitraryShadow] }], "drop-shadow-color": [{ "drop-shadow": tn() }], grayscale: [{ grayscale: ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], "hue-rotate": [{ "hue-rotate": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], invert: [{ invert: ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], saturate: [{ saturate: [isNumber$1, isArbitraryVariable, isArbitraryValue] }], sepia: [{ sepia: ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-filter": [{ "backdrop-filter": ["", "none", isArbitraryVariable, isArbitraryValue] }], "backdrop-blur": [{ "backdrop-blur": pn() }], "backdrop-brightness": [{ "backdrop-brightness": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-contrast": [{ "backdrop-contrast": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-grayscale": [{ "backdrop-grayscale": ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-hue-rotate": [{ "backdrop-hue-rotate": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-invert": [{ "backdrop-invert": ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-opacity": [{ "backdrop-opacity": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-saturate": [{ "backdrop-saturate": [isNumber$1, isArbitraryVariable, isArbitraryValue] }], "backdrop-sepia": [{ "backdrop-sepia": ["", isNumber$1, isArbitraryVariable, isArbitraryValue] }], "border-collapse": [{ border: ["collapse", "separate"] }], "border-spacing": [{ "border-spacing": on() }], "border-spacing-x": [{ "border-spacing-x": on() }], "border-spacing-y": [{ "border-spacing-y": on() }], "table-layout": [{ table: ["auto", "fixed"] }], caption: [{ caption: ["top", "bottom"] }], transition: [{ transition: ["", "all", "colors", "opacity", "shadow", "transform", "none", isArbitraryVariable, isArbitraryValue] }], "transition-behavior": [{ transition: ["normal", "discrete"] }], duration: [{ duration: [isNumber$1, "initial", isArbitraryVariable, isArbitraryValue] }], ease: [{ ease: ["linear", "initial", He, isArbitraryVariable, isArbitraryValue] }], delay: [{ delay: [isNumber$1, isArbitraryVariable, isArbitraryValue] }], animate: [{ animate: ["none", Ge, isArbitraryVariable, isArbitraryValue] }], backface: [{ backface: ["hidden", "visible"] }], perspective: [{ perspective: [ze, isArbitraryVariable, isArbitraryValue] }], "perspective-origin": [{ "perspective-origin": Xe() }], rotate: [{ rotate: yn() }], "rotate-x": [{ "rotate-x": yn() }], "rotate-y": [{ "rotate-y": yn() }], "rotate-z": [{ "rotate-z": yn() }], scale: [{ scale: _n() }], "scale-x": [{ "scale-x": _n() }], "scale-y": [{ "scale-y": _n() }], "scale-z": [{ "scale-z": _n() }], "scale-3d": ["scale-3d"], skew: [{ skew: On() }], "skew-x": [{ "skew-x": On() }], "skew-y": [{ "skew-y": On() }], transform: [{ transform: [isArbitraryVariable, isArbitraryValue, "", "none", "gpu", "cpu"] }], "transform-origin": [{ origin: Xe() }], "transform-style": [{ transform: ["3d", "flat"] }], translate: [{ translate: kn() }], "translate-x": [{ "translate-x": kn() }], "translate-y": [{ "translate-y": kn() }], "translate-z": [{ "translate-z": kn() }], "translate-none": ["translate-none"], accent: [{ accent: tn() }], appearance: [{ appearance: ["none", "auto"] }], "caret-color": [{ caret: tn() }], "color-scheme": [{ scheme: ["normal", "dark", "light", "light-dark", "only-dark", "only-light"] }], cursor: [{ cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryVariable, isArbitraryValue] }], "field-sizing": [{ "field-sizing": ["fixed", "content"] }], "pointer-events": [{ "pointer-events": ["auto", "none"] }], resize: [{ resize: ["none", "", "y", "x"] }], "scroll-behavior": [{ scroll: ["auto", "smooth"] }], "scroll-m": [{ "scroll-m": on() }], "scroll-mx": [{ "scroll-mx": on() }], "scroll-my": [{ "scroll-my": on() }], "scroll-ms": [{ "scroll-ms": on() }], "scroll-me": [{ "scroll-me": on() }], "scroll-mt": [{ "scroll-mt": on() }], "scroll-mr": [{ "scroll-mr": on() }], "scroll-mb": [{ "scroll-mb": on() }], "scroll-ml": [{ "scroll-ml": on() }], "scroll-p": [{ "scroll-p": on() }], "scroll-px": [{ "scroll-px": on() }], "scroll-py": [{ "scroll-py": on() }], "scroll-ps": [{ "scroll-ps": on() }], "scroll-pe": [{ "scroll-pe": on() }], "scroll-pt": [{ "scroll-pt": on() }], "scroll-pr": [{ "scroll-pr": on() }], "scroll-pb": [{ "scroll-pb": on() }], "scroll-pl": [{ "scroll-pl": on() }], "snap-align": [{ snap: ["start", "end", "center", "align-none"] }], "snap-stop": [{ snap: ["normal", "always"] }], "snap-type": [{ snap: ["none", "x", "y", "both"] }], "snap-strictness": [{ snap: ["mandatory", "proximity"] }], touch: [{ touch: ["auto", "none", "manipulation"] }], "touch-x": [{ "touch-pan": ["x", "left", "right"] }], "touch-y": [{ "touch-pan": ["y", "up", "down"] }], "touch-pz": ["touch-pinch-zoom"], select: [{ select: ["none", "text", "all", "auto"] }], "will-change": [{ "will-change": ["auto", "scroll", "contents", "transform", isArbitraryVariable, isArbitraryValue] }], fill: [{ fill: ["none", ...tn()] }], "stroke-w": [{ stroke: [isNumber$1, isArbitraryVariableLength, isArbitraryLength, isArbitraryNumber] }], stroke: [{ stroke: ["none", ...tn()] }], "forced-color-adjust": [{ "forced-color-adjust": ["auto", "none"] }] }, conflictingClassGroups: { overflow: ["overflow-x", "overflow-y"], overscroll: ["overscroll-x", "overscroll-y"], inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"], "inset-x": ["right", "left"], "inset-y": ["top", "bottom"], flex: ["basis", "grow", "shrink"], gap: ["gap-x", "gap-y"], p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"], px: ["pr", "pl"], py: ["pt", "pb"], m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"], mx: ["mr", "ml"], my: ["mt", "mb"], size: ["w", "h"], "font-size": ["leading"], "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"], "fvn-ordinal": ["fvn-normal"], "fvn-slashed-zero": ["fvn-normal"], "fvn-figure": ["fvn-normal"], "fvn-spacing": ["fvn-normal"], "fvn-fraction": ["fvn-normal"], "line-clamp": ["display", "overflow"], rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"], "rounded-s": ["rounded-ss", "rounded-es"], "rounded-e": ["rounded-se", "rounded-ee"], "rounded-t": ["rounded-tl", "rounded-tr"], "rounded-r": ["rounded-tr", "rounded-br"], "rounded-b": ["rounded-br", "rounded-bl"], "rounded-l": ["rounded-tl", "rounded-bl"], "border-spacing": ["border-spacing-x", "border-spacing-y"], "border-w": ["border-w-x", "border-w-y", "border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"], "border-w-x": ["border-w-r", "border-w-l"], "border-w-y": ["border-w-t", "border-w-b"], "border-color": ["border-color-x", "border-color-y", "border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"], "border-color-x": ["border-color-r", "border-color-l"], "border-color-y": ["border-color-t", "border-color-b"], translate: ["translate-x", "translate-y", "translate-none"], "translate-none": ["translate", "translate-x", "translate-y", "translate-z"], "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"], "scroll-mx": ["scroll-mr", "scroll-ml"], "scroll-my": ["scroll-mt", "scroll-mb"], "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"], "scroll-px": ["scroll-pr", "scroll-pl"], "scroll-py": ["scroll-pt", "scroll-pb"], touch: ["touch-x", "touch-y", "touch-pz"], "touch-x": ["touch"], "touch-y": ["touch"], "touch-pz": ["touch"] }, conflictingClassGroupModifiers: { "font-size": ["leading"] }, orderSensitiveModifiers: ["*", "**", "after", "backdrop", "before", "details-content", "file", "first-letter", "first-line", "marker", "placeholder", "selection"] } }, twMerge = createTailwindMerge(getDefaultConfig); function cn$1(...e) { return twMerge(clsx(e)) } const buttonVariants = cva("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", { variants: { variant: { default: "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90", destructive: "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50", secondary: "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80", ghost: "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50", link: "text-primary underline-offset-4 hover:underline" }, size: { default: "h-9 px-4 py-2 has-[>svg]:px-3", sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5", lg: "h-10 rounded-md px-6 has-[>svg]:px-4", icon: "size-9" } }, defaultVariants: { variant: "default", size: "default" } }); function Button({ className: e, variant: t, size: xe, asChild: Ee = !1, ..._e }) { const Re = Ee ? Slot$3 : "button"; return jsxRuntimeExports.jsx(Re, { "data-slot": "button", className: cn$1(buttonVariants({ variant: t, size: xe, className: e })), ..._e }) } const useForm = e => { const [t, xe] = reactExports.useState(e), [Ee, _e] = reactExports.useState({}); return { formData: t, handleChange: Me => { const { name: De, value: Pe } = Me.target; xe(Oe => ({ ...Oe, [De]: Pe })), _e(Oe => ({ ...Oe, [De]: "" })) }, handleFileChange: (Me, De) => { const Pe = Me.target.files[0]; xe(Oe => ({ ...Oe, [De]: Pe })), _e(Oe => ({ ...Oe, [De]: "" })) }, errors: Ee, setErrors: _e } }; function __insertCSS(e) { if (typeof document > "u") return; let t = document.head || document.getElementsByTagName("head")[0], xe = document.createElement("style"); xe.type = "text/css", t.appendChild(xe), xe.styleSheet ? xe.styleSheet.cssText = e : xe.appendChild(document.createTextNode(e)) } const getAsset = e => { switch (e) { case "success": return SuccessIcon; case "info": return InfoIcon; case "warning": return WarningIcon; case "error": return ErrorIcon; default: return null } }, bars = Array(12).fill(0), Loader = ({ visible: e, className: t }) => React.createElement("div", { className: ["sonner-loading-wrapper", t].filter(Boolean).join(" "), "data-visible": e }, React.createElement("div", { className: "sonner-spinner" }, bars.map((xe, Ee) => React.createElement("div", { className: "sonner-loading-bar", key: `spinner-bar-${Ee}` })))), SuccessIcon = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z", clipRule: "evenodd" })), WarningIcon = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z", clipRule: "evenodd" })), InfoIcon = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z", clipRule: "evenodd" })), ErrorIcon = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 20 20", fill: "currentColor", height: "20", width: "20" }, React.createElement("path", { fillRule: "evenodd", d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z", clipRule: "evenodd" })), CloseIcon = React.createElement("svg", { xmlns: "http://www.w3.org/2000/svg", width: "12", height: "12", viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }, React.createElement("line", { x1: "18", y1: "6", x2: "6", y2: "18" }), React.createElement("line", { x1: "6", y1: "6", x2: "18", y2: "18" })), useIsDocumentHidden = () => { const [e, t] = React.useState(document.hidden); return React.useEffect(() => { const xe = () => { t(document.hidden) }; return document.addEventListener("visibilitychange", xe), () => window.removeEventListener("visibilitychange", xe) }, []), e }; let toastsCounter = 1; class Observer { constructor() { this.subscribe = t => (this.subscribers.push(t), () => { const xe = this.subscribers.indexOf(t); this.subscribers.splice(xe, 1) }), this.publish = t => { this.subscribers.forEach(xe => xe(t)) }, this.addToast = t => { this.publish(t), this.toasts = [...this.toasts, t] }, this.create = t => { var xe; const { message: Ee, ..._e } = t, Re = typeof t?.id == "number" || ((xe = t.id) == null ? void 0 : xe.length) > 0 ? t.id : toastsCounter++, Ce = this.toasts.find(De => De.id === Re), Me = t.dismissible === void 0 ? !0 : t.dismissible; return this.dismissedToasts.has(Re) && this.dismissedToasts.delete(Re), Ce ? this.toasts = this.toasts.map(De => De.id === Re ? (this.publish({ ...De, ...t, id: Re, title: Ee }), { ...De, ...t, id: Re, dismissible: Me, title: Ee }) : De) : this.addToast({ title: Ee, ..._e, dismissible: Me, id: Re }), Re }, this.dismiss = t => (t ? (this.dismissedToasts.add(t), requestAnimationFrame(() => this.subscribers.forEach(xe => xe({ id: t, dismiss: !0 })))) : this.toasts.forEach(xe => { this.subscribers.forEach(Ee => Ee({ id: xe.id, dismiss: !0 })) }), t), this.message = (t, xe) => this.create({ ...xe, message: t }), this.error = (t, xe) => this.create({ ...xe, message: t, type: "error" }), this.success = (t, xe) => this.create({ ...xe, type: "success", message: t }), this.info = (t, xe) => this.create({ ...xe, type: "info", message: t }), this.warning = (t, xe) => this.create({ ...xe, type: "warning", message: t }), this.loading = (t, xe) => this.create({ ...xe, type: "loading", message: t }), this.promise = (t, xe) => { if (!xe) return; let Ee; xe.loading !== void 0 && (Ee = this.create({ ...xe, promise: t, type: "loading", message: xe.loading, description: typeof xe.description != "function" ? xe.description : void 0 })); const _e = Promise.resolve(t instanceof Function ? t() : t); let Re = Ee !== void 0, Ce; const Me = _e.then(async Pe => { if (Ce = ["resolve", Pe], React.isValidElement(Pe)) Re = !1, this.create({ id: Ee, type: "default", message: Pe }); else if (isHttpResponse(Pe) && !Pe.ok) { Re = !1; const je = typeof xe.error == "function" ? await xe.error(`HTTP error! status: ${Pe.status}`) : xe.error, Be = typeof xe.description == "function" ? await xe.description(`HTTP error! status: ${Pe.status}`) : xe.description, Fe = typeof je == "object" && !React.isValidElement(je) ? je : { message: je }; this.create({ id: Ee, type: "error", description: Be, ...Fe }) } else if (Pe instanceof Error) { Re = !1; const je = typeof xe.error == "function" ? await xe.error(Pe) : xe.error, Be = typeof xe.description == "function" ? await xe.description(Pe) : xe.description, Fe = typeof je == "object" && !React.isValidElement(je) ? je : { message: je }; this.create({ id: Ee, type: "error", description: Be, ...Fe }) } else if (xe.success !== void 0) { Re = !1; const je = typeof xe.success == "function" ? await xe.success(Pe) : xe.success, Be = typeof xe.description == "function" ? await xe.description(Pe) : xe.description, Fe = typeof je == "object" && !React.isValidElement(je) ? je : { message: je }; this.create({ id: Ee, type: "success", description: Be, ...Fe }) } }).catch(async Pe => { if (Ce = ["reject", Pe], xe.error !== void 0) { Re = !1; const Oe = typeof xe.error == "function" ? await xe.error(Pe) : xe.error, je = typeof xe.description == "function" ? await xe.description(Pe) : xe.description, Ie = typeof Oe == "object" && !React.isValidElement(Oe) ? Oe : { message: Oe }; this.create({ id: Ee, type: "error", description: je, ...Ie }) } }).finally(() => { Re && (this.dismiss(Ee), Ee = void 0), xe.finally == null || xe.finally.call(xe) }), De = () => new Promise((Pe, Oe) => Me.then(() => Ce[0] === "reject" ? Oe(Ce[1]) : Pe(Ce[1])).catch(Oe)); return typeof Ee != "string" && typeof Ee != "number" ? { unwrap: De } : Object.assign(Ee, { unwrap: De }) }, this.custom = (t, xe) => { const Ee = xe?.id || toastsCounter++; return this.create({ jsx: t(Ee), id: Ee, ...xe }), Ee }, this.getActiveToasts = () => this.toasts.filter(t => !this.dismissedToasts.has(t.id)), this.subscribers = [], this.toasts = [], this.dismissedToasts = new Set } } const ToastState = new Observer, toastFunction = (e, t) => { const xe = t?.id || toastsCounter++; return ToastState.addToast({ title: e, ...t, id: xe }), xe }, isHttpResponse = e => e && typeof e == "object" && "ok" in e && typeof e.ok == "boolean" && "status" in e && typeof e.status == "number", basicToast = toastFunction, getHistory = () => ToastState.toasts, getToasts = () => ToastState.getActiveToasts(), toast = Object.assign(basicToast, { success: ToastState.success, info: ToastState.info, warning: ToastState.warning, error: ToastState.error, custom: ToastState.custom, message: ToastState.message, promise: ToastState.promise, dismiss: ToastState.dismiss, loading: ToastState.loading }, { getHistory, getToasts }); __insertCSS("[data-sonner-toaster][dir=ltr],html[dir=ltr]{--toast-icon-margin-start:-3px;--toast-icon-margin-end:4px;--toast-svg-margin-start:-1px;--toast-svg-margin-end:0px;--toast-button-margin-start:auto;--toast-button-margin-end:0;--toast-close-button-start:0;--toast-close-button-end:unset;--toast-close-button-transform:translate(-35%, -35%)}[data-sonner-toaster][dir=rtl],html[dir=rtl]{--toast-icon-margin-start:4px;--toast-icon-margin-end:-3px;--toast-svg-margin-start:0px;--toast-svg-margin-end:-1px;--toast-button-margin-start:0;--toast-button-margin-end:auto;--toast-close-button-start:unset;--toast-close-button-end:0;--toast-close-button-transform:translate(35%, -35%)}[data-sonner-toaster]{position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1:hsl(0, 0%, 99%);--gray2:hsl(0, 0%, 97.3%);--gray3:hsl(0, 0%, 95.1%);--gray4:hsl(0, 0%, 93%);--gray5:hsl(0, 0%, 90.9%);--gray6:hsl(0, 0%, 88.7%);--gray7:hsl(0, 0%, 85.8%);--gray8:hsl(0, 0%, 78%);--gray9:hsl(0, 0%, 56.1%);--gray10:hsl(0, 0%, 52.3%);--gray11:hsl(0, 0%, 43.5%);--gray12:hsl(0, 0%, 9%);--border-radius:8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:0;z-index:999999999;transition:transform .4s ease}@media (hover:none) and (pointer:coarse){[data-sonner-toaster][data-lifted=true]{transform:none}}[data-sonner-toaster][data-x-position=right]{right:var(--offset-right)}[data-sonner-toaster][data-x-position=left]{left:var(--offset-left)}[data-sonner-toaster][data-x-position=center]{left:50%;transform:translateX(-50%)}[data-sonner-toaster][data-y-position=top]{top:var(--offset-top)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--offset-bottom)}[data-sonner-toast]{--y:translateY(100%);--lift-amount:calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:0;overflow-wrap:anywhere}[data-sonner-toast][data-styled=true]{padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px rgba(0,0,0,.1);width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}[data-sonner-toast]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-y-position=top]{top:0;--y:translateY(-100%);--lift:1;--lift-amount:calc(1 * var(--gap))}[data-sonner-toast][data-y-position=bottom]{bottom:0;--y:translateY(100%);--lift:-1;--lift-amount:calc(var(--lift) * var(--gap))}[data-sonner-toast][data-styled=true] [data-description]{font-weight:400;line-height:1.4;color:#3f3f3f}[data-rich-colors=true][data-sonner-toast][data-styled=true] [data-description]{color:inherit}[data-sonner-toaster][data-sonner-theme=dark] [data-description]{color:#e8e8e8}[data-sonner-toast][data-styled=true] [data-title]{font-weight:500;line-height:1.5;color:inherit}[data-sonner-toast][data-styled=true] [data-icon]{display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}[data-sonner-toast][data-promise=true] [data-icon]>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}[data-sonner-toast][data-styled=true] [data-icon]>*{flex-shrink:0}[data-sonner-toast][data-styled=true] [data-icon] svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}[data-sonner-toast][data-styled=true] [data-content]{display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;font-weight:500;cursor:pointer;outline:0;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}[data-sonner-toast][data-styled=true] [data-button]:focus-visible{box-shadow:0 0 0 2px rgba(0,0,0,.4)}[data-sonner-toast][data-styled=true] [data-button]:first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}[data-sonner-toast][data-styled=true] [data-cancel]{color:var(--normal-text);background:rgba(0,0,0,.08)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-styled=true] [data-cancel]{background:rgba(255,255,255,.3)}[data-sonner-toast][data-styled=true] [data-close-button]{position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);background:var(--normal-bg);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast][data-styled=true] [data-close-button]:focus-visible{box-shadow:0 4px 12px rgba(0,0,0,.1),0 0 0 2px rgba(0,0,0,.2)}[data-sonner-toast][data-styled=true] [data-disabled=true]{cursor:not-allowed}[data-sonner-toast][data-styled=true]:hover [data-close-button]:hover{background:var(--gray2);border-color:var(--gray5)}[data-sonner-toast][data-swiping=true]::before{content:'';position:absolute;left:-100%;right:-100%;height:100%;z-index:-1}[data-sonner-toast][data-y-position=top][data-swiping=true]::before{bottom:50%;transform:scaleY(3) translateY(50%)}[data-sonner-toast][data-y-position=bottom][data-swiping=true]::before{top:50%;transform:scaleY(3) translateY(-50%)}[data-sonner-toast][data-swiping=false][data-removed=true]::before{content:'';position:absolute;inset:0;transform:scaleY(2)}[data-sonner-toast][data-expanded=true]::after{content:'';position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}[data-sonner-toast][data-mounted=true]{--y:translateY(0);opacity:1}[data-sonner-toast][data-expanded=false][data-front=false]{--scale:var(--toasts-before) * 0.05 + 1;--y:translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}[data-sonner-toast]>*{transition:opacity .4s}[data-sonner-toast][data-x-position=right]{right:0}[data-sonner-toast][data-x-position=left]{left:0}[data-sonner-toast][data-expanded=false][data-front=false][data-styled=true]>*{opacity:0}[data-sonner-toast][data-visible=false]{opacity:0;pointer-events:none}[data-sonner-toast][data-mounted=true][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}[data-sonner-toast][data-removed=true][data-front=true][data-swipe-out=false]{--y:translateY(calc(var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=true]{--y:translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}[data-sonner-toast][data-removed=true][data-front=false][data-swipe-out=false][data-expanded=false]{--y:translateY(40%);opacity:0;transition:transform .5s,opacity .2s}[data-sonner-toast][data-removed=true][data-front=false]::before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y,0)) translateX(var(--swipe-amount-x,0));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{from{transform:var(--y) translateX(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translateX(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{from{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width:600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-sonner-theme=light]{--normal-bg:#fff;--normal-border:var(--gray4);--normal-text:var(--gray12);--success-bg:hsl(143, 85%, 96%);--success-border:hsl(145, 92%, 87%);--success-text:hsl(140, 100%, 27%);--info-bg:hsl(208, 100%, 97%);--info-border:hsl(221, 91%, 93%);--info-text:hsl(210, 92%, 45%);--warning-bg:hsl(49, 100%, 97%);--warning-border:hsl(49, 91%, 84%);--warning-text:hsl(31, 92%, 45%);--error-bg:hsl(359, 100%, 97%);--error-border:hsl(359, 100%, 94%);--error-text:hsl(360, 100%, 45%)}[data-sonner-toaster][data-sonner-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg:#000;--normal-border:hsl(0, 0%, 20%);--normal-text:var(--gray1)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg:#fff;--normal-border:var(--gray3);--normal-text:var(--gray12)}[data-sonner-toaster][data-sonner-theme=dark]{--normal-bg:#000;--normal-bg-hover:hsl(0, 0%, 12%);--normal-border:hsl(0, 0%, 20%);--normal-border-hover:hsl(0, 0%, 25%);--normal-text:var(--gray1);--success-bg:hsl(150, 100%, 6%);--success-border:hsl(147, 100%, 12%);--success-text:hsl(150, 86%, 65%);--info-bg:hsl(215, 100%, 6%);--info-border:hsl(223, 43%, 17%);--info-text:hsl(216, 87%, 65%);--warning-bg:hsl(64, 100%, 6%);--warning-border:hsl(60, 100%, 9%);--warning-text:hsl(46, 87%, 65%);--error-bg:hsl(358, 76%, 10%);--error-border:hsl(357, 89%, 16%);--error-text:hsl(358, 100%, 81%)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-sonner-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size:16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:first-child{animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}100%{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}100%{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}100%{opacity:.15}}@media (prefers-reduced-motion){.sonner-loading-bar,[data-sonner-toast],[data-sonner-toast]>*{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}"); function isAction(e) { return e.label !== void 0 } const VISIBLE_TOASTS_AMOUNT = 3, VIEWPORT_OFFSET = "24px", MOBILE_VIEWPORT_OFFSET = "16px", TOAST_LIFETIME = 4e3, TOAST_WIDTH = 356, GAP = 14, SWIPE_THRESHOLD = 45, TIME_BEFORE_UNMOUNT = 200; function cn(...e) { return e.filter(Boolean).join(" ") } function getDefaultSwipeDirections(e) { const [t, xe] = e.split("-"), Ee = []; return t && Ee.push(t), xe && Ee.push(xe), Ee } const Toast = e => { var t, xe, Ee, _e, Re, Ce, Me, De, Pe; const { invert: Oe, toast: je, unstyled: Be, interacting: Ie, setHeights: Fe, visibleToasts: ze, heights: qe, index: He, toasts: Ge, expanded: Ze, removeToast: sn, defaultRichColors: Xe, closeButton: St, style: un, cancelButtonStyle: on, actionButtonStyle: bn, className: Tn = "", descriptionClassName: fn = "", duration: En, position: Pn, gap: Rn, expandByDefault: In, classNames: xn, icons: vn, closeButtonAriaLabel: tn = "Close toast" } = e, [nn, We] = React.useState(null), [dn, Je] = React.useState(null), [rn, hn] = React.useState(!1), [mn, Ye] = React.useState(!1), [an, pn] = React.useState(!1), [yn, _n] = React.useState(!1), [On, kn] = React.useState(!1), [zn, sr] = React.useState(0), [Fn, Cn] = React.useState(0), Vn = React.useRef(je.duration || En || TOAST_LIFETIME), Yn = React.useRef(null), qn = React.useRef(null), rr = He === 0, hr = He + 1 <= ze, ur = je.type, Er = je.dismissible !== !1, _r = je.className || "", Or = je.descriptionClassName || "", Ir = React.useMemo(() => qe.findIndex(Ar => Ar.toastId === je.id) || 0, [qe, je.id]), Dr = React.useMemo(() => { var Ar; return (Ar = je.closeButton) != null ? Ar : St }, [je.closeButton, St]), Wr = React.useMemo(() => je.duration || En || TOAST_LIFETIME, [je.duration, En]), Cr = React.useRef(0), zr = React.useRef(0), Tr = React.useRef(0), wi = React.useRef(null), [Jr, mr] = Pn.split("-"), Kn = React.useMemo(() => qe.reduce((Ar, Ur, hi) => hi >= Ir ? Ar : Ar + Ur.height, 0), [qe, Ir]), Qn = useIsDocumentHidden(), Rr = je.invert || Oe, kr = ur === "loading"; zr.current = React.useMemo(() => Ir * Rn + Kn, [Ir, Kn]), React.useEffect(() => { Vn.current = Wr }, [Wr]), React.useEffect(() => { hn(!0) }, []), React.useEffect(() => { const Ar = qn.current; if (Ar) { const Ur = Ar.getBoundingClientRect().height; return Cn(Ur), Fe(hi => [{ toastId: je.id, height: Ur, position: je.position }, ...hi]), () => Fe(hi => hi.filter(ii => ii.toastId !== je.id)) } }, [Fe, je.id]), React.useLayoutEffect(() => { if (!rn) return; const Ar = qn.current, Ur = Ar.style.height; Ar.style.height = "auto"; const hi = Ar.getBoundingClientRect().height; Ar.style.height = Ur, Cn(hi), Fe(ii => ii.find(yi => yi.toastId === je.id) ? ii.map(yi => yi.toastId === je.id ? { ...yi, height: hi } : yi) : [{ toastId: je.id, height: hi, position: je.position }, ...ii]) }, [rn, je.title, je.description, Fe, je.id, je.jsx, je.action, je.cancel]); const di = React.useCallback(() => { Ye(!0), sr(zr.current), Fe(Ar => Ar.filter(Ur => Ur.toastId !== je.id)), setTimeout(() => { sn(je) }, TIME_BEFORE_UNMOUNT) }, [je, sn, Fe, zr]); React.useEffect(() => { if (je.promise && ur === "loading" || je.duration === 1 / 0 || je.type === "loading") return; let Ar; return Ze || Ie || Qn ? (() => { if (Tr.current < Cr.current) { const ii = new Date().getTime() - Cr.current; Vn.current = Vn.current - ii } Tr.current = new Date().getTime() })() : (() => { Vn.current !== 1 / 0 && (Cr.current = new Date().getTime(), Ar = setTimeout(() => { je.onAutoClose == null || je.onAutoClose.call(je, je), di() }, Vn.current)) })(), () => clearTimeout(Ar) }, [Ze, Ie, je, ur, Qn, di]), React.useEffect(() => { je.delete && (di(), je.onDismiss == null || je.onDismiss.call(je, je)) }, [di, je.delete]); function ei() { var Ar; if (vn?.loading) { var Ur; return React.createElement("div", { className: cn(xn?.loader, je == null || (Ur = je.classNames) == null ? void 0 : Ur.loader, "sonner-loader"), "data-visible": ur === "loading" }, vn.loading) } return React.createElement(Loader, { className: cn(xn?.loader, je == null || (Ar = je.classNames) == null ? void 0 : Ar.loader), visible: ur === "loading" }) } const Wi = je.icon || vn?.[ur] || getAsset(ur); var $i, xi; return React.createElement("li", { tabIndex: 0, ref: qn, className: cn(Tn, _r, xn?.toast, je == null || (t = je.classNames) == null ? void 0 : t.toast, xn?.default, xn?.[ur], je == null || (xe = je.classNames) == null ? void 0 : xe[ur]), "data-sonner-toast": "", "data-rich-colors": ($i = je.richColors) != null ? $i : Xe, "data-styled": !(je.jsx || je.unstyled || Be), "data-mounted": rn, "data-promise": !!je.promise, "data-swiped": On, "data-removed": mn, "data-visible": hr, "data-y-position": Jr, "data-x-position": mr, "data-index": He, "data-front": rr, "data-swiping": an, "data-dismissible": Er, "data-type": ur, "data-invert": Rr, "data-swipe-out": yn, "data-swipe-direction": dn, "data-expanded": !!(Ze || In && rn), style: { "--index": He, "--toasts-before": He, "--z-index": Ge.length - He, "--offset": `${mn ? zn : zr.current}px`, "--initial-height": In ? "auto" : `${Fn}px`, ...un, ...je.style }, onDragEnd: () => { pn(!1), We(null), wi.current = null }, onPointerDown: Ar => { Ar.button !== 2 && (kr || !Er || (Yn.current = new Date, sr(zr.current), Ar.target.setPointerCapture(Ar.pointerId), Ar.target.tagName !== "BUTTON" && (pn(!0), wi.current = { x: Ar.clientX, y: Ar.clientY }))) }, onPointerUp: () => { var Ar, Ur, hi; if (yn || !Er) return; wi.current = null; const ii = Number(((Ar = qn.current) == null ? void 0 : Ar.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0), fi = Number(((Ur = qn.current) == null ? void 0 : Ur.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0), yi = new Date().getTime() - ((hi = Yn.current) == null ? void 0 : hi.getTime()), Lr = nn === "x" ? ii : fi, pi = Math.abs(Lr) / yi; if (Math.abs(Lr) >= SWIPE_THRESHOLD || pi > .11) { sr(zr.current), je.onDismiss == null || je.onDismiss.call(je, je), Je(nn === "x" ? ii > 0 ? "right" : "left" : fi > 0 ? "down" : "up"), di(), _n(!0); return } else { var ni, oi; (ni = qn.current) == null || ni.style.setProperty("--swipe-amount-x", "0px"), (oi = qn.current) == null || oi.style.setProperty("--swipe-amount-y", "0px") } kn(!1), pn(!1), We(null) }, onPointerMove: Ar => { var Ur, hi, ii; if (!wi.current || !Er || ((Ur = window.getSelection()) == null ? void 0 : Ur.toString().length) > 0) return; const yi = Ar.clientY - wi.current.y, Lr = Ar.clientX - wi.current.x; var pi; const ni = (pi = e.swipeDirections) != null ? pi : getDefaultSwipeDirections(Pn); !nn && (Math.abs(Lr) > 1 || Math.abs(yi) > 1) && We(Math.abs(Lr) > Math.abs(yi) ? "x" : "y"); let oi = { x: 0, y: 0 }; const si = bi => 1 / (1.5 + Math.abs(bi) / 20); if (nn === "y") { if (ni.includes("top") || ni.includes("bottom")) if (ni.includes("top") && yi < 0 || ni.includes("bottom") && yi > 0) oi.y = yi; else { const bi = yi * si(yi); oi.y = Math.abs(bi) < Math.abs(yi) ? bi : yi } } else if (nn === "x" && (ni.includes("left") || ni.includes("right"))) if (ni.includes("left") && Lr < 0 || ni.includes("right") && Lr > 0) oi.x = Lr; else { const bi = Lr * si(Lr); oi.x = Math.abs(bi) < Math.abs(Lr) ? bi : Lr } (Math.abs(oi.x) > 0 || Math.abs(oi.y) > 0) && kn(!0), (hi = qn.current) == null || hi.style.setProperty("--swipe-amount-x", `${oi.x}px`), (ii = qn.current) == null || ii.style.setProperty("--swipe-amount-y", `${oi.y}px`) } }, Dr && !je.jsx && ur !== "loading" ? React.createElement("button", { "aria-label": tn, "data-disabled": kr, "data-close-button": !0, onClick: kr || !Er ? () => { } : () => { di(), je.onDismiss == null || je.onDismiss.call(je, je) }, className: cn(xn?.closeButton, je == null || (Ee = je.classNames) == null ? void 0 : Ee.closeButton) }, (xi = vn?.close) != null ? xi : CloseIcon) : null, (ur || je.icon || je.promise) && je.icon !== null && (vn?.[ur] !== null || je.icon) ? React.createElement("div", { "data-icon": "", className: cn(xn?.icon, je == null || (_e = je.classNames) == null ? void 0 : _e.icon) }, je.promise || je.type === "loading" && !je.icon ? je.icon || ei() : null, je.type !== "loading" ? Wi : null) : null, React.createElement("div", { "data-content": "", className: cn(xn?.content, je == null || (Re = je.classNames) == null ? void 0 : Re.content) }, React.createElement("div", { "data-title": "", className: cn(xn?.title, je == null || (Ce = je.classNames) == null ? void 0 : Ce.title) }, je.jsx ? je.jsx : typeof je.title == "function" ? je.title() : je.title), je.description ? React.createElement("div", { "data-description": "", className: cn(fn, Or, xn?.description, je == null || (Me = je.classNames) == null ? void 0 : Me.description) }, typeof je.description == "function" ? je.description() : je.description) : null), React.isValidElement(je.cancel) ? je.cancel : je.cancel && isAction(je.cancel) ? React.createElement("button", { "data-button": !0, "data-cancel": !0, style: je.cancelButtonStyle || on, onClick: Ar => { isAction(je.cancel) && Er && (je.cancel.onClick == null || je.cancel.onClick.call(je.cancel, Ar), di()) }, className: cn(xn?.cancelButton, je == null || (De = je.classNames) == null ? void 0 : De.cancelButton) }, je.cancel.label) : null, React.isValidElement(je.action) ? je.action : je.action && isAction(je.action) ? React.createElement("button", { "data-button": !0, "data-action": !0, style: je.actionButtonStyle || bn, onClick: Ar => { isAction(je.action) && (je.action.onClick == null || je.action.onClick.call(je.action, Ar), !Ar.defaultPrevented && di()) }, className: cn(xn?.actionButton, je == null || (Pe = je.classNames) == null ? void 0 : Pe.actionButton) }, je.action.label) : null) }; function getDocumentDirection() { if (typeof window > "u" || typeof document > "u") return "ltr"; const e = document.documentElement.getAttribute("dir"); return e === "auto" || !e ? window.getComputedStyle(document.documentElement).direction : e } function assignOffset(e, t) { const xe = {}; return [e, t].forEach((Ee, _e) => { const Re = _e === 1, Ce = Re ? "--mobile-offset" : "--offset", Me = Re ? MOBILE_VIEWPORT_OFFSET : VIEWPORT_OFFSET; function De(Pe) { ["top", "right", "bottom", "left"].forEach(Oe => { xe[`${Ce}-${Oe}`] = typeof Pe == "number" ? `${Pe}px` : Pe }) } typeof Ee == "number" || typeof Ee == "string" ? De(Ee) : typeof Ee == "object" ? ["top", "right", "bottom", "left"].forEach(Pe => { Ee[Pe] === void 0 ? xe[`${Ce}-${Pe}`] = Me : xe[`${Ce}-${Pe}`] = typeof Ee[Pe] == "number" ? `${Ee[Pe]}px` : Ee[Pe] }) : De(Me) }), xe } const Toaster = React.forwardRef(function (t, xe) { const { invert: Ee, position: _e = "bottom-right", hotkey: Re = ["altKey", "KeyT"], expand: Ce, closeButton: Me, className: De, offset: Pe, mobileOffset: Oe, theme: je = "light", richColors: Be, duration: Ie, style: Fe, visibleToasts: ze = VISIBLE_TOASTS_AMOUNT, toastOptions: qe, dir: He = getDocumentDirection(), gap: Ge = GAP, icons: Ze, containerAriaLabel: sn = "Notifications" } = t, [Xe, St] = React.useState([]), un = React.useMemo(() => Array.from(new Set([_e].concat(Xe.filter(dn => dn.position).map(dn => dn.position)))), [Xe, _e]), [on, bn] = React.useState([]), [Tn, fn] = React.useState(!1), [En, Pn] = React.useState(!1), [Rn, In] = React.useState(je !== "system" ? je : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"), xn = React.useRef(null), vn = Re.join("+").replace(/Key/g, "").replace(/Digit/g, ""), tn = React.useRef(null), nn = React.useRef(!1), We = React.useCallback(dn => { St(Je => { var rn; return (rn = Je.find(hn => hn.id === dn.id)) != null && rn.delete || ToastState.dismiss(dn.id), Je.filter(({ id: hn }) => hn !== dn.id) }) }, []); return React.useEffect(() => ToastState.subscribe(dn => { if (dn.dismiss) { requestAnimationFrame(() => { St(Je => Je.map(rn => rn.id === dn.id ? { ...rn, delete: !0 } : rn)) }); return } setTimeout(() => { ReactDOM.flushSync(() => { St(Je => { const rn = Je.findIndex(hn => hn.id === dn.id); return rn !== -1 ? [...Je.slice(0, rn), { ...Je[rn], ...dn }, ...Je.slice(rn + 1)] : [dn, ...Je] }) }) }) }), [Xe]), React.useEffect(() => { if (je !== "system") { In(je); return } if (je === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? In("dark") : In("light")), typeof window > "u") return; const dn = window.matchMedia("(prefers-color-scheme: dark)"); try { dn.addEventListener("change", ({ matches: Je }) => { In(Je ? "dark" : "light") }) } catch { dn.addListener(({ matches: rn }) => { try { In(rn ? "dark" : "light") } catch (hn) { console.error(hn) } }) } }, [je]), React.useEffect(() => { Xe.length <= 1 && fn(!1) }, [Xe]), React.useEffect(() => { const dn = Je => { var rn; if (Re.every(Ye => Je[Ye] || Je.code === Ye)) { var mn; fn(!0), (mn = xn.current) == null || mn.focus() } Je.code === "Escape" && (document.activeElement === xn.current || (rn = xn.current) != null && rn.contains(document.activeElement)) && fn(!1) }; return document.addEventListener("keydown", dn), () => document.removeEventListener("keydown", dn) }, [Re]), React.useEffect(() => { if (xn.current) return () => { tn.current && (tn.current.focus({ preventScroll: !0 }), tn.current = null, nn.current = !1) } }, [xn.current]), React.createElement("section", { ref: xe, "aria-label": `${sn} ${vn}`, tabIndex: -1, "aria-live": "polite", "aria-relevant": "additions text", "aria-atomic": "false", suppressHydrationWarning: !0 }, un.map((dn, Je) => { var rn; const [hn, mn] = dn.split("-"); return Xe.length ? React.createElement("ol", { key: dn, dir: He === "auto" ? getDocumentDirection() : He, tabIndex: -1, ref: xn, className: De, "data-sonner-toaster": !0, "data-sonner-theme": Rn, "data-y-position": hn, "data-x-position": mn, style: { "--front-toast-height": `${((rn = on[0]) == null ? void 0 : rn.height) || 0}px`, "--width": `${TOAST_WIDTH}px`, "--gap": `${Ge}px`, ...Fe, ...assignOffset(Pe, Oe) }, onBlur: Ye => { nn.current && !Ye.currentTarget.contains(Ye.relatedTarget) && (nn.current = !1, tn.current && (tn.current.focus({ preventScroll: !0 }), tn.current = null)) }, onFocus: Ye => { Ye.target instanceof HTMLElement && Ye.target.dataset.dismissible === "false" || nn.current || (nn.current = !0, tn.current = Ye.relatedTarget) }, onMouseEnter: () => fn(!0), onMouseMove: () => fn(!0), onMouseLeave: () => { En || fn(!1) }, onDragEnd: () => fn(!1), onPointerDown: Ye => { Ye.target instanceof HTMLElement && Ye.target.dataset.dismissible === "false" || Pn(!0) }, onPointerUp: () => Pn(!1) }, Xe.filter(Ye => !Ye.position && Je === 0 || Ye.position === dn).map((Ye, an) => { var pn, yn; return React.createElement(Toast, { key: Ye.id, icons: Ze, index: an, toast: Ye, defaultRichColors: Be, duration: (pn = qe?.duration) != null ? pn : Ie, className: qe?.className, descriptionClassName: qe?.descriptionClassName, invert: Ee, visibleToasts: ze, closeButton: (yn = qe?.closeButton) != null ? yn : Me, interacting: En, position: dn, style: qe?.style, unstyled: qe?.unstyled, classNames: qe?.classNames, cancelButtonStyle: qe?.cancelButtonStyle, actionButtonStyle: qe?.actionButtonStyle, closeButtonAriaLabel: qe?.closeButtonAriaLabel, removeToast: We, toasts: Xe.filter(_n => _n.position == Ye.position), heights: on.filter(_n => _n.position == Ye.position), setHeights: bn, expandByDefault: Ce, gap: Ge, expanded: Tn, swipeDirections: t.swipeDirections }) })) : null })) }), useToastError = () => ({ showError: (xe, Ee) => { toast.error(xe?.response?.data?.message || Ee, { duration: 5e3, style: { background: "#fee2e2", color: "#b91c1c", border: "1px solid #ef4444" } }) }, showSuccess: xe => { toast.success(xe, { duration: 4e3, style: { background: "#d1fae5", color: "#065f46", border: "1px solid #10b981" } }) } }); function Input({ className: e, type: t, ...xe }) { return jsxRuntimeExports.jsx("input", { type: t, "data-slot": "input", className: cn$1("file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground dark:bg-input/30 border-input flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]", "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive", e), ...xe }) } var NODES = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"], Primitive = NODES.reduce((e, t) => { const xe = createSlot(`Primitive.${t}`), Ee = reactExports.forwardRef((_e, Re) => { const { asChild: Ce, ...Me } = _e, De = Ce ? xe : t; return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), jsxRuntimeExports.jsx(De, { ...Me, ref: Re }) }); return Ee.displayName = `Primitive.${t}`, { ...e, [t]: Ee } }, {}); function dispatchDiscreteCustomEvent(e, t) { e && reactDomExports.flushSync(() => e.dispatchEvent(t)) } var NAME$2 = "Label", Label$1 = reactExports.forwardRef((e, t) => jsxRuntimeExports.jsx(Primitive.label, { ...e, ref: t, onMouseDown: xe => { xe.target.closest("button, input, select, textarea") || (e.onMouseDown?.(xe), !xe.defaultPrevented && xe.detail > 1 && xe.preventDefault()) } })); Label$1.displayName = NAME$2; var Root$4 = Label$1; function Label({ className: e, ...t }) { return jsxRuntimeExports.jsx(Root$4, { "data-slot": "label", className: cn$1("flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50", e), ...t }) } function clamp$1(e, [t, xe]) { return Math.min(xe, Math.max(t, e)) } function composeEventHandlers(e, t, { checkForDefaultPrevented: xe = !0 } = {}) { return function (_e) { if (e?.(_e), xe === !1 || !_e.defaultPrevented) return t?.(_e) } } function createContext2(e, t) { const xe = reactExports.createContext(t), Ee = Re => { const { children: Ce, ...Me } = Re, De = reactExports.useMemo(() => Me, Object.values(Me)); return jsxRuntimeExports.jsx(xe.Provider, { value: De, children: Ce }) }; Ee.displayName = e + "Provider"; function _e(Re) { const Ce = reactExports.useContext(xe); if (Ce) return Ce; if (t !== void 0) return t; throw new Error(`\`${Re}\` must be used within \`${e}\``) } return [Ee, _e] } function createContextScope(e, t = []) { let xe = []; function Ee(Re, Ce) { const Me = reactExports.createContext(Ce), De = xe.length; xe = [...xe, Ce]; const Pe = je => { const { scope: Be, children: Ie, ...Fe } = je, ze = Be?.[e]?.[De] || Me, qe = reactExports.useMemo(() => Fe, Object.values(Fe)); return jsxRuntimeExports.jsx(ze.Provider, { value: qe, children: Ie }) }; Pe.displayName = Re + "Provider"; function Oe(je, Be) { const Ie = Be?.[e]?.[De] || Me, Fe = reactExports.useContext(Ie); if (Fe) return Fe; if (Ce !== void 0) return Ce; throw new Error(`\`${je}\` must be used within \`${Re}\``) } return [Pe, Oe] } const _e = () => { const Re = xe.map(Ce => reactExports.createContext(Ce)); return function (Me) { const De = Me?.[e] || Re; return reactExports.useMemo(() => ({ [`__scope${e}`]: { ...Me, [e]: De } }), [Me, De]) } }; return _e.scopeName = e, [Ee, composeContextScopes(_e, ...t)] } function composeContextScopes(...e) { const t = e[0]; if (e.length === 1) return t; const xe = () => { const Ee = e.map(_e => ({ useScope: _e(), scopeName: _e.scopeName })); return function (Re) { const Ce = Ee.reduce((Me, { useScope: De, scopeName: Pe }) => { const je = De(Re)[`__scope${Pe}`]; return { ...Me, ...je } }, {}); return reactExports.useMemo(() => ({ [`__scope${t.scopeName}`]: Ce }), [Ce]) } }; return xe.scopeName = t.scopeName, xe } function createCollection(e) { const t = e + "CollectionProvider", [xe, Ee] = createContextScope(t), [_e, Re] = xe(t, { collectionRef: { current: null }, itemMap: new Map }), Ce = ze => { const { scope: qe, children: He } = ze, Ge = React.useRef(null), Ze = React.useRef(new Map).current; return jsxRuntimeExports.jsx(_e, { scope: qe, itemMap: Ze, collectionRef: Ge, children: He }) }; Ce.displayName = t; const Me = e + "CollectionSlot", De = createSlot(Me), Pe = React.forwardRef((ze, qe) => { const { scope: He, children: Ge } = ze, Ze = Re(Me, He), sn = useComposedRefs(qe, Ze.collectionRef); return jsxRuntimeExports.jsx(De, { ref: sn, children: Ge }) }); Pe.displayName = Me; const Oe = e + "CollectionItemSlot", je = "data-radix-collection-item", Be = createSlot(Oe), Ie = React.forwardRef((ze, qe) => { const { scope: He, children: Ge, ...Ze } = ze, sn = React.useRef(null), Xe = useComposedRefs(qe, sn), St = Re(Oe, He); return React.useEffect(() => (St.itemMap.set(sn, { ref: sn, ...Ze }), () => void St.itemMap.delete(sn))), jsxRuntimeExports.jsx(Be, { [je]: "", ref: Xe, children: Ge }) }); Ie.displayName = Oe; function Fe(ze) { const qe = Re(e + "CollectionConsumer", ze); return React.useCallback(() => { const Ge = qe.collectionRef.current; if (!Ge) return []; const Ze = Array.from(Ge.querySelectorAll(`[${je}]`)); return Array.from(qe.itemMap.values()).sort((St, un) => Ze.indexOf(St.ref.current) - Ze.indexOf(un.ref.current)) }, [qe.collectionRef, qe.itemMap]) } return [{ Provider: Ce, Slot: Pe, ItemSlot: Ie }, Fe, Ee] } var DirectionContext = reactExports.createContext(void 0); function useDirection(e) { const t = reactExports.useContext(DirectionContext); return e || t || "ltr" } function useCallbackRef$1(e) { const t = reactExports.useRef(e); return reactExports.useEffect(() => { t.current = e }), reactExports.useMemo(() => (...xe) => t.current?.(...xe), []) } function useEscapeKeydown(e, t = globalThis?.document) { const xe = useCallbackRef$1(e); reactExports.useEffect(() => { const Ee = _e => { _e.key === "Escape" && xe(_e) }; return t.addEventListener("keydown", Ee, { capture: !0 }), () => t.removeEventListener("keydown", Ee, { capture: !0 }) }, [xe, t]) } var DISMISSABLE_LAYER_NAME = "DismissableLayer", CONTEXT_UPDATE = "dismissableLayer.update", POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside", FOCUS_OUTSIDE = "dismissableLayer.focusOutside", originalBodyPointerEvents, DismissableLayerContext = reactExports.createContext({ layers: new Set, layersWithOutsidePointerEventsDisabled: new Set, branches: new Set }), DismissableLayer = reactExports.forwardRef((e, t) => { const { disableOutsidePointerEvents: xe = !1, onEscapeKeyDown: Ee, onPointerDownOutside: _e, onFocusOutside: Re, onInteractOutside: Ce, onDismiss: Me, ...De } = e, Pe = reactExports.useContext(DismissableLayerContext), [Oe, je] = reactExports.useState(null), Be = Oe?.ownerDocument ?? globalThis?.document, [, Ie] = reactExports.useState({}), Fe = useComposedRefs(t, un => je(un)), ze = Array.from(Pe.layers), [qe] = [...Pe.layersWithOutsidePointerEventsDisabled].slice(-1), He = ze.indexOf(qe), Ge = Oe ? ze.indexOf(Oe) : -1, Ze = Pe.layersWithOutsidePointerEventsDisabled.size > 0, sn = Ge >= He, Xe = usePointerDownOutside(un => { const on = un.target, bn = [...Pe.branches].some(Tn => Tn.contains(on)); !sn || bn || (_e?.(un), Ce?.(un), un.defaultPrevented || Me?.()) }, Be), St = useFocusOutside(un => { const on = un.target;[...Pe.branches].some(Tn => Tn.contains(on)) || (Re?.(un), Ce?.(un), un.defaultPrevented || Me?.()) }, Be); return useEscapeKeydown(un => { Ge === Pe.layers.size - 1 && (Ee?.(un), !un.defaultPrevented && Me && (un.preventDefault(), Me())) }, Be), reactExports.useEffect(() => { if (Oe) return xe && (Pe.layersWithOutsidePointerEventsDisabled.size === 0 && (originalBodyPointerEvents = Be.body.style.pointerEvents, Be.body.style.pointerEvents = "none"), Pe.layersWithOutsidePointerEventsDisabled.add(Oe)), Pe.layers.add(Oe), dispatchUpdate(), () => { xe && Pe.layersWithOutsidePointerEventsDisabled.size === 1 && (Be.body.style.pointerEvents = originalBodyPointerEvents) } }, [Oe, Be, xe, Pe]), reactExports.useEffect(() => () => { Oe && (Pe.layers.delete(Oe), Pe.layersWithOutsidePointerEventsDisabled.delete(Oe), dispatchUpdate()) }, [Oe, Pe]), reactExports.useEffect(() => { const un = () => Ie({}); return document.addEventListener(CONTEXT_UPDATE, un), () => document.removeEventListener(CONTEXT_UPDATE, un) }, []), jsxRuntimeExports.jsx(Primitive.div, { ...De, ref: Fe, style: { pointerEvents: Ze ? sn ? "auto" : "none" : void 0, ...e.style }, onFocusCapture: composeEventHandlers(e.onFocusCapture, St.onFocusCapture), onBlurCapture: composeEventHandlers(e.onBlurCapture, St.onBlurCapture), onPointerDownCapture: composeEventHandlers(e.onPointerDownCapture, Xe.onPointerDownCapture) }) }); DismissableLayer.displayName = DISMISSABLE_LAYER_NAME; var BRANCH_NAME = "DismissableLayerBranch", DismissableLayerBranch = reactExports.forwardRef((e, t) => { const xe = reactExports.useContext(DismissableLayerContext), Ee = reactExports.useRef(null), _e = useComposedRefs(t, Ee); return reactExports.useEffect(() => { const Re = Ee.current; if (Re) return xe.branches.add(Re), () => { xe.branches.delete(Re) } }, [xe.branches]), jsxRuntimeExports.jsx(Primitive.div, { ...e, ref: _e }) }); DismissableLayerBranch.displayName = BRANCH_NAME; function usePointerDownOutside(e, t = globalThis?.document) { const xe = useCallbackRef$1(e), Ee = reactExports.useRef(!1), _e = reactExports.useRef(() => { }); return reactExports.useEffect(() => { const Re = Me => { if (Me.target && !Ee.current) { let De = function () { handleAndDispatchCustomEvent(POINTER_DOWN_OUTSIDE, xe, Pe, { discrete: !0 }) }; const Pe = { originalEvent: Me }; Me.pointerType === "touch" ? (t.removeEventListener("click", _e.current), _e.current = De, t.addEventListener("click", _e.current, { once: !0 })) : De() } else t.removeEventListener("click", _e.current); Ee.current = !1 }, Ce = window.setTimeout(() => { t.addEventListener("pointerdown", Re) }, 0); return () => { window.clearTimeout(Ce), t.removeEventListener("pointerdown", Re), t.removeEventListener("click", _e.current) } }, [t, xe]), { onPointerDownCapture: () => Ee.current = !0 } } function useFocusOutside(e, t = globalThis?.document) { const xe = useCallbackRef$1(e), Ee = reactExports.useRef(!1); return reactExports.useEffect(() => { const _e = Re => { Re.target && !Ee.current && handleAndDispatchCustomEvent(FOCUS_OUTSIDE, xe, { originalEvent: Re }, { discrete: !1 }) }; return t.addEventListener("focusin", _e), () => t.removeEventListener("focusin", _e) }, [t, xe]), { onFocusCapture: () => Ee.current = !0, onBlurCapture: () => Ee.current = !1 } } function dispatchUpdate() { const e = new CustomEvent(CONTEXT_UPDATE); document.dispatchEvent(e) } function handleAndDispatchCustomEvent(e, t, xe, { discrete: Ee }) { const _e = xe.originalEvent.target, Re = new CustomEvent(e, { bubbles: !1, cancelable: !0, detail: xe }); t && _e.addEventListener(e, t, { once: !0 }), Ee ? dispatchDiscreteCustomEvent(_e, Re) : _e.dispatchEvent(Re) } var count$1 = 0; function useFocusGuards() { reactExports.useEffect(() => { const e = document.querySelectorAll("[data-radix-focus-guard]"); return document.body.insertAdjacentElement("afterbegin", e[0] ?? createFocusGuard()), document.body.insertAdjacentElement("beforeend", e[1] ?? createFocusGuard()), count$1++, () => { count$1 === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(t => t.remove()), count$1-- } }, []) } function createFocusGuard() { const e = document.createElement("span"); return e.setAttribute("data-radix-focus-guard", ""), e.tabIndex = 0, e.style.outline = "none", e.style.opacity = "0", e.style.position = "fixed", e.style.pointerEvents = "none", e } var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount", AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount", EVENT_OPTIONS = { bubbles: !1, cancelable: !0 }, FOCUS_SCOPE_NAME = "FocusScope", FocusScope = reactExports.forwardRef((e, t) => { const { loop: xe = !1, trapped: Ee = !1, onMountAutoFocus: _e, onUnmountAutoFocus: Re, ...Ce } = e, [Me, De] = reactExports.useState(null), Pe = useCallbackRef$1(_e), Oe = useCallbackRef$1(Re), je = reactExports.useRef(null), Be = useComposedRefs(t, ze => De(ze)), Ie = reactExports.useRef({ paused: !1, pause() { this.paused = !0 }, resume() { this.paused = !1 } }).current; reactExports.useEffect(() => { if (Ee) { let ze = function (Ze) { if (Ie.paused || !Me) return; const sn = Ze.target; Me.contains(sn) ? je.current = sn : focus(je.current, { select: !0 }) }, qe = function (Ze) { if (Ie.paused || !Me) return; const sn = Ze.relatedTarget; sn !== null && (Me.contains(sn) || focus(je.current, { select: !0 })) }, He = function (Ze) { if (document.activeElement === document.body) for (const Xe of Ze) Xe.removedNodes.length > 0 && focus(Me) }; document.addEventListener("focusin", ze), document.addEventListener("focusout", qe); const Ge = new MutationObserver(He); return Me && Ge.observe(Me, { childList: !0, subtree: !0 }), () => { document.removeEventListener("focusin", ze), document.removeEventListener("focusout", qe), Ge.disconnect() } } }, [Ee, Me, Ie.paused]), reactExports.useEffect(() => { if (Me) { focusScopesStack.add(Ie); const ze = document.activeElement; if (!Me.contains(ze)) { const He = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS); Me.addEventListener(AUTOFOCUS_ON_MOUNT, Pe), Me.dispatchEvent(He), He.defaultPrevented || (focusFirst(removeLinks(getTabbableCandidates(Me)), { select: !0 }), document.activeElement === ze && focus(Me)) } return () => { Me.removeEventListener(AUTOFOCUS_ON_MOUNT, Pe), setTimeout(() => { const He = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS); Me.addEventListener(AUTOFOCUS_ON_UNMOUNT, Oe), Me.dispatchEvent(He), He.defaultPrevented || focus(ze ?? document.body, { select: !0 }), Me.removeEventListener(AUTOFOCUS_ON_UNMOUNT, Oe), focusScopesStack.remove(Ie) }, 0) } } }, [Me, Pe, Oe, Ie]); const Fe = reactExports.useCallback(ze => { if (!xe && !Ee || Ie.paused) return; const qe = ze.key === "Tab" && !ze.altKey && !ze.ctrlKey && !ze.metaKey, He = document.activeElement; if (qe && He) { const Ge = ze.currentTarget, [Ze, sn] = getTabbableEdges(Ge); Ze && sn ? !ze.shiftKey && He === sn ? (ze.preventDefault(), xe && focus(Ze, { select: !0 })) : ze.shiftKey && He === Ze && (ze.preventDefault(), xe && focus(sn, { select: !0 })) : He === Ge && ze.preventDefault() } }, [xe, Ee, Ie.paused]); return jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...Ce, ref: Be, onKeyDown: Fe }) }); FocusScope.displayName = FOCUS_SCOPE_NAME; function focusFirst(e, { select: t = !1 } = {}) { const xe = document.activeElement; for (const Ee of e) if (focus(Ee, { select: t }), document.activeElement !== xe) return } function getTabbableEdges(e) { const t = getTabbableCandidates(e), xe = findVisible(t, e), Ee = findVisible(t.reverse(), e); return [xe, Ee] } function getTabbableCandidates(e) { const t = [], xe = document.createTreeWalker(e, NodeFilter.SHOW_ELEMENT, { acceptNode: Ee => { const _e = Ee.tagName === "INPUT" && Ee.type === "hidden"; return Ee.disabled || Ee.hidden || _e ? NodeFilter.FILTER_SKIP : Ee.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP } }); for (; xe.nextNode();)t.push(xe.currentNode); return t } function findVisible(e, t) { for (const xe of e) if (!isHidden(xe, { upTo: t })) return xe } function isHidden(e, { upTo: t }) { if (getComputedStyle(e).visibility === "hidden") return !0; for (; e;) { if (t !== void 0 && e === t) return !1; if (getComputedStyle(e).display === "none") return !0; e = e.parentElement } return !1 } function isSelectableInput(e) { return e instanceof HTMLInputElement && "select" in e } function focus(e, { select: t = !1 } = {}) { if (e && e.focus) { const xe = document.activeElement; e.focus({ preventScroll: !0 }), e !== xe && isSelectableInput(e) && t && e.select() } } var focusScopesStack = createFocusScopesStack(); function createFocusScopesStack() { let e = []; return { add(t) { const xe = e[0]; t !== xe && xe?.pause(), e = arrayRemove(e, t), e.unshift(t) }, remove(t) { e = arrayRemove(e, t), e[0]?.resume() } } } function arrayRemove(e, t) { const xe = [...e], Ee = xe.indexOf(t); return Ee !== -1 && xe.splice(Ee, 1), xe } function removeLinks(e) { return e.filter(t => t.tagName !== "A") } var useLayoutEffect2 = globalThis?.document ? reactExports.useLayoutEffect : () => { }, useReactId = React$1[" useId ".trim().toString()] || (() => { }), count = 0; function useId(e) { const [t, xe] = reactExports.useState(useReactId()); return useLayoutEffect2(() => { xe(Ee => Ee ?? String(count++)) }, [e]), e || (t ? `radix-${t}` : "") } const sides = ["top", "right", "bottom", "left"], min = Math.min, max$1 = Math.max, round = Math.round, floor = Math.floor, createCoords = e => ({ x: e, y: e }), oppositeSideMap = { left: "right", right: "left", bottom: "top", top: "bottom" }, oppositeAlignmentMap = { start: "end", end: "start" }; function clamp(e, t, xe) { return max$1(e, min(t, xe)) } function evaluate(e, t) { return typeof e == "function" ? e(t) : e } function getSide(e) { return e.split("-")[0] } function getAlignment(e) { return e.split("-")[1] } function getOppositeAxis(e) { return e === "x" ? "y" : "x" } function getAxisLength(e) { return e === "y" ? "height" : "width" } const yAxisSides = new Set(["top", "bottom"]); function getSideAxis(e) { return yAxisSides.has(getSide(e)) ? "y" : "x" } function getAlignmentAxis(e) { return getOppositeAxis(getSideAxis(e)) } function getAlignmentSides(e, t, xe) { xe === void 0 && (xe = !1); const Ee = getAlignment(e), _e = getAlignmentAxis(e), Re = getAxisLength(_e); let Ce = _e === "x" ? Ee === (xe ? "end" : "start") ? "right" : "left" : Ee === "start" ? "bottom" : "top"; return t.reference[Re] > t.floating[Re] && (Ce = getOppositePlacement(Ce)), [Ce, getOppositePlacement(Ce)] } function getExpandedPlacements(e) { const t = getOppositePlacement(e); return [getOppositeAlignmentPlacement(e), t, getOppositeAlignmentPlacement(t)] } function getOppositeAlignmentPlacement(e) { return e.replace(/start|end/g, t => oppositeAlignmentMap[t]) } const lrPlacement = ["left", "right"], rlPlacement = ["right", "left"], tbPlacement = ["top", "bottom"], btPlacement = ["bottom", "top"]; function getSideList(e, t, xe) { switch (e) { case "top": case "bottom": return xe ? t ? rlPlacement : lrPlacement : t ? lrPlacement : rlPlacement; case "left": case "right": return t ? tbPlacement : btPlacement; default: return [] } } function getOppositeAxisPlacements(e, t, xe, Ee) { const _e = getAlignment(e); let Re = getSideList(getSide(e), xe === "start", Ee); return _e && (Re = Re.map(Ce => Ce + "-" + _e), t && (Re = Re.concat(Re.map(getOppositeAlignmentPlacement)))), Re } function getOppositePlacement(e) { return e.replace(/left|right|bottom|top/g, t => oppositeSideMap[t]) } function expandPaddingObject(e) { return { top: 0, right: 0, bottom: 0, left: 0, ...e } } function getPaddingObject(e) { return typeof e != "number" ? expandPaddingObject(e) : { top: e, right: e, bottom: e, left: e } } function rectToClientRect(e) { const { x: t, y: xe, width: Ee, height: _e } = e; return { width: Ee, height: _e, top: xe, left: t, right: t + Ee, bottom: xe + _e, x: t, y: xe } } function computeCoordsFromPlacement(e, t, xe) { let { reference: Ee, floating: _e } = e; const Re = getSideAxis(t), Ce = getAlignmentAxis(t), Me = getAxisLength(Ce), De = getSide(t), Pe = Re === "y", Oe = Ee.x + Ee.width / 2 - _e.width / 2, je = Ee.y + Ee.height / 2 - _e.height / 2, Be = Ee[Me] / 2 - _e[Me] / 2; let Ie; switch (De) { case "top": Ie = { x: Oe, y: Ee.y - _e.height }; break; case "bottom": Ie = { x: Oe, y: Ee.y + Ee.height }; break; case "right": Ie = { x: Ee.x + Ee.width, y: je }; break; case "left": Ie = { x: Ee.x - _e.width, y: je }; break; default: Ie = { x: Ee.x, y: Ee.y } }switch (getAlignment(t)) { case "start": Ie[Ce] -= Be * (xe && Pe ? -1 : 1); break; case "end": Ie[Ce] += Be * (xe && Pe ? -1 : 1); break }return Ie } const computePosition$1 = async (e, t, xe) => { const { placement: Ee = "bottom", strategy: _e = "absolute", middleware: Re = [], platform: Ce } = xe, Me = Re.filter(Boolean), De = await (Ce.isRTL == null ? void 0 : Ce.isRTL(t)); let Pe = await Ce.getElementRects({ reference: e, floating: t, strategy: _e }), { x: Oe, y: je } = computeCoordsFromPlacement(Pe, Ee, De), Be = Ee, Ie = {}, Fe = 0; for (let ze = 0; ze < Me.length; ze++) { const { name: qe, fn: He } = Me[ze], { x: Ge, y: Ze, data: sn, reset: Xe } = await He({ x: Oe, y: je, initialPlacement: Ee, placement: Be, strategy: _e, middlewareData: Ie, rects: Pe, platform: Ce, elements: { reference: e, floating: t } }); Oe = Ge ?? Oe, je = Ze ?? je, Ie = { ...Ie, [qe]: { ...Ie[qe], ...sn } }, Xe && Fe <= 50 && (Fe++, typeof Xe == "object" && (Xe.placement && (Be = Xe.placement), Xe.rects && (Pe = Xe.rects === !0 ? await Ce.getElementRects({ reference: e, floating: t, strategy: _e }) : Xe.rects), { x: Oe, y: je } = computeCoordsFromPlacement(Pe, Be, De)), ze = -1) } return { x: Oe, y: je, placement: Be, strategy: _e, middlewareData: Ie } }; async function detectOverflow(e, t) { var xe; t === void 0 && (t = {}); const { x: Ee, y: _e, platform: Re, rects: Ce, elements: Me, strategy: De } = e, { boundary: Pe = "clippingAncestors", rootBoundary: Oe = "viewport", elementContext: je = "floating", altBoundary: Be = !1, padding: Ie = 0 } = evaluate(t, e), Fe = getPaddingObject(Ie), qe = Me[Be ? je === "floating" ? "reference" : "floating" : je], He = rectToClientRect(await Re.getClippingRect({ element: (xe = await (Re.isElement == null ? void 0 : Re.isElement(qe))) == null || xe ? qe : qe.contextElement || await (Re.getDocumentElement == null ? void 0 : Re.getDocumentElement(Me.floating)), boundary: Pe, rootBoundary: Oe, strategy: De })), Ge = je === "floating" ? { x: Ee, y: _e, width: Ce.floating.width, height: Ce.floating.height } : Ce.reference, Ze = await (Re.getOffsetParent == null ? void 0 : Re.getOffsetParent(Me.floating)), sn = await (Re.isElement == null ? void 0 : Re.isElement(Ze)) ? await (Re.getScale == null ? void 0 : Re.getScale(Ze)) || { x: 1, y: 1 } : { x: 1, y: 1 }, Xe = rectToClientRect(Re.convertOffsetParentRelativeRectToViewportRelativeRect ? await Re.convertOffsetParentRelativeRectToViewportRelativeRect({ elements: Me, rect: Ge, offsetParent: Ze, strategy: De }) : Ge); return { top: (He.top - Xe.top + Fe.top) / sn.y, bottom: (Xe.bottom - He.bottom + Fe.bottom) / sn.y, left: (He.left - Xe.left + Fe.left) / sn.x, right: (Xe.right - He.right + Fe.right) / sn.x } } const arrow$3 = e => ({ name: "arrow", options: e, async fn(t) { const { x: xe, y: Ee, placement: _e, rects: Re, platform: Ce, elements: Me, middlewareData: De } = t, { element: Pe, padding: Oe = 0 } = evaluate(e, t) || {}; if (Pe == null) return {}; const je = getPaddingObject(Oe), Be = { x: xe, y: Ee }, Ie = getAlignmentAxis(_e), Fe = getAxisLength(Ie), ze = await Ce.getDimensions(Pe), qe = Ie === "y", He = qe ? "top" : "left", Ge = qe ? "bottom" : "right", Ze = qe ? "clientHeight" : "clientWidth", sn = Re.reference[Fe] + Re.reference[Ie] - Be[Ie] - Re.floating[Fe], Xe = Be[Ie] - Re.reference[Ie], St = await (Ce.getOffsetParent == null ? void 0 : Ce.getOffsetParent(Pe)); let un = St ? St[Ze] : 0; (!un || !await (Ce.isElement == null ? void 0 : Ce.isElement(St))) && (un = Me.floating[Ze] || Re.floating[Fe]); const on = sn / 2 - Xe / 2, bn = un / 2 - ze[Fe] / 2 - 1, Tn = min(je[He], bn), fn = min(je[Ge], bn), En = Tn, Pn = un - ze[Fe] - fn, Rn = un / 2 - ze[Fe] / 2 + on, In = clamp(En, Rn, Pn), xn = !De.arrow && getAlignment(_e) != null && Rn !== In && Re.reference[Fe] / 2 - (Rn < En ? Tn : fn) - ze[Fe] / 2 < 0, vn = xn ? Rn < En ? Rn - En : Rn - Pn : 0; return { [Ie]: Be[Ie] + vn, data: { [Ie]: In, centerOffset: Rn - In - vn, ...xn && { alignmentOffset: vn } }, reset: xn } } }), flip$2 = function (e) { return e === void 0 && (e = {}), { name: "flip", options: e, async fn(t) { var xe, Ee; const { placement: _e, middlewareData: Re, rects: Ce, initialPlacement: Me, platform: De, elements: Pe } = t, { mainAxis: Oe = !0, crossAxis: je = !0, fallbackPlacements: Be, fallbackStrategy: Ie = "bestFit", fallbackAxisSideDirection: Fe = "none", flipAlignment: ze = !0, ...qe } = evaluate(e, t); if ((xe = Re.arrow) != null && xe.alignmentOffset) return {}; const He = getSide(_e), Ge = getSideAxis(Me), Ze = getSide(Me) === Me, sn = await (De.isRTL == null ? void 0 : De.isRTL(Pe.floating)), Xe = Be || (Ze || !ze ? [getOppositePlacement(Me)] : getExpandedPlacements(Me)), St = Fe !== "none"; !Be && St && Xe.push(...getOppositeAxisPlacements(Me, ze, Fe, sn)); const un = [Me, ...Xe], on = await detectOverflow(t, qe), bn = []; let Tn = ((Ee = Re.flip) == null ? void 0 : Ee.overflows) || []; if (Oe && bn.push(on[He]), je) { const Rn = getAlignmentSides(_e, Ce, sn); bn.push(on[Rn[0]], on[Rn[1]]) } if (Tn = [...Tn, { placement: _e, overflows: bn }], !bn.every(Rn => Rn <= 0)) { var fn, En; const Rn = (((fn = Re.flip) == null ? void 0 : fn.index) || 0) + 1, In = un[Rn]; if (In && (!(je === "alignment" ? Ge !== getSideAxis(In) : !1) || Tn.every(tn => tn.overflows[0] > 0 && getSideAxis(tn.placement) === Ge))) return { data: { index: Rn, overflows: Tn }, reset: { placement: In } }; let xn = (En = Tn.filter(vn => vn.overflows[0] <= 0).sort((vn, tn) => vn.overflows[1] - tn.overflows[1])[0]) == null ? void 0 : En.placement; if (!xn) switch (Ie) { case "bestFit": { var Pn; const vn = (Pn = Tn.filter(tn => { if (St) { const nn = getSideAxis(tn.placement); return nn === Ge || nn === "y" } return !0 }).map(tn => [tn.placement, tn.overflows.filter(nn => nn > 0).reduce((nn, We) => nn + We, 0)]).sort((tn, nn) => tn[1] - nn[1])[0]) == null ? void 0 : Pn[0]; vn && (xn = vn); break } case "initialPlacement": xn = Me; break }if (_e !== xn) return { reset: { placement: xn } } } return {} } } }; function getSideOffsets(e, t) { return { top: e.top - t.height, right: e.right - t.width, bottom: e.bottom - t.height, left: e.left - t.width } } function isAnySideFullyClipped(e) { return sides.some(t => e[t] >= 0) } const hide$2 = function (e) { return e === void 0 && (e = {}), { name: "hide", options: e, async fn(t) { const { rects: xe } = t, { strategy: Ee = "referenceHidden", ..._e } = evaluate(e, t); switch (Ee) { case "referenceHidden": { const Re = await detectOverflow(t, { ..._e, elementContext: "reference" }), Ce = getSideOffsets(Re, xe.reference); return { data: { referenceHiddenOffsets: Ce, referenceHidden: isAnySideFullyClipped(Ce) } } } case "escaped": { const Re = await detectOverflow(t, { ..._e, altBoundary: !0 }), Ce = getSideOffsets(Re, xe.floating); return { data: { escapedOffsets: Ce, escaped: isAnySideFullyClipped(Ce) } } } default: return {} } } } }, originSides = new Set(["left", "top"]); async function convertValueToCoords(e, t) { const { placement: xe, platform: Ee, elements: _e } = e, Re = await (Ee.isRTL == null ? void 0 : Ee.isRTL(_e.floating)), Ce = getSide(xe), Me = getAlignment(xe), De = getSideAxis(xe) === "y", Pe = originSides.has(Ce) ? -1 : 1, Oe = Re && De ? -1 : 1, je = evaluate(t, e); let { mainAxis: Be, crossAxis: Ie, alignmentAxis: Fe } = typeof je == "number" ? { mainAxis: je, crossAxis: 0, alignmentAxis: null } : { mainAxis: je.mainAxis || 0, crossAxis: je.crossAxis || 0, alignmentAxis: je.alignmentAxis }; return Me && typeof Fe == "number" && (Ie = Me === "end" ? Fe * -1 : Fe), De ? { x: Ie * Oe, y: Be * Pe } : { x: Be * Pe, y: Ie * Oe } } const offset$2 = function (e) { return e === void 0 && (e = 0), { name: "offset", options: e, async fn(t) { var xe, Ee; const { x: _e, y: Re, placement: Ce, middlewareData: Me } = t, De = await convertValueToCoords(t, e); return Ce === ((xe = Me.offset) == null ? void 0 : xe.placement) && (Ee = Me.arrow) != null && Ee.alignmentOffset ? {} : { x: _e + De.x, y: Re + De.y, data: { ...De, placement: Ce } } } } }, shift$2 = function (e) { return e === void 0 && (e = {}), { name: "shift", options: e, async fn(t) { const { x: xe, y: Ee, placement: _e } = t, { mainAxis: Re = !0, crossAxis: Ce = !1, limiter: Me = { fn: qe => { let { x: He, y: Ge } = qe; return { x: He, y: Ge } } }, ...De } = evaluate(e, t), Pe = { x: xe, y: Ee }, Oe = await detectOverflow(t, De), je = getSideAxis(getSide(_e)), Be = getOppositeAxis(je); let Ie = Pe[Be], Fe = Pe[je]; if (Re) { const qe = Be === "y" ? "top" : "left", He = Be === "y" ? "bottom" : "right", Ge = Ie + Oe[qe], Ze = Ie - Oe[He]; Ie = clamp(Ge, Ie, Ze) } if (Ce) { const qe = je === "y" ? "top" : "left", He = je === "y" ? "bottom" : "right", Ge = Fe + Oe[qe], Ze = Fe - Oe[He]; Fe = clamp(Ge, Fe, Ze) } const ze = Me.fn({ ...t, [Be]: Ie, [je]: Fe }); return { ...ze, data: { x: ze.x - xe, y: ze.y - Ee, enabled: { [Be]: Re, [je]: Ce } } } } } }, limitShift$2 = function (e) { return e === void 0 && (e = {}), { options: e, fn(t) { const { x: xe, y: Ee, placement: _e, rects: Re, middlewareData: Ce } = t, { offset: Me = 0, mainAxis: De = !0, crossAxis: Pe = !0 } = evaluate(e, t), Oe = { x: xe, y: Ee }, je = getSideAxis(_e), Be = getOppositeAxis(je); let Ie = Oe[Be], Fe = Oe[je]; const ze = evaluate(Me, t), qe = typeof ze == "number" ? { mainAxis: ze, crossAxis: 0 } : { mainAxis: 0, crossAxis: 0, ...ze }; if (De) { const Ze = Be === "y" ? "height" : "width", sn = Re.reference[Be] - Re.floating[Ze] + qe.mainAxis, Xe = Re.reference[Be] + Re.reference[Ze] - qe.mainAxis; Ie < sn ? Ie = sn : Ie > Xe && (Ie = Xe) } if (Pe) { var He, Ge; const Ze = Be === "y" ? "width" : "height", sn = originSides.has(getSide(_e)), Xe = Re.reference[je] - Re.floating[Ze] + (sn && ((He = Ce.offset) == null ? void 0 : He[je]) || 0) + (sn ? 0 : qe.crossAxis), St = Re.reference[je] + Re.reference[Ze] + (sn ? 0 : ((Ge = Ce.offset) == null ? void 0 : Ge[je]) || 0) - (sn ? qe.crossAxis : 0); Fe < Xe ? Fe = Xe : Fe > St && (Fe = St) } return { [Be]: Ie, [je]: Fe } } } }, size$2 = function (e) { return e === void 0 && (e = {}), { name: "size", options: e, async fn(t) { var xe, Ee; const { placement: _e, rects: Re, platform: Ce, elements: Me } = t, { apply: De = () => { }, ...Pe } = evaluate(e, t), Oe = await detectOverflow(t, Pe), je = getSide(_e), Be = getAlignment(_e), Ie = getSideAxis(_e) === "y", { width: Fe, height: ze } = Re.floating; let qe, He; je === "top" || je === "bottom" ? (qe = je, He = Be === (await (Ce.isRTL == null ? void 0 : Ce.isRTL(Me.floating)) ? "start" : "end") ? "left" : "right") : (He = je, qe = Be === "end" ? "top" : "bottom"); const Ge = ze - Oe.top - Oe.bottom, Ze = Fe - Oe.left - Oe.right, sn = min(ze - Oe[qe], Ge), Xe = min(Fe - Oe[He], Ze), St = !t.middlewareData.shift; let un = sn, on = Xe; if ((xe = t.middlewareData.shift) != null && xe.enabled.x && (on = Ze), (Ee = t.middlewareData.shift) != null && Ee.enabled.y && (un = Ge), St && !Be) { const Tn = max$1(Oe.left, 0), fn = max$1(Oe.right, 0), En = max$1(Oe.top, 0), Pn = max$1(Oe.bottom, 0); Ie ? on = Fe - 2 * (Tn !== 0 || fn !== 0 ? Tn + fn : max$1(Oe.left, Oe.right)) : un = ze - 2 * (En !== 0 || Pn !== 0 ? En + Pn : max$1(Oe.top, Oe.bottom)) } await De({ ...t, availableWidth: on, availableHeight: un }); const bn = await Ce.getDimensions(Me.floating); return Fe !== bn.width || ze !== bn.height ? { reset: { rects: !0 } } : {} } } }; function hasWindow() { return typeof window < "u" } function getNodeName(e) { return isNode(e) ? (e.nodeName || "").toLowerCase() : "#document" } function getWindow(e) { var t; return (e == null || (t = e.ownerDocument) == null ? void 0 : t.defaultView) || window } function getDocumentElement(e) { var t; return (t = (isNode(e) ? e.ownerDocument : e.document) || window.document) == null ? void 0 : t.documentElement } function isNode(e) { return hasWindow() ? e instanceof Node || e instanceof getWindow(e).Node : !1 } function isElement(e) { return hasWindow() ? e instanceof Element || e instanceof getWindow(e).Element : !1 } function isHTMLElement(e) { return hasWindow() ? e instanceof HTMLElement || e instanceof getWindow(e).HTMLElement : !1 } function isShadowRoot(e) { return !hasWindow() || typeof ShadowRoot > "u" ? !1 : e instanceof ShadowRoot || e instanceof getWindow(e).ShadowRoot } const invalidOverflowDisplayValues = new Set(["inline", "contents"]); function isOverflowElement(e) { const { overflow: t, overflowX: xe, overflowY: Ee, display: _e } = getComputedStyle$1(e); return /auto|scroll|overlay|hidden|clip/.test(t + Ee + xe) && !invalidOverflowDisplayValues.has(_e) } const tableElements = new Set(["table", "td", "th"]); function isTableElement(e) { return tableElements.has(getNodeName(e)) } const topLayerSelectors = [":popover-open", ":modal"]; function isTopLayer(e) { return topLayerSelectors.some(t => { try { return e.matches(t) } catch { return !1 } }) } const transformProperties = ["transform", "translate", "scale", "rotate", "perspective"], willChangeValues = ["transform", "translate", "scale", "rotate", "perspective", "filter"], containValues = ["paint", "layout", "strict", "content"]; function isContainingBlock(e) { const t = isWebKit(), xe = isElement(e) ? getComputedStyle$1(e) : e; return transformProperties.some(Ee => xe[Ee] ? xe[Ee] !== "none" : !1) || (xe.containerType ? xe.containerType !== "normal" : !1) || !t && (xe.backdropFilter ? xe.backdropFilter !== "none" : !1) || !t && (xe.filter ? xe.filter !== "none" : !1) || willChangeValues.some(Ee => (xe.willChange || "").includes(Ee)) || containValues.some(Ee => (xe.contain || "").includes(Ee)) } function getContainingBlock(e) { let t = getParentNode(e); for (; isHTMLElement(t) && !isLastTraversableNode(t);) { if (isContainingBlock(t)) return t; if (isTopLayer(t)) return null; t = getParentNode(t) } return null } function isWebKit() { return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none") } const lastTraversableNodeNames = new Set(["html", "body", "#document"]); function isLastTraversableNode(e) { return lastTraversableNodeNames.has(getNodeName(e)) } function getComputedStyle$1(e) { return getWindow(e).getComputedStyle(e) } function getNodeScroll(e) { return isElement(e) ? { scrollLeft: e.scrollLeft, scrollTop: e.scrollTop } : { scrollLeft: e.scrollX, scrollTop: e.scrollY } } function getParentNode(e) { if (getNodeName(e) === "html") return e; const t = e.assignedSlot || e.parentNode || isShadowRoot(e) && e.host || getDocumentElement(e); return isShadowRoot(t) ? t.host : t } function getNearestOverflowAncestor(e) { const t = getParentNode(e); return isLastTraversableNode(t) ? e.ownerDocument ? e.ownerDocument.body : e.body : isHTMLElement(t) && isOverflowElement(t) ? t : getNearestOverflowAncestor(t) } function getOverflowAncestors(e, t, xe) { var Ee; t === void 0 && (t = []), xe === void 0 && (xe = !0); const _e = getNearestOverflowAncestor(e), Re = _e === ((Ee = e.ownerDocument) == null ? void 0 : Ee.body), Ce = getWindow(_e); if (Re) { const Me = getFrameElement(Ce); return t.concat(Ce, Ce.visualViewport || [], isOverflowElement(_e) ? _e : [], Me && xe ? getOverflowAncestors(Me) : []) } return t.concat(_e, getOverflowAncestors(_e, [], xe)) } function getFrameElement(e) { return e.parent && Object.getPrototypeOf(e.parent) ? e.frameElement : null } function getCssDimensions(e) { const t = getComputedStyle$1(e); let xe = parseFloat(t.width) || 0, Ee = parseFloat(t.height) || 0; const _e = isHTMLElement(e), Re = _e ? e.offsetWidth : xe, Ce = _e ? e.offsetHeight : Ee, Me = round(xe) !== Re || round(Ee) !== Ce; return Me && (xe = Re, Ee = Ce), { width: xe, height: Ee, $: Me } } function unwrapElement(e) { return isElement(e) ? e : e.contextElement } function getScale(e) { const t = unwrapElement(e); if (!isHTMLElement(t)) return createCoords(1); const xe = t.getBoundingClientRect(), { width: Ee, height: _e, $: Re } = getCssDimensions(t); let Ce = (Re ? round(xe.width) : xe.width) / Ee, Me = (Re ? round(xe.height) : xe.height) / _e; return (!Ce || !Number.isFinite(Ce)) && (Ce = 1), (!Me || !Number.isFinite(Me)) && (Me = 1), { x: Ce, y: Me } } const noOffsets = createCoords(0); function getVisualOffsets(e) { const t = getWindow(e); return !isWebKit() || !t.visualViewport ? noOffsets : { x: t.visualViewport.offsetLeft, y: t.visualViewport.offsetTop } } function shouldAddVisualOffsets(e, t, xe) { return t === void 0 && (t = !1), !xe || t && xe !== getWindow(e) ? !1 : t } function getBoundingClientRect(e, t, xe, Ee) { t === void 0 && (t = !1), xe === void 0 && (xe = !1); const _e = e.getBoundingClientRect(), Re = unwrapElement(e); let Ce = createCoords(1); t && (Ee ? isElement(Ee) && (Ce = getScale(Ee)) : Ce = getScale(e)); const Me = shouldAddVisualOffsets(Re, xe, Ee) ? getVisualOffsets(Re) : createCoords(0); let De = (_e.left + Me.x) / Ce.x, Pe = (_e.top + Me.y) / Ce.y, Oe = _e.width / Ce.x, je = _e.height / Ce.y; if (Re) { const Be = getWindow(Re), Ie = Ee && isElement(Ee) ? getWindow(Ee) : Ee; let Fe = Be, ze = getFrameElement(Fe); for (; ze && Ee && Ie !== Fe;) { const qe = getScale(ze), He = ze.getBoundingClientRect(), Ge = getComputedStyle$1(ze), Ze = He.left + (ze.clientLeft + parseFloat(Ge.paddingLeft)) * qe.x, sn = He.top + (ze.clientTop + parseFloat(Ge.paddingTop)) * qe.y; De *= qe.x, Pe *= qe.y, Oe *= qe.x, je *= qe.y, De += Ze, Pe += sn, Fe = getWindow(ze), ze = getFrameElement(Fe) } } return rectToClientRect({ width: Oe, height: je, x: De, y: Pe }) } function getWindowScrollBarX(e, t) { const xe = getNodeScroll(e).scrollLeft; return t ? t.left + xe : getBoundingClientRect(getDocumentElement(e)).left + xe } function getHTMLOffset(e, t, xe) { xe === void 0 && (xe = !1); const Ee = e.getBoundingClientRect(), _e = Ee.left + t.scrollLeft - (xe ? 0 : getWindowScrollBarX(e, Ee)), Re = Ee.top + t.scrollTop; return { x: _e, y: Re } } function convertOffsetParentRelativeRectToViewportRelativeRect(e) { let { elements: t, rect: xe, offsetParent: Ee, strategy: _e } = e; const Re = _e === "fixed", Ce = getDocumentElement(Ee), Me = t ? isTopLayer(t.floating) : !1; if (Ee === Ce || Me && Re) return xe; let De = { scrollLeft: 0, scrollTop: 0 }, Pe = createCoords(1); const Oe = createCoords(0), je = isHTMLElement(Ee); if ((je || !je && !Re) && ((getNodeName(Ee) !== "body" || isOverflowElement(Ce)) && (De = getNodeScroll(Ee)), isHTMLElement(Ee))) { const Ie = getBoundingClientRect(Ee); Pe = getScale(Ee), Oe.x = Ie.x + Ee.clientLeft, Oe.y = Ie.y + Ee.clientTop } const Be = Ce && !je && !Re ? getHTMLOffset(Ce, De, !0) : createCoords(0); return { width: xe.width * Pe.x, height: xe.height * Pe.y, x: xe.x * Pe.x - De.scrollLeft * Pe.x + Oe.x + Be.x, y: xe.y * Pe.y - De.scrollTop * Pe.y + Oe.y + Be.y } } function getClientRects(e) { return Array.from(e.getClientRects()) } function getDocumentRect(e) { const t = getDocumentElement(e), xe = getNodeScroll(e), Ee = e.ownerDocument.body, _e = max$1(t.scrollWidth, t.clientWidth, Ee.scrollWidth, Ee.clientWidth), Re = max$1(t.scrollHeight, t.clientHeight, Ee.scrollHeight, Ee.clientHeight); let Ce = -xe.scrollLeft + getWindowScrollBarX(e); const Me = -xe.scrollTop; return getComputedStyle$1(Ee).direction === "rtl" && (Ce += max$1(t.clientWidth, Ee.clientWidth) - _e), { width: _e, height: Re, x: Ce, y: Me } } function getViewportRect(e, t) { const xe = getWindow(e), Ee = getDocumentElement(e), _e = xe.visualViewport; let Re = Ee.clientWidth, Ce = Ee.clientHeight, Me = 0, De = 0; if (_e) { Re = _e.width, Ce = _e.height; const Pe = isWebKit(); (!Pe || Pe && t === "fixed") && (Me = _e.offsetLeft, De = _e.offsetTop) } return { width: Re, height: Ce, x: Me, y: De } } const absoluteOrFixed = new Set(["absolute", "fixed"]); function getInnerBoundingClientRect(e, t) { const xe = getBoundingClientRect(e, !0, t === "fixed"), Ee = xe.top + e.clientTop, _e = xe.left + e.clientLeft, Re = isHTMLElement(e) ? getScale(e) : createCoords(1), Ce = e.clientWidth * Re.x, Me = e.clientHeight * Re.y, De = _e * Re.x, Pe = Ee * Re.y; return { width: Ce, height: Me, x: De, y: Pe } } function getClientRectFromClippingAncestor(e, t, xe) { let Ee; if (t === "viewport") Ee = getViewportRect(e, xe); else if (t === "document") Ee = getDocumentRect(getDocumentElement(e)); else if (isElement(t)) Ee = getInnerBoundingClientRect(t, xe); else { const _e = getVisualOffsets(e); Ee = { x: t.x - _e.x, y: t.y - _e.y, width: t.width, height: t.height } } return rectToClientRect(Ee) } function hasFixedPositionAncestor(e, t) { const xe = getParentNode(e); return xe === t || !isElement(xe) || isLastTraversableNode(xe) ? !1 : getComputedStyle$1(xe).position === "fixed" || hasFixedPositionAncestor(xe, t) } function getClippingElementAncestors(e, t) { const xe = t.get(e); if (xe) return xe; let Ee = getOverflowAncestors(e, [], !1).filter(Me => isElement(Me) && getNodeName(Me) !== "body"), _e = null; const Re = getComputedStyle$1(e).position === "fixed"; let Ce = Re ? getParentNode(e) : e; for (; isElement(Ce) && !isLastTraversableNode(Ce);) { const Me = getComputedStyle$1(Ce), De = isContainingBlock(Ce); !De && Me.position === "fixed" && (_e = null), (Re ? !De && !_e : !De && Me.position === "static" && !!_e && absoluteOrFixed.has(_e.position) || isOverflowElement(Ce) && !De && hasFixedPositionAncestor(e, Ce)) ? Ee = Ee.filter(Oe => Oe !== Ce) : _e = Me, Ce = getParentNode(Ce) } return t.set(e, Ee), Ee } function getClippingRect(e) { let { element: t, boundary: xe, rootBoundary: Ee, strategy: _e } = e; const Ce = [...xe === "clippingAncestors" ? isTopLayer(t) ? [] : getClippingElementAncestors(t, this._c) : [].concat(xe), Ee], Me = Ce[0], De = Ce.reduce((Pe, Oe) => { const je = getClientRectFromClippingAncestor(t, Oe, _e); return Pe.top = max$1(je.top, Pe.top), Pe.right = min(je.right, Pe.right), Pe.bottom = min(je.bottom, Pe.bottom), Pe.left = max$1(je.left, Pe.left), Pe }, getClientRectFromClippingAncestor(t, Me, _e)); return { width: De.right - De.left, height: De.bottom - De.top, x: De.left, y: De.top } } function getDimensions(e) { const { width: t, height: xe } = getCssDimensions(e); return { width: t, height: xe } } function getRectRelativeToOffsetParent(e, t, xe) { const Ee = isHTMLElement(t), _e = getDocumentElement(t), Re = xe === "fixed", Ce = getBoundingClientRect(e, !0, Re, t); let Me = { scrollLeft: 0, scrollTop: 0 }; const De = createCoords(0); function Pe() { De.x = getWindowScrollBarX(_e) } if (Ee || !Ee && !Re) if ((getNodeName(t) !== "body" || isOverflowElement(_e)) && (Me = getNodeScroll(t)), Ee) { const Ie = getBoundingClientRect(t, !0, Re, t); De.x = Ie.x + t.clientLeft, De.y = Ie.y + t.clientTop } else _e && Pe(); Re && !Ee && _e && Pe(); const Oe = _e && !Ee && !Re ? getHTMLOffset(_e, Me) : createCoords(0), je = Ce.left + Me.scrollLeft - De.x - Oe.x, Be = Ce.top + Me.scrollTop - De.y - Oe.y; return { x: je, y: Be, width: Ce.width, height: Ce.height } } function isStaticPositioned(e) { return getComputedStyle$1(e).position === "static" } function getTrueOffsetParent(e, t) { if (!isHTMLElement(e) || getComputedStyle$1(e).position === "fixed") return null; if (t) return t(e); let xe = e.offsetParent; return getDocumentElement(e) === xe && (xe = xe.ownerDocument.body), xe } function getOffsetParent(e, t) { const xe = getWindow(e); if (isTopLayer(e)) return xe; if (!isHTMLElement(e)) { let _e = getParentNode(e); for (; _e && !isLastTraversableNode(_e);) { if (isElement(_e) && !isStaticPositioned(_e)) return _e; _e = getParentNode(_e) } return xe } let Ee = getTrueOffsetParent(e, t); for (; Ee && isTableElement(Ee) && isStaticPositioned(Ee);)Ee = getTrueOffsetParent(Ee, t); return Ee && isLastTraversableNode(Ee) && isStaticPositioned(Ee) && !isContainingBlock(Ee) ? xe : Ee || getContainingBlock(e) || xe } const getElementRects = async function (e) { const t = this.getOffsetParent || getOffsetParent, xe = this.getDimensions, Ee = await xe(e.floating); return { reference: getRectRelativeToOffsetParent(e.reference, await t(e.floating), e.strategy), floating: { x: 0, y: 0, width: Ee.width, height: Ee.height } } }; function isRTL(e) { return getComputedStyle$1(e).direction === "rtl" } const platform = { convertOffsetParentRelativeRectToViewportRelativeRect, getDocumentElement, getClippingRect, getOffsetParent, getElementRects, getClientRects, getDimensions, getScale, isElement, isRTL }; function rectsAreEqual(e, t) { return e.x === t.x && e.y === t.y && e.width === t.width && e.height === t.height } function observeMove(e, t) { let xe = null, Ee; const _e = getDocumentElement(e); function Re() { var Me; clearTimeout(Ee), (Me = xe) == null || Me.disconnect(), xe = null } function Ce(Me, De) { Me === void 0 && (Me = !1), De === void 0 && (De = 1), Re(); const Pe = e.getBoundingClientRect(), { left: Oe, top: je, width: Be, height: Ie } = Pe; if (Me || t(), !Be || !Ie) return; const Fe = floor(je), ze = floor(_e.clientWidth - (Oe + Be)), qe = floor(_e.clientHeight - (je + Ie)), He = floor(Oe), Ze = { rootMargin: -Fe + "px " + -ze + "px " + -qe + "px " + -He + "px", threshold: max$1(0, min(1, De)) || 1 }; let sn = !0; function Xe(St) { const un = St[0].intersectionRatio; if (un !== De) { if (!sn) return Ce(); un ? Ce(!1, un) : Ee = setTimeout(() => { Ce(!1, 1e-7) }, 1e3) } un === 1 && !rectsAreEqual(Pe, e.getBoundingClientRect()) && Ce(), sn = !1 } try { xe = new IntersectionObserver(Xe, { ...Ze, root: _e.ownerDocument }) } catch { xe = new IntersectionObserver(Xe, Ze) } xe.observe(e) } return Ce(!0), Re } function autoUpdate(e, t, xe, Ee) { Ee === void 0 && (Ee = {}); const { ancestorScroll: _e = !0, ancestorResize: Re = !0, elementResize: Ce = typeof ResizeObserver == "function", layoutShift: Me = typeof IntersectionObserver == "function", animationFrame: De = !1 } = Ee, Pe = unwrapElement(e), Oe = _e || Re ? [...Pe ? getOverflowAncestors(Pe) : [], ...getOverflowAncestors(t)] : []; Oe.forEach(He => { _e && He.addEventListener("scroll", xe, { passive: !0 }), Re && He.addEventListener("resize", xe) }); const je = Pe && Me ? observeMove(Pe, xe) : null; let Be = -1, Ie = null; Ce && (Ie = new ResizeObserver(He => { let [Ge] = He; Ge && Ge.target === Pe && Ie && (Ie.unobserve(t), cancelAnimationFrame(Be), Be = requestAnimationFrame(() => { var Ze; (Ze = Ie) == null || Ze.observe(t) })), xe() }), Pe && !De && Ie.observe(Pe), Ie.observe(t)); let Fe, ze = De ? getBoundingClientRect(e) : null; De && qe(); function qe() { const He = getBoundingClientRect(e); ze && !rectsAreEqual(ze, He) && xe(), ze = He, Fe = requestAnimationFrame(qe) } return xe(), () => { var He; Oe.forEach(Ge => { _e && Ge.removeEventListener("scroll", xe), Re && Ge.removeEventListener("resize", xe) }), je?.(), (He = Ie) == null || He.disconnect(), Ie = null, De && cancelAnimationFrame(Fe) } } const offset$1 = offset$2, shift$1 = shift$2, flip$1 = flip$2, size$1 = size$2, hide$1 = hide$2, arrow$2 = arrow$3, limitShift$1 = limitShift$2, computePosition = (e, t, xe) => { const Ee = new Map, _e = { platform, ...xe }, Re = { ..._e.platform, _c: Ee }; return computePosition$1(e, t, { ..._e, platform: Re }) }; var isClient = typeof document < "u", noop = function () { }, index = isClient ? reactExports.useLayoutEffect : noop; function deepEqual(e, t) { if (e === t) return !0; if (typeof e != typeof t) return !1; if (typeof e == "function" && e.toString() === t.toString()) return !0; let xe, Ee, _e; if (e && t && typeof e == "object") { if (Array.isArray(e)) { if (xe = e.length, xe !== t.length) return !1; for (Ee = xe; Ee-- !== 0;)if (!deepEqual(e[Ee], t[Ee])) return !1; return !0 } if (_e = Object.keys(e), xe = _e.length, xe !== Object.keys(t).length) return !1; for (Ee = xe; Ee-- !== 0;)if (!{}.hasOwnProperty.call(t, _e[Ee])) return !1; for (Ee = xe; Ee-- !== 0;) { const Re = _e[Ee]; if (!(Re === "_owner" && e.$$typeof) && !deepEqual(e[Re], t[Re])) return !1 } return !0 } return e !== e && t !== t } function getDPR(e) { return typeof window > "u" ? 1 : (e.ownerDocument.defaultView || window).devicePixelRatio || 1 } function roundByDPR(e, t) { const xe = getDPR(e); return Math.round(t * xe) / xe } function useLatestRef(e) { const t = reactExports.useRef(e); return index(() => { t.current = e }), t } function useFloating(e) { e === void 0 && (e = {}); const { placement: t = "bottom", strategy: xe = "absolute", middleware: Ee = [], platform: _e, elements: { reference: Re, floating: Ce } = {}, transform: Me = !0, whileElementsMounted: De, open: Pe } = e, [Oe, je] = reactExports.useState({ x: 0, y: 0, strategy: xe, placement: t, middlewareData: {}, isPositioned: !1 }), [Be, Ie] = reactExports.useState(Ee); deepEqual(Be, Ee) || Ie(Ee); const [Fe, ze] = reactExports.useState(null), [qe, He] = reactExports.useState(null), Ge = reactExports.useCallback(tn => { tn !== St.current && (St.current = tn, ze(tn)) }, []), Ze = reactExports.useCallback(tn => { tn !== un.current && (un.current = tn, He(tn)) }, []), sn = Re || Fe, Xe = Ce || qe, St = reactExports.useRef(null), un = reactExports.useRef(null), on = reactExports.useRef(Oe), bn = De != null, Tn = useLatestRef(De), fn = useLatestRef(_e), En = useLatestRef(Pe), Pn = reactExports.useCallback(() => { if (!St.current || !un.current) return; const tn = { placement: t, strategy: xe, middleware: Be }; fn.current && (tn.platform = fn.current), computePosition(St.current, un.current, tn).then(nn => { const We = { ...nn, isPositioned: En.current !== !1 }; Rn.current && !deepEqual(on.current, We) && (on.current = We, reactDomExports.flushSync(() => { je(We) })) }) }, [Be, t, xe, fn, En]); index(() => { Pe === !1 && on.current.isPositioned && (on.current.isPositioned = !1, je(tn => ({ ...tn, isPositioned: !1 }))) }, [Pe]); const Rn = reactExports.useRef(!1); index(() => (Rn.current = !0, () => { Rn.current = !1 }), []), index(() => { if (sn && (St.current = sn), Xe && (un.current = Xe), sn && Xe) { if (Tn.current) return Tn.current(sn, Xe, Pn); Pn() } }, [sn, Xe, Pn, Tn, bn]); const In = reactExports.useMemo(() => ({ reference: St, floating: un, setReference: Ge, setFloating: Ze }), [Ge, Ze]), xn = reactExports.useMemo(() => ({ reference: sn, floating: Xe }), [sn, Xe]), vn = reactExports.useMemo(() => { const tn = { position: xe, left: 0, top: 0 }; if (!xn.floating) return tn; const nn = roundByDPR(xn.floating, Oe.x), We = roundByDPR(xn.floating, Oe.y); return Me ? { ...tn, transform: "translate(" + nn + "px, " + We + "px)", ...getDPR(xn.floating) >= 1.5 && { willChange: "transform" } } : { position: xe, left: nn, top: We } }, [xe, Me, xn.floating, Oe.x, Oe.y]); return reactExports.useMemo(() => ({ ...Oe, update: Pn, refs: In, elements: xn, floatingStyles: vn }), [Oe, Pn, In, xn, vn]) } const arrow$1 = e => { function t(xe) { return {}.hasOwnProperty.call(xe, "current") } return { name: "arrow", options: e, fn(xe) { const { element: Ee, padding: _e } = typeof e == "function" ? e(xe) : e; return Ee && t(Ee) ? Ee.current != null ? arrow$2({ element: Ee.current, padding: _e }).fn(xe) : {} : Ee ? arrow$2({ element: Ee, padding: _e }).fn(xe) : {} } } }, offset = (e, t) => ({ ...offset$1(e), options: [e, t] }), shift = (e, t) => ({ ...shift$1(e), options: [e, t] }), limitShift = (e, t) => ({ ...limitShift$1(e), options: [e, t] }), flip = (e, t) => ({ ...flip$1(e), options: [e, t] }), size = (e, t) => ({ ...size$1(e), options: [e, t] }), hide = (e, t) => ({ ...hide$1(e), options: [e, t] }), arrow = (e, t) => ({ ...arrow$1(e), options: [e, t] }); var NAME$1 = "Arrow", Arrow$1 = reactExports.forwardRef((e, t) => { const { children: xe, width: Ee = 10, height: _e = 5, ...Re } = e; return jsxRuntimeExports.jsx(Primitive.svg, { ...Re, ref: t, width: Ee, height: _e, viewBox: "0 0 30 10", preserveAspectRatio: "none", children: e.asChild ? xe : jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" }) }) }); Arrow$1.displayName = NAME$1; var Root$3 = Arrow$1; function useSize(e) { const [t, xe] = reactExports.useState(void 0); return useLayoutEffect2(() => { if (e) { xe({ width: e.offsetWidth, height: e.offsetHeight }); const Ee = new ResizeObserver(_e => { if (!Array.isArray(_e) || !_e.length) return; const Re = _e[0]; let Ce, Me; if ("borderBoxSize" in Re) { const De = Re.borderBoxSize, Pe = Array.isArray(De) ? De[0] : De; Ce = Pe.inlineSize, Me = Pe.blockSize } else Ce = e.offsetWidth, Me = e.offsetHeight; xe({ width: Ce, height: Me }) }); return Ee.observe(e, { box: "border-box" }), () => Ee.unobserve(e) } else xe(void 0) }, [e]), t } var POPPER_NAME = "Popper", [createPopperContext, createPopperScope] = createContextScope(POPPER_NAME), [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME), Popper = e => { const { __scopePopper: t, children: xe } = e, [Ee, _e] = reactExports.useState(null); return jsxRuntimeExports.jsx(PopperProvider, { scope: t, anchor: Ee, onAnchorChange: _e, children: xe }) }; Popper.displayName = POPPER_NAME; var ANCHOR_NAME$1 = "PopperAnchor", PopperAnchor = reactExports.forwardRef((e, t) => { const { __scopePopper: xe, virtualRef: Ee, ..._e } = e, Re = usePopperContext(ANCHOR_NAME$1, xe), Ce = reactExports.useRef(null), Me = useComposedRefs(t, Ce); return reactExports.useEffect(() => { Re.onAnchorChange(Ee?.current || Ce.current) }), Ee ? null : jsxRuntimeExports.jsx(Primitive.div, { ..._e, ref: Me }) }); PopperAnchor.displayName = ANCHOR_NAME$1; var CONTENT_NAME$4 = "PopperContent", [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$4), PopperContent = reactExports.forwardRef((e, t) => { const { __scopePopper: xe, side: Ee = "bottom", sideOffset: _e = 0, align: Re = "center", alignOffset: Ce = 0, arrowPadding: Me = 0, avoidCollisions: De = !0, collisionBoundary: Pe = [], collisionPadding: Oe = 0, sticky: je = "partial", hideWhenDetached: Be = !1, updatePositionStrategy: Ie = "optimized", onPlaced: Fe, ...ze } = e, qe = usePopperContext(CONTENT_NAME$4, xe), [He, Ge] = reactExports.useState(null), Ze = useComposedRefs(t, an => Ge(an)), [sn, Xe] = reactExports.useState(null), St = useSize(sn), un = St?.width ?? 0, on = St?.height ?? 0, bn = Ee + (Re !== "center" ? "-" + Re : ""), Tn = typeof Oe == "number" ? Oe : { top: 0, right: 0, bottom: 0, left: 0, ...Oe }, fn = Array.isArray(Pe) ? Pe : [Pe], En = fn.length > 0, Pn = { padding: Tn, boundary: fn.filter(isNotNull), altBoundary: En }, { refs: Rn, floatingStyles: In, placement: xn, isPositioned: vn, middlewareData: tn } = useFloating({ strategy: "fixed", placement: bn, whileElementsMounted: (...an) => autoUpdate(...an, { animationFrame: Ie === "always" }), elements: { reference: qe.anchor }, middleware: [offset({ mainAxis: _e + on, alignmentAxis: Ce }), De && shift({ mainAxis: !0, crossAxis: !1, limiter: je === "partial" ? limitShift() : void 0, ...Pn }), De && flip({ ...Pn }), size({ ...Pn, apply: ({ elements: an, rects: pn, availableWidth: yn, availableHeight: _n }) => { const { width: On, height: kn } = pn.reference, zn = an.floating.style; zn.setProperty("--radix-popper-available-width", `${yn}px`), zn.setProperty("--radix-popper-available-height", `${_n}px`), zn.setProperty("--radix-popper-anchor-width", `${On}px`), zn.setProperty("--radix-popper-anchor-height", `${kn}px`) } }), sn && arrow({ element: sn, padding: Me }), transformOrigin({ arrowWidth: un, arrowHeight: on }), Be && hide({ strategy: "referenceHidden", ...Pn })] }), [nn, We] = getSideAndAlignFromPlacement(xn), dn = useCallbackRef$1(Fe); useLayoutEffect2(() => { vn && dn?.() }, [vn, dn]); const Je = tn.arrow?.x, rn = tn.arrow?.y, hn = tn.arrow?.centerOffset !== 0, [mn, Ye] = reactExports.useState(); return useLayoutEffect2(() => { He && Ye(window.getComputedStyle(He).zIndex) }, [He]), jsxRuntimeExports.jsx("div", { ref: Rn.setFloating, "data-radix-popper-content-wrapper": "", style: { ...In, transform: vn ? In.transform : "translate(0, -200%)", minWidth: "max-content", zIndex: mn, "--radix-popper-transform-origin": [tn.transformOrigin?.x, tn.transformOrigin?.y].join(" "), ...tn.hide?.referenceHidden && { visibility: "hidden", pointerEvents: "none" } }, dir: e.dir, children: jsxRuntimeExports.jsx(PopperContentProvider, { scope: xe, placedSide: nn, onArrowChange: Xe, arrowX: Je, arrowY: rn, shouldHideArrow: hn, children: jsxRuntimeExports.jsx(Primitive.div, { "data-side": nn, "data-align": We, ...ze, ref: Ze, style: { ...ze.style, animation: vn ? void 0 : "none" } }) }) }) }); PopperContent.displayName = CONTENT_NAME$4; var ARROW_NAME$3 = "PopperArrow", OPPOSITE_SIDE = { top: "bottom", right: "left", bottom: "top", left: "right" }, PopperArrow = reactExports.forwardRef(function (t, xe) { const { __scopePopper: Ee, ..._e } = t, Re = useContentContext(ARROW_NAME$3, Ee), Ce = OPPOSITE_SIDE[Re.placedSide]; return jsxRuntimeExports.jsx("span", { ref: Re.onArrowChange, style: { position: "absolute", left: Re.arrowX, top: Re.arrowY, [Ce]: 0, transformOrigin: { top: "", right: "0 0", bottom: "center 0", left: "100% 0" }[Re.placedSide], transform: { top: "translateY(100%)", right: "translateY(50%) rotate(90deg) translateX(-50%)", bottom: "rotate(180deg)", left: "translateY(50%) rotate(-90deg) translateX(50%)" }[Re.placedSide], visibility: Re.shouldHideArrow ? "hidden" : void 0 }, children: jsxRuntimeExports.jsx(Root$3, { ..._e, ref: xe, style: { ..._e.style, display: "block" } }) }) }); PopperArrow.displayName = ARROW_NAME$3; function isNotNull(e) { return e !== null } var transformOrigin = e => ({ name: "transformOrigin", options: e, fn(t) { const { placement: xe, rects: Ee, middlewareData: _e } = t, Ce = _e.arrow?.centerOffset !== 0, Me = Ce ? 0 : e.arrowWidth, De = Ce ? 0 : e.arrowHeight, [Pe, Oe] = getSideAndAlignFromPlacement(xe), je = { start: "0%", center: "50%", end: "100%" }[Oe], Be = (_e.arrow?.x ?? 0) + Me / 2, Ie = (_e.arrow?.y ?? 0) + De / 2; let Fe = "", ze = ""; return Pe === "bottom" ? (Fe = Ce ? je : `${Be}px`, ze = `${-De}px`) : Pe === "top" ? (Fe = Ce ? je : `${Be}px`, ze = `${Ee.floating.height + De}px`) : Pe === "right" ? (Fe = `${-De}px`, ze = Ce ? je : `${Ie}px`) : Pe === "left" && (Fe = `${Ee.floating.width + De}px`, ze = Ce ? je : `${Ie}px`), { data: { x: Fe, y: ze } } } }); function getSideAndAlignFromPlacement(e) { const [t, xe = "center"] = e.split("-"); return [t, xe] } var Root2$2 = Popper, Anchor = PopperAnchor, Content$1 = PopperContent, Arrow = PopperArrow, PORTAL_NAME$4 = "Portal", Portal$4 = reactExports.forwardRef((e, t) => { const { container: xe, ...Ee } = e, [_e, Re] = reactExports.useState(!1); useLayoutEffect2(() => Re(!0), []); const Ce = xe || _e && globalThis?.document?.body; return Ce ? ReactDOM.createPortal(jsxRuntimeExports.jsx(Primitive.div, { ...Ee, ref: t }), Ce) : null }); Portal$4.displayName = PORTAL_NAME$4; var useInsertionEffect = React$1[" useInsertionEffect ".trim().toString()] || useLayoutEffect2; function useControllableState({ prop: e, defaultProp: t, onChange: xe = () => { }, caller: Ee }) { const [_e, Re, Ce] = useUncontrolledState({ defaultProp: t, onChange: xe }), Me = e !== void 0, De = Me ? e : _e; { const Oe = reactExports.useRef(e !== void 0); reactExports.useEffect(() => { const je = Oe.current; je !== Me && console.warn(`${Ee} is changing from ${je ? "controlled" : "uncontrolled"} to ${Me ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`), Oe.current = Me }, [Me, Ee]) } const Pe = reactExports.useCallback(Oe => { if (Me) { const je = isFunction$2(Oe) ? Oe(e) : Oe; je !== e && Ce.current?.(je) } else Re(Oe) }, [Me, e, Re, Ce]); return [De, Pe] } function useUncontrolledState({ defaultProp: e, onChange: t }) { const [xe, Ee] = reactExports.useState(e), _e = reactExports.useRef(xe), Re = reactExports.useRef(t); return useInsertionEffect(() => { Re.current = t }, [t]), reactExports.useEffect(() => { _e.current !== xe && (Re.current?.(xe), _e.current = xe) }, [xe, _e]), [xe, Ee, Re] } function isFunction$2(e) { return typeof e == "function" } function usePrevious(e) { const t = reactExports.useRef({ value: e, previous: e }); return reactExports.useMemo(() => (t.current.value !== e && (t.current.previous = t.current.value, t.current.value = e), t.current.previous), [e]) } var VISUALLY_HIDDEN_STYLES = Object.freeze({ position: "absolute", border: 0, width: 1, height: 1, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", wordWrap: "normal" }), NAME = "VisuallyHidden", VisuallyHidden = reactExports.forwardRef((e, t) => jsxRuntimeExports.jsx(Primitive.span, { ...e, ref: t, style: { ...VISUALLY_HIDDEN_STYLES, ...e.style } })); VisuallyHidden.displayName = NAME; var Root$2 = VisuallyHidden, getDefaultParent = function (e) { if (typeof document > "u") return null; var t = Array.isArray(e) ? e[0] : e; return t.ownerDocument.body }, counterMap = new WeakMap, uncontrolledNodes = new WeakMap, markerMap = {}, lockCount = 0, unwrapHost = function (e) { return e && (e.host || unwrapHost(e.parentNode)) }, correctTargets = function (e, t) { return t.map(function (xe) { if (e.contains(xe)) return xe; var Ee = unwrapHost(xe); return Ee && e.contains(Ee) ? Ee : (console.error("aria-hidden", xe, "in not contained inside", e, ". Doing nothing"), null) }).filter(function (xe) { return !!xe }) }, applyAttributeToOthers = function (e, t, xe, Ee) { var _e = correctTargets(t, Array.isArray(e) ? e : [e]); markerMap[xe] || (markerMap[xe] = new WeakMap); var Re = markerMap[xe], Ce = [], Me = new Set, De = new Set(_e), Pe = function (je) { !je || Me.has(je) || (Me.add(je), Pe(je.parentNode)) }; _e.forEach(Pe); var Oe = function (je) { !je || De.has(je) || Array.prototype.forEach.call(je.children, function (Be) { if (Me.has(Be)) Oe(Be); else try { var Ie = Be.getAttribute(Ee), Fe = Ie !== null && Ie !== "false", ze = (counterMap.get(Be) || 0) + 1, qe = (Re.get(Be) || 0) + 1; counterMap.set(Be, ze), Re.set(Be, qe), Ce.push(Be), ze === 1 && Fe && uncontrolledNodes.set(Be, !0), qe === 1 && Be.setAttribute(xe, "true"), Fe || Be.setAttribute(Ee, "true") } catch (He) { console.error("aria-hidden: cannot operate on ", Be, He) } }) }; return Oe(t), Me.clear(), lockCount++, function () { Ce.forEach(function (je) { var Be = counterMap.get(je) - 1, Ie = Re.get(je) - 1; counterMap.set(je, Be), Re.set(je, Ie), Be || (uncontrolledNodes.has(je) || je.removeAttribute(Ee), uncontrolledNodes.delete(je)), Ie || je.removeAttribute(xe) }), lockCount--, lockCount || (counterMap = new WeakMap, counterMap = new WeakMap, uncontrolledNodes = new WeakMap, markerMap = {}) } }, hideOthers = function (e, t, xe) { xe === void 0 && (xe = "data-aria-hidden"); var Ee = Array.from(Array.isArray(e) ? e : [e]), _e = getDefaultParent(e); return _e ? (Ee.push.apply(Ee, Array.from(_e.querySelectorAll("[aria-live], script"))), applyAttributeToOthers(Ee, _e, xe, "aria-hidden")) : function () { return null } }, __assign = function () { return __assign = Object.assign || function (t) { for (var xe, Ee = 1, _e = arguments.length; Ee < _e; Ee++) { xe = arguments[Ee]; for (var Re in xe) Object.prototype.hasOwnProperty.call(xe, Re) && (t[Re] = xe[Re]) } return t }, __assign.apply(this, arguments) }; function __rest$2(e, t) { var xe = {}; for (var Ee in e) Object.prototype.hasOwnProperty.call(e, Ee) && t.indexOf(Ee) < 0 && (xe[Ee] = e[Ee]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var _e = 0, Ee = Object.getOwnPropertySymbols(e); _e < Ee.length; _e++)t.indexOf(Ee[_e]) < 0 && Object.prototype.propertyIsEnumerable.call(e, Ee[_e]) && (xe[Ee[_e]] = e[Ee[_e]]); return xe } function __spreadArray$1(e, t, xe) { if (xe || arguments.length === 2) for (var Ee = 0, _e = t.length, Re; Ee < _e; Ee++)(Re || !(Ee in t)) && (Re || (Re = Array.prototype.slice.call(t, 0, Ee)), Re[Ee] = t[Ee]); return e.concat(Re || Array.prototype.slice.call(t)) } typeof SuppressedError == "function" && SuppressedError; var zeroRightClassName = "right-scroll-bar-position", fullWidthClassName = "width-before-scroll-bar", noScrollbarsClassName = "with-scroll-bars-hidden", removedBarSizeVariable = "--removed-body-scroll-bar-size"; function assignRef(e, t) { return typeof e == "function" ? e(t) : e && (e.current = t), e } function useCallbackRef(e, t) { var xe = reactExports.useState(function () { return { value: e, callback: t, facade: { get current() { return xe.value }, set current(Ee) { var _e = xe.value; _e !== Ee && (xe.value = Ee, xe.callback(Ee, _e)) } } } })[0]; return xe.callback = t, xe.facade } var useIsomorphicLayoutEffect = typeof window < "u" ? reactExports.useLayoutEffect : reactExports.useEffect, currentValues = new WeakMap; function useMergeRefs(e, t) { var xe = useCallbackRef(null, function (Ee) { return e.forEach(function (_e) { return assignRef(_e, Ee) }) }); return useIsomorphicLayoutEffect(function () { var Ee = currentValues.get(xe); if (Ee) { var _e = new Set(Ee), Re = new Set(e), Ce = xe.current; _e.forEach(function (Me) { Re.has(Me) || assignRef(Me, null) }), Re.forEach(function (Me) { _e.has(Me) || assignRef(Me, Ce) }) } currentValues.set(xe, e) }, [e]), xe } function ItoI(e) { return e } function innerCreateMedium(e, t) { t === void 0 && (t = ItoI); var xe = [], Ee = !1, _e = { read: function () { if (Ee) throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`."); return xe.length ? xe[xe.length - 1] : e }, useMedium: function (Re) { var Ce = t(Re, Ee); return xe.push(Ce), function () { xe = xe.filter(function (Me) { return Me !== Ce }) } }, assignSyncMedium: function (Re) { for (Ee = !0; xe.length;) { var Ce = xe; xe = [], Ce.forEach(Re) } xe = { push: function (Me) { return Re(Me) }, filter: function () { return xe } } }, assignMedium: function (Re) { Ee = !0; var Ce = []; if (xe.length) { var Me = xe; xe = [], Me.forEach(Re), Ce = xe } var De = function () { var Oe = Ce; Ce = [], Oe.forEach(Re) }, Pe = function () { return Promise.resolve().then(De) }; Pe(), xe = { push: function (Oe) { Ce.push(Oe), Pe() }, filter: function (Oe) { return Ce = Ce.filter(Oe), xe } } } }; return _e } function createSidecarMedium(e) { e === void 0 && (e = {}); var t = innerCreateMedium(null); return t.options = __assign({ async: !0, ssr: !1 }, e), t } var SideCar$1 = function (e) { var t = e.sideCar, xe = __rest$2(e, ["sideCar"]); if (!t) throw new Error("Sidecar: please provide `sideCar` property to import the right car"); var Ee = t.read(); if (!Ee) throw new Error("Sidecar medium not found"); return reactExports.createElement(Ee, __assign({}, xe)) }; SideCar$1.isSideCarExport = !0; function exportSidecar(e, t) { return e.useMedium(t), SideCar$1 } var effectCar = createSidecarMedium(), nothing = function () { }, RemoveScroll = reactExports.forwardRef(function (e, t) { var xe = reactExports.useRef(null), Ee = reactExports.useState({ onScrollCapture: nothing, onWheelCapture: nothing, onTouchMoveCapture: nothing }), _e = Ee[0], Re = Ee[1], Ce = e.forwardProps, Me = e.children, De = e.className, Pe = e.removeScrollBar, Oe = e.enabled, je = e.shards, Be = e.sideCar, Ie = e.noRelative, Fe = e.noIsolation, ze = e.inert, qe = e.allowPinchZoom, He = e.as, Ge = He === void 0 ? "div" : He, Ze = e.gapMode, sn = __rest$2(e, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), Xe = Be, St = useMergeRefs([xe, t]), un = __assign(__assign({}, sn), _e); return reactExports.createElement(reactExports.Fragment, null, Oe && reactExports.createElement(Xe, { sideCar: effectCar, removeScrollBar: Pe, shards: je, noRelative: Ie, noIsolation: Fe, inert: ze, setCallbacks: Re, allowPinchZoom: !!qe, lockRef: xe, gapMode: Ze }), Ce ? reactExports.cloneElement(reactExports.Children.only(Me), __assign(__assign({}, un), { ref: St })) : reactExports.createElement(Ge, __assign({}, un, { className: De, ref: St }), Me)) }); RemoveScroll.defaultProps = { enabled: !0, removeScrollBar: !0, inert: !1 }; RemoveScroll.classNames = { fullWidth: fullWidthClassName, zeroRight: zeroRightClassName }; var getNonce = function () { if (typeof __webpack_nonce__ < "u") return __webpack_nonce__ }; function makeStyleTag() { if (!document) return null; var e = document.createElement("style"); e.type = "text/css"; var t = getNonce(); return t && e.setAttribute("nonce", t), e } function injectStyles(e, t) { e.styleSheet ? e.styleSheet.cssText = t : e.appendChild(document.createTextNode(t)) } function insertStyleTag(e) { var t = document.head || document.getElementsByTagName("head")[0]; t.appendChild(e) } var stylesheetSingleton = function () { var e = 0, t = null; return { add: function (xe) { e == 0 && (t = makeStyleTag()) && (injectStyles(t, xe), insertStyleTag(t)), e++ }, remove: function () { e--, !e && t && (t.parentNode && t.parentNode.removeChild(t), t = null) } } }, styleHookSingleton = function () { var e = stylesheetSingleton(); return function (t, xe) { reactExports.useEffect(function () { return e.add(t), function () { e.remove() } }, [t && xe]) } }, styleSingleton = function () { var e = styleHookSingleton(), t = function (xe) { var Ee = xe.styles, _e = xe.dynamic; return e(Ee, _e), null }; return t }, zeroGap = { left: 0, top: 0, right: 0, gap: 0 }, parse = function (e) { return parseInt(e || "", 10) || 0 }, getOffset$1 = function (e) { var t = window.getComputedStyle(document.body), xe = t[e === "padding" ? "paddingLeft" : "marginLeft"], Ee = t[e === "padding" ? "paddingTop" : "marginTop"], _e = t[e === "padding" ? "paddingRight" : "marginRight"]; return [parse(xe), parse(Ee), parse(_e)] }, getGapWidth = function (e) { if (e === void 0 && (e = "margin"), typeof window > "u") return zeroGap; var t = getOffset$1(e), xe = document.documentElement.clientWidth, Ee = window.innerWidth; return { left: t[0], top: t[1], right: t[2], gap: Math.max(0, Ee - xe + t[2] - t[0]) } }, Style = styleSingleton(), lockAttribute = "data-scroll-locked", getStyles = function (e, t, xe, Ee) {
  var _e = e.left, Re = e.top, Ce = e.right, Me = e.gap; return xe === void 0 && (xe = "margin"), `
  .`.concat(noScrollbarsClassName, ` {
   overflow: hidden `).concat(Ee, `;
   padding-right: `).concat(Me, "px ").concat(Ee, `;
  }
  body[`).concat(lockAttribute, `] {
    overflow: hidden `).concat(Ee, `;
    overscroll-behavior: contain;
    `).concat([t && "position: relative ".concat(Ee, ";"), xe === "margin" && `
    padding-left: `.concat(_e, `px;
    padding-top: `).concat(Re, `px;
    padding-right: `).concat(Ce, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(Me, "px ").concat(Ee, `;
    `), xe === "padding" && "padding-right: ".concat(Me, "px ").concat(Ee, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(zeroRightClassName, ` {
    right: `).concat(Me, "px ").concat(Ee, `;
  }
  
  .`).concat(fullWidthClassName, ` {
    margin-right: `).concat(Me, "px ").concat(Ee, `;
  }
  
  .`).concat(zeroRightClassName, " .").concat(zeroRightClassName, ` {
    right: 0 `).concat(Ee, `;
  }
  
  .`).concat(fullWidthClassName, " .").concat(fullWidthClassName, ` {
    margin-right: 0 `).concat(Ee, `;
  }
  
  body[`).concat(lockAttribute, `] {
    `).concat(removedBarSizeVariable, ": ").concat(Me, `px;
  }
`)
}, getCurrentUseCounter = function () { var e = parseInt(document.body.getAttribute(lockAttribute) || "0", 10); return isFinite(e) ? e : 0 }, useLockAttribute = function () { reactExports.useEffect(function () { return document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString()), function () { var e = getCurrentUseCounter() - 1; e <= 0 ? document.body.removeAttribute(lockAttribute) : document.body.setAttribute(lockAttribute, e.toString()) } }, []) }, RemoveScrollBar = function (e) { var t = e.noRelative, xe = e.noImportant, Ee = e.gapMode, _e = Ee === void 0 ? "margin" : Ee; useLockAttribute(); var Re = reactExports.useMemo(function () { return getGapWidth(_e) }, [_e]); return reactExports.createElement(Style, { styles: getStyles(Re, !t, _e, xe ? "" : "!important") }) }, passiveSupported = !1; if (typeof window < "u") try { var options = Object.defineProperty({}, "passive", { get: function () { return passiveSupported = !0, !0 } }); window.addEventListener("test", options, options), window.removeEventListener("test", options, options) } catch { passiveSupported = !1 } var nonPassive = passiveSupported ? { passive: !1 } : !1, alwaysContainsScroll = function (e) { return e.tagName === "TEXTAREA" }, elementCanBeScrolled = function (e, t) { if (!(e instanceof Element)) return !1; var xe = window.getComputedStyle(e); return xe[t] !== "hidden" && !(xe.overflowY === xe.overflowX && !alwaysContainsScroll(e) && xe[t] === "visible") }, elementCouldBeVScrolled = function (e) { return elementCanBeScrolled(e, "overflowY") }, elementCouldBeHScrolled = function (e) { return elementCanBeScrolled(e, "overflowX") }, locationCouldBeScrolled = function (e, t) { var xe = t.ownerDocument, Ee = t; do { typeof ShadowRoot < "u" && Ee instanceof ShadowRoot && (Ee = Ee.host); var _e = elementCouldBeScrolled(e, Ee); if (_e) { var Re = getScrollVariables(e, Ee), Ce = Re[1], Me = Re[2]; if (Ce > Me) return !0 } Ee = Ee.parentNode } while (Ee && Ee !== xe.body); return !1 }, getVScrollVariables = function (e) { var t = e.scrollTop, xe = e.scrollHeight, Ee = e.clientHeight; return [t, xe, Ee] }, getHScrollVariables = function (e) { var t = e.scrollLeft, xe = e.scrollWidth, Ee = e.clientWidth; return [t, xe, Ee] }, elementCouldBeScrolled = function (e, t) { return e === "v" ? elementCouldBeVScrolled(t) : elementCouldBeHScrolled(t) }, getScrollVariables = function (e, t) { return e === "v" ? getVScrollVariables(t) : getHScrollVariables(t) }, getDirectionFactor = function (e, t) { return e === "h" && t === "rtl" ? -1 : 1 }, handleScroll = function (e, t, xe, Ee, _e) { var Re = getDirectionFactor(e, window.getComputedStyle(t).direction), Ce = Re * Ee, Me = xe.target, De = t.contains(Me), Pe = !1, Oe = Ce > 0, je = 0, Be = 0; do { if (!Me) break; var Ie = getScrollVariables(e, Me), Fe = Ie[0], ze = Ie[1], qe = Ie[2], He = ze - qe - Re * Fe; (Fe || He) && elementCouldBeScrolled(e, Me) && (je += He, Be += Fe); var Ge = Me.parentNode; Me = Ge && Ge.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? Ge.host : Ge } while (!De && Me !== document.body || De && (t.contains(Me) || t === Me)); return (Oe && Math.abs(je) < 1 || !Oe && Math.abs(Be) < 1) && (Pe = !0), Pe }, getTouchXY = function (e) { return "changedTouches" in e ? [e.changedTouches[0].clientX, e.changedTouches[0].clientY] : [0, 0] }, getDeltaXY = function (e) { return [e.deltaX, e.deltaY] }, extractRef = function (e) { return e && "current" in e ? e.current : e }, deltaCompare = function (e, t) { return e[0] === t[0] && e[1] === t[1] }, generateStyle = function (e) {
  return `
  .block-interactivity-`.concat(e, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e, ` {pointer-events: all;}
`)
}, idCounter = 0, lockStack = []; function RemoveScrollSideCar(e) { var t = reactExports.useRef([]), xe = reactExports.useRef([0, 0]), Ee = reactExports.useRef(), _e = reactExports.useState(idCounter++)[0], Re = reactExports.useState(styleSingleton)[0], Ce = reactExports.useRef(e); reactExports.useEffect(function () { Ce.current = e }, [e]), reactExports.useEffect(function () { if (e.inert) { document.body.classList.add("block-interactivity-".concat(_e)); var ze = __spreadArray$1([e.lockRef.current], (e.shards || []).map(extractRef), !0).filter(Boolean); return ze.forEach(function (qe) { return qe.classList.add("allow-interactivity-".concat(_e)) }), function () { document.body.classList.remove("block-interactivity-".concat(_e)), ze.forEach(function (qe) { return qe.classList.remove("allow-interactivity-".concat(_e)) }) } } }, [e.inert, e.lockRef.current, e.shards]); var Me = reactExports.useCallback(function (ze, qe) { if ("touches" in ze && ze.touches.length === 2 || ze.type === "wheel" && ze.ctrlKey) return !Ce.current.allowPinchZoom; var He = getTouchXY(ze), Ge = xe.current, Ze = "deltaX" in ze ? ze.deltaX : Ge[0] - He[0], sn = "deltaY" in ze ? ze.deltaY : Ge[1] - He[1], Xe, St = ze.target, un = Math.abs(Ze) > Math.abs(sn) ? "h" : "v"; if ("touches" in ze && un === "h" && St.type === "range") return !1; var on = locationCouldBeScrolled(un, St); if (!on) return !0; if (on ? Xe = un : (Xe = un === "v" ? "h" : "v", on = locationCouldBeScrolled(un, St)), !on) return !1; if (!Ee.current && "changedTouches" in ze && (Ze || sn) && (Ee.current = Xe), !Xe) return !0; var bn = Ee.current || Xe; return handleScroll(bn, qe, ze, bn === "h" ? Ze : sn) }, []), De = reactExports.useCallback(function (ze) { var qe = ze; if (!(!lockStack.length || lockStack[lockStack.length - 1] !== Re)) { var He = "deltaY" in qe ? getDeltaXY(qe) : getTouchXY(qe), Ge = t.current.filter(function (Xe) { return Xe.name === qe.type && (Xe.target === qe.target || qe.target === Xe.shadowParent) && deltaCompare(Xe.delta, He) })[0]; if (Ge && Ge.should) { qe.cancelable && qe.preventDefault(); return } if (!Ge) { var Ze = (Ce.current.shards || []).map(extractRef).filter(Boolean).filter(function (Xe) { return Xe.contains(qe.target) }), sn = Ze.length > 0 ? Me(qe, Ze[0]) : !Ce.current.noIsolation; sn && qe.cancelable && qe.preventDefault() } } }, []), Pe = reactExports.useCallback(function (ze, qe, He, Ge) { var Ze = { name: ze, delta: qe, target: He, should: Ge, shadowParent: getOutermostShadowParent(He) }; t.current.push(Ze), setTimeout(function () { t.current = t.current.filter(function (sn) { return sn !== Ze }) }, 1) }, []), Oe = reactExports.useCallback(function (ze) { xe.current = getTouchXY(ze), Ee.current = void 0 }, []), je = reactExports.useCallback(function (ze) { Pe(ze.type, getDeltaXY(ze), ze.target, Me(ze, e.lockRef.current)) }, []), Be = reactExports.useCallback(function (ze) { Pe(ze.type, getTouchXY(ze), ze.target, Me(ze, e.lockRef.current)) }, []); reactExports.useEffect(function () { return lockStack.push(Re), e.setCallbacks({ onScrollCapture: je, onWheelCapture: je, onTouchMoveCapture: Be }), document.addEventListener("wheel", De, nonPassive), document.addEventListener("touchmove", De, nonPassive), document.addEventListener("touchstart", Oe, nonPassive), function () { lockStack = lockStack.filter(function (ze) { return ze !== Re }), document.removeEventListener("wheel", De, nonPassive), document.removeEventListener("touchmove", De, nonPassive), document.removeEventListener("touchstart", Oe, nonPassive) } }, []); var Ie = e.removeScrollBar, Fe = e.inert; return reactExports.createElement(reactExports.Fragment, null, Fe ? reactExports.createElement(Re, { styles: generateStyle(_e) }) : null, Ie ? reactExports.createElement(RemoveScrollBar, { noRelative: e.noRelative, gapMode: e.gapMode }) : null) } function getOutermostShadowParent(e) { for (var t = null; e !== null;)e instanceof ShadowRoot && (t = e.host, e = e.host), e = e.parentNode; return t } const SideCar = exportSidecar(effectCar, RemoveScrollSideCar); var ReactRemoveScroll = reactExports.forwardRef(function (e, t) { return reactExports.createElement(RemoveScroll, __assign({}, e, { ref: t, sideCar: SideCar })) }); ReactRemoveScroll.classNames = RemoveScroll.classNames; var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"], SELECTION_KEYS = [" ", "Enter"], SELECT_NAME = "Select", [Collection, useCollection, createCollectionScope] = createCollection(SELECT_NAME), [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [createCollectionScope, createPopperScope]), usePopperScope$2 = createPopperScope(), [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME), [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME), Select$1 = e => { const { __scopeSelect: t, children: xe, open: Ee, defaultOpen: _e, onOpenChange: Re, value: Ce, defaultValue: Me, onValueChange: De, dir: Pe, name: Oe, autoComplete: je, disabled: Be, required: Ie, form: Fe } = e, ze = usePopperScope$2(t), [qe, He] = reactExports.useState(null), [Ge, Ze] = reactExports.useState(null), [sn, Xe] = reactExports.useState(!1), St = useDirection(Pe), [un, on] = useControllableState({ prop: Ee, defaultProp: _e ?? !1, onChange: Re, caller: SELECT_NAME }), [bn, Tn] = useControllableState({ prop: Ce, defaultProp: Me, onChange: De, caller: SELECT_NAME }), fn = reactExports.useRef(null), En = qe ? Fe || !!qe.closest("form") : !0, [Pn, Rn] = reactExports.useState(new Set), In = Array.from(Pn).map(xn => xn.props.value).join(";"); return jsxRuntimeExports.jsx(Root2$2, { ...ze, children: jsxRuntimeExports.jsxs(SelectProvider, { required: Ie, scope: t, trigger: qe, onTriggerChange: He, valueNode: Ge, onValueNodeChange: Ze, valueNodeHasChildren: sn, onValueNodeHasChildrenChange: Xe, contentId: useId(), value: bn, onValueChange: Tn, open: un, onOpenChange: on, dir: St, triggerPointerDownPosRef: fn, disabled: Be, children: [jsxRuntimeExports.jsx(Collection.Provider, { scope: t, children: jsxRuntimeExports.jsx(SelectNativeOptionsProvider, { scope: e.__scopeSelect, onNativeOptionAdd: reactExports.useCallback(xn => { Rn(vn => new Set(vn).add(xn)) }, []), onNativeOptionRemove: reactExports.useCallback(xn => { Rn(vn => { const tn = new Set(vn); return tn.delete(xn), tn }) }, []), children: xe }) }), En ? jsxRuntimeExports.jsxs(SelectBubbleInput, { "aria-hidden": !0, required: Ie, tabIndex: -1, name: Oe, autoComplete: je, value: bn, onChange: xn => Tn(xn.target.value), disabled: Be, form: Fe, children: [bn === void 0 ? jsxRuntimeExports.jsx("option", { value: "" }) : null, Array.from(Pn)] }, In) : null] }) }) }; Select$1.displayName = SELECT_NAME; var TRIGGER_NAME$4 = "SelectTrigger", SelectTrigger$1 = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, disabled: Ee = !1, ..._e } = e, Re = usePopperScope$2(xe), Ce = useSelectContext(TRIGGER_NAME$4, xe), Me = Ce.disabled || Ee, De = useComposedRefs(t, Ce.onTriggerChange), Pe = useCollection(xe), Oe = reactExports.useRef("touch"), [je, Be, Ie] = useTypeaheadSearch(ze => { const qe = Pe().filter(Ze => !Ze.disabled), He = qe.find(Ze => Ze.value === Ce.value), Ge = findNextItem(qe, ze, He); Ge !== void 0 && Ce.onValueChange(Ge.value) }), Fe = ze => { Me || (Ce.onOpenChange(!0), Ie()), ze && (Ce.triggerPointerDownPosRef.current = { x: Math.round(ze.pageX), y: Math.round(ze.pageY) }) }; return jsxRuntimeExports.jsx(Anchor, { asChild: !0, ...Re, children: jsxRuntimeExports.jsx(Primitive.button, { type: "button", role: "combobox", "aria-controls": Ce.contentId, "aria-expanded": Ce.open, "aria-required": Ce.required, "aria-autocomplete": "none", dir: Ce.dir, "data-state": Ce.open ? "open" : "closed", disabled: Me, "data-disabled": Me ? "" : void 0, "data-placeholder": shouldShowPlaceholder(Ce.value) ? "" : void 0, ..._e, ref: De, onClick: composeEventHandlers(_e.onClick, ze => { ze.currentTarget.focus(), Oe.current !== "mouse" && Fe(ze) }), onPointerDown: composeEventHandlers(_e.onPointerDown, ze => { Oe.current = ze.pointerType; const qe = ze.target; qe.hasPointerCapture(ze.pointerId) && qe.releasePointerCapture(ze.pointerId), ze.button === 0 && ze.ctrlKey === !1 && ze.pointerType === "mouse" && (Fe(ze), ze.preventDefault()) }), onKeyDown: composeEventHandlers(_e.onKeyDown, ze => { const qe = je.current !== ""; !(ze.ctrlKey || ze.altKey || ze.metaKey) && ze.key.length === 1 && Be(ze.key), !(qe && ze.key === " ") && OPEN_KEYS.includes(ze.key) && (Fe(), ze.preventDefault()) }) }) }) }); SelectTrigger$1.displayName = TRIGGER_NAME$4; var VALUE_NAME = "SelectValue", SelectValue$1 = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, className: Ee, style: _e, children: Re, placeholder: Ce = "", ...Me } = e, De = useSelectContext(VALUE_NAME, xe), { onValueNodeHasChildrenChange: Pe } = De, Oe = Re !== void 0, je = useComposedRefs(t, De.onValueNodeChange); return useLayoutEffect2(() => { Pe(Oe) }, [Pe, Oe]), jsxRuntimeExports.jsx(Primitive.span, { ...Me, ref: je, style: { pointerEvents: "none" }, children: shouldShowPlaceholder(De.value) ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: Ce }) : Re }) }); SelectValue$1.displayName = VALUE_NAME; var ICON_NAME = "SelectIcon", SelectIcon = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, children: Ee, ..._e } = e; return jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": !0, ..._e, ref: t, children: Ee || "▼" }) }); SelectIcon.displayName = ICON_NAME; var PORTAL_NAME$3 = "SelectPortal", SelectPortal = e => jsxRuntimeExports.jsx(Portal$4, { asChild: !0, ...e }); SelectPortal.displayName = PORTAL_NAME$3; var CONTENT_NAME$3 = "SelectContent", SelectContent$1 = reactExports.forwardRef((e, t) => { const xe = useSelectContext(CONTENT_NAME$3, e.__scopeSelect), [Ee, _e] = reactExports.useState(); if (useLayoutEffect2(() => { _e(new DocumentFragment) }, []), !xe.open) { const Re = Ee; return Re ? reactDomExports.createPortal(jsxRuntimeExports.jsx(SelectContentProvider, { scope: e.__scopeSelect, children: jsxRuntimeExports.jsx(Collection.Slot, { scope: e.__scopeSelect, children: jsxRuntimeExports.jsx("div", { children: e.children }) }) }), Re) : null } return jsxRuntimeExports.jsx(SelectContentImpl, { ...e, ref: t }) }); SelectContent$1.displayName = CONTENT_NAME$3; var CONTENT_MARGIN = 10, [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$3), CONTENT_IMPL_NAME = "SelectContentImpl", Slot$2 = createSlot("SelectContent.RemoveScroll"), SelectContentImpl = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, position: Ee = "item-aligned", onCloseAutoFocus: _e, onEscapeKeyDown: Re, onPointerDownOutside: Ce, side: Me, sideOffset: De, align: Pe, alignOffset: Oe, arrowPadding: je, collisionBoundary: Be, collisionPadding: Ie, sticky: Fe, hideWhenDetached: ze, avoidCollisions: qe, ...He } = e, Ge = useSelectContext(CONTENT_NAME$3, xe), [Ze, sn] = reactExports.useState(null), [Xe, St] = reactExports.useState(null), un = useComposedRefs(t, an => sn(an)), [on, bn] = reactExports.useState(null), [Tn, fn] = reactExports.useState(null), En = useCollection(xe), [Pn, Rn] = reactExports.useState(!1), In = reactExports.useRef(!1); reactExports.useEffect(() => { if (Ze) return hideOthers(Ze) }, [Ze]), useFocusGuards(); const xn = reactExports.useCallback(an => { const [pn, ...yn] = En().map(kn => kn.ref.current), [_n] = yn.slice(-1), On = document.activeElement; for (const kn of an) if (kn === On || (kn?.scrollIntoView({ block: "nearest" }), kn === pn && Xe && (Xe.scrollTop = 0), kn === _n && Xe && (Xe.scrollTop = Xe.scrollHeight), kn?.focus(), document.activeElement !== On)) return }, [En, Xe]), vn = reactExports.useCallback(() => xn([on, Ze]), [xn, on, Ze]); reactExports.useEffect(() => { Pn && vn() }, [Pn, vn]); const { onOpenChange: tn, triggerPointerDownPosRef: nn } = Ge; reactExports.useEffect(() => { if (Ze) { let an = { x: 0, y: 0 }; const pn = _n => { an = { x: Math.abs(Math.round(_n.pageX) - (nn.current?.x ?? 0)), y: Math.abs(Math.round(_n.pageY) - (nn.current?.y ?? 0)) } }, yn = _n => { an.x <= 10 && an.y <= 10 ? _n.preventDefault() : Ze.contains(_n.target) || tn(!1), document.removeEventListener("pointermove", pn), nn.current = null }; return nn.current !== null && (document.addEventListener("pointermove", pn), document.addEventListener("pointerup", yn, { capture: !0, once: !0 })), () => { document.removeEventListener("pointermove", pn), document.removeEventListener("pointerup", yn, { capture: !0 }) } } }, [Ze, tn, nn]), reactExports.useEffect(() => { const an = () => tn(!1); return window.addEventListener("blur", an), window.addEventListener("resize", an), () => { window.removeEventListener("blur", an), window.removeEventListener("resize", an) } }, [tn]); const [We, dn] = useTypeaheadSearch(an => { const pn = En().filter(On => !On.disabled), yn = pn.find(On => On.ref.current === document.activeElement), _n = findNextItem(pn, an, yn); _n && setTimeout(() => _n.ref.current.focus()) }), Je = reactExports.useCallback((an, pn, yn) => { const _n = !In.current && !yn; (Ge.value !== void 0 && Ge.value === pn || _n) && (bn(an), _n && (In.current = !0)) }, [Ge.value]), rn = reactExports.useCallback(() => Ze?.focus(), [Ze]), hn = reactExports.useCallback((an, pn, yn) => { const _n = !In.current && !yn; (Ge.value !== void 0 && Ge.value === pn || _n) && fn(an) }, [Ge.value]), mn = Ee === "popper" ? SelectPopperPosition : SelectItemAlignedPosition, Ye = mn === SelectPopperPosition ? { side: Me, sideOffset: De, align: Pe, alignOffset: Oe, arrowPadding: je, collisionBoundary: Be, collisionPadding: Ie, sticky: Fe, hideWhenDetached: ze, avoidCollisions: qe } : {}; return jsxRuntimeExports.jsx(SelectContentProvider, { scope: xe, content: Ze, viewport: Xe, onViewportChange: St, itemRefCallback: Je, selectedItem: on, onItemLeave: rn, itemTextRefCallback: hn, focusSelectedItem: vn, selectedItemText: Tn, position: Ee, isPositioned: Pn, searchRef: We, children: jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$2, allowPinchZoom: !0, children: jsxRuntimeExports.jsx(FocusScope, { asChild: !0, trapped: Ge.open, onMountAutoFocus: an => { an.preventDefault() }, onUnmountAutoFocus: composeEventHandlers(_e, an => { Ge.trigger?.focus({ preventScroll: !0 }), an.preventDefault() }), children: jsxRuntimeExports.jsx(DismissableLayer, { asChild: !0, disableOutsidePointerEvents: !0, onEscapeKeyDown: Re, onPointerDownOutside: Ce, onFocusOutside: an => an.preventDefault(), onDismiss: () => Ge.onOpenChange(!1), children: jsxRuntimeExports.jsx(mn, { role: "listbox", id: Ge.contentId, "data-state": Ge.open ? "open" : "closed", dir: Ge.dir, onContextMenu: an => an.preventDefault(), ...He, ...Ye, onPlaced: () => Rn(!0), ref: un, style: { display: "flex", flexDirection: "column", outline: "none", ...He.style }, onKeyDown: composeEventHandlers(He.onKeyDown, an => { const pn = an.ctrlKey || an.altKey || an.metaKey; if (an.key === "Tab" && an.preventDefault(), !pn && an.key.length === 1 && dn(an.key), ["ArrowUp", "ArrowDown", "Home", "End"].includes(an.key)) { let _n = En().filter(On => !On.disabled).map(On => On.ref.current); if (["ArrowUp", "End"].includes(an.key) && (_n = _n.slice().reverse()), ["ArrowUp", "ArrowDown"].includes(an.key)) { const On = an.target, kn = _n.indexOf(On); _n = _n.slice(kn + 1) } setTimeout(() => xn(_n)), an.preventDefault() } }) }) }) }) }) }) }); SelectContentImpl.displayName = CONTENT_IMPL_NAME; var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition", SelectItemAlignedPosition = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, onPlaced: Ee, ..._e } = e, Re = useSelectContext(CONTENT_NAME$3, xe), Ce = useSelectContentContext(CONTENT_NAME$3, xe), [Me, De] = reactExports.useState(null), [Pe, Oe] = reactExports.useState(null), je = useComposedRefs(t, un => Oe(un)), Be = useCollection(xe), Ie = reactExports.useRef(!1), Fe = reactExports.useRef(!0), { viewport: ze, selectedItem: qe, selectedItemText: He, focusSelectedItem: Ge } = Ce, Ze = reactExports.useCallback(() => { if (Re.trigger && Re.valueNode && Me && Pe && ze && qe && He) { const un = Re.trigger.getBoundingClientRect(), on = Pe.getBoundingClientRect(), bn = Re.valueNode.getBoundingClientRect(), Tn = He.getBoundingClientRect(); if (Re.dir !== "rtl") { const On = Tn.left - on.left, kn = bn.left - On, zn = un.left - kn, sr = un.width + zn, Fn = Math.max(sr, on.width), Cn = window.innerWidth - CONTENT_MARGIN, Vn = clamp$1(kn, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, Cn - Fn)]); Me.style.minWidth = sr + "px", Me.style.left = Vn + "px" } else { const On = on.right - Tn.right, kn = window.innerWidth - bn.right - On, zn = window.innerWidth - un.right - kn, sr = un.width + zn, Fn = Math.max(sr, on.width), Cn = window.innerWidth - CONTENT_MARGIN, Vn = clamp$1(kn, [CONTENT_MARGIN, Math.max(CONTENT_MARGIN, Cn - Fn)]); Me.style.minWidth = sr + "px", Me.style.right = Vn + "px" } const fn = Be(), En = window.innerHeight - CONTENT_MARGIN * 2, Pn = ze.scrollHeight, Rn = window.getComputedStyle(Pe), In = parseInt(Rn.borderTopWidth, 10), xn = parseInt(Rn.paddingTop, 10), vn = parseInt(Rn.borderBottomWidth, 10), tn = parseInt(Rn.paddingBottom, 10), nn = In + xn + Pn + tn + vn, We = Math.min(qe.offsetHeight * 5, nn), dn = window.getComputedStyle(ze), Je = parseInt(dn.paddingTop, 10), rn = parseInt(dn.paddingBottom, 10), hn = un.top + un.height / 2 - CONTENT_MARGIN, mn = En - hn, Ye = qe.offsetHeight / 2, an = qe.offsetTop + Ye, pn = In + xn + an, yn = nn - pn; if (pn <= hn) { const On = fn.length > 0 && qe === fn[fn.length - 1].ref.current; Me.style.bottom = "0px"; const kn = Pe.clientHeight - ze.offsetTop - ze.offsetHeight, zn = Math.max(mn, Ye + (On ? rn : 0) + kn + vn), sr = pn + zn; Me.style.height = sr + "px" } else { const On = fn.length > 0 && qe === fn[0].ref.current; Me.style.top = "0px"; const zn = Math.max(hn, In + ze.offsetTop + (On ? Je : 0) + Ye) + yn; Me.style.height = zn + "px", ze.scrollTop = pn - hn + ze.offsetTop } Me.style.margin = `${CONTENT_MARGIN}px 0`, Me.style.minHeight = We + "px", Me.style.maxHeight = En + "px", Ee?.(), requestAnimationFrame(() => Ie.current = !0) } }, [Be, Re.trigger, Re.valueNode, Me, Pe, ze, qe, He, Re.dir, Ee]); useLayoutEffect2(() => Ze(), [Ze]); const [sn, Xe] = reactExports.useState(); useLayoutEffect2(() => { Pe && Xe(window.getComputedStyle(Pe).zIndex) }, [Pe]); const St = reactExports.useCallback(un => { un && Fe.current === !0 && (Ze(), Ge?.(), Fe.current = !1) }, [Ze, Ge]); return jsxRuntimeExports.jsx(SelectViewportProvider, { scope: xe, contentWrapper: Me, shouldExpandOnScrollRef: Ie, onScrollButtonChange: St, children: jsxRuntimeExports.jsx("div", { ref: De, style: { display: "flex", flexDirection: "column", position: "fixed", zIndex: sn }, children: jsxRuntimeExports.jsx(Primitive.div, { ..._e, ref: je, style: { boxSizing: "border-box", maxHeight: "100%", ..._e.style } }) }) }) }); SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME; var POPPER_POSITION_NAME = "SelectPopperPosition", SelectPopperPosition = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, align: Ee = "start", collisionPadding: _e = CONTENT_MARGIN, ...Re } = e, Ce = usePopperScope$2(xe); return jsxRuntimeExports.jsx(Content$1, { ...Ce, ...Re, ref: t, align: Ee, collisionPadding: _e, style: { boxSizing: "border-box", ...Re.style, "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-select-content-available-width": "var(--radix-popper-available-width)", "--radix-select-content-available-height": "var(--radix-popper-available-height)", "--radix-select-trigger-width": "var(--radix-popper-anchor-width)", "--radix-select-trigger-height": "var(--radix-popper-anchor-height)" } }) }); SelectPopperPosition.displayName = POPPER_POSITION_NAME; var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$3, {}), VIEWPORT_NAME = "SelectViewport", SelectViewport = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, nonce: Ee, ..._e } = e, Re = useSelectContentContext(VIEWPORT_NAME, xe), Ce = useSelectViewportContext(VIEWPORT_NAME, xe), Me = useComposedRefs(t, Re.onViewportChange), De = reactExports.useRef(0); return jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("style", { dangerouslySetInnerHTML: { __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}" }, nonce: Ee }), jsxRuntimeExports.jsx(Collection.Slot, { scope: xe, children: jsxRuntimeExports.jsx(Primitive.div, { "data-radix-select-viewport": "", role: "presentation", ..._e, ref: Me, style: { position: "relative", flex: 1, overflow: "hidden auto", ..._e.style }, onScroll: composeEventHandlers(_e.onScroll, Pe => { const Oe = Pe.currentTarget, { contentWrapper: je, shouldExpandOnScrollRef: Be } = Ce; if (Be?.current && je) { const Ie = Math.abs(De.current - Oe.scrollTop); if (Ie > 0) { const Fe = window.innerHeight - CONTENT_MARGIN * 2, ze = parseFloat(je.style.minHeight), qe = parseFloat(je.style.height), He = Math.max(ze, qe); if (He < Fe) { const Ge = He + Ie, Ze = Math.min(Fe, Ge), sn = Ge - Ze; je.style.height = Ze + "px", je.style.bottom === "0px" && (Oe.scrollTop = sn > 0 ? sn : 0, je.style.justifyContent = "flex-end") } } } De.current = Oe.scrollTop }) }) })] }) }); SelectViewport.displayName = VIEWPORT_NAME; var GROUP_NAME = "SelectGroup", [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME), SelectGroup = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, ...Ee } = e, _e = useId(); return jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: xe, id: _e, children: jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": _e, ...Ee, ref: t }) }) }); SelectGroup.displayName = GROUP_NAME; var LABEL_NAME = "SelectLabel", SelectLabel = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, ...Ee } = e, _e = useSelectGroupContext(LABEL_NAME, xe); return jsxRuntimeExports.jsx(Primitive.div, { id: _e.id, ...Ee, ref: t }) }); SelectLabel.displayName = LABEL_NAME; var ITEM_NAME = "SelectItem", [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME), SelectItem$1 = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, value: Ee, disabled: _e = !1, textValue: Re, ...Ce } = e, Me = useSelectContext(ITEM_NAME, xe), De = useSelectContentContext(ITEM_NAME, xe), Pe = Me.value === Ee, [Oe, je] = reactExports.useState(Re ?? ""), [Be, Ie] = reactExports.useState(!1), Fe = useComposedRefs(t, Ge => De.itemRefCallback?.(Ge, Ee, _e)), ze = useId(), qe = reactExports.useRef("touch"), He = () => { _e || (Me.onValueChange(Ee), Me.onOpenChange(!1)) }; if (Ee === "") throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."); return jsxRuntimeExports.jsx(SelectItemContextProvider, { scope: xe, value: Ee, disabled: _e, textId: ze, isSelected: Pe, onItemTextChange: reactExports.useCallback(Ge => { je(Ze => Ze || (Ge?.textContent ?? "").trim()) }, []), children: jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: xe, value: Ee, disabled: _e, textValue: Oe, children: jsxRuntimeExports.jsx(Primitive.div, { role: "option", "aria-labelledby": ze, "data-highlighted": Be ? "" : void 0, "aria-selected": Pe && Be, "data-state": Pe ? "checked" : "unchecked", "aria-disabled": _e || void 0, "data-disabled": _e ? "" : void 0, tabIndex: _e ? void 0 : -1, ...Ce, ref: Fe, onFocus: composeEventHandlers(Ce.onFocus, () => Ie(!0)), onBlur: composeEventHandlers(Ce.onBlur, () => Ie(!1)), onClick: composeEventHandlers(Ce.onClick, () => { qe.current !== "mouse" && He() }), onPointerUp: composeEventHandlers(Ce.onPointerUp, () => { qe.current === "mouse" && He() }), onPointerDown: composeEventHandlers(Ce.onPointerDown, Ge => { qe.current = Ge.pointerType }), onPointerMove: composeEventHandlers(Ce.onPointerMove, Ge => { qe.current = Ge.pointerType, _e ? De.onItemLeave?.() : qe.current === "mouse" && Ge.currentTarget.focus({ preventScroll: !0 }) }), onPointerLeave: composeEventHandlers(Ce.onPointerLeave, Ge => { Ge.currentTarget === document.activeElement && De.onItemLeave?.() }), onKeyDown: composeEventHandlers(Ce.onKeyDown, Ge => { De.searchRef?.current !== "" && Ge.key === " " || (SELECTION_KEYS.includes(Ge.key) && He(), Ge.key === " " && Ge.preventDefault()) }) }) }) }) }); SelectItem$1.displayName = ITEM_NAME; var ITEM_TEXT_NAME = "SelectItemText", SelectItemText = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, className: Ee, style: _e, ...Re } = e, Ce = useSelectContext(ITEM_TEXT_NAME, xe), Me = useSelectContentContext(ITEM_TEXT_NAME, xe), De = useSelectItemContext(ITEM_TEXT_NAME, xe), Pe = useSelectNativeOptionsContext(ITEM_TEXT_NAME, xe), [Oe, je] = reactExports.useState(null), Be = useComposedRefs(t, He => je(He), De.onItemTextChange, He => Me.itemTextRefCallback?.(He, De.value, De.disabled)), Ie = Oe?.textContent, Fe = reactExports.useMemo(() => jsxRuntimeExports.jsx("option", { value: De.value, disabled: De.disabled, children: Ie }, De.value), [De.disabled, De.value, Ie]), { onNativeOptionAdd: ze, onNativeOptionRemove: qe } = Pe; return useLayoutEffect2(() => (ze(Fe), () => qe(Fe)), [ze, qe, Fe]), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Primitive.span, { id: De.textId, ...Re, ref: Be }), De.isSelected && Ce.valueNode && !Ce.valueNodeHasChildren ? reactDomExports.createPortal(Re.children, Ce.valueNode) : null] }) }); SelectItemText.displayName = ITEM_TEXT_NAME; var ITEM_INDICATOR_NAME = "SelectItemIndicator", SelectItemIndicator = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, ...Ee } = e; return useSelectItemContext(ITEM_INDICATOR_NAME, xe).isSelected ? jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": !0, ...Ee, ref: t }) : null }); SelectItemIndicator.displayName = ITEM_INDICATOR_NAME; var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton", SelectScrollUpButton$1 = reactExports.forwardRef((e, t) => { const xe = useSelectContentContext(SCROLL_UP_BUTTON_NAME, e.__scopeSelect), Ee = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, e.__scopeSelect), [_e, Re] = reactExports.useState(!1), Ce = useComposedRefs(t, Ee.onScrollButtonChange); return useLayoutEffect2(() => { if (xe.viewport && xe.isPositioned) { let Me = function () { const Pe = De.scrollTop > 0; Re(Pe) }; const De = xe.viewport; return Me(), De.addEventListener("scroll", Me), () => De.removeEventListener("scroll", Me) } }, [xe.viewport, xe.isPositioned]), _e ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, { ...e, ref: Ce, onAutoScroll: () => { const { viewport: Me, selectedItem: De } = xe; Me && De && (Me.scrollTop = Me.scrollTop - De.offsetHeight) } }) : null }); SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME; var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton", SelectScrollDownButton$1 = reactExports.forwardRef((e, t) => { const xe = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, e.__scopeSelect), Ee = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, e.__scopeSelect), [_e, Re] = reactExports.useState(!1), Ce = useComposedRefs(t, Ee.onScrollButtonChange); return useLayoutEffect2(() => { if (xe.viewport && xe.isPositioned) { let Me = function () { const Pe = De.scrollHeight - De.clientHeight, Oe = Math.ceil(De.scrollTop) < Pe; Re(Oe) }; const De = xe.viewport; return Me(), De.addEventListener("scroll", Me), () => De.removeEventListener("scroll", Me) } }, [xe.viewport, xe.isPositioned]), _e ? jsxRuntimeExports.jsx(SelectScrollButtonImpl, { ...e, ref: Ce, onAutoScroll: () => { const { viewport: Me, selectedItem: De } = xe; Me && De && (Me.scrollTop = Me.scrollTop + De.offsetHeight) } }) : null }); SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME; var SelectScrollButtonImpl = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, onAutoScroll: Ee, ..._e } = e, Re = useSelectContentContext("SelectScrollButton", xe), Ce = reactExports.useRef(null), Me = useCollection(xe), De = reactExports.useCallback(() => { Ce.current !== null && (window.clearInterval(Ce.current), Ce.current = null) }, []); return reactExports.useEffect(() => () => De(), [De]), useLayoutEffect2(() => { Me().find(Oe => Oe.ref.current === document.activeElement)?.ref.current?.scrollIntoView({ block: "nearest" }) }, [Me]), jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": !0, ..._e, ref: t, style: { flexShrink: 0, ..._e.style }, onPointerDown: composeEventHandlers(_e.onPointerDown, () => { Ce.current === null && (Ce.current = window.setInterval(Ee, 50)) }), onPointerMove: composeEventHandlers(_e.onPointerMove, () => { Re.onItemLeave?.(), Ce.current === null && (Ce.current = window.setInterval(Ee, 50)) }), onPointerLeave: composeEventHandlers(_e.onPointerLeave, () => { De() }) }) }), SEPARATOR_NAME = "SelectSeparator", SelectSeparator = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, ...Ee } = e; return jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": !0, ...Ee, ref: t }) }); SelectSeparator.displayName = SEPARATOR_NAME; var ARROW_NAME$2 = "SelectArrow", SelectArrow = reactExports.forwardRef((e, t) => { const { __scopeSelect: xe, ...Ee } = e, _e = usePopperScope$2(xe), Re = useSelectContext(ARROW_NAME$2, xe), Ce = useSelectContentContext(ARROW_NAME$2, xe); return Re.open && Ce.position === "popper" ? jsxRuntimeExports.jsx(Arrow, { ..._e, ...Ee, ref: t }) : null }); SelectArrow.displayName = ARROW_NAME$2; var BUBBLE_INPUT_NAME$1 = "SelectBubbleInput", SelectBubbleInput = reactExports.forwardRef(({ __scopeSelect: e, value: t, ...xe }, Ee) => { const _e = reactExports.useRef(null), Re = useComposedRefs(Ee, _e), Ce = usePrevious(t); return reactExports.useEffect(() => { const Me = _e.current; if (!Me) return; const De = window.HTMLSelectElement.prototype, Oe = Object.getOwnPropertyDescriptor(De, "value").set; if (Ce !== t && Oe) { const je = new Event("change", { bubbles: !0 }); Oe.call(Me, t), Me.dispatchEvent(je) } }, [Ce, t]), jsxRuntimeExports.jsx(Primitive.select, { ...xe, style: { ...VISUALLY_HIDDEN_STYLES, ...xe.style }, ref: Re, defaultValue: t }) }); SelectBubbleInput.displayName = BUBBLE_INPUT_NAME$1; function shouldShowPlaceholder(e) { return e === "" || e === void 0 } function useTypeaheadSearch(e) { const t = useCallbackRef$1(e), xe = reactExports.useRef(""), Ee = reactExports.useRef(0), _e = reactExports.useCallback(Ce => { const Me = xe.current + Ce; t(Me), function De(Pe) { xe.current = Pe, window.clearTimeout(Ee.current), Pe !== "" && (Ee.current = window.setTimeout(() => De(""), 1e3)) }(Me) }, [t]), Re = reactExports.useCallback(() => { xe.current = "", window.clearTimeout(Ee.current) }, []); return reactExports.useEffect(() => () => window.clearTimeout(Ee.current), []), [xe, _e, Re] } function findNextItem(e, t, xe) { const _e = t.length > 1 && Array.from(t).every(Pe => Pe === t[0]) ? t[0] : t, Re = xe ? e.indexOf(xe) : -1; let Ce = wrapArray(e, Math.max(Re, 0)); _e.length === 1 && (Ce = Ce.filter(Pe => Pe !== xe)); const De = Ce.find(Pe => Pe.textValue.toLowerCase().startsWith(_e.toLowerCase())); return De !== xe ? De : void 0 } function wrapArray(e, t) { return e.map((xe, Ee) => e[(t + Ee) % e.length]) } var Root2$1 = Select$1, Trigger$3 = SelectTrigger$1, Value = SelectValue$1, Icon$1 = SelectIcon, Portal$3 = SelectPortal, Content2$2 = SelectContent$1, Viewport = SelectViewport, Item = SelectItem$1, ItemText = SelectItemText, ItemIndicator = SelectItemIndicator, ScrollUpButton = SelectScrollUpButton$1, ScrollDownButton = SelectScrollDownButton$1;/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const toKebabCase = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), toCamelCase = e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, xe, Ee) => Ee ? Ee.toUpperCase() : xe.toLowerCase()), toPascalCase = e => { const t = toCamelCase(e); return t.charAt(0).toUpperCase() + t.slice(1) }, mergeClasses = (...e) => e.filter((t, xe, Ee) => !!t && t.trim() !== "" && Ee.indexOf(t) === xe).join(" ").trim(), hasA11yProp = e => { for (const t in e) if (t.startsWith("aria-") || t === "role" || t === "title") return !0 };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var defaultAttributes = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const Icon = reactExports.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: xe = 2, absoluteStrokeWidth: Ee, className: _e = "", children: Re, iconNode: Ce, ...Me }, De) => reactExports.createElement("svg", { ref: De, ...defaultAttributes, width: t, height: t, stroke: e, strokeWidth: Ee ? Number(xe) * 24 / Number(t) : xe, className: mergeClasses("lucide", _e), ...!Re && !hasA11yProp(Me) && { "aria-hidden": "true" }, ...Me }, [...Ce.map(([Pe, Oe]) => reactExports.createElement(Pe, Oe)), ...Array.isArray(Re) ? Re : [Re]]));/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const createLucideIcon = (e, t) => { const xe = reactExports.forwardRef(({ className: Ee, ..._e }, Re) => reactExports.createElement(Icon, { ref: Re, iconNode: t, className: mergeClasses(`lucide-${toKebabCase(toPascalCase(e))}`, `lucide-${e}`, Ee), ..._e })); return xe.displayName = toPascalCase(e), xe };/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$j = [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]], Check = createLucideIcon("check", __iconNode$j);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$i = [["path", { d: "m6 9 6 6 6-6", key: "qrunsl" }]], ChevronDown = createLucideIcon("chevron-down", __iconNode$i);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$h = [["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]], ChevronLeft = createLucideIcon("chevron-left", __iconNode$h);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$g = [["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]], ChevronRight = createLucideIcon("chevron-right", __iconNode$g);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$f = [["path", { d: "m18 15-6-6-6 6", key: "153udz" }]], ChevronUp = createLucideIcon("chevron-up", __iconNode$f);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$e = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], CircleAlert = createLucideIcon("circle-alert", __iconNode$e);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$d = [["path", { d: "M15 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7Z", key: "1rqfz7" }], ["path", { d: "M14 2v4a2 2 0 0 0 2 2h4", key: "tnqrlb" }], ["path", { d: "M10 9H8", key: "b1mrlr" }], ["path", { d: "M16 13H8", key: "t4e002" }], ["path", { d: "M16 17H8", key: "z1uh3a" }]], FileText = createLucideIcon("file-text", __iconNode$d);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$c = [["path", { d: "M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8", key: "5wwlr5" }], ["path", { d: "M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z", key: "1d0kgt" }]], House = createLucideIcon("house", __iconNode$c);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$b = [["polyline", { points: "22 12 16 12 14 15 10 15 8 12 2 12", key: "o97t9d" }], ["path", { d: "M5.45 5.11 2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z", key: "oot6mr" }]], Inbox = createLucideIcon("inbox", __iconNode$b);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$a = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], Info = createLucideIcon("info", __iconNode$a);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$9 = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], LoaderCircle = createLucideIcon("loader-circle", __iconNode$9);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$8 = [["path", { d: "m16 17 5-5-5-5", key: "1bji2h" }], ["path", { d: "M21 12H9", key: "dn1m92" }], ["path", { d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4", key: "1uf3rs" }]], LogOut = createLucideIcon("log-out", __iconNode$8);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$7 = [["path", { d: "M4 12h16", key: "1lakjw" }], ["path", { d: "M4 18h16", key: "19g7jn" }], ["path", { d: "M4 6h16", key: "1o0s65" }]], Menu = createLucideIcon("menu", __iconNode$7);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$6 = [["rect", { width: "18", height: "18", x: "3", y: "3", rx: "2", key: "afitv7" }], ["path", { d: "M9 3v18", key: "fh3hqa" }]], PanelLeft = createLucideIcon("panel-left", __iconNode$6);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$5 = [["path", { d: "M3 7V5a2 2 0 0 1 2-2h2", key: "aa7l1z" }], ["path", { d: "M17 3h2a2 2 0 0 1 2 2v2", key: "4qcy5o" }], ["path", { d: "M21 17v2a2 2 0 0 1-2 2h-2", key: "6vwrx8" }], ["path", { d: "M7 21H5a2 2 0 0 1-2-2v-2", key: "ioqczr" }]], Scan = createLucideIcon("scan", __iconNode$5);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$4 = [["path", { d: "m21 21-4.34-4.34", key: "14j7rj" }], ["circle", { cx: "11", cy: "11", r: "8", key: "4ej97u" }]], Search = createLucideIcon("search", __iconNode$4);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$3 = [["path", { d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z", key: "oel41y" }]], Shield = createLucideIcon("shield", __iconNode$3);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$2 = [["path", { d: "M3 6h18", key: "d0wm0j" }], ["path", { d: "M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6", key: "4alrt4" }], ["path", { d: "M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2", key: "v07s0e" }], ["line", { x1: "10", x2: "10", y1: "11", y2: "17", key: "1uufr5" }], ["line", { x1: "14", x2: "14", y1: "11", y2: "17", key: "xtxkd" }]], Trash2 = createLucideIcon("trash-2", __iconNode$2);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode$1 = [["path", { d: "M19 21v-2a4 4 0 0 0-4-4H9a4 4 0 0 0-4 4v2", key: "975kel" }], ["circle", { cx: "12", cy: "7", r: "4", key: "17ys0d" }]], User = createLucideIcon("user", __iconNode$1);/**
 * @license lucide-react v0.525.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const __iconNode = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], X$1 = createLucideIcon("x", __iconNode); function Select({ ...e }) { return jsxRuntimeExports.jsx(Root2$1, { "data-slot": "select", ...e }) } function SelectValue({ ...e }) { return jsxRuntimeExports.jsx(Value, { "data-slot": "select-value", ...e }) } function SelectTrigger({ className: e, size: t = "default", children: xe, ...Ee }) { return jsxRuntimeExports.jsxs(Trigger$3, { "data-slot": "select-trigger", "data-size": t, className: cn$1("border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 dark:hover:bg-input/50 flex w-fit items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 data-[size=default]:h-9 data-[size=sm]:h-8 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", e), ...Ee, children: [xe, jsxRuntimeExports.jsx(Icon$1, { asChild: !0, children: jsxRuntimeExports.jsx(ChevronDown, { className: "size-4 opacity-50" }) })] }) } function SelectContent({ className: e, children: t, position: xe = "popper", ...Ee }) { return jsxRuntimeExports.jsx(Portal$3, { children: jsxRuntimeExports.jsxs(Content2$2, { "data-slot": "select-content", className: cn$1("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-(--radix-select-content-available-height) min-w-[8rem] origin-(--radix-select-content-transform-origin) overflow-x-hidden overflow-y-auto rounded-md border shadow-md", xe === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", e), position: xe, ...Ee, children: [jsxRuntimeExports.jsx(SelectScrollUpButton, {}), jsxRuntimeExports.jsx(Viewport, { className: cn$1("p-1", xe === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"), children: t }), jsxRuntimeExports.jsx(SelectScrollDownButton, {})] }) }) } function SelectItem({ className: e, children: t, ...xe }) { return jsxRuntimeExports.jsxs(Item, { "data-slot": "select-item", className: cn$1("focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2", e), ...xe, children: [jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex size-3.5 items-center justify-center", children: jsxRuntimeExports.jsx(ItemIndicator, { children: jsxRuntimeExports.jsx(Check, { className: "size-4" }) }) }), jsxRuntimeExports.jsx(ItemText, { children: t })] }) } function SelectScrollUpButton({ className: e, ...t }) { return jsxRuntimeExports.jsx(ScrollUpButton, { "data-slot": "select-scroll-up-button", className: cn$1("flex cursor-default items-center justify-center py-1", e), ...t, children: jsxRuntimeExports.jsx(ChevronUp, { className: "size-4" }) }) } function SelectScrollDownButton({ className: e, ...t }) { return jsxRuntimeExports.jsx(ScrollDownButton, { "data-slot": "select-scroll-down-button", className: cn$1("flex cursor-default items-center justify-center py-1", e), ...t, children: jsxRuntimeExports.jsx(ChevronDown, { className: "size-4" }) }) } const FormField = ({ label: e, id: t, type: xe = "text", name: Ee, value: _e, onChange: Re, required: Ce, accept: Me, placeholder: De, options: Pe }) => jsxRuntimeExports.jsxs("div", { className: "mb-4 flex-col space-y-2", children: [jsxRuntimeExports.jsx(Label, { htmlFor: t, children: e }), Pe ? jsxRuntimeExports.jsxs(Select, { name: Ee, value: _e, onValueChange: Oe => Re({ target: { name: Ee, value: Oe } }), required: Ce, children: [jsxRuntimeExports.jsx(SelectTrigger, { id: t, children: jsxRuntimeExports.jsx(SelectValue, { placeholder: De }) }), jsxRuntimeExports.jsx(SelectContent, { children: Pe.map(Oe => jsxRuntimeExports.jsx(SelectItem, { value: Oe.value, children: Oe.label }, Oe.value)) })] }) : jsxRuntimeExports.jsx(Input, { id: t, type: xe, name: Ee, value: xe !== "file" ? _e : void 0, onChange: Re, required: Ce, accept: Me, placeholder: De })] }), LoginForm = () => { const { login: e, isLoading: t } = reactExports.useContext(AuthContext), { showError: xe } = useToastError(), Ee = useNavigate(), { formData: _e, handleChange: Re } = useForm({ email: "", password: "" }), Ce = Me => { Me.preventDefault(), e(_e, { onSuccess: () => Ee("/"), onError: De => xe(De, "Login failed") }) }; return jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: jsxRuntimeExports.jsxs("form", { onSubmit: Ce, className: "w-full max-w-md p-6 bg-white rounded shadow", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Login" }), jsxRuntimeExports.jsx(FormField, { label: "Email", id: "email", type: "email", name: "email", value: _e.email, onChange: Re, required: !0 }), jsxRuntimeExports.jsx(FormField, { label: "Password", id: "password", type: "password", name: "password", value: _e.password, onChange: Re, required: !0 }), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: t, className: "w-full", children: t ? "Logging in..." : "Login" }), jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: jsxRuntimeExports.jsx(Link, { to: "/reset-password", className: "text-blue-600", children: "Forgot Password?" }) }), jsxRuntimeExports.jsx("div", { className: "mt-2 text-center", children: jsxRuntimeExports.jsx(Link, { to: "/register", className: "text-blue-600", children: "Register" }) })] }) }) }, Login = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(LoginForm, {}) }), RegisterForm = () => { const { showError: e, showSuccess: t } = useToastError(), { formData: xe, handleChange: Ee } = useForm({ employeeId: "", fullName: "", department: "", email: "", education: "", profession: "", password: "" }), _e = useMutation({ mutationFn: selfRegister, onSuccess: () => t("Registration submitted, pending approval"), onError: Me => e(Me, "Registration failed") }), Re = Me => { Me.preventDefault(), _e.mutate(xe) }, Ce = [{ id: "employeeId", label: "Employee ID", type: "text", placeholder: "Enter your employee ID" }, { id: "fullName", label: "Full Name", type: "text", placeholder: "Enter your full name" }, { id: "department", label: "Department", type: "select", placeholder: "Select your department", options: [{ value: "engineering", label: "Engineering" }, { value: "hr", label: "Human Resources" }, { value: "marketing", label: "Marketing" }, { value: "finance", label: "Finance" }, { value: "it", label: "Information Technology" }] }, { id: "email", label: "Email", type: "email", placeholder: "Enter your email" }, { id: "education", label: "Education", type: "select", placeholder: "Select your education level", options: [{ value: "highschool", label: "High School" }, { value: "bachelor", label: "Bachelor’s Degree" }, { value: "master", label: "Master’s Degree" }, { value: "phd", label: "PhD" }] }, { id: "profession", label: "Profession", type: "select", placeholder: "Select your profession", options: [{ value: "engineer", label: "Engineer" }, { value: "manager", label: "Manager" }, { value: "analyst", label: "Analyst" }, { value: "developer", label: "Developer" }, { value: "designer", label: "Designer" }] }, { id: "password", label: "Password", type: "password", placeholder: "Enter your password" }]; return jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: jsxRuntimeExports.jsxs("form", { onSubmit: Re, className: "w-full max-w-md p-6 bg-white rounded shadow", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Register" }), Ce.map(Me => jsxRuntimeExports.jsx(FormField, { label: Me.label, id: Me.id, type: Me.type, name: Me.id, value: xe[Me.id], onChange: Ee, required: !0, placeholder: Me.placeholder, options: Me.options }, Me.id)), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: _e.isLoading, className: "w-full", children: _e.isLoading ? "Submitting..." : "Submit" }), jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: jsxRuntimeExports.jsx(Link, { to: "/login", className: "text-blue-600", children: "Already registered? Login" }) })] }) }) }, Register = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(RegisterForm, {}) }), PasswordResetRequestForm = () => { const { showError: e, showSuccess: t } = useToastError(), { formData: xe, handleChange: Ee } = useForm({ email: "" }), _e = useMutation({ mutationFn: requestPasswordReset, onSuccess: () => t("Password reset link sent to email"), onError: Ce => e(Ce, "Request failed") }), Re = Ce => { Ce.preventDefault(), _e.mutate(xe) }; return jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: jsxRuntimeExports.jsxs("form", { onSubmit: Re, className: "w-full max-w-md p-6 bg-white rounded shadow", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Request Password Reset" }), jsxRuntimeExports.jsx(FormField, { label: "Email", id: "email", type: "email", name: "email", value: xe.email, onChange: Ee, required: !0 }), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: _e.isLoading, className: "w-full", children: _e.isLoading ? "Sending..." : "Send Reset Link" }), jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: jsxRuntimeExports.jsx(Link, { to: "/login", className: "text-blue-600", children: "Back to Login" }) })] }) }) }, PasswordResetRequest = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(PasswordResetRequestForm, {}) }), PasswordResetForm = () => { const { token: e } = useParams(), { showError: t, showSuccess: xe } = useToastError(), { formData: Ee, handleChange: _e } = useForm({ newPassword: "" }), Re = useMutation({ mutationFn: Me => resetPassword(e, Me), onSuccess: () => { xe("Password reset successful"), window.location.href = "/login" }, onError: Me => t(Me, "Reset failed") }), Ce = Me => { Me.preventDefault(), Re.mutate(Ee) }; return jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: jsxRuntimeExports.jsxs("form", { onSubmit: Ce, className: "w-full max-w-md p-6 bg-white rounded shadow", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Reset Password" }), jsxRuntimeExports.jsx(FormField, { label: "New Password", id: "newPassword", type: "password", name: "newPassword", value: Ee.newPassword, onChange: _e, required: !0 }), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: Re.isLoading, className: "w-full", children: Re.isLoading ? "Resetting..." : "Reset Password" }), jsxRuntimeExports.jsx("div", { className: "mt-4 text-center", children: jsxRuntimeExports.jsx(Link, { to: "/login", className: "text-blue-600", children: "Back to Login" }) })] }) }) }, PasswordReset = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsx(PasswordResetForm, {}) }), ROLES = { ADMIN: "Admin", SCANNER_CLERK: "ScannerClerk", APPROVER: "Approver", UPLOADER: "Uploader" }; function useStateMachine(e, t) { return reactExports.useReducer((xe, Ee) => t[xe][Ee] ?? xe, e) } var Presence = e => { const { present: t, children: xe } = e, Ee = usePresence(t), _e = typeof xe == "function" ? xe({ present: Ee.isPresent }) : reactExports.Children.only(xe), Re = useComposedRefs(Ee.ref, getElementRef(_e)); return typeof xe == "function" || Ee.isPresent ? reactExports.cloneElement(_e, { ref: Re }) : null }; Presence.displayName = "Presence"; function usePresence(e) { const [t, xe] = reactExports.useState(), Ee = reactExports.useRef(null), _e = reactExports.useRef(e), Re = reactExports.useRef("none"), Ce = e ? "mounted" : "unmounted", [Me, De] = useStateMachine(Ce, { mounted: { UNMOUNT: "unmounted", ANIMATION_OUT: "unmountSuspended" }, unmountSuspended: { MOUNT: "mounted", ANIMATION_END: "unmounted" }, unmounted: { MOUNT: "mounted" } }); return reactExports.useEffect(() => { const Pe = getAnimationName(Ee.current); Re.current = Me === "mounted" ? Pe : "none" }, [Me]), useLayoutEffect2(() => { const Pe = Ee.current, Oe = _e.current; if (Oe !== e) { const Be = Re.current, Ie = getAnimationName(Pe); e ? De("MOUNT") : Ie === "none" || Pe?.display === "none" ? De("UNMOUNT") : De(Oe && Be !== Ie ? "ANIMATION_OUT" : "UNMOUNT"), _e.current = e } }, [e, De]), useLayoutEffect2(() => { if (t) { let Pe; const Oe = t.ownerDocument.defaultView ?? window, je = Ie => { const ze = getAnimationName(Ee.current).includes(Ie.animationName); if (Ie.target === t && ze && (De("ANIMATION_END"), !_e.current)) { const qe = t.style.animationFillMode; t.style.animationFillMode = "forwards", Pe = Oe.setTimeout(() => { t.style.animationFillMode === "forwards" && (t.style.animationFillMode = qe) }) } }, Be = Ie => { Ie.target === t && (Re.current = getAnimationName(Ee.current)) }; return t.addEventListener("animationstart", Be), t.addEventListener("animationcancel", je), t.addEventListener("animationend", je), () => { Oe.clearTimeout(Pe), t.removeEventListener("animationstart", Be), t.removeEventListener("animationcancel", je), t.removeEventListener("animationend", je) } } else De("ANIMATION_END") }, [t, De]), { isPresent: ["mounted", "unmountSuspended"].includes(Me), ref: reactExports.useCallback(Pe => { Ee.current = Pe ? getComputedStyle(Pe) : null, xe(Pe) }, []) } } function getAnimationName(e) { return e?.animationName || "none" } function getElementRef(e) { let t = Object.getOwnPropertyDescriptor(e.props, "ref")?.get, xe = t && "isReactWarning" in t && t.isReactWarning; return xe ? e.ref : (t = Object.getOwnPropertyDescriptor(e, "ref")?.get, xe = t && "isReactWarning" in t && t.isReactWarning, xe ? e.props.ref : e.props.ref || e.ref) } var POPOVER_NAME = "Popover", [createPopoverContext, createPopoverScope] = createContextScope(POPOVER_NAME, [createPopperScope]), usePopperScope$1 = createPopperScope(), [PopoverProvider, usePopoverContext] = createPopoverContext(POPOVER_NAME), Popover$1 = e => { const { __scopePopover: t, children: xe, open: Ee, defaultOpen: _e, onOpenChange: Re, modal: Ce = !1 } = e, Me = usePopperScope$1(t), De = reactExports.useRef(null), [Pe, Oe] = reactExports.useState(!1), [je, Be] = useControllableState({ prop: Ee, defaultProp: _e ?? !1, onChange: Re, caller: POPOVER_NAME }); return jsxRuntimeExports.jsx(Root2$2, { ...Me, children: jsxRuntimeExports.jsx(PopoverProvider, { scope: t, contentId: useId(), triggerRef: De, open: je, onOpenChange: Be, onOpenToggle: reactExports.useCallback(() => Be(Ie => !Ie), [Be]), hasCustomAnchor: Pe, onCustomAnchorAdd: reactExports.useCallback(() => Oe(!0), []), onCustomAnchorRemove: reactExports.useCallback(() => Oe(!1), []), modal: Ce, children: xe }) }) }; Popover$1.displayName = POPOVER_NAME; var ANCHOR_NAME = "PopoverAnchor", PopoverAnchor = reactExports.forwardRef((e, t) => { const { __scopePopover: xe, ...Ee } = e, _e = usePopoverContext(ANCHOR_NAME, xe), Re = usePopperScope$1(xe), { onCustomAnchorAdd: Ce, onCustomAnchorRemove: Me } = _e; return reactExports.useEffect(() => (Ce(), () => Me()), [Ce, Me]), jsxRuntimeExports.jsx(Anchor, { ...Re, ...Ee, ref: t }) }); PopoverAnchor.displayName = ANCHOR_NAME; var TRIGGER_NAME$3 = "PopoverTrigger", PopoverTrigger$1 = reactExports.forwardRef((e, t) => { const { __scopePopover: xe, ...Ee } = e, _e = usePopoverContext(TRIGGER_NAME$3, xe), Re = usePopperScope$1(xe), Ce = useComposedRefs(t, _e.triggerRef), Me = jsxRuntimeExports.jsx(Primitive.button, { type: "button", "aria-haspopup": "dialog", "aria-expanded": _e.open, "aria-controls": _e.contentId, "data-state": getState$2(_e.open), ...Ee, ref: Ce, onClick: composeEventHandlers(e.onClick, _e.onOpenToggle) }); return _e.hasCustomAnchor ? Me : jsxRuntimeExports.jsx(Anchor, { asChild: !0, ...Re, children: Me }) }); PopoverTrigger$1.displayName = TRIGGER_NAME$3; var PORTAL_NAME$2 = "PopoverPortal", [PortalProvider$2, usePortalContext$2] = createPopoverContext(PORTAL_NAME$2, { forceMount: void 0 }), PopoverPortal = e => { const { __scopePopover: t, forceMount: xe, children: Ee, container: _e } = e, Re = usePopoverContext(PORTAL_NAME$2, t); return jsxRuntimeExports.jsx(PortalProvider$2, { scope: t, forceMount: xe, children: jsxRuntimeExports.jsx(Presence, { present: xe || Re.open, children: jsxRuntimeExports.jsx(Portal$4, { asChild: !0, container: _e, children: Ee }) }) }) }; PopoverPortal.displayName = PORTAL_NAME$2; var CONTENT_NAME$2 = "PopoverContent", PopoverContent$1 = reactExports.forwardRef((e, t) => { const xe = usePortalContext$2(CONTENT_NAME$2, e.__scopePopover), { forceMount: Ee = xe.forceMount, ..._e } = e, Re = usePopoverContext(CONTENT_NAME$2, e.__scopePopover); return jsxRuntimeExports.jsx(Presence, { present: Ee || Re.open, children: Re.modal ? jsxRuntimeExports.jsx(PopoverContentModal, { ..._e, ref: t }) : jsxRuntimeExports.jsx(PopoverContentNonModal, { ..._e, ref: t }) }) }); PopoverContent$1.displayName = CONTENT_NAME$2; var Slot$1 = createSlot("PopoverContent.RemoveScroll"), PopoverContentModal = reactExports.forwardRef((e, t) => { const xe = usePopoverContext(CONTENT_NAME$2, e.__scopePopover), Ee = reactExports.useRef(null), _e = useComposedRefs(t, Ee), Re = reactExports.useRef(!1); return reactExports.useEffect(() => { const Ce = Ee.current; if (Ce) return hideOthers(Ce) }, []), jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot$1, allowPinchZoom: !0, children: jsxRuntimeExports.jsx(PopoverContentImpl, { ...e, ref: _e, trapFocus: xe.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: composeEventHandlers(e.onCloseAutoFocus, Ce => { Ce.preventDefault(), Re.current || xe.triggerRef.current?.focus() }), onPointerDownOutside: composeEventHandlers(e.onPointerDownOutside, Ce => { const Me = Ce.detail.originalEvent, De = Me.button === 0 && Me.ctrlKey === !0, Pe = Me.button === 2 || De; Re.current = Pe }, { checkForDefaultPrevented: !1 }), onFocusOutside: composeEventHandlers(e.onFocusOutside, Ce => Ce.preventDefault(), { checkForDefaultPrevented: !1 }) }) }) }), PopoverContentNonModal = reactExports.forwardRef((e, t) => { const xe = usePopoverContext(CONTENT_NAME$2, e.__scopePopover), Ee = reactExports.useRef(!1), _e = reactExports.useRef(!1); return jsxRuntimeExports.jsx(PopoverContentImpl, { ...e, ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: Re => { e.onCloseAutoFocus?.(Re), Re.defaultPrevented || (Ee.current || xe.triggerRef.current?.focus(), Re.preventDefault()), Ee.current = !1, _e.current = !1 }, onInteractOutside: Re => { e.onInteractOutside?.(Re), Re.defaultPrevented || (Ee.current = !0, Re.detail.originalEvent.type === "pointerdown" && (_e.current = !0)); const Ce = Re.target; xe.triggerRef.current?.contains(Ce) && Re.preventDefault(), Re.detail.originalEvent.type === "focusin" && _e.current && Re.preventDefault() } }) }), PopoverContentImpl = reactExports.forwardRef((e, t) => { const { __scopePopover: xe, trapFocus: Ee, onOpenAutoFocus: _e, onCloseAutoFocus: Re, disableOutsidePointerEvents: Ce, onEscapeKeyDown: Me, onPointerDownOutside: De, onFocusOutside: Pe, onInteractOutside: Oe, ...je } = e, Be = usePopoverContext(CONTENT_NAME$2, xe), Ie = usePopperScope$1(xe); return useFocusGuards(), jsxRuntimeExports.jsx(FocusScope, { asChild: !0, loop: !0, trapped: Ee, onMountAutoFocus: _e, onUnmountAutoFocus: Re, children: jsxRuntimeExports.jsx(DismissableLayer, { asChild: !0, disableOutsidePointerEvents: Ce, onInteractOutside: Oe, onEscapeKeyDown: Me, onPointerDownOutside: De, onFocusOutside: Pe, onDismiss: () => Be.onOpenChange(!1), children: jsxRuntimeExports.jsx(Content$1, { "data-state": getState$2(Be.open), role: "dialog", id: Be.contentId, ...Ie, ...je, ref: t, style: { ...je.style, "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-popover-content-available-width": "var(--radix-popper-available-width)", "--radix-popover-content-available-height": "var(--radix-popper-available-height)", "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)", "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)" } }) }) }) }), CLOSE_NAME$1 = "PopoverClose", PopoverClose = reactExports.forwardRef((e, t) => { const { __scopePopover: xe, ...Ee } = e, _e = usePopoverContext(CLOSE_NAME$1, xe); return jsxRuntimeExports.jsx(Primitive.button, { type: "button", ...Ee, ref: t, onClick: composeEventHandlers(e.onClick, () => _e.onOpenChange(!1)) }) }); PopoverClose.displayName = CLOSE_NAME$1; var ARROW_NAME$1 = "PopoverArrow", PopoverArrow = reactExports.forwardRef((e, t) => { const { __scopePopover: xe, ...Ee } = e, _e = usePopperScope$1(xe); return jsxRuntimeExports.jsx(Arrow, { ..._e, ...Ee, ref: t }) }); PopoverArrow.displayName = ARROW_NAME$1; function getState$2(e) { return e ? "open" : "closed" } var Root2 = Popover$1, Trigger$2 = PopoverTrigger$1, Portal$2 = PopoverPortal, Content2$1 = PopoverContent$1; function Popover({ ...e }) { return jsxRuntimeExports.jsx(Root2, { "data-slot": "popover", ...e }) } function PopoverTrigger({ ...e }) { return jsxRuntimeExports.jsx(Trigger$2, { "data-slot": "popover-trigger", ...e }) } function PopoverContent({ className: e, align: t = "center", sideOffset: xe = 4, ...Ee }) { return jsxRuntimeExports.jsx(Portal$2, { children: jsxRuntimeExports.jsx(Content2$1, { "data-slot": "popover-content", align: t, sideOffset: xe, className: cn$1("bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden", e), ...Ee }) }) } var shim = { exports: {} }, useSyncExternalStoreShim_production = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var hasRequiredUseSyncExternalStoreShim_production; function requireUseSyncExternalStoreShim_production() { if (hasRequiredUseSyncExternalStoreShim_production) return useSyncExternalStoreShim_production; hasRequiredUseSyncExternalStoreShim_production = 1; var e = requireReact(); function t(je, Be) { return je === Be && (je !== 0 || 1 / je === 1 / Be) || je !== je && Be !== Be } var xe = typeof Object.is == "function" ? Object.is : t, Ee = e.useState, _e = e.useEffect, Re = e.useLayoutEffect, Ce = e.useDebugValue; function Me(je, Be) { var Ie = Be(), Fe = Ee({ inst: { value: Ie, getSnapshot: Be } }), ze = Fe[0].inst, qe = Fe[1]; return Re(function () { ze.value = Ie, ze.getSnapshot = Be, De(ze) && qe({ inst: ze }) }, [je, Ie, Be]), _e(function () { return De(ze) && qe({ inst: ze }), je(function () { De(ze) && qe({ inst: ze }) }) }, [je]), Ce(Ie), Ie } function De(je) { var Be = je.getSnapshot; je = je.value; try { var Ie = Be(); return !xe(je, Ie) } catch { return !0 } } function Pe(je, Be) { return Be() } var Oe = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? Pe : Me; return useSyncExternalStoreShim_production.useSyncExternalStore = e.useSyncExternalStore !== void 0 ? e.useSyncExternalStore : Oe, useSyncExternalStoreShim_production } var hasRequiredShim; function requireShim() { return hasRequiredShim || (hasRequiredShim = 1, shim.exports = requireUseSyncExternalStoreShim_production()), shim.exports } var shimExports = requireShim(); function useIsHydrated() { return shimExports.useSyncExternalStore(subscribe, () => !0, () => !1) } function subscribe() { return () => { } } var AVATAR_NAME = "Avatar", [createAvatarContext, createAvatarScope] = createContextScope(AVATAR_NAME), [AvatarProvider, useAvatarContext] = createAvatarContext(AVATAR_NAME), Avatar$1 = reactExports.forwardRef((e, t) => { const { __scopeAvatar: xe, ...Ee } = e, [_e, Re] = reactExports.useState("idle"); return jsxRuntimeExports.jsx(AvatarProvider, { scope: xe, imageLoadingStatus: _e, onImageLoadingStatusChange: Re, children: jsxRuntimeExports.jsx(Primitive.span, { ...Ee, ref: t }) }) }); Avatar$1.displayName = AVATAR_NAME; var IMAGE_NAME = "AvatarImage", AvatarImage$1 = reactExports.forwardRef((e, t) => { const { __scopeAvatar: xe, src: Ee, onLoadingStatusChange: _e = () => { }, ...Re } = e, Ce = useAvatarContext(IMAGE_NAME, xe), Me = useImageLoadingStatus(Ee, Re), De = useCallbackRef$1(Pe => { _e(Pe), Ce.onImageLoadingStatusChange(Pe) }); return useLayoutEffect2(() => { Me !== "idle" && De(Me) }, [Me, De]), Me === "loaded" ? jsxRuntimeExports.jsx(Primitive.img, { ...Re, ref: t, src: Ee }) : null }); AvatarImage$1.displayName = IMAGE_NAME; var FALLBACK_NAME = "AvatarFallback", AvatarFallback$1 = reactExports.forwardRef((e, t) => { const { __scopeAvatar: xe, delayMs: Ee, ..._e } = e, Re = useAvatarContext(FALLBACK_NAME, xe), [Ce, Me] = reactExports.useState(Ee === void 0); return reactExports.useEffect(() => { if (Ee !== void 0) { const De = window.setTimeout(() => Me(!0), Ee); return () => window.clearTimeout(De) } }, [Ee]), Ce && Re.imageLoadingStatus !== "loaded" ? jsxRuntimeExports.jsx(Primitive.span, { ..._e, ref: t }) : null }); AvatarFallback$1.displayName = FALLBACK_NAME; function resolveLoadingStatus(e, t) { return e ? t ? (e.src !== t && (e.src = t), e.complete && e.naturalWidth > 0 ? "loaded" : "loading") : "error" : "idle" } function useImageLoadingStatus(e, { referrerPolicy: t, crossOrigin: xe }) { const Ee = useIsHydrated(), _e = reactExports.useRef(null), Re = Ee ? (_e.current || (_e.current = new window.Image), _e.current) : null, [Ce, Me] = reactExports.useState(() => resolveLoadingStatus(Re, e)); return useLayoutEffect2(() => { Me(resolveLoadingStatus(Re, e)) }, [Re, e]), useLayoutEffect2(() => { const De = je => () => { Me(je) }; if (!Re) return; const Pe = De("loaded"), Oe = De("error"); return Re.addEventListener("load", Pe), Re.addEventListener("error", Oe), t && (Re.referrerPolicy = t), typeof xe == "string" && (Re.crossOrigin = xe), () => { Re.removeEventListener("load", Pe), Re.removeEventListener("error", Oe) } }, [Re, xe, t]), Ce } var Root$1 = Avatar$1, Image$1 = AvatarImage$1, Fallback = AvatarFallback$1; function Avatar({ className: e, ...t }) { return jsxRuntimeExports.jsx(Root$1, { "data-slot": "avatar", className: cn$1("relative flex size-8 shrink-0 overflow-hidden rounded-full", e), ...t }) } function AvatarImage({ className: e, ...t }) { return jsxRuntimeExports.jsx(Image$1, { "data-slot": "avatar-image", className: cn$1("aspect-square size-full", e), ...t }) } function AvatarFallback({ className: e, ...t }) { return jsxRuntimeExports.jsx(Fallback, { "data-slot": "avatar-fallback", className: cn$1("bg-muted flex size-full items-center justify-center rounded-full", e), ...t }) } const badgeVariants = cva("inline-flex items-center justify-center rounded-md border px-2 py-0.5 text-xs font-medium w-fit whitespace-nowrap shrink-0 [&>svg]:size-3 gap-1 [&>svg]:pointer-events-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive transition-[color,box-shadow] overflow-hidden", { variants: { variant: { default: "border-transparent bg-primary text-primary-foreground [a&]:hover:bg-primary/90", secondary: "border-transparent bg-secondary text-secondary-foreground [a&]:hover:bg-secondary/90", destructive: "border-transparent bg-destructive text-white [a&]:hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60", outline: "text-foreground [a&]:hover:bg-accent [a&]:hover:text-accent-foreground" } }, defaultVariants: { variant: "default" } }); function Badge({ className: e, variant: t, asChild: xe = !1, ...Ee }) { const _e = xe ? Slot$3 : "span"; return jsxRuntimeExports.jsx(_e, { "data-slot": "badge", className: cn$1(badgeVariants({ variant: t }), e), ...Ee }) } const getStaticUrl = e => { if (!e || typeof e != "string" || e.trim() === "") return ""; const t = "https://192.168.0.7:5555".replace(/\/api$/, ""); return e.startsWith("http") ? e : `${t}${e}` }, Navbar = () => { const { user: e, logout: t } = reactExports.useContext(AuthContext), xe = useNavigate(), [Ee, _e] = reactExports.useState(!1), Re = () => { t(null, { onSuccess: () => xe("/login") }), _e(!1) }; return jsxRuntimeExports.jsxs("nav", { className: "bg-gray-800 text-white p-4 sticky top-0 z-50 shadow-md", children: [jsxRuntimeExports.jsxs("div", { className: "container mx-auto flex justify-between items-center", children: [jsxRuntimeExports.jsxs(Link, { to: "/", className: "text-xl font-bold flex items-center gap-2", children: [jsxRuntimeExports.jsx(House, { className: "h-5 w-5" }), "Bahmni"] }), jsxRuntimeExports.jsx("div", { className: "hidden md:flex items-center gap-4", children: e ? jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: jsxRuntimeExports.jsxs(Popover, { children: [jsxRuntimeExports.jsx(PopoverTrigger, { asChild: !0, children: jsxRuntimeExports.jsxs(Button, { variant: "ghost", className: "text-white flex items-center gap-2", children: [jsxRuntimeExports.jsxs(Avatar, { className: "h-8 w-8", children: [jsxRuntimeExports.jsx(AvatarImage, { src: getStaticUrl(e.photo), alt: e.fullName }), jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-gray-600 text-white", children: e.fullName?.charAt(0).toUpperCase() || "?" })] }), e.fullName] }) }), jsxRuntimeExports.jsxs(PopoverContent, { className: "w-72 bg-white rounded-lg shadow-lg p-4 border border-gray-200", children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3 mb-4", children: [jsxRuntimeExports.jsxs(Avatar, { className: "h-8 w-8", children: [jsxRuntimeExports.jsx(AvatarImage, { src: getStaticUrl(e.photo), alt: e.fullName }), jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-gray-600 text-white", children: e.fullName?.charAt(0).toUpperCase() || "?" })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("p", { className: "text-sm font-semibold text-gray-800", children: e.fullName }), jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-500", children: e.email })] })] }), jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-1 mb-4", children: [e.roles.map(Ce => jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs", children: Ce }, Ce)), e.roles.length === 0 && jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-500", children: "No roles assigned" })] }), jsxRuntimeExports.jsxs("div", { className: "grid gap-2", children: [jsxRuntimeExports.jsx(Link, { to: "/profile", className: "text-sm text-gray-700 hover:text-blue-600 transition-colors", children: "Edit Profile" }), e.roles.includes(ROLES.ADMIN) && jsxRuntimeExports.jsx(Link, { to: "/admin", className: "text-sm text-gray-700 hover:text-blue-600 transition-colors", children: "Admin Dashboard" }), jsxRuntimeExports.jsxs(Button, { variant: "ghost", className: "w-full text-left text-sm text-gray-700 bg-gray-100 hover:text-red-600 hover:bg-gray-200", onClick: Re, children: [jsxRuntimeExports.jsx(LogOut, { className: "h-4 w-4 mr-2" }), "Logout"] })] })] })] }) }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Link, { to: "/login", className: "text-sm hover:text-gray-300 transition-colors", children: "Login" }), jsxRuntimeExports.jsx(Link, { to: "/register", className: "text-sm hover:text-gray-300 transition-colors", children: "Register" })] }) }), jsxRuntimeExports.jsx(Button, { variant: "ghost", className: "md:hidden text-white", onClick: () => _e(!Ee), children: Ee ? jsxRuntimeExports.jsx(X$1, { className: "h-6 w-6" }) : jsxRuntimeExports.jsx(Menu, { className: "h-6 w-6" }) })] }), Ee && jsxRuntimeExports.jsx("div", { className: "md:hidden bg-gray-800 p-4 flex flex-col gap-3 transition-transform duration-300", children: e ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-3", children: [jsxRuntimeExports.jsxs(Avatar, { className: "h-8 w-8", children: [jsxRuntimeExports.jsx(AvatarImage, { src: getStaticUrl(e.photo), alt: e.fullName }), jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-gray-600 text-white", children: e.fullName?.charAt(0).toUpperCase() || "?" })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("p", { className: "text-sm font-semibold", children: e.fullName }), jsxRuntimeExports.jsx("p", { className: "text-xs text-gray-300", children: e.email })] })] }), jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-1", children: [e.roles.map(Ce => jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs bg-gray-700 text-white", children: Ce }, Ce)), e.roles.length === 0 && jsxRuntimeExports.jsx("span", { className: "text-xs text-gray-300", children: "No roles assigned" })] }), jsxRuntimeExports.jsxs(Link, { to: "/profile", className: "flex items-center gap-2 text-sm hover:text-gray-300 transition-colors", onClick: () => _e(!1), children: [jsxRuntimeExports.jsx(User, { className: "h-4 w-4" }), "Profile"] }), e.roles.includes(ROLES.ADMIN) && jsxRuntimeExports.jsxs(Link, { to: "/admin", className: "flex items-center gap-2 text-sm hover:text-gray-300 transition-colors", onClick: () => _e(!1), children: [jsxRuntimeExports.jsx(Shield, { className: "h-4 w-4" }), "Admin Dashboard"] }), jsxRuntimeExports.jsxs(Button, { onClick: Re, variant: "outline", className: "text-white border-white hover:bg-gray-700 hover:text-white w-full", children: [jsxRuntimeExports.jsx(LogOut, { className: "h-4 w-4 mr-2" }), "Logout"] })] }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(Link, { to: "/login", className: "text-sm hover:text-gray-300 transition-colors", onClick: () => _e(!1), children: "Login" }), jsxRuntimeExports.jsx(Link, { to: "/register", className: "text-sm hover:text-gray-300 transition-colors", onClick: () => _e(!1), children: "Register" })] }) })] }) }, DashboardCard = ({ title: e, description: t, link: xe, disabled: Ee, onClick: _e }) => jsxRuntimeExports.jsxs("div", { className: "p-6 bg-white rounded-lg shadow-md", children: [jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-2", children: e }), jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: t }), xe ? jsxRuntimeExports.jsx(Link, { to: xe, children: jsxRuntimeExports.jsxs(Button, { disabled: Ee, children: ["Go to ", e] }) }) : jsxRuntimeExports.jsx(Button, { onClick: _e, disabled: Ee, className: Ee === !0 ? "cursor-not-allowed" : "", children: e })] }), UserDashboard = () => { const { user: e } = reactExports.useContext(AuthContext); return jsxRuntimeExports.jsxs("div", { className: "container mx-auto p-6", children: [jsxRuntimeExports.jsxs("h2", { className: "text-2xl font-bold mb-4", children: ["Welcome, ", e?.fullName || "User", "!"] }), jsxRuntimeExports.jsxs("p", { className: "text-gray-600 mb-6 flex gap-2 justify-start items-center", children: ["Your roles:", jsxRuntimeExports.jsx("div", { className: "flex gap-1", children: e.roles.length > 0 ? e.roles.map(t => jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs", children: t }, t)) : jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-500", children: "No roles assigned" }) })] }), jsxRuntimeExports.jsxs("div", { className: "grid gap-6 sm:grid-cols-1 md:grid-cols-2 lg:grid-cols-3", children: [e?.roles.includes(ROLES.ADMIN) && jsxRuntimeExports.jsx(DashboardCard, { title: "Admin Dashboard", description: "Manage users, approve registrations, and assign roles.", link: "/admin" }), e?.roles.includes(ROLES.SCANNER_CLERK) && jsxRuntimeExports.jsx(DashboardCard, { title: "Scan Documents", description: "Scan or upload documents for processing.", onClick: () => alert("Document scanning coming soon!"), link: "/scanner" }), e?.roles.includes(ROLES.APPROVER) && jsxRuntimeExports.jsx(DashboardCard, { title: "Review Documents", description: "Review and approve/reject scanned documents.", onClick: () => alert("Document review coming soon!"), link: "/approver" }), e?.roles.includes(ROLES.UPLOADER) && jsxRuntimeExports.jsx(DashboardCard, { title: "Upload to Bahmni", description: "Upload approved documents to Bahmni EMR.", onClick: () => alert("Bahmni upload coming soon!"), link: "/uploader" })] })] }) }, Dashboard = () => { const { user: e } = reactExports.useContext(AuthContext); return e ? jsxRuntimeExports.jsx(UserDashboard, {}) : jsxRuntimeExports.jsx(Navigate, { to: "/login" }) }; var DIALOG_NAME = "Dialog", [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME), [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME), Dialog$1 = e => { const { __scopeDialog: t, children: xe, open: Ee, defaultOpen: _e, onOpenChange: Re, modal: Ce = !0 } = e, Me = reactExports.useRef(null), De = reactExports.useRef(null), [Pe, Oe] = useControllableState({ prop: Ee, defaultProp: _e ?? !1, onChange: Re, caller: DIALOG_NAME }); return jsxRuntimeExports.jsx(DialogProvider, { scope: t, triggerRef: Me, contentRef: De, contentId: useId(), titleId: useId(), descriptionId: useId(), open: Pe, onOpenChange: Oe, onOpenToggle: reactExports.useCallback(() => Oe(je => !je), [Oe]), modal: Ce, children: xe }) }; Dialog$1.displayName = DIALOG_NAME; var TRIGGER_NAME$2 = "DialogTrigger", DialogTrigger$1 = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, ...Ee } = e, _e = useDialogContext(TRIGGER_NAME$2, xe), Re = useComposedRefs(t, _e.triggerRef); return jsxRuntimeExports.jsx(Primitive.button, { type: "button", "aria-haspopup": "dialog", "aria-expanded": _e.open, "aria-controls": _e.contentId, "data-state": getState$1(_e.open), ...Ee, ref: Re, onClick: composeEventHandlers(e.onClick, _e.onOpenToggle) }) }); DialogTrigger$1.displayName = TRIGGER_NAME$2; var PORTAL_NAME$1 = "DialogPortal", [PortalProvider$1, usePortalContext$1] = createDialogContext(PORTAL_NAME$1, { forceMount: void 0 }), DialogPortal$1 = e => { const { __scopeDialog: t, forceMount: xe, children: Ee, container: _e } = e, Re = useDialogContext(PORTAL_NAME$1, t); return jsxRuntimeExports.jsx(PortalProvider$1, { scope: t, forceMount: xe, children: reactExports.Children.map(Ee, Ce => jsxRuntimeExports.jsx(Presence, { present: xe || Re.open, children: jsxRuntimeExports.jsx(Portal$4, { asChild: !0, container: _e, children: Ce }) })) }) }; DialogPortal$1.displayName = PORTAL_NAME$1; var OVERLAY_NAME = "DialogOverlay", DialogOverlay$1 = reactExports.forwardRef((e, t) => { const xe = usePortalContext$1(OVERLAY_NAME, e.__scopeDialog), { forceMount: Ee = xe.forceMount, ..._e } = e, Re = useDialogContext(OVERLAY_NAME, e.__scopeDialog); return Re.modal ? jsxRuntimeExports.jsx(Presence, { present: Ee || Re.open, children: jsxRuntimeExports.jsx(DialogOverlayImpl, { ..._e, ref: t }) }) : null }); DialogOverlay$1.displayName = OVERLAY_NAME; var Slot = createSlot("DialogOverlay.RemoveScroll"), DialogOverlayImpl = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, ...Ee } = e, _e = useDialogContext(OVERLAY_NAME, xe); return jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: !0, shards: [_e.contentRef], children: jsxRuntimeExports.jsx(Primitive.div, { "data-state": getState$1(_e.open), ...Ee, ref: t, style: { pointerEvents: "auto", ...Ee.style } }) }) }), CONTENT_NAME$1 = "DialogContent", DialogContent$1 = reactExports.forwardRef((e, t) => { const xe = usePortalContext$1(CONTENT_NAME$1, e.__scopeDialog), { forceMount: Ee = xe.forceMount, ..._e } = e, Re = useDialogContext(CONTENT_NAME$1, e.__scopeDialog); return jsxRuntimeExports.jsx(Presence, { present: Ee || Re.open, children: Re.modal ? jsxRuntimeExports.jsx(DialogContentModal, { ..._e, ref: t }) : jsxRuntimeExports.jsx(DialogContentNonModal, { ..._e, ref: t }) }) }); DialogContent$1.displayName = CONTENT_NAME$1; var DialogContentModal = reactExports.forwardRef((e, t) => { const xe = useDialogContext(CONTENT_NAME$1, e.__scopeDialog), Ee = reactExports.useRef(null), _e = useComposedRefs(t, xe.contentRef, Ee); return reactExports.useEffect(() => { const Re = Ee.current; if (Re) return hideOthers(Re) }, []), jsxRuntimeExports.jsx(DialogContentImpl, { ...e, ref: _e, trapFocus: xe.open, disableOutsidePointerEvents: !0, onCloseAutoFocus: composeEventHandlers(e.onCloseAutoFocus, Re => { Re.preventDefault(), xe.triggerRef.current?.focus() }), onPointerDownOutside: composeEventHandlers(e.onPointerDownOutside, Re => { const Ce = Re.detail.originalEvent, Me = Ce.button === 0 && Ce.ctrlKey === !0; (Ce.button === 2 || Me) && Re.preventDefault() }), onFocusOutside: composeEventHandlers(e.onFocusOutside, Re => Re.preventDefault()) }) }), DialogContentNonModal = reactExports.forwardRef((e, t) => { const xe = useDialogContext(CONTENT_NAME$1, e.__scopeDialog), Ee = reactExports.useRef(!1), _e = reactExports.useRef(!1); return jsxRuntimeExports.jsx(DialogContentImpl, { ...e, ref: t, trapFocus: !1, disableOutsidePointerEvents: !1, onCloseAutoFocus: Re => { e.onCloseAutoFocus?.(Re), Re.defaultPrevented || (Ee.current || xe.triggerRef.current?.focus(), Re.preventDefault()), Ee.current = !1, _e.current = !1 }, onInteractOutside: Re => { e.onInteractOutside?.(Re), Re.defaultPrevented || (Ee.current = !0, Re.detail.originalEvent.type === "pointerdown" && (_e.current = !0)); const Ce = Re.target; xe.triggerRef.current?.contains(Ce) && Re.preventDefault(), Re.detail.originalEvent.type === "focusin" && _e.current && Re.preventDefault() } }) }), DialogContentImpl = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, trapFocus: Ee, onOpenAutoFocus: _e, onCloseAutoFocus: Re, ...Ce } = e, Me = useDialogContext(CONTENT_NAME$1, xe), De = reactExports.useRef(null), Pe = useComposedRefs(t, De); return useFocusGuards(), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(FocusScope, { asChild: !0, loop: !0, trapped: Ee, onMountAutoFocus: _e, onUnmountAutoFocus: Re, children: jsxRuntimeExports.jsx(DismissableLayer, { role: "dialog", id: Me.contentId, "aria-describedby": Me.descriptionId, "aria-labelledby": Me.titleId, "data-state": getState$1(Me.open), ...Ce, ref: Pe, onDismiss: () => Me.onOpenChange(!1) }) }), jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(TitleWarning, { titleId: Me.titleId }), jsxRuntimeExports.jsx(DescriptionWarning, { contentRef: De, descriptionId: Me.descriptionId })] })] }) }), TITLE_NAME = "DialogTitle", DialogTitle$1 = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, ...Ee } = e, _e = useDialogContext(TITLE_NAME, xe); return jsxRuntimeExports.jsx(Primitive.h2, { id: _e.titleId, ...Ee, ref: t }) }); DialogTitle$1.displayName = TITLE_NAME; var DESCRIPTION_NAME = "DialogDescription", DialogDescription = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, ...Ee } = e, _e = useDialogContext(DESCRIPTION_NAME, xe); return jsxRuntimeExports.jsx(Primitive.p, { id: _e.descriptionId, ...Ee, ref: t }) }); DialogDescription.displayName = DESCRIPTION_NAME; var CLOSE_NAME = "DialogClose", DialogClose = reactExports.forwardRef((e, t) => { const { __scopeDialog: xe, ...Ee } = e, _e = useDialogContext(CLOSE_NAME, xe); return jsxRuntimeExports.jsx(Primitive.button, { type: "button", ...Ee, ref: t, onClick: composeEventHandlers(e.onClick, () => _e.onOpenChange(!1)) }) }); DialogClose.displayName = CLOSE_NAME; function getState$1(e) { return e ? "open" : "closed" } var TITLE_WARNING_NAME = "DialogTitleWarning", [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, { contentName: CONTENT_NAME$1, titleName: TITLE_NAME, docsSlug: "dialog" }), TitleWarning = ({ titleId: e }) => {
  const t = useWarningContext(TITLE_WARNING_NAME), xe = `\`${t.contentName}\` requires a \`${t.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t.docsSlug}`; return reactExports.useEffect(() => { e && (document.getElementById(e) || console.error(xe)) }, [xe, e]), null
}, DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning", DescriptionWarning = ({ contentRef: e, descriptionId: t }) => { const Ee = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${useWarningContext(DESCRIPTION_WARNING_NAME).contentName}}.`; return reactExports.useEffect(() => { const _e = e.current?.getAttribute("aria-describedby"); t && _e && (document.getElementById(t) || console.warn(Ee)) }, [Ee, e, t]), null }, Root = Dialog$1, Trigger$1 = DialogTrigger$1, Portal$1 = DialogPortal$1, Overlay = DialogOverlay$1, Content = DialogContent$1, Title = DialogTitle$1, Description = DialogDescription, Close = DialogClose; function Dialog({ ...e }) { return jsxRuntimeExports.jsx(Root, { "data-slot": "dialog", ...e }) } function DialogTrigger({ ...e }) { return jsxRuntimeExports.jsx(Trigger$1, { "data-slot": "dialog-trigger", ...e }) } function DialogPortal({ ...e }) { return jsxRuntimeExports.jsx(Portal$1, { "data-slot": "dialog-portal", ...e }) } function DialogOverlay({ className: e, ...t }) { return jsxRuntimeExports.jsx(Overlay, { "data-slot": "dialog-overlay", className: cn$1("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e), ...t }) } function DialogContent({ className: e, children: t, showCloseButton: xe = !0, ...Ee }) { return jsxRuntimeExports.jsxs(DialogPortal, { "data-slot": "dialog-portal", children: [jsxRuntimeExports.jsx(DialogOverlay, {}), jsxRuntimeExports.jsxs(Content, { "data-slot": "dialog-content", className: cn$1("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg", e), ...Ee, children: [t, xe && jsxRuntimeExports.jsxs(Close, { "data-slot": "dialog-close", className: "ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4", children: [jsxRuntimeExports.jsx(X$1, {}), jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })] })] })] }) } function DialogHeader({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "dialog-header", className: cn$1("flex flex-col gap-2 text-center sm:text-left", e), ...t }) } function DialogFooter({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "dialog-footer", className: cn$1("flex flex-col-reverse gap-2 sm:flex-row sm:justify-end", e), ...t }) } function DialogTitle({ className: e, ...t }) { return jsxRuntimeExports.jsx(Title, { "data-slot": "dialog-title", className: cn$1("text-lg leading-none font-semibold", e), ...t }) } var CHECKBOX_NAME = "Checkbox", [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME), [CheckboxProviderImpl, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME); function CheckboxProvider(e) { const { __scopeCheckbox: t, checked: xe, children: Ee, defaultChecked: _e, disabled: Re, form: Ce, name: Me, onCheckedChange: De, required: Pe, value: Oe = "on", internal_do_not_use_render: je } = e, [Be, Ie] = useControllableState({ prop: xe, defaultProp: _e ?? !1, onChange: De, caller: CHECKBOX_NAME }), [Fe, ze] = reactExports.useState(null), [qe, He] = reactExports.useState(null), Ge = reactExports.useRef(!1), Ze = Fe ? !!Ce || !!Fe.closest("form") : !0, sn = { checked: Be, disabled: Re, setChecked: Ie, control: Fe, setControl: ze, name: Me, form: Ce, value: Oe, hasConsumerStoppedPropagationRef: Ge, required: Pe, defaultChecked: isIndeterminate(_e) ? !1 : _e, isFormControl: Ze, bubbleInput: qe, setBubbleInput: He }; return jsxRuntimeExports.jsx(CheckboxProviderImpl, { scope: t, ...sn, children: isFunction$1(je) ? je(sn) : Ee }) } var TRIGGER_NAME$1 = "CheckboxTrigger", CheckboxTrigger = reactExports.forwardRef(({ __scopeCheckbox: e, onKeyDown: t, onClick: xe, ...Ee }, _e) => { const { control: Re, value: Ce, disabled: Me, checked: De, required: Pe, setControl: Oe, setChecked: je, hasConsumerStoppedPropagationRef: Be, isFormControl: Ie, bubbleInput: Fe } = useCheckboxContext(TRIGGER_NAME$1, e), ze = useComposedRefs(_e, Oe), qe = reactExports.useRef(De); return reactExports.useEffect(() => { const He = Re?.form; if (He) { const Ge = () => je(qe.current); return He.addEventListener("reset", Ge), () => He.removeEventListener("reset", Ge) } }, [Re, je]), jsxRuntimeExports.jsx(Primitive.button, { type: "button", role: "checkbox", "aria-checked": isIndeterminate(De) ? "mixed" : De, "aria-required": Pe, "data-state": getState(De), "data-disabled": Me ? "" : void 0, disabled: Me, value: Ce, ...Ee, ref: ze, onKeyDown: composeEventHandlers(t, He => { He.key === "Enter" && He.preventDefault() }), onClick: composeEventHandlers(xe, He => { je(Ge => isIndeterminate(Ge) ? !0 : !Ge), Fe && Ie && (Be.current = He.isPropagationStopped(), Be.current || He.stopPropagation()) }) }) }); CheckboxTrigger.displayName = TRIGGER_NAME$1; var Checkbox$1 = reactExports.forwardRef((e, t) => { const { __scopeCheckbox: xe, name: Ee, checked: _e, defaultChecked: Re, required: Ce, disabled: Me, value: De, onCheckedChange: Pe, form: Oe, ...je } = e; return jsxRuntimeExports.jsx(CheckboxProvider, { __scopeCheckbox: xe, checked: _e, defaultChecked: Re, disabled: Me, required: Ce, onCheckedChange: Pe, name: Ee, form: Oe, value: De, internal_do_not_use_render: ({ isFormControl: Be }) => jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(CheckboxTrigger, { ...je, ref: t, __scopeCheckbox: xe }), Be && jsxRuntimeExports.jsx(CheckboxBubbleInput, { __scopeCheckbox: xe })] }) }) }); Checkbox$1.displayName = CHECKBOX_NAME; var INDICATOR_NAME = "CheckboxIndicator", CheckboxIndicator = reactExports.forwardRef((e, t) => { const { __scopeCheckbox: xe, forceMount: Ee, ..._e } = e, Re = useCheckboxContext(INDICATOR_NAME, xe); return jsxRuntimeExports.jsx(Presence, { present: Ee || isIndeterminate(Re.checked) || Re.checked === !0, children: jsxRuntimeExports.jsx(Primitive.span, { "data-state": getState(Re.checked), "data-disabled": Re.disabled ? "" : void 0, ..._e, ref: t, style: { pointerEvents: "none", ...e.style } }) }) }); CheckboxIndicator.displayName = INDICATOR_NAME; var BUBBLE_INPUT_NAME = "CheckboxBubbleInput", CheckboxBubbleInput = reactExports.forwardRef(({ __scopeCheckbox: e, ...t }, xe) => { const { control: Ee, hasConsumerStoppedPropagationRef: _e, checked: Re, defaultChecked: Ce, required: Me, disabled: De, name: Pe, value: Oe, form: je, bubbleInput: Be, setBubbleInput: Ie } = useCheckboxContext(BUBBLE_INPUT_NAME, e), Fe = useComposedRefs(xe, Ie), ze = usePrevious(Re), qe = useSize(Ee); reactExports.useEffect(() => { const Ge = Be; if (!Ge) return; const Ze = window.HTMLInputElement.prototype, Xe = Object.getOwnPropertyDescriptor(Ze, "checked").set, St = !_e.current; if (ze !== Re && Xe) { const un = new Event("click", { bubbles: St }); Ge.indeterminate = isIndeterminate(Re), Xe.call(Ge, isIndeterminate(Re) ? !1 : Re), Ge.dispatchEvent(un) } }, [Be, ze, Re, _e]); const He = reactExports.useRef(isIndeterminate(Re) ? !1 : Re); return jsxRuntimeExports.jsx(Primitive.input, { type: "checkbox", "aria-hidden": !0, defaultChecked: Ce ?? He.current, required: Me, disabled: De, name: Pe, value: Oe, form: je, ...t, tabIndex: -1, ref: Fe, style: { ...t.style, ...qe, position: "absolute", pointerEvents: "none", opacity: 0, margin: 0, transform: "translateX(-100%)" } }) }); CheckboxBubbleInput.displayName = BUBBLE_INPUT_NAME; function isFunction$1(e) { return typeof e == "function" } function isIndeterminate(e) { return e === "indeterminate" } function getState(e) { return isIndeterminate(e) ? "indeterminate" : e ? "checked" : "unchecked" } function Checkbox({ className: e, ...t }) { return jsxRuntimeExports.jsx(Checkbox$1, { "data-slot": "checkbox", className: cn$1("peer border-input dark:bg-input/30 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground dark:data-[state=checked]:bg-primary data-[state=checked]:border-primary focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive size-4 shrink-0 rounded-[4px] border shadow-xs transition-shadow outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50", e), ...t, children: jsxRuntimeExports.jsx(CheckboxIndicator, { "data-slot": "checkbox-indicator", className: "flex items-center justify-center text-current transition-none", children: jsxRuntimeExports.jsx(Check, { className: "size-3.5" }) }) }) } const RegisterUserForm = ({ onClose: e }) => { const { showError: t, showSuccess: xe } = useToastError(), { formData: Ee, handleChange: _e } = useForm({ employeeId: "", fullName: "", email: "", department: "", education: "", profession: "", password: "" }), [Re, Ce] = reactExports.useState([]), Me = useMutation({ mutationFn: () => { const je = { ...Ee, roles: Re }; return registerUser(je) }, onSuccess: () => { xe("User registered successfully"), e() }, onError: je => t(je, "User registration failed") }), De = je => { if (je.preventDefault(), Re.length === 0) { t(null, "At least one role is required"); return } Me.mutate() }, Pe = (je, Be) => { Ce(Ie => Be ? [...Ie, je] : Ie.filter(Fe => Fe !== je)) }, Oe = [{ id: "employeeId", label: "Employee ID", type: "text", placeholder: "Enter your employee ID" }, { id: "fullName", label: "Full Name", type: "text", placeholder: "Enter your full name" }, { id: "department", label: "Department", type: "select", placeholder: "Select your department", options: [{ value: "engineering", label: "Engineering" }, { value: "hr", label: "Human Resources" }, { value: "marketing", label: "Marketing" }, { value: "finance", label: "Finance" }, { value: "it", label: "Information Technology" }] }, { id: "email", label: "Email", type: "email", placeholder: "Enter your email" }, { id: "education", label: "Education", type: "select", placeholder: "Select your education level", options: [{ value: "highschool", label: "High School" }, { value: "bachelor", label: "Bachelor’s Degree" }, { value: "master", label: "Master’s Degree" }, { value: "phd", label: "PhD" }] }, { id: "profession", label: "Profession", type: "select", placeholder: "Select your profession", options: [{ value: "engineer", label: "Engineer" }, { value: "manager", label: "Manager" }, { value: "analyst", label: "Analyst" }, { value: "developer", label: "Developer" }, { value: "designer", label: "Designer" }] }, { id: "password", label: "Password", type: "password", placeholder: "Enter your password" }]; return jsxRuntimeExports.jsxs("form", { onSubmit: De, className: "w-full max-w-md p-6 bg-white rounded shadow", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6", children: "Register" }), Oe.map(je => jsxRuntimeExports.jsx(FormField, { label: je.label, id: je.id, type: je.type, name: je.id, value: Ee[je.id], onChange: _e, required: !0, placeholder: je.placeholder, options: je.options }, je.id)), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(Label, { children: "Roles" }), jsxRuntimeExports.jsx("div", { className: "grid gap-2 m-2", children: Object.values(ROLES).map(je => jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx(Checkbox, { id: `role-${je}`, checked: Re.includes(je), onCheckedChange: Be => Pe(je, Be) }), jsxRuntimeExports.jsx(Label, { htmlFor: `role-${je}`, children: je })] }, je)) })] }), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: Me.isLoading, className: "w-full", children: Me.isLoading ? "Submitting..." : "Submit" })] }) }, UserCard = ({ user: e, handleReview: t, handleStatusToggle: xe, handleRoleUpdate: Ee, rejectionReason: _e, setRejectionReason: Re }) => (console.log("UserCard rendered for:", e), jsxRuntimeExports.jsx("div", { className: "p-4 bg-white rounded-lg shadow-md border border-gray-200", children: jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row justify-between items-start sm:items-center gap-4", children: [jsxRuntimeExports.jsxs("div", { className: "space-y-1", children: [e.photo && jsxRuntimeExports.jsx("img", { src: getStaticUrl(e.photo), alt: `${e.fullName}'s Photo`, className: "w-16 h-16 rounded-full border object-cover" }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Name:" }), " ", e.fullName] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Email:" }), " ", e.email] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Employee ID:" }), " ", e.employeeId || "N/A"] }), e.employeeIdPhoto && jsxRuntimeExports.jsx("img", { src: e.employeeIdPhoto, alt: "Employee ID", className: "w-32 h-20 rounded border object-cover" }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Department:" }), " ", e.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Profession:" }), " ", e.profession || "N/A"] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Education:" }), " ", e.education || "N/A"] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Status:" }), " ", e.isActive ? "Active" : "Inactive"] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Registration:" }), " ", e.registrationStatus] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Account Created:" }), " ", new Date(e.createdAt).toLocaleString()] }), jsxRuntimeExports.jsxs("div", { className: "flex flex-wrap gap-1", children: [jsxRuntimeExports.jsx("strong", { className: "text-sm", children: "Roles:" }), e.roles.length > 0 ? e.roles.map(Ce => jsxRuntimeExports.jsx(Badge, { variant: "secondary", className: "text-xs", children: Ce }, Ce)) : jsxRuntimeExports.jsx("span", { className: "text-sm text-gray-500", children: "No roles assigned" })] })] }), jsxRuntimeExports.jsxs("div", { className: "flex flex-col sm:flex-row gap-2 w-full sm:w-auto", children: [e.isSelfRegistered && e.registrationStatus === "Pending" && jsxRuntimeExports.jsxs(Dialog, { children: [jsxRuntimeExports.jsx(DialogTrigger, { asChild: !0, children: jsxRuntimeExports.jsx(Button, { size: "sm", className: "w-full sm:w-auto", children: "Review Registration" }) }), jsxRuntimeExports.jsxs(DialogContent, { className: "max-h-[80vh] overflow-y-auto", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { children: "Review Registration" }) }), jsxRuntimeExports.jsxs("div", { className: "grid gap-4", children: [jsxRuntimeExports.jsx(Button, { onClick: () => t(e.id, "Approved"), size: "sm", children: "Approve" }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx(Label, { htmlFor: "rejectionReason", children: "Rejection Reason" }), jsxRuntimeExports.jsx(Input, { id: "rejectionReason", value: _e, onChange: Ce => Re(Ce.target.value) }), jsxRuntimeExports.jsx(Button, { onClick: () => t(e.id, "Rejected"), disabled: !_e, className: "mt-2", size: "sm", children: "Reject" })] })] })] })] }), jsxRuntimeExports.jsx(Button, { onClick: () => xe(e.id, !e.isActive), children: e.isActive ? "Deactivate" : "Activate" }), jsxRuntimeExports.jsxs(Popover, { children: [jsxRuntimeExports.jsx(PopoverTrigger, { asChild: !0, children: jsxRuntimeExports.jsx(Button, { variant: "outline", size: "sm", className: "w-full sm:w-auto", children: e.roles.length > 0 ? "Edit Roles" : "Assign Roles" }) }), jsxRuntimeExports.jsx(PopoverContent, { className: "w-56", children: jsxRuntimeExports.jsx("div", { className: "grid gap-4", children: Object.values(ROLES).map(Ce => jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx(Checkbox, { id: `${e.id}-${Ce}`, checked: e.roles.includes(Ce), onCheckedChange: Me => { const De = Me ? [...e.roles, Ce] : e.roles.filter(Pe => Pe !== Ce); Ee(e.id, De) } }), jsxRuntimeExports.jsx(Label, { htmlFor: `${e.id}-${Ce}`, children: Ce })] }, Ce)) }) })] })] })] }) })), AdminDashboard = () => { const { showError: e, showSuccess: t } = useToastError(), { data: xe, isLoading: Ee, refetch: _e } = useQuery({ queryKey: ["users"], queryFn: getUsers }), [Re, Ce] = reactExports.useState(""), [Me, De] = reactExports.useState(!1), Pe = useMutation({ mutationFn: reviewSelfRegistration, onSuccess: () => { t("Registration reviewed"), _e() }, onError: ze => e(ze, "Review failed") }), Oe = useMutation({ mutationFn: ({ userId: ze, data: qe }) => toggleUserStatus(ze, qe), onSuccess: () => { t("User status updated"), _e() }, onError: ze => e(ze, "Status update failed") }), je = useMutation({ mutationFn: ({ userId: ze, data: qe }) => updateUserRoles(ze, qe), onSuccess: () => { t("User roles updated"), _e() }, onError: ze => e(ze, "Roles update failed") }), Be = (ze, qe) => { const He = { userId: ze, status: qe }; console.log("Reviewing user:", He), qe === "Rejected" && (He.rejectionReason = Re), Pe.mutate(He), Ce("") }, Ie = (ze, qe) => { Oe.mutate({ userId: ze, data: { isActive: qe } }) }, Fe = (ze, qe) => { if (qe.length === 0) { e(null, "At least one role is required"); return } je.mutate({ userId: ze, data: { roles: qe } }) }; return Ee ? jsxRuntimeExports.jsx("div", { children: "Loading..." }) : jsxRuntimeExports.jsxs("div", { className: "container mx-auto p-6", children: [jsxRuntimeExports.jsxs("div", { className: "flex justify-between items-center mb-6", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold", children: "Admin Dashboard" }), jsxRuntimeExports.jsxs(Dialog, { open: Me, onOpenChange: De, children: [jsxRuntimeExports.jsx(DialogTrigger, { asChild: !0, children: jsxRuntimeExports.jsx(Button, { children: "Register New User" }) }), jsxRuntimeExports.jsxs(DialogContent, { className: "max-h-[85vh] overflow-y-auto", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { children: "Register New User" }) }), jsxRuntimeExports.jsx(RegisterUserForm, { onClose: () => { De(!1), _e() } })] })] })] }), jsxRuntimeExports.jsx("div", { className: "grid gap-4", children: xe?.data?.data?.users?.map(ze => jsxRuntimeExports.jsx(UserCard, { user: ze, handleReview: Be, handleRoleUpdate: Fe, handleStatusToggle: Ie, rejectionReason: Re, setRejectionReason: Ce })) })] }) }, ProtectedRoute = ({ children: e, roles: t }) => { const { user: xe } = reactExports.useContext(AuthContext); return xe ? (console.log("User roles:", xe.roles), t && !t.some(Ee => xe.roles.includes(Ee)) ? jsxRuntimeExports.jsx(Navigate, { to: "/unauthorized" }) : e) : jsxRuntimeExports.jsx(Navigate, { to: "/login" }) }, AdminDashboardPage = () => jsxRuntimeExports.jsx(ProtectedRoute, { roles: ["Admin"], children: jsxRuntimeExports.jsx(AdminDashboard, {}) }), Profile = () => { const { user: e, setUser: t } = reactExports.useContext(AuthContext), { showError: xe, showSuccess: Ee } = useToastError(), { formData: _e, handleChange: Re, handleFileChange: Ce } = useForm({ fullName: e?.fullName || "", email: e?.email || "", department: e?.department || "", employeeId: e?.employeeId || "", password: "", photo: null }), [Me, De] = reactExports.useState({}), [Pe, Oe] = reactExports.useState(!1), je = useMutation({ mutationFn: ze => updateUser(e.id, ze), onSuccess: ({ data: ze }) => { localStorage.setItem("user", JSON.stringify(ze.data)), t(ze.data), Ee("Profile updated successfully"), Oe(!1) }, onError: ze => { console.log(ze), xe(ze, "Profile update failed") } }), Be = () => { const ze = {}; return _e.fullName || (ze.fullName = "Full name is required"), _e.email ? /\S+@\S+\.\S+/.test(_e.email) || (ze.email = "Invalid email") : ze.email = "Email is required", _e.department || (ze.department = "Department is required"), _e.employeeId || (ze.employeeId = "Employee ID is required"), _e.password && _e.password.length < 6 && (ze.password = "Password must be at least 6 characters"), _e.photo && !["image/jpeg", "image/png"].includes(_e.photo.type) && (ze.photo = "Only JPEG or PNG images are allowed"), De(ze), Object.keys(ze).length === 0 }, Ie = ze => { ze.preventDefault(), Be() && Oe(!0) }, Fe = () => { const ze = new FormData; Object.entries(_e).forEach(([qe, He]) => { He && qe !== "password" && ze.append(qe, He) }), _e.password && ze.append("password", _e.password), je.mutate(ze) }; return e ? jsxRuntimeExports.jsxs("div", { className: "container mx-auto p-6 max-w-2xl", children: [jsxRuntimeExports.jsx("h2", { className: "text-2xl font-bold mb-6 text-center", children: "User Profile" }), jsxRuntimeExports.jsxs("form", { onSubmit: Ie, className: "grid gap-6 sm:grid-cols-1 md:grid-cols-2 bg-white p-6 rounded-lg shadow-md", children: [jsxRuntimeExports.jsx("div", { className: "col-span-2 flex justify-center mb-4", children: jsxRuntimeExports.jsxs(Avatar, { className: "h-24 w-24", children: [jsxRuntimeExports.jsx(AvatarImage, { src: _e.photo || getStaticUrl(e.photo), alt: e.fullName }), jsxRuntimeExports.jsx(AvatarFallback, { className: "bg-gray-600 text-white text-2xl", children: e.fullName.charAt(0).toUpperCase() })] }) }), jsxRuntimeExports.jsxs("div", { className: "col-span-1", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "fullName", className: "text-sm font-medium", children: "Full Name" }), jsxRuntimeExports.jsx(FormField, { id: "fullName", type: "text", name: "fullName", value: _e.fullName, onChange: Re, required: !0, className: "mt-1" }), Me.fullName && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.fullName })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-1", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "email", className: "text-sm font-medium", children: "Email" }), jsxRuntimeExports.jsx(FormField, { id: "email", type: "email", name: "email", value: _e.email, onChange: Re, required: !0, className: "mt-1" }), Me.email && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.email })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-1", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "department", className: "text-sm font-medium", children: "Department" }), jsxRuntimeExports.jsx(FormField, { id: "department", type: "text", name: "department", value: _e.department, onChange: Re, required: !0, className: "mt-1" }), Me.department && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.department })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-1", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "employeeId", className: "text-sm font-medium", children: "Employee ID" }), jsxRuntimeExports.jsx(FormField, { id: "employeeId", type: "text", name: "employeeId", value: _e.employeeId, onChange: Re, required: !0, className: "mt-1" }), Me.employeeId && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.employeeId })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "password", className: "text-sm font-medium", children: "New Password (optional)" }), jsxRuntimeExports.jsx(FormField, { id: "password", type: "password", name: "password", value: _e.password, onChange: Re, className: "mt-1" }), Me.password && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.password })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-2", children: [jsxRuntimeExports.jsx(Label, { htmlFor: "photo", className: "text-sm font-medium", children: "Profile Photo (optional)" }), jsxRuntimeExports.jsx(FormField, { id: "photo", type: "file", name: "photo", onChange: ze => Ce(ze, "photo"), accept: "image/jpeg,image/png", className: "mt-1" }), Me.photo && jsxRuntimeExports.jsx("p", { className: "text-red-600 text-sm mt-1", children: Me.photo })] }), jsxRuntimeExports.jsxs("div", { className: "col-span-2 space-y-2", children: [jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Roles:" }), " ", e.roles.join(", ") || "None"] }), jsxRuntimeExports.jsxs("p", { className: "text-sm", children: [jsxRuntimeExports.jsx("strong", { children: "Status:" }), " ", e.isActive ? "Active" : "Inactive"] }), jsxRuntimeExports.jsx(Button, { type: "submit", disabled: je.isLoading, className: "w-full mt-4", children: je.isLoading ? "Updating..." : "Update Profile" })] })] }), jsxRuntimeExports.jsx(Dialog, { open: Pe, onOpenChange: Oe, children: jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { children: "Confirm Profile Update" }) }), jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: "Are you sure you want to update your profile?" }), jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 justify-end", children: [jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => Oe(!1), disabled: je.isLoading, children: "Cancel" }), jsxRuntimeExports.jsx(Button, { onClick: Fe, disabled: je.isLoading, children: "Confirm" })] })] }) })] }) : jsxRuntimeExports.jsx("div", { className: "container mx-auto p-6 text-center", children: "Please log in to view your profile." }) }, MOBILE_BREAKPOINT = 768; function useIsMobile() { const [e, t] = reactExports.useState(void 0); return reactExports.useEffect(() => { const xe = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`), Ee = () => { t(window.innerWidth < MOBILE_BREAKPOINT) }; return xe.addEventListener("change", Ee), t(window.innerWidth < MOBILE_BREAKPOINT), () => xe.removeEventListener("change", Ee) }, []), !!e } function Sheet({ ...e }) { return jsxRuntimeExports.jsx(Root, { "data-slot": "sheet", ...e }) } function SheetPortal({ ...e }) { return jsxRuntimeExports.jsx(Portal$1, { "data-slot": "sheet-portal", ...e }) } function SheetOverlay({ className: e, ...t }) { return jsxRuntimeExports.jsx(Overlay, { "data-slot": "sheet-overlay", className: cn$1("data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/50", e), ...t }) } function SheetContent({ className: e, children: t, side: xe = "right", ...Ee }) { return jsxRuntimeExports.jsxs(SheetPortal, { children: [jsxRuntimeExports.jsx(SheetOverlay, {}), jsxRuntimeExports.jsxs(Content, { "data-slot": "sheet-content", className: cn$1("bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500", xe === "right" && "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm", xe === "left" && "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm", xe === "top" && "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b", xe === "bottom" && "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t", e), ...Ee, children: [t, jsxRuntimeExports.jsxs(Close, { className: "ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none", children: [jsxRuntimeExports.jsx(X$1, { className: "size-4" }), jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })] })] })] }) } function SheetHeader({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "sheet-header", className: cn$1("flex flex-col gap-1.5 p-4", e), ...t }) } function SheetTitle({ className: e, ...t }) { return jsxRuntimeExports.jsx(Title, { "data-slot": "sheet-title", className: cn$1("text-foreground font-semibold", e), ...t }) } function SheetDescription({ className: e, ...t }) { return jsxRuntimeExports.jsx(Description, { "data-slot": "sheet-description", className: cn$1("text-muted-foreground text-sm", e), ...t }) } var [createTooltipContext, createTooltipScope] = createContextScope("Tooltip", [createPopperScope]), usePopperScope = createPopperScope(), PROVIDER_NAME = "TooltipProvider", DEFAULT_DELAY_DURATION = 700, TOOLTIP_OPEN = "tooltip.open", [TooltipProviderContextProvider, useTooltipProviderContext] = createTooltipContext(PROVIDER_NAME), TooltipProvider$1 = e => { const { __scopeTooltip: t, delayDuration: xe = DEFAULT_DELAY_DURATION, skipDelayDuration: Ee = 300, disableHoverableContent: _e = !1, children: Re } = e, Ce = reactExports.useRef(!0), Me = reactExports.useRef(!1), De = reactExports.useRef(0); return reactExports.useEffect(() => { const Pe = De.current; return () => window.clearTimeout(Pe) }, []), jsxRuntimeExports.jsx(TooltipProviderContextProvider, { scope: t, isOpenDelayedRef: Ce, delayDuration: xe, onOpen: reactExports.useCallback(() => { window.clearTimeout(De.current), Ce.current = !1 }, []), onClose: reactExports.useCallback(() => { window.clearTimeout(De.current), De.current = window.setTimeout(() => Ce.current = !0, Ee) }, [Ee]), isPointerInTransitRef: Me, onPointerInTransitChange: reactExports.useCallback(Pe => { Me.current = Pe }, []), disableHoverableContent: _e, children: Re }) }; TooltipProvider$1.displayName = PROVIDER_NAME; var TOOLTIP_NAME = "Tooltip", [TooltipContextProvider, useTooltipContext] = createTooltipContext(TOOLTIP_NAME), Tooltip$1 = e => { const { __scopeTooltip: t, children: xe, open: Ee, defaultOpen: _e, onOpenChange: Re, disableHoverableContent: Ce, delayDuration: Me } = e, De = useTooltipProviderContext(TOOLTIP_NAME, e.__scopeTooltip), Pe = usePopperScope(t), [Oe, je] = reactExports.useState(null), Be = useId(), Ie = reactExports.useRef(0), Fe = Ce ?? De.disableHoverableContent, ze = Me ?? De.delayDuration, qe = reactExports.useRef(!1), [He, Ge] = useControllableState({ prop: Ee, defaultProp: _e ?? !1, onChange: un => { un ? (De.onOpen(), document.dispatchEvent(new CustomEvent(TOOLTIP_OPEN))) : De.onClose(), Re?.(un) }, caller: TOOLTIP_NAME }), Ze = reactExports.useMemo(() => He ? qe.current ? "delayed-open" : "instant-open" : "closed", [He]), sn = reactExports.useCallback(() => { window.clearTimeout(Ie.current), Ie.current = 0, qe.current = !1, Ge(!0) }, [Ge]), Xe = reactExports.useCallback(() => { window.clearTimeout(Ie.current), Ie.current = 0, Ge(!1) }, [Ge]), St = reactExports.useCallback(() => { window.clearTimeout(Ie.current), Ie.current = window.setTimeout(() => { qe.current = !0, Ge(!0), Ie.current = 0 }, ze) }, [ze, Ge]); return reactExports.useEffect(() => () => { Ie.current && (window.clearTimeout(Ie.current), Ie.current = 0) }, []), jsxRuntimeExports.jsx(Root2$2, { ...Pe, children: jsxRuntimeExports.jsx(TooltipContextProvider, { scope: t, contentId: Be, open: He, stateAttribute: Ze, trigger: Oe, onTriggerChange: je, onTriggerEnter: reactExports.useCallback(() => { De.isOpenDelayedRef.current ? St() : sn() }, [De.isOpenDelayedRef, St, sn]), onTriggerLeave: reactExports.useCallback(() => { Fe ? Xe() : (window.clearTimeout(Ie.current), Ie.current = 0) }, [Xe, Fe]), onOpen: sn, onClose: Xe, disableHoverableContent: Fe, children: xe }) }) }; Tooltip$1.displayName = TOOLTIP_NAME; var TRIGGER_NAME = "TooltipTrigger", TooltipTrigger$1 = reactExports.forwardRef((e, t) => { const { __scopeTooltip: xe, ...Ee } = e, _e = useTooltipContext(TRIGGER_NAME, xe), Re = useTooltipProviderContext(TRIGGER_NAME, xe), Ce = usePopperScope(xe), Me = reactExports.useRef(null), De = useComposedRefs(t, Me, _e.onTriggerChange), Pe = reactExports.useRef(!1), Oe = reactExports.useRef(!1), je = reactExports.useCallback(() => Pe.current = !1, []); return reactExports.useEffect(() => () => document.removeEventListener("pointerup", je), [je]), jsxRuntimeExports.jsx(Anchor, { asChild: !0, ...Ce, children: jsxRuntimeExports.jsx(Primitive.button, { "aria-describedby": _e.open ? _e.contentId : void 0, "data-state": _e.stateAttribute, ...Ee, ref: De, onPointerMove: composeEventHandlers(e.onPointerMove, Be => { Be.pointerType !== "touch" && !Oe.current && !Re.isPointerInTransitRef.current && (_e.onTriggerEnter(), Oe.current = !0) }), onPointerLeave: composeEventHandlers(e.onPointerLeave, () => { _e.onTriggerLeave(), Oe.current = !1 }), onPointerDown: composeEventHandlers(e.onPointerDown, () => { _e.open && _e.onClose(), Pe.current = !0, document.addEventListener("pointerup", je, { once: !0 }) }), onFocus: composeEventHandlers(e.onFocus, () => { Pe.current || _e.onOpen() }), onBlur: composeEventHandlers(e.onBlur, _e.onClose), onClick: composeEventHandlers(e.onClick, _e.onClose) }) }) }); TooltipTrigger$1.displayName = TRIGGER_NAME; var PORTAL_NAME = "TooltipPortal", [PortalProvider, usePortalContext] = createTooltipContext(PORTAL_NAME, { forceMount: void 0 }), TooltipPortal = e => { const { __scopeTooltip: t, forceMount: xe, children: Ee, container: _e } = e, Re = useTooltipContext(PORTAL_NAME, t); return jsxRuntimeExports.jsx(PortalProvider, { scope: t, forceMount: xe, children: jsxRuntimeExports.jsx(Presence, { present: xe || Re.open, children: jsxRuntimeExports.jsx(Portal$4, { asChild: !0, container: _e, children: Ee }) }) }) }; TooltipPortal.displayName = PORTAL_NAME; var CONTENT_NAME = "TooltipContent", TooltipContent$1 = reactExports.forwardRef((e, t) => { const xe = usePortalContext(CONTENT_NAME, e.__scopeTooltip), { forceMount: Ee = xe.forceMount, side: _e = "top", ...Re } = e, Ce = useTooltipContext(CONTENT_NAME, e.__scopeTooltip); return jsxRuntimeExports.jsx(Presence, { present: Ee || Ce.open, children: Ce.disableHoverableContent ? jsxRuntimeExports.jsx(TooltipContentImpl, { side: _e, ...Re, ref: t }) : jsxRuntimeExports.jsx(TooltipContentHoverable, { side: _e, ...Re, ref: t }) }) }), TooltipContentHoverable = reactExports.forwardRef((e, t) => { const xe = useTooltipContext(CONTENT_NAME, e.__scopeTooltip), Ee = useTooltipProviderContext(CONTENT_NAME, e.__scopeTooltip), _e = reactExports.useRef(null), Re = useComposedRefs(t, _e), [Ce, Me] = reactExports.useState(null), { trigger: De, onClose: Pe } = xe, Oe = _e.current, { onPointerInTransitChange: je } = Ee, Be = reactExports.useCallback(() => { Me(null), je(!1) }, [je]), Ie = reactExports.useCallback((Fe, ze) => { const qe = Fe.currentTarget, He = { x: Fe.clientX, y: Fe.clientY }, Ge = getExitSideFromRect(He, qe.getBoundingClientRect()), Ze = getPaddedExitPoints(He, Ge), sn = getPointsFromRect(ze.getBoundingClientRect()), Xe = getHull([...Ze, ...sn]); Me(Xe), je(!0) }, [je]); return reactExports.useEffect(() => () => Be(), [Be]), reactExports.useEffect(() => { if (De && Oe) { const Fe = qe => Ie(qe, Oe), ze = qe => Ie(qe, De); return De.addEventListener("pointerleave", Fe), Oe.addEventListener("pointerleave", ze), () => { De.removeEventListener("pointerleave", Fe), Oe.removeEventListener("pointerleave", ze) } } }, [De, Oe, Ie, Be]), reactExports.useEffect(() => { if (Ce) { const Fe = ze => { const qe = ze.target, He = { x: ze.clientX, y: ze.clientY }, Ge = De?.contains(qe) || Oe?.contains(qe), Ze = !isPointInPolygon(He, Ce); Ge ? Be() : Ze && (Be(), Pe()) }; return document.addEventListener("pointermove", Fe), () => document.removeEventListener("pointermove", Fe) } }, [De, Oe, Ce, Pe, Be]), jsxRuntimeExports.jsx(TooltipContentImpl, { ...e, ref: Re }) }), [VisuallyHiddenContentContextProvider, useVisuallyHiddenContentContext] = createTooltipContext(TOOLTIP_NAME, { isInside: !1 }), Slottable = createSlottable("TooltipContent"), TooltipContentImpl = reactExports.forwardRef((e, t) => { const { __scopeTooltip: xe, children: Ee, "aria-label": _e, onEscapeKeyDown: Re, onPointerDownOutside: Ce, ...Me } = e, De = useTooltipContext(CONTENT_NAME, xe), Pe = usePopperScope(xe), { onClose: Oe } = De; return reactExports.useEffect(() => (document.addEventListener(TOOLTIP_OPEN, Oe), () => document.removeEventListener(TOOLTIP_OPEN, Oe)), [Oe]), reactExports.useEffect(() => { if (De.trigger) { const je = Be => { Be.target?.contains(De.trigger) && Oe() }; return window.addEventListener("scroll", je, { capture: !0 }), () => window.removeEventListener("scroll", je, { capture: !0 }) } }, [De.trigger, Oe]), jsxRuntimeExports.jsx(DismissableLayer, { asChild: !0, disableOutsidePointerEvents: !1, onEscapeKeyDown: Re, onPointerDownOutside: Ce, onFocusOutside: je => je.preventDefault(), onDismiss: Oe, children: jsxRuntimeExports.jsxs(Content$1, { "data-state": De.stateAttribute, ...Pe, ...Me, ref: t, style: { ...Me.style, "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)", "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)", "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)", "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)", "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)" }, children: [jsxRuntimeExports.jsx(Slottable, { children: Ee }), jsxRuntimeExports.jsx(VisuallyHiddenContentContextProvider, { scope: xe, isInside: !0, children: jsxRuntimeExports.jsx(Root$2, { id: De.contentId, role: "tooltip", children: _e || Ee }) })] }) }) }); TooltipContent$1.displayName = CONTENT_NAME; var ARROW_NAME = "TooltipArrow", TooltipArrow = reactExports.forwardRef((e, t) => { const { __scopeTooltip: xe, ...Ee } = e, _e = usePopperScope(xe); return useVisuallyHiddenContentContext(ARROW_NAME, xe).isInside ? null : jsxRuntimeExports.jsx(Arrow, { ..._e, ...Ee, ref: t }) }); TooltipArrow.displayName = ARROW_NAME; function getExitSideFromRect(e, t) { const xe = Math.abs(t.top - e.y), Ee = Math.abs(t.bottom - e.y), _e = Math.abs(t.right - e.x), Re = Math.abs(t.left - e.x); switch (Math.min(xe, Ee, _e, Re)) { case Re: return "left"; case _e: return "right"; case xe: return "top"; case Ee: return "bottom"; default: throw new Error("unreachable") } } function getPaddedExitPoints(e, t, xe = 5) { const Ee = []; switch (t) { case "top": Ee.push({ x: e.x - xe, y: e.y + xe }, { x: e.x + xe, y: e.y + xe }); break; case "bottom": Ee.push({ x: e.x - xe, y: e.y - xe }, { x: e.x + xe, y: e.y - xe }); break; case "left": Ee.push({ x: e.x + xe, y: e.y - xe }, { x: e.x + xe, y: e.y + xe }); break; case "right": Ee.push({ x: e.x - xe, y: e.y - xe }, { x: e.x - xe, y: e.y + xe }); break }return Ee } function getPointsFromRect(e) { const { top: t, right: xe, bottom: Ee, left: _e } = e; return [{ x: _e, y: t }, { x: xe, y: t }, { x: xe, y: Ee }, { x: _e, y: Ee }] } function isPointInPolygon(e, t) { const { x: xe, y: Ee } = e; let _e = !1; for (let Re = 0, Ce = t.length - 1; Re < t.length; Ce = Re++) { const Me = t[Re], De = t[Ce], Pe = Me.x, Oe = Me.y, je = De.x, Be = De.y; Oe > Ee != Be > Ee && xe < (je - Pe) * (Ee - Oe) / (Be - Oe) + Pe && (_e = !_e) } return _e } function getHull(e) { const t = e.slice(); return t.sort((xe, Ee) => xe.x < Ee.x ? -1 : xe.x > Ee.x ? 1 : xe.y < Ee.y ? -1 : xe.y > Ee.y ? 1 : 0), getHullPresorted(t) } function getHullPresorted(e) { if (e.length <= 1) return e.slice(); const t = []; for (let Ee = 0; Ee < e.length; Ee++) { const _e = e[Ee]; for (; t.length >= 2;) { const Re = t[t.length - 1], Ce = t[t.length - 2]; if ((Re.x - Ce.x) * (_e.y - Ce.y) >= (Re.y - Ce.y) * (_e.x - Ce.x)) t.pop(); else break } t.push(_e) } t.pop(); const xe = []; for (let Ee = e.length - 1; Ee >= 0; Ee--) { const _e = e[Ee]; for (; xe.length >= 2;) { const Re = xe[xe.length - 1], Ce = xe[xe.length - 2]; if ((Re.x - Ce.x) * (_e.y - Ce.y) >= (Re.y - Ce.y) * (_e.x - Ce.x)) xe.pop(); else break } xe.push(_e) } return xe.pop(), t.length === 1 && xe.length === 1 && t[0].x === xe[0].x && t[0].y === xe[0].y ? t : t.concat(xe) } var Provider = TooltipProvider$1, Root3 = Tooltip$1, Trigger = TooltipTrigger$1, Portal = TooltipPortal, Content2 = TooltipContent$1, Arrow2 = TooltipArrow; function TooltipProvider({ delayDuration: e = 0, ...t }) { return jsxRuntimeExports.jsx(Provider, { "data-slot": "tooltip-provider", delayDuration: e, ...t }) } function Tooltip({ ...e }) { return jsxRuntimeExports.jsx(TooltipProvider, { children: jsxRuntimeExports.jsx(Root3, { "data-slot": "tooltip", ...e }) }) } function TooltipTrigger({ ...e }) { return jsxRuntimeExports.jsx(Trigger, { "data-slot": "tooltip-trigger", ...e }) } function TooltipContent({ className: e, sideOffset: t = 0, children: xe, ...Ee }) { return jsxRuntimeExports.jsx(Portal, { children: jsxRuntimeExports.jsxs(Content2, { "data-slot": "tooltip-content", sideOffset: t, className: cn$1("bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance", e), ...Ee, children: [xe, jsxRuntimeExports.jsx(Arrow2, { className: "bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" })] }) }) } const SIDEBAR_COOKIE_NAME = "sidebar_state", SIDEBAR_COOKIE_MAX_AGE = 3600 * 24 * 7, SIDEBAR_WIDTH = "16rem", SIDEBAR_WIDTH_MOBILE = "18rem", SIDEBAR_WIDTH_ICON = "3rem", SIDEBAR_KEYBOARD_SHORTCUT = "b", SidebarContext = reactExports.createContext(null); function useSidebar() { const e = reactExports.useContext(SidebarContext); if (!e) throw new Error("useSidebar must be used within a SidebarProvider."); return e } function SidebarProvider({ defaultOpen: e = !0, open: t, onOpenChange: xe, className: Ee, style: _e, children: Re, ...Ce }) { const Me = useIsMobile(), [De, Pe] = reactExports.useState(!1), [Oe, je] = reactExports.useState(e), Be = t ?? Oe, Ie = reactExports.useCallback(He => { const Ge = typeof He == "function" ? He(Be) : He; xe ? xe(Ge) : je(Ge), document.cookie = `${SIDEBAR_COOKIE_NAME}=${Ge}; path=/; max-age=${SIDEBAR_COOKIE_MAX_AGE}` }, [xe, Be]), Fe = reactExports.useCallback(() => Me ? Pe(He => !He) : Ie(He => !He), [Me, Ie, Pe]); reactExports.useEffect(() => { const He = Ge => { Ge.key === SIDEBAR_KEYBOARD_SHORTCUT && (Ge.metaKey || Ge.ctrlKey) && (Ge.preventDefault(), Fe()) }; return window.addEventListener("keydown", He), () => window.removeEventListener("keydown", He) }, [Fe]); const ze = Be ? "expanded" : "collapsed", qe = reactExports.useMemo(() => ({ state: ze, open: Be, setOpen: Ie, isMobile: Me, openMobile: De, setOpenMobile: Pe, toggleSidebar: Fe }), [ze, Be, Ie, Me, De, Pe, Fe]); return jsxRuntimeExports.jsx(SidebarContext.Provider, { value: qe, children: jsxRuntimeExports.jsx(TooltipProvider, { delayDuration: 0, children: jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-wrapper", style: { "--sidebar-width": SIDEBAR_WIDTH, "--sidebar-width-icon": SIDEBAR_WIDTH_ICON, ..._e }, className: cn$1("group/sidebar-wrapper has-data-[variant=inset]:bg-sidebar flex min-h-svh w-full", Ee), ...Ce, children: Re }) }) }) } function Sidebar({ side: e = "left", variant: t = "sidebar", collapsible: xe = "offcanvas", className: Ee, children: _e, ...Re }) { const { isMobile: Ce, state: Me, openMobile: De, setOpenMobile: Pe } = useSidebar(); return xe === "none" ? jsxRuntimeExports.jsx("div", { "data-slot": "sidebar", className: cn$1("bg-sidebar text-sidebar-foreground flex h-full w-(--sidebar-width) flex-col", Ee), ...Re, children: _e }) : Ce ? jsxRuntimeExports.jsx(Sheet, { open: De, onOpenChange: Pe, ...Re, children: jsxRuntimeExports.jsxs(SheetContent, { "data-sidebar": "sidebar", "data-slot": "sidebar", "data-mobile": "true", className: "bg-sidebar text-sidebar-foreground w-(--sidebar-width) p-0 [&>button]:hidden", style: { "--sidebar-width": SIDEBAR_WIDTH_MOBILE }, side: e, children: [jsxRuntimeExports.jsxs(SheetHeader, { className: "sr-only", children: [jsxRuntimeExports.jsx(SheetTitle, { children: "Sidebar" }), jsxRuntimeExports.jsx(SheetDescription, { children: "Displays the mobile sidebar." })] }), jsxRuntimeExports.jsx("div", { className: "flex h-full w-full flex-col", children: _e })] }) }) : jsxRuntimeExports.jsxs("div", { className: "group peer text-sidebar-foreground hidden md:block", "data-state": Me, "data-collapsible": Me === "collapsed" ? xe : "", "data-variant": t, "data-side": e, "data-slot": "sidebar", children: [jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-gap", className: cn$1("relative w-(--sidebar-width) bg-transparent transition-[width] duration-200 ease-linear", "group-data-[collapsible=offcanvas]:w-0", "group-data-[side=right]:rotate-180", t === "floating" || t === "inset" ? "group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4)))]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon)") }), jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-container", className: cn$1("fixed inset-y-0 z-10 hidden h-svh w-(--sidebar-width) transition-[left,right,width] duration-200 ease-linear md:flex", e === "left" ? "left-0 group-data-[collapsible=offcanvas]:left-[calc(var(--sidebar-width)*-1)]" : "right-0 group-data-[collapsible=offcanvas]:right-[calc(var(--sidebar-width)*-1)]", t === "floating" || t === "inset" ? "p-2 group-data-[collapsible=icon]:w-[calc(var(--sidebar-width-icon)+(--spacing(4))+2px)]" : "group-data-[collapsible=icon]:w-(--sidebar-width-icon) group-data-[side=left]:border-r group-data-[side=right]:border-l", Ee), ...Re, children: jsxRuntimeExports.jsx("div", { "data-sidebar": "sidebar", "data-slot": "sidebar-inner", className: "bg-sidebar group-data-[variant=floating]:border-sidebar-border flex h-full w-full flex-col group-data-[variant=floating]:rounded-lg group-data-[variant=floating]:border group-data-[variant=floating]:shadow-sm", children: _e }) })] }) } function SidebarTrigger({ className: e, onClick: t, ...xe }) { const { toggleSidebar: Ee } = useSidebar(); return jsxRuntimeExports.jsxs(Button, { "data-sidebar": "trigger", "data-slot": "sidebar-trigger", variant: "ghost", size: "icon", className: cn$1("size-7", e), onClick: _e => { t?.(_e), Ee() }, ...xe, children: [jsxRuntimeExports.jsx(PanelLeft, {}), jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Toggle Sidebar" })] }) } function SidebarContent({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-content", "data-sidebar": "content", className: cn$1("flex min-h-0 flex-1 flex-col gap-2 overflow-auto group-data-[collapsible=icon]:overflow-hidden", e), ...t }) } function SidebarGroup({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-group", "data-sidebar": "group", className: cn$1("relative flex w-full min-w-0 flex-col p-2", e), ...t }) } function SidebarGroupLabel({ className: e, asChild: t = !1, ...xe }) { const Ee = t ? Slot$3 : "div"; return jsxRuntimeExports.jsx(Ee, { "data-slot": "sidebar-group-label", "data-sidebar": "group-label", className: cn$1("text-sidebar-foreground/70 ring-sidebar-ring flex h-8 shrink-0 items-center rounded-md px-2 text-xs font-medium outline-hidden transition-[margin,opacity] duration-200 ease-linear focus-visible:ring-2 [&>svg]:size-4 [&>svg]:shrink-0", "group-data-[collapsible=icon]:-mt-8 group-data-[collapsible=icon]:opacity-0", e), ...xe }) } function SidebarGroupContent({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "sidebar-group-content", "data-sidebar": "group-content", className: cn$1("w-full text-sm", e), ...t }) } function SidebarMenu({ className: e, ...t }) { return jsxRuntimeExports.jsx("ul", { "data-slot": "sidebar-menu", "data-sidebar": "menu", className: cn$1("flex w-full min-w-0 flex-col gap-1", e), ...t }) } function SidebarMenuItem({ className: e, ...t }) { return jsxRuntimeExports.jsx("li", { "data-slot": "sidebar-menu-item", "data-sidebar": "menu-item", className: cn$1("group/menu-item relative", e), ...t }) } const sidebarMenuButtonVariants = cva("peer/menu-button flex w-full items-center gap-2 overflow-hidden rounded-md p-2 text-left text-sm outline-hidden ring-sidebar-ring transition-[width,height,padding] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground focus-visible:ring-2 active:bg-sidebar-accent active:text-sidebar-accent-foreground disabled:pointer-events-none disabled:opacity-50 group-has-data-[sidebar=menu-action]/menu-item:pr-8 aria-disabled:pointer-events-none aria-disabled:opacity-50 data-[active=true]:bg-sidebar-accent data-[active=true]:font-medium data-[active=true]:text-sidebar-accent-foreground data-[state=open]:hover:bg-sidebar-accent data-[state=open]:hover:text-sidebar-accent-foreground group-data-[collapsible=icon]:size-8! group-data-[collapsible=icon]:p-2! [&>span:last-child]:truncate [&>svg]:size-4 [&>svg]:shrink-0", { variants: { variant: { default: "hover:bg-sidebar-accent hover:text-sidebar-accent-foreground", outline: "bg-background shadow-[0_0_0_1px_hsl(var(--sidebar-border))] hover:bg-sidebar-accent hover:text-sidebar-accent-foreground hover:shadow-[0_0_0_1px_hsl(var(--sidebar-accent))]" }, size: { default: "h-8 text-sm", sm: "h-7 text-xs", lg: "h-12 text-sm group-data-[collapsible=icon]:p-0!" } }, defaultVariants: { variant: "default", size: "default" } }); function SidebarMenuButton({ asChild: e = !1, isActive: t = !1, variant: xe = "default", size: Ee = "default", tooltip: _e, className: Re, ...Ce }) { const Me = e ? Slot$3 : "button", { isMobile: De, state: Pe } = useSidebar(), Oe = jsxRuntimeExports.jsx(Me, { "data-slot": "sidebar-menu-button", "data-sidebar": "menu-button", "data-size": Ee, "data-active": t, className: cn$1(sidebarMenuButtonVariants({ variant: xe, size: Ee }), Re), ...Ce }); return _e ? (typeof _e == "string" && (_e = { children: _e }), jsxRuntimeExports.jsxs(Tooltip, { children: [jsxRuntimeExports.jsx(TooltipTrigger, { asChild: !0, children: Oe }), jsxRuntimeExports.jsx(TooltipContent, { side: "right", align: "center", hidden: Pe !== "collapsed" || De, ..._e })] })) : Oe } const items$1 = [{ title: "Scan Document", url: "/scanner/scan", icon: Scan }, { title: "Scanned Documents", url: "/scanner/docs", icon: Inbox }]; function AppSidebar$1() { return jsxRuntimeExports.jsx(Sidebar, { className: "mt-16", children: jsxRuntimeExports.jsx(SidebarContent, { children: jsxRuntimeExports.jsxs(SidebarGroup, { children: [jsxRuntimeExports.jsx(SidebarGroupLabel, { children: "Application" }), jsxRuntimeExports.jsx(SidebarGroupContent, { children: jsxRuntimeExports.jsx(SidebarMenu, { children: items$1.map(e => jsxRuntimeExports.jsx(SidebarMenuItem, { children: jsxRuntimeExports.jsx(SidebarMenuButton, { asChild: !0, children: jsxRuntimeExports.jsxs("a", { href: e.url, children: [jsxRuntimeExports.jsx(e.icon, {}), jsxRuntimeExports.jsx("span", { children: e.title })] }) }) }, e.title)) }) })] }) }) }) } const ScannerDashboard = () => jsxRuntimeExports.jsx("div", { className: "mt-8", children: jsxRuntimeExports.jsxs(SidebarProvider, { children: [jsxRuntimeExports.jsx(AppSidebar$1, {}), jsxRuntimeExports.jsx(SidebarTrigger, {}), jsxRuntimeExports.jsx(Outlet, {})] }) }), ScannerPage = () => jsxRuntimeExports.jsx(ProtectedRoute, { roles: ["ScannerClerk"], children: jsxRuntimeExports.jsx(ScannerDashboard, {}) }); function Card({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "card", className: cn$1("bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm", e), ...t }) } function CardHeader({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "card-header", className: cn$1("@container/card-header grid auto-rows-min grid-rows-[auto_auto] items-start gap-1.5 px-6 has-data-[slot=card-action]:grid-cols-[1fr_auto] [.border-b]:pb-6", e), ...t }) } function CardTitle({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "card-title", className: cn$1("leading-none font-semibold", e), ...t }) } function CardContent({ className: e, ...t }) { return jsxRuntimeExports.jsx("div", { "data-slot": "card-content", className: cn$1("px-6", e), ...t }) } function Unauthorized() { return jsxRuntimeExports.jsx("div", { className: "flex items-center justify-center min-h-screen bg-gray-100", children: jsxRuntimeExports.jsxs(Card, { className: "w-full max-w-md", children: [jsxRuntimeExports.jsx(CardHeader, { children: jsxRuntimeExports.jsxs(CardTitle, { className: "text-2xl flex items-center gap-2", children: [jsxRuntimeExports.jsx(CircleAlert, { className: "h-6 w-6 text-red-500" }), "Unauthorized Access"] }) }), jsxRuntimeExports.jsxs(CardContent, { children: [jsxRuntimeExports.jsx("p", { className: "text-gray-600 mb-4", children: "You are not authorized to view this page." }), jsxRuntimeExports.jsx(Button, { asChild: !0, children: jsxRuntimeExports.jsx(Link, { to: "/", children: "Go to Homepage" }) })] })] }) }) } var reactWebcam$1 = { exports: {} }, reactWebcam = reactWebcam$1.exports, hasRequiredReactWebcam; function requireReactWebcam() { return hasRequiredReactWebcam || (hasRequiredReactWebcam = 1, function (e, t) { (function (Ee, _e) { e.exports = _e(requireReact()) })(reactWebcam, function (xe) { return function (Ee) { var _e = {}; function Re(Ce) { if (_e[Ce]) return _e[Ce].exports; var Me = _e[Ce] = { i: Ce, l: !1, exports: {} }; return Ee[Ce].call(Me.exports, Me, Me.exports, Re), Me.l = !0, Me.exports } return Re.m = Ee, Re.c = _e, Re.d = function (Ce, Me, De) { Re.o(Ce, Me) || Object.defineProperty(Ce, Me, { enumerable: !0, get: De }) }, Re.r = function (Ce) { typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(Ce, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(Ce, "__esModule", { value: !0 }) }, Re.t = function (Ce, Me) { if (Me & 1 && (Ce = Re(Ce)), Me & 8 || Me & 4 && typeof Ce == "object" && Ce && Ce.__esModule) return Ce; var De = Object.create(null); if (Re.r(De), Object.defineProperty(De, "default", { enumerable: !0, value: Ce }), Me & 2 && typeof Ce != "string") for (var Pe in Ce) Re.d(De, Pe, (function (Oe) { return Ce[Oe] }).bind(null, Pe)); return De }, Re.n = function (Ce) { var Me = Ce && Ce.__esModule ? function () { return Ce.default } : function () { return Ce }; return Re.d(Me, "a", Me), Me }, Re.o = function (Ce, Me) { return Object.prototype.hasOwnProperty.call(Ce, Me) }, Re.p = "", Re(Re.s = "./src/react-webcam.tsx") }({ "./src/react-webcam.tsx": function (Ee, _e, Re) { Re.r(_e); var Ce = Re("react"), Me = function () { var Be = function (Ie, Fe) { return Be = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function (ze, qe) { ze.__proto__ = qe } || function (ze, qe) { for (var He in qe) qe.hasOwnProperty(He) && (ze[He] = qe[He]) }, Be(Ie, Fe) }; return function (Ie, Fe) { Be(Ie, Fe); function ze() { this.constructor = Ie } Ie.prototype = Fe === null ? Object.create(Fe) : (ze.prototype = Fe.prototype, new ze) } }(), De = function () { return De = Object.assign || function (Be) { for (var Ie, Fe = 1, ze = arguments.length; Fe < ze; Fe++) { Ie = arguments[Fe]; for (var qe in Ie) Object.prototype.hasOwnProperty.call(Ie, qe) && (Be[qe] = Ie[qe]) } return Be }, De.apply(this, arguments) }, Pe = function (Be, Ie) { var Fe = {}; for (var ze in Be) Object.prototype.hasOwnProperty.call(Be, ze) && Ie.indexOf(ze) < 0 && (Fe[ze] = Be[ze]); if (Be != null && typeof Object.getOwnPropertySymbols == "function") for (var qe = 0, ze = Object.getOwnPropertySymbols(Be); qe < ze.length; qe++)Ie.indexOf(ze[qe]) < 0 && Object.prototype.propertyIsEnumerable.call(Be, ze[qe]) && (Fe[ze[qe]] = Be[ze[qe]]); return Fe }; (function () { typeof window > "u" || (navigator.mediaDevices === void 0 && (navigator.mediaDevices = {}), navigator.mediaDevices.getUserMedia === void 0 && (navigator.mediaDevices.getUserMedia = function (Ie) { var Fe = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia; return Fe ? new Promise(function (ze, qe) { Fe.call(navigator, Ie, ze, qe) }) : Promise.reject(new Error("getUserMedia is not implemented in this browser")) })) })(); function Oe() { return !!(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) } var je = function (Be) { Me(Ie, Be); function Ie(Fe) { var ze = Be.call(this, Fe) || this; return ze.canvas = null, ze.ctx = null, ze.requestUserMediaId = 0, ze.unmounted = !1, ze.state = { hasUserMedia: !1 }, ze } return Ie.prototype.componentDidMount = function () { var Fe = this, ze = Fe.state, qe = Fe.props; if (this.unmounted = !1, !Oe()) { qe.onUserMediaError("getUserMedia not supported"); return } ze.hasUserMedia || this.requestUserMedia(), qe.children && typeof qe.children != "function" && console.warn("children must be a function") }, Ie.prototype.componentDidUpdate = function (Fe) { var ze = this.props; if (!Oe()) { ze.onUserMediaError("getUserMedia not supported"); return } var qe = JSON.stringify(Fe.audioConstraints) !== JSON.stringify(ze.audioConstraints), He = JSON.stringify(Fe.videoConstraints) !== JSON.stringify(ze.videoConstraints), Ge = Fe.minScreenshotWidth !== ze.minScreenshotWidth, Ze = Fe.minScreenshotHeight !== ze.minScreenshotHeight; (He || Ge || Ze) && (this.canvas = null, this.ctx = null), (qe || He) && (this.stopAndCleanup(), this.requestUserMedia()) }, Ie.prototype.componentWillUnmount = function () { this.unmounted = !0, this.stopAndCleanup() }, Ie.stopMediaStream = function (Fe) { Fe && (Fe.getVideoTracks && Fe.getAudioTracks ? (Fe.getVideoTracks().map(function (ze) { Fe.removeTrack(ze), ze.stop() }), Fe.getAudioTracks().map(function (ze) { Fe.removeTrack(ze), ze.stop() })) : Fe.stop()) }, Ie.prototype.stopAndCleanup = function () { var Fe = this.state; Fe.hasUserMedia && (Ie.stopMediaStream(this.stream), Fe.src && window.URL.revokeObjectURL(Fe.src)) }, Ie.prototype.getScreenshot = function (Fe) { var ze = this, qe = ze.state, He = ze.props; if (!qe.hasUserMedia) return null; var Ge = this.getCanvas(Fe); return Ge && Ge.toDataURL(He.screenshotFormat, He.screenshotQuality) }, Ie.prototype.getCanvas = function (Fe) { var ze = this, qe = ze.state, He = ze.props; if (!this.video || !qe.hasUserMedia || !this.video.videoHeight) return null; if (!this.ctx) { var Ge = this.video.videoWidth, Ze = this.video.videoHeight; if (!this.props.forceScreenshotSourceSize) { var sn = Ge / Ze; Ge = He.minScreenshotWidth || this.video.clientWidth, Ze = Ge / sn, He.minScreenshotHeight && Ze < He.minScreenshotHeight && (Ze = He.minScreenshotHeight, Ge = Ze * sn) } this.canvas = document.createElement("canvas"), this.canvas.width = Fe?.width || Ge, this.canvas.height = Fe?.height || Ze, this.ctx = this.canvas.getContext("2d") } var Xe = this, St = Xe.ctx, un = Xe.canvas; return St && un && (un.width = Fe?.width || un.width, un.height = Fe?.height || un.height, He.mirrored && (St.translate(un.width, 0), St.scale(-1, 1)), St.imageSmoothingEnabled = He.imageSmoothing, St.drawImage(this.video, 0, 0, Fe?.width || un.width, Fe?.height || un.height), He.mirrored && (St.scale(-1, 1), St.translate(-un.width, 0))), un }, Ie.prototype.requestUserMedia = function () { var Fe = this, ze = this.props, qe = function (Ze, sn) { var Xe = { video: typeof sn < "u" ? sn : !0 }; ze.audio && (Xe.audio = typeof Ze < "u" ? Ze : !0), Fe.requestUserMediaId++; var St = Fe.requestUserMediaId; navigator.mediaDevices.getUserMedia(Xe).then(function (un) { Fe.unmounted || St !== Fe.requestUserMediaId ? Ie.stopMediaStream(un) : Fe.handleUserMedia(null, un) }).catch(function (un) { Fe.handleUserMedia(un) }) }; if ("mediaDevices" in navigator) qe(ze.audioConstraints, ze.videoConstraints); else { var He = function (Ze) { return { optional: [{ sourceId: Ze }] } }, Ge = function (Ze) { var sn = Ze.deviceId; return typeof sn == "string" ? sn : Array.isArray(sn) && sn.length > 0 ? sn[0] : typeof sn == "object" && sn.ideal ? sn.ideal : null }; MediaStreamTrack.getSources(function (Ze) { var sn = null, Xe = null; Ze.forEach(function (on) { on.kind === "audio" ? sn = on.id : on.kind === "video" && (Xe = on.id) }); var St = Ge(ze.audioConstraints); St && (sn = St); var un = Ge(ze.videoConstraints); un && (Xe = un), qe(He(sn), He(Xe)) }) } }, Ie.prototype.handleUserMedia = function (Fe, ze) { var qe = this.props; if (Fe || !ze) { this.setState({ hasUserMedia: !1 }), qe.onUserMediaError(Fe); return } this.stream = ze; try { this.video && (this.video.srcObject = ze), this.setState({ hasUserMedia: !0 }) } catch { this.setState({ hasUserMedia: !0, src: window.URL.createObjectURL(ze) }) } qe.onUserMedia(ze) }, Ie.prototype.render = function () { var Fe = this, ze = this, qe = ze.state, He = ze.props, Ge = He.audio; He.forceScreenshotSourceSize; var Ze = He.disablePictureInPicture; He.onUserMedia, He.onUserMediaError, He.screenshotFormat, He.screenshotQuality, He.minScreenshotWidth, He.minScreenshotHeight, He.audioConstraints, He.videoConstraints, He.imageSmoothing; var sn = He.mirrored, Xe = He.style, St = Xe === void 0 ? {} : Xe, un = He.children, on = Pe(He, ["audio", "forceScreenshotSourceSize", "disablePictureInPicture", "onUserMedia", "onUserMediaError", "screenshotFormat", "screenshotQuality", "minScreenshotWidth", "minScreenshotHeight", "audioConstraints", "videoConstraints", "imageSmoothing", "mirrored", "style", "children"]), bn = sn ? De(De({}, St), { transform: (St.transform || "") + " scaleX(-1)" }) : St, Tn = { getScreenshot: this.getScreenshot.bind(this) }; return Ce.createElement(Ce.Fragment, null, Ce.createElement("video", De({ autoPlay: !0, disablePictureInPicture: Ze, src: qe.src, muted: !Ge, playsInline: !0, ref: function (fn) { Fe.video = fn }, style: bn }, on)), un && un(Tn)) }, Ie.defaultProps = { audio: !1, disablePictureInPicture: !1, forceScreenshotSourceSize: !1, imageSmoothing: !0, mirrored: !1, onUserMedia: function () { }, onUserMediaError: function () { }, screenshotFormat: "image/webp", screenshotQuality: .92 }, Ie }(Ce.Component); _e.default = je }, react: function (Ee, _e) { Ee.exports = xe } }).default }) }(reactWebcam$1)), reactWebcam$1.exports } var reactWebcamExports = requireReactWebcam(); const Webcam = getDefaultExportFromCjs(reactWebcamExports);/*!
 * Cropper.js v1.6.2
 * https://fengyuanchen.github.io/cropperjs
 *
 * Copyright 2015-present Chen Fengyuan
 * Released under the MIT license
 *
 * Date: 2024-04-21T07:43:05.335Z
 */function ownKeys(e, t) { var xe = Object.keys(e); if (Object.getOwnPropertySymbols) { var Ee = Object.getOwnPropertySymbols(e); t && (Ee = Ee.filter(function (_e) { return Object.getOwnPropertyDescriptor(e, _e).enumerable })), xe.push.apply(xe, Ee) } return xe } function _objectSpread2(e) { for (var t = 1; t < arguments.length; t++) { var xe = arguments[t] != null ? arguments[t] : {}; t % 2 ? ownKeys(Object(xe), !0).forEach(function (Ee) { _defineProperty(e, Ee, xe[Ee]) }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(xe)) : ownKeys(Object(xe)).forEach(function (Ee) { Object.defineProperty(e, Ee, Object.getOwnPropertyDescriptor(xe, Ee)) }) } return e } function _toPrimitive(e, t) { if (typeof e != "object" || !e) return e; var xe = e[Symbol.toPrimitive]; if (xe !== void 0) { var Ee = xe.call(e, t); if (typeof Ee != "object") return Ee; throw new TypeError("@@toPrimitive must return a primitive value.") } return String(e) } function _toPropertyKey(e) { var t = _toPrimitive(e, "string"); return typeof t == "symbol" ? t : t + "" } function _typeof$1(e) { "@babel/helpers - typeof"; return _typeof$1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof$1(e) } function _classCallCheck(e, t) { if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function") } function _defineProperties(e, t) { for (var xe = 0; xe < t.length; xe++) { var Ee = t[xe]; Ee.enumerable = Ee.enumerable || !1, Ee.configurable = !0, "value" in Ee && (Ee.writable = !0), Object.defineProperty(e, _toPropertyKey(Ee.key), Ee) } } function _createClass(e, t, xe) { return t && _defineProperties(e.prototype, t), xe && _defineProperties(e, xe), Object.defineProperty(e, "prototype", { writable: !1 }), e } function _defineProperty(e, t, xe) { return t = _toPropertyKey(t), t in e ? Object.defineProperty(e, t, { value: xe, enumerable: !0, configurable: !0, writable: !0 }) : e[t] = xe, e } function _toConsumableArray(e) { return _arrayWithoutHoles(e) || _iterableToArray(e) || _unsupportedIterableToArray(e) || _nonIterableSpread() } function _arrayWithoutHoles(e) { if (Array.isArray(e)) return _arrayLikeToArray(e) } function _iterableToArray(e) { if (typeof Symbol < "u" && e[Symbol.iterator] != null || e["@@iterator"] != null) return Array.from(e) } function _unsupportedIterableToArray(e, t) { if (e) { if (typeof e == "string") return _arrayLikeToArray(e, t); var xe = Object.prototype.toString.call(e).slice(8, -1); if (xe === "Object" && e.constructor && (xe = e.constructor.name), xe === "Map" || xe === "Set") return Array.from(e); if (xe === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(xe)) return _arrayLikeToArray(e, t) } } function _arrayLikeToArray(e, t) { (t == null || t > e.length) && (t = e.length); for (var xe = 0, Ee = new Array(t); xe < t; xe++)Ee[xe] = e[xe]; return Ee } function _nonIterableSpread() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`)
} var IS_BROWSER = typeof window < "u" && typeof window.document < "u", WINDOW = IS_BROWSER ? window : {}, IS_TOUCH_DEVICE = IS_BROWSER && WINDOW.document.documentElement ? "ontouchstart" in WINDOW.document.documentElement : !1, HAS_POINTER_EVENT = IS_BROWSER ? "PointerEvent" in WINDOW : !1, NAMESPACE = "cropper", ACTION_ALL = "all", ACTION_CROP = "crop", ACTION_MOVE = "move", ACTION_ZOOM = "zoom", ACTION_EAST = "e", ACTION_WEST = "w", ACTION_SOUTH = "s", ACTION_NORTH = "n", ACTION_NORTH_EAST = "ne", ACTION_NORTH_WEST = "nw", ACTION_SOUTH_EAST = "se", ACTION_SOUTH_WEST = "sw", CLASS_CROP = "".concat(NAMESPACE, "-crop"), CLASS_DISABLED = "".concat(NAMESPACE, "-disabled"), CLASS_HIDDEN = "".concat(NAMESPACE, "-hidden"), CLASS_HIDE = "".concat(NAMESPACE, "-hide"), CLASS_INVISIBLE = "".concat(NAMESPACE, "-invisible"), CLASS_MODAL = "".concat(NAMESPACE, "-modal"), CLASS_MOVE = "".concat(NAMESPACE, "-move"), DATA_ACTION = "".concat(NAMESPACE, "Action"), DATA_PREVIEW = "".concat(NAMESPACE, "Preview"), DRAG_MODE_CROP = "crop", DRAG_MODE_MOVE = "move", DRAG_MODE_NONE = "none", EVENT_CROP = "crop", EVENT_CROP_END = "cropend", EVENT_CROP_MOVE = "cropmove", EVENT_CROP_START = "cropstart", EVENT_DBLCLICK = "dblclick", EVENT_TOUCH_START = IS_TOUCH_DEVICE ? "touchstart" : "mousedown", EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? "touchmove" : "mousemove", EVENT_TOUCH_END = IS_TOUCH_DEVICE ? "touchend touchcancel" : "mouseup", EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? "pointerdown" : EVENT_TOUCH_START, EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? "pointermove" : EVENT_TOUCH_MOVE, EVENT_POINTER_UP = HAS_POINTER_EVENT ? "pointerup pointercancel" : EVENT_TOUCH_END, EVENT_READY = "ready", EVENT_RESIZE = "resize", EVENT_WHEEL = "wheel", EVENT_ZOOM = "zoom", MIME_TYPE_JPEG = "image/jpeg", REGEXP_ACTIONS = /^e|w|s|n|se|sw|ne|nw|all|crop|move|zoom$/, REGEXP_DATA_URL = /^data:/, REGEXP_DATA_URL_JPEG = /^data:image\/jpeg;base64,/, REGEXP_TAG_NAME = /^img|canvas$/i, MIN_CONTAINER_WIDTH = 200, MIN_CONTAINER_HEIGHT = 100, DEFAULTS = { viewMode: 0, dragMode: DRAG_MODE_CROP, initialAspectRatio: NaN, aspectRatio: NaN, data: null, preview: "", responsive: !0, restore: !0, checkCrossOrigin: !0, checkOrientation: !0, modal: !0, guides: !0, center: !0, highlight: !0, background: !0, autoCrop: !0, autoCropArea: .8, movable: !0, rotatable: !0, scalable: !0, zoomable: !0, zoomOnTouch: !0, zoomOnWheel: !0, wheelZoomRatio: .1, cropBoxMovable: !0, cropBoxResizable: !0, toggleDragModeOnDblclick: !0, minCanvasWidth: 0, minCanvasHeight: 0, minCropBoxWidth: 0, minCropBoxHeight: 0, minContainerWidth: MIN_CONTAINER_WIDTH, minContainerHeight: MIN_CONTAINER_HEIGHT, ready: null, cropstart: null, cropmove: null, cropend: null, crop: null, zoom: null }, TEMPLATE = '<div class="cropper-container" touch-action="none"><div class="cropper-wrap-box"><div class="cropper-canvas"></div></div><div class="cropper-drag-box"></div><div class="cropper-crop-box"><span class="cropper-view-box"></span><span class="cropper-dashed dashed-h"></span><span class="cropper-dashed dashed-v"></span><span class="cropper-center"></span><span class="cropper-face"></span><span class="cropper-line line-e" data-cropper-action="e"></span><span class="cropper-line line-n" data-cropper-action="n"></span><span class="cropper-line line-w" data-cropper-action="w"></span><span class="cropper-line line-s" data-cropper-action="s"></span><span class="cropper-point point-e" data-cropper-action="e"></span><span class="cropper-point point-n" data-cropper-action="n"></span><span class="cropper-point point-w" data-cropper-action="w"></span><span class="cropper-point point-s" data-cropper-action="s"></span><span class="cropper-point point-ne" data-cropper-action="ne"></span><span class="cropper-point point-nw" data-cropper-action="nw"></span><span class="cropper-point point-sw" data-cropper-action="sw"></span><span class="cropper-point point-se" data-cropper-action="se"></span></div></div>', isNaN$1 = Number.isNaN || WINDOW.isNaN; function isNumber(e) { return typeof e == "number" && !isNaN$1(e) } var isPositiveNumber = function (t) { return t > 0 && t < 1 / 0 }; function isUndefined(e) { return typeof e > "u" } function isObject(e) { return _typeof$1(e) === "object" && e !== null } var hasOwnProperty = Object.prototype.hasOwnProperty; function isPlainObject(e) { if (!isObject(e)) return !1; try { var t = e.constructor, xe = t.prototype; return t && xe && hasOwnProperty.call(xe, "isPrototypeOf") } catch { return !1 } } function isFunction(e) { return typeof e == "function" } var slice = Array.prototype.slice; function toArray(e) { return Array.from ? Array.from(e) : slice.call(e) } function forEach(e, t) { return e && isFunction(t) && (Array.isArray(e) || isNumber(e.length) ? toArray(e).forEach(function (xe, Ee) { t.call(e, xe, Ee, e) }) : isObject(e) && Object.keys(e).forEach(function (xe) { t.call(e, e[xe], xe, e) })), e } var assign = Object.assign || function (t) { for (var xe = arguments.length, Ee = new Array(xe > 1 ? xe - 1 : 0), _e = 1; _e < xe; _e++)Ee[_e - 1] = arguments[_e]; return isObject(t) && Ee.length > 0 && Ee.forEach(function (Re) { isObject(Re) && Object.keys(Re).forEach(function (Ce) { t[Ce] = Re[Ce] }) }), t }, REGEXP_DECIMALS = /\.\d*(?:0|9){12}\d*$/; function normalizeDecimalNumber(e) { var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1e11; return REGEXP_DECIMALS.test(e) ? Math.round(e * t) / t : e } var REGEXP_SUFFIX = /^width|height|left|top|marginLeft|marginTop$/; function setStyle(e, t) { var xe = e.style; forEach(t, function (Ee, _e) { REGEXP_SUFFIX.test(_e) && isNumber(Ee) && (Ee = "".concat(Ee, "px")), xe[_e] = Ee }) } function hasClass(e, t) { return e.classList ? e.classList.contains(t) : e.className.indexOf(t) > -1 } function addClass(e, t) { if (t) { if (isNumber(e.length)) { forEach(e, function (Ee) { addClass(Ee, t) }); return } if (e.classList) { e.classList.add(t); return } var xe = e.className.trim(); xe ? xe.indexOf(t) < 0 && (e.className = "".concat(xe, " ").concat(t)) : e.className = t } } function removeClass(e, t) { if (t) { if (isNumber(e.length)) { forEach(e, function (xe) { removeClass(xe, t) }); return } if (e.classList) { e.classList.remove(t); return } e.className.indexOf(t) >= 0 && (e.className = e.className.replace(t, "")) } } function toggleClass(e, t, xe) { if (t) { if (isNumber(e.length)) { forEach(e, function (Ee) { toggleClass(Ee, t, xe) }); return } xe ? addClass(e, t) : removeClass(e, t) } } var REGEXP_CAMEL_CASE = /([a-z\d])([A-Z])/g; function toParamCase(e) { return e.replace(REGEXP_CAMEL_CASE, "$1-$2").toLowerCase() } function getData(e, t) { return isObject(e[t]) ? e[t] : e.dataset ? e.dataset[t] : e.getAttribute("data-".concat(toParamCase(t))) } function setData(e, t, xe) { isObject(xe) ? e[t] = xe : e.dataset ? e.dataset[t] = xe : e.setAttribute("data-".concat(toParamCase(t)), xe) } function removeData(e, t) { if (isObject(e[t])) try { delete e[t] } catch { e[t] = void 0 } else if (e.dataset) try { delete e.dataset[t] } catch { e.dataset[t] = void 0 } else e.removeAttribute("data-".concat(toParamCase(t))) } var REGEXP_SPACES = /\s\s*/, onceSupported = function () { var e = !1; if (IS_BROWSER) { var t = !1, xe = function () { }, Ee = Object.defineProperty({}, "once", { get: function () { return e = !0, t }, set: function (Re) { t = Re } }); WINDOW.addEventListener("test", xe, Ee), WINDOW.removeEventListener("test", xe, Ee) } return e }(); function removeListener(e, t, xe) { var Ee = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, _e = xe; t.trim().split(REGEXP_SPACES).forEach(function (Re) { if (!onceSupported) { var Ce = e.listeners; Ce && Ce[Re] && Ce[Re][xe] && (_e = Ce[Re][xe], delete Ce[Re][xe], Object.keys(Ce[Re]).length === 0 && delete Ce[Re], Object.keys(Ce).length === 0 && delete e.listeners) } e.removeEventListener(Re, _e, Ee) }) } function addListener(e, t, xe) { var Ee = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, _e = xe; t.trim().split(REGEXP_SPACES).forEach(function (Re) { if (Ee.once && !onceSupported) { var Ce = e.listeners, Me = Ce === void 0 ? {} : Ce; _e = function () { delete Me[Re][xe], e.removeEventListener(Re, _e, Ee); for (var Pe = arguments.length, Oe = new Array(Pe), je = 0; je < Pe; je++)Oe[je] = arguments[je]; xe.apply(e, Oe) }, Me[Re] || (Me[Re] = {}), Me[Re][xe] && e.removeEventListener(Re, Me[Re][xe], Ee), Me[Re][xe] = _e, e.listeners = Me } e.addEventListener(Re, _e, Ee) }) } function dispatchEvent(e, t, xe) { var Ee; return isFunction(Event) && isFunction(CustomEvent) ? Ee = new CustomEvent(t, { detail: xe, bubbles: !0, cancelable: !0 }) : (Ee = document.createEvent("CustomEvent"), Ee.initCustomEvent(t, !0, !0, xe)), e.dispatchEvent(Ee) } function getOffset(e) { var t = e.getBoundingClientRect(); return { left: t.left + (window.pageXOffset - document.documentElement.clientLeft), top: t.top + (window.pageYOffset - document.documentElement.clientTop) } } var location$1 = WINDOW.location, REGEXP_ORIGINS = /^(\w+:)\/\/([^:/?#]*):?(\d*)/i; function isCrossOriginURL(e) { var t = e.match(REGEXP_ORIGINS); return t !== null && (t[1] !== location$1.protocol || t[2] !== location$1.hostname || t[3] !== location$1.port) } function addTimestamp(e) { var t = "timestamp=".concat(new Date().getTime()); return e + (e.indexOf("?") === -1 ? "?" : "&") + t } function getTransforms(e) { var t = e.rotate, xe = e.scaleX, Ee = e.scaleY, _e = e.translateX, Re = e.translateY, Ce = []; isNumber(_e) && _e !== 0 && Ce.push("translateX(".concat(_e, "px)")), isNumber(Re) && Re !== 0 && Ce.push("translateY(".concat(Re, "px)")), isNumber(t) && t !== 0 && Ce.push("rotate(".concat(t, "deg)")), isNumber(xe) && xe !== 1 && Ce.push("scaleX(".concat(xe, ")")), isNumber(Ee) && Ee !== 1 && Ce.push("scaleY(".concat(Ee, ")")); var Me = Ce.length ? Ce.join(" ") : "none"; return { WebkitTransform: Me, msTransform: Me, transform: Me } } function getMaxZoomRatio(e) { var t = _objectSpread2({}, e), xe = 0; return forEach(e, function (Ee, _e) { delete t[_e], forEach(t, function (Re) { var Ce = Math.abs(Ee.startX - Re.startX), Me = Math.abs(Ee.startY - Re.startY), De = Math.abs(Ee.endX - Re.endX), Pe = Math.abs(Ee.endY - Re.endY), Oe = Math.sqrt(Ce * Ce + Me * Me), je = Math.sqrt(De * De + Pe * Pe), Be = (je - Oe) / Oe; Math.abs(Be) > Math.abs(xe) && (xe = Be) }) }), xe } function getPointer(e, t) { var xe = e.pageX, Ee = e.pageY, _e = { endX: xe, endY: Ee }; return t ? _e : _objectSpread2({ startX: xe, startY: Ee }, _e) } function getPointersCenter(e) { var t = 0, xe = 0, Ee = 0; return forEach(e, function (_e) { var Re = _e.startX, Ce = _e.startY; t += Re, xe += Ce, Ee += 1 }), t /= Ee, xe /= Ee, { pageX: t, pageY: xe } } function getAdjustedSizes(e) { var t = e.aspectRatio, xe = e.height, Ee = e.width, _e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "contain", Re = isPositiveNumber(Ee), Ce = isPositiveNumber(xe); if (Re && Ce) { var Me = xe * t; _e === "contain" && Me > Ee || _e === "cover" && Me < Ee ? xe = Ee / t : Ee = xe * t } else Re ? xe = Ee / t : Ce && (Ee = xe * t); return { width: Ee, height: xe } } function getRotatedSizes(e) { var t = e.width, xe = e.height, Ee = e.degree; if (Ee = Math.abs(Ee) % 180, Ee === 90) return { width: xe, height: t }; var _e = Ee % 90 * Math.PI / 180, Re = Math.sin(_e), Ce = Math.cos(_e), Me = t * Ce + xe * Re, De = t * Re + xe * Ce; return Ee > 90 ? { width: De, height: Me } : { width: Me, height: De } } function getSourceCanvas(e, t, xe, Ee) { var _e = t.aspectRatio, Re = t.naturalWidth, Ce = t.naturalHeight, Me = t.rotate, De = Me === void 0 ? 0 : Me, Pe = t.scaleX, Oe = Pe === void 0 ? 1 : Pe, je = t.scaleY, Be = je === void 0 ? 1 : je, Ie = xe.aspectRatio, Fe = xe.naturalWidth, ze = xe.naturalHeight, qe = Ee.fillColor, He = qe === void 0 ? "transparent" : qe, Ge = Ee.imageSmoothingEnabled, Ze = Ge === void 0 ? !0 : Ge, sn = Ee.imageSmoothingQuality, Xe = sn === void 0 ? "low" : sn, St = Ee.maxWidth, un = St === void 0 ? 1 / 0 : St, on = Ee.maxHeight, bn = on === void 0 ? 1 / 0 : on, Tn = Ee.minWidth, fn = Tn === void 0 ? 0 : Tn, En = Ee.minHeight, Pn = En === void 0 ? 0 : En, Rn = document.createElement("canvas"), In = Rn.getContext("2d"), xn = getAdjustedSizes({ aspectRatio: Ie, width: un, height: bn }), vn = getAdjustedSizes({ aspectRatio: Ie, width: fn, height: Pn }, "cover"), tn = Math.min(xn.width, Math.max(vn.width, Fe)), nn = Math.min(xn.height, Math.max(vn.height, ze)), We = getAdjustedSizes({ aspectRatio: _e, width: un, height: bn }), dn = getAdjustedSizes({ aspectRatio: _e, width: fn, height: Pn }, "cover"), Je = Math.min(We.width, Math.max(dn.width, Re)), rn = Math.min(We.height, Math.max(dn.height, Ce)), hn = [-Je / 2, -rn / 2, Je, rn]; return Rn.width = normalizeDecimalNumber(tn), Rn.height = normalizeDecimalNumber(nn), In.fillStyle = He, In.fillRect(0, 0, tn, nn), In.save(), In.translate(tn / 2, nn / 2), In.rotate(De * Math.PI / 180), In.scale(Oe, Be), In.imageSmoothingEnabled = Ze, In.imageSmoothingQuality = Xe, In.drawImage.apply(In, [e].concat(_toConsumableArray(hn.map(function (mn) { return Math.floor(normalizeDecimalNumber(mn)) })))), In.restore(), Rn } var fromCharCode = String.fromCharCode; function getStringFromCharCode(e, t, xe) { var Ee = ""; xe += t; for (var _e = t; _e < xe; _e += 1)Ee += fromCharCode(e.getUint8(_e)); return Ee } var REGEXP_DATA_URL_HEAD = /^data:.*,/; function dataURLToArrayBuffer(e) { var t = e.replace(REGEXP_DATA_URL_HEAD, ""), xe = atob(t), Ee = new ArrayBuffer(xe.length), _e = new Uint8Array(Ee); return forEach(_e, function (Re, Ce) { _e[Ce] = xe.charCodeAt(Ce) }), Ee } function arrayBufferToDataURL(e, t) { for (var xe = [], Ee = 8192, _e = new Uint8Array(e); _e.length > 0;)xe.push(fromCharCode.apply(null, toArray(_e.subarray(0, Ee)))), _e = _e.subarray(Ee); return "data:".concat(t, ";base64,").concat(btoa(xe.join(""))) } function resetAndGetOrientation(e) { var t = new DataView(e), xe; try { var Ee, _e, Re; if (t.getUint8(0) === 255 && t.getUint8(1) === 216) for (var Ce = t.byteLength, Me = 2; Me + 1 < Ce;) { if (t.getUint8(Me) === 255 && t.getUint8(Me + 1) === 225) { _e = Me; break } Me += 1 } if (_e) { var De = _e + 4, Pe = _e + 10; if (getStringFromCharCode(t, De, 4) === "Exif") { var Oe = t.getUint16(Pe); if (Ee = Oe === 18761, (Ee || Oe === 19789) && t.getUint16(Pe + 2, Ee) === 42) { var je = t.getUint32(Pe + 4, Ee); je >= 8 && (Re = Pe + je) } } } if (Re) { var Be = t.getUint16(Re, Ee), Ie, Fe; for (Fe = 0; Fe < Be; Fe += 1)if (Ie = Re + Fe * 12 + 2, t.getUint16(Ie, Ee) === 274) { Ie += 8, xe = t.getUint16(Ie, Ee), t.setUint16(Ie, 1, Ee); break } } } catch { xe = 1 } return xe } function parseOrientation(e) { var t = 0, xe = 1, Ee = 1; switch (e) { case 2: xe = -1; break; case 3: t = -180; break; case 4: Ee = -1; break; case 5: t = 90, Ee = -1; break; case 6: t = 90; break; case 7: t = 90, xe = -1; break; case 8: t = -90; break }return { rotate: t, scaleX: xe, scaleY: Ee } } var render = { render: function () { this.initContainer(), this.initCanvas(), this.initCropBox(), this.renderCanvas(), this.cropped && this.renderCropBox() }, initContainer: function () { var t = this.element, xe = this.options, Ee = this.container, _e = this.cropper, Re = Number(xe.minContainerWidth), Ce = Number(xe.minContainerHeight); addClass(_e, CLASS_HIDDEN), removeClass(t, CLASS_HIDDEN); var Me = { width: Math.max(Ee.offsetWidth, Re >= 0 ? Re : MIN_CONTAINER_WIDTH), height: Math.max(Ee.offsetHeight, Ce >= 0 ? Ce : MIN_CONTAINER_HEIGHT) }; this.containerData = Me, setStyle(_e, { width: Me.width, height: Me.height }), addClass(t, CLASS_HIDDEN), removeClass(_e, CLASS_HIDDEN) }, initCanvas: function () { var t = this.containerData, xe = this.imageData, Ee = this.options.viewMode, _e = Math.abs(xe.rotate) % 180 === 90, Re = _e ? xe.naturalHeight : xe.naturalWidth, Ce = _e ? xe.naturalWidth : xe.naturalHeight, Me = Re / Ce, De = t.width, Pe = t.height; t.height * Me > t.width ? Ee === 3 ? De = t.height * Me : Pe = t.width / Me : Ee === 3 ? Pe = t.width / Me : De = t.height * Me; var Oe = { aspectRatio: Me, naturalWidth: Re, naturalHeight: Ce, width: De, height: Pe }; this.canvasData = Oe, this.limited = Ee === 1 || Ee === 2, this.limitCanvas(!0, !0), Oe.width = Math.min(Math.max(Oe.width, Oe.minWidth), Oe.maxWidth), Oe.height = Math.min(Math.max(Oe.height, Oe.minHeight), Oe.maxHeight), Oe.left = (t.width - Oe.width) / 2, Oe.top = (t.height - Oe.height) / 2, Oe.oldLeft = Oe.left, Oe.oldTop = Oe.top, this.initialCanvasData = assign({}, Oe) }, limitCanvas: function (t, xe) { var Ee = this.options, _e = this.containerData, Re = this.canvasData, Ce = this.cropBoxData, Me = Ee.viewMode, De = Re.aspectRatio, Pe = this.cropped && Ce; if (t) { var Oe = Number(Ee.minCanvasWidth) || 0, je = Number(Ee.minCanvasHeight) || 0; Me > 1 ? (Oe = Math.max(Oe, _e.width), je = Math.max(je, _e.height), Me === 3 && (je * De > Oe ? Oe = je * De : je = Oe / De)) : Me > 0 && (Oe ? Oe = Math.max(Oe, Pe ? Ce.width : 0) : je ? je = Math.max(je, Pe ? Ce.height : 0) : Pe && (Oe = Ce.width, je = Ce.height, je * De > Oe ? Oe = je * De : je = Oe / De)); var Be = getAdjustedSizes({ aspectRatio: De, width: Oe, height: je }); Oe = Be.width, je = Be.height, Re.minWidth = Oe, Re.minHeight = je, Re.maxWidth = 1 / 0, Re.maxHeight = 1 / 0 } if (xe) if (Me > (Pe ? 0 : 1)) { var Ie = _e.width - Re.width, Fe = _e.height - Re.height; Re.minLeft = Math.min(0, Ie), Re.minTop = Math.min(0, Fe), Re.maxLeft = Math.max(0, Ie), Re.maxTop = Math.max(0, Fe), Pe && this.limited && (Re.minLeft = Math.min(Ce.left, Ce.left + (Ce.width - Re.width)), Re.minTop = Math.min(Ce.top, Ce.top + (Ce.height - Re.height)), Re.maxLeft = Ce.left, Re.maxTop = Ce.top, Me === 2 && (Re.width >= _e.width && (Re.minLeft = Math.min(0, Ie), Re.maxLeft = Math.max(0, Ie)), Re.height >= _e.height && (Re.minTop = Math.min(0, Fe), Re.maxTop = Math.max(0, Fe)))) } else Re.minLeft = -Re.width, Re.minTop = -Re.height, Re.maxLeft = _e.width, Re.maxTop = _e.height }, renderCanvas: function (t, xe) { var Ee = this.canvasData, _e = this.imageData; if (xe) { var Re = getRotatedSizes({ width: _e.naturalWidth * Math.abs(_e.scaleX || 1), height: _e.naturalHeight * Math.abs(_e.scaleY || 1), degree: _e.rotate || 0 }), Ce = Re.width, Me = Re.height, De = Ee.width * (Ce / Ee.naturalWidth), Pe = Ee.height * (Me / Ee.naturalHeight); Ee.left -= (De - Ee.width) / 2, Ee.top -= (Pe - Ee.height) / 2, Ee.width = De, Ee.height = Pe, Ee.aspectRatio = Ce / Me, Ee.naturalWidth = Ce, Ee.naturalHeight = Me, this.limitCanvas(!0, !1) } (Ee.width > Ee.maxWidth || Ee.width < Ee.minWidth) && (Ee.left = Ee.oldLeft), (Ee.height > Ee.maxHeight || Ee.height < Ee.minHeight) && (Ee.top = Ee.oldTop), Ee.width = Math.min(Math.max(Ee.width, Ee.minWidth), Ee.maxWidth), Ee.height = Math.min(Math.max(Ee.height, Ee.minHeight), Ee.maxHeight), this.limitCanvas(!1, !0), Ee.left = Math.min(Math.max(Ee.left, Ee.minLeft), Ee.maxLeft), Ee.top = Math.min(Math.max(Ee.top, Ee.minTop), Ee.maxTop), Ee.oldLeft = Ee.left, Ee.oldTop = Ee.top, setStyle(this.canvas, assign({ width: Ee.width, height: Ee.height }, getTransforms({ translateX: Ee.left, translateY: Ee.top }))), this.renderImage(t), this.cropped && this.limited && this.limitCropBox(!0, !0) }, renderImage: function (t) { var xe = this.canvasData, Ee = this.imageData, _e = Ee.naturalWidth * (xe.width / xe.naturalWidth), Re = Ee.naturalHeight * (xe.height / xe.naturalHeight); assign(Ee, { width: _e, height: Re, left: (xe.width - _e) / 2, top: (xe.height - Re) / 2 }), setStyle(this.image, assign({ width: Ee.width, height: Ee.height }, getTransforms(assign({ translateX: Ee.left, translateY: Ee.top }, Ee)))), t && this.output() }, initCropBox: function () { var t = this.options, xe = this.canvasData, Ee = t.aspectRatio || t.initialAspectRatio, _e = Number(t.autoCropArea) || .8, Re = { width: xe.width, height: xe.height }; Ee && (xe.height * Ee > xe.width ? Re.height = Re.width / Ee : Re.width = Re.height * Ee), this.cropBoxData = Re, this.limitCropBox(!0, !0), Re.width = Math.min(Math.max(Re.width, Re.minWidth), Re.maxWidth), Re.height = Math.min(Math.max(Re.height, Re.minHeight), Re.maxHeight), Re.width = Math.max(Re.minWidth, Re.width * _e), Re.height = Math.max(Re.minHeight, Re.height * _e), Re.left = xe.left + (xe.width - Re.width) / 2, Re.top = xe.top + (xe.height - Re.height) / 2, Re.oldLeft = Re.left, Re.oldTop = Re.top, this.initialCropBoxData = assign({}, Re) }, limitCropBox: function (t, xe) { var Ee = this.options, _e = this.containerData, Re = this.canvasData, Ce = this.cropBoxData, Me = this.limited, De = Ee.aspectRatio; if (t) { var Pe = Number(Ee.minCropBoxWidth) || 0, Oe = Number(Ee.minCropBoxHeight) || 0, je = Me ? Math.min(_e.width, Re.width, Re.width + Re.left, _e.width - Re.left) : _e.width, Be = Me ? Math.min(_e.height, Re.height, Re.height + Re.top, _e.height - Re.top) : _e.height; Pe = Math.min(Pe, _e.width), Oe = Math.min(Oe, _e.height), De && (Pe && Oe ? Oe * De > Pe ? Oe = Pe / De : Pe = Oe * De : Pe ? Oe = Pe / De : Oe && (Pe = Oe * De), Be * De > je ? Be = je / De : je = Be * De), Ce.minWidth = Math.min(Pe, je), Ce.minHeight = Math.min(Oe, Be), Ce.maxWidth = je, Ce.maxHeight = Be } xe && (Me ? (Ce.minLeft = Math.max(0, Re.left), Ce.minTop = Math.max(0, Re.top), Ce.maxLeft = Math.min(_e.width, Re.left + Re.width) - Ce.width, Ce.maxTop = Math.min(_e.height, Re.top + Re.height) - Ce.height) : (Ce.minLeft = 0, Ce.minTop = 0, Ce.maxLeft = _e.width - Ce.width, Ce.maxTop = _e.height - Ce.height)) }, renderCropBox: function () { var t = this.options, xe = this.containerData, Ee = this.cropBoxData; (Ee.width > Ee.maxWidth || Ee.width < Ee.minWidth) && (Ee.left = Ee.oldLeft), (Ee.height > Ee.maxHeight || Ee.height < Ee.minHeight) && (Ee.top = Ee.oldTop), Ee.width = Math.min(Math.max(Ee.width, Ee.minWidth), Ee.maxWidth), Ee.height = Math.min(Math.max(Ee.height, Ee.minHeight), Ee.maxHeight), this.limitCropBox(!1, !0), Ee.left = Math.min(Math.max(Ee.left, Ee.minLeft), Ee.maxLeft), Ee.top = Math.min(Math.max(Ee.top, Ee.minTop), Ee.maxTop), Ee.oldLeft = Ee.left, Ee.oldTop = Ee.top, t.movable && t.cropBoxMovable && setData(this.face, DATA_ACTION, Ee.width >= xe.width && Ee.height >= xe.height ? ACTION_MOVE : ACTION_ALL), setStyle(this.cropBox, assign({ width: Ee.width, height: Ee.height }, getTransforms({ translateX: Ee.left, translateY: Ee.top }))), this.cropped && this.limited && this.limitCanvas(!0, !0), this.disabled || this.output() }, output: function () { this.preview(), dispatchEvent(this.element, EVENT_CROP, this.getData()) } }, preview = { initPreview: function () { var t = this.element, xe = this.crossOrigin, Ee = this.options.preview, _e = xe ? this.crossOriginUrl : this.url, Re = t.alt || "The image to preview", Ce = document.createElement("img"); if (xe && (Ce.crossOrigin = xe), Ce.src = _e, Ce.alt = Re, this.viewBox.appendChild(Ce), this.viewBoxImage = Ce, !!Ee) { var Me = Ee; typeof Ee == "string" ? Me = t.ownerDocument.querySelectorAll(Ee) : Ee.querySelector && (Me = [Ee]), this.previews = Me, forEach(Me, function (De) { var Pe = document.createElement("img"); setData(De, DATA_PREVIEW, { width: De.offsetWidth, height: De.offsetHeight, html: De.innerHTML }), xe && (Pe.crossOrigin = xe), Pe.src = _e, Pe.alt = Re, Pe.style.cssText = 'display:block;width:100%;height:auto;min-width:0!important;min-height:0!important;max-width:none!important;max-height:none!important;image-orientation:0deg!important;"', De.innerHTML = "", De.appendChild(Pe) }) } }, resetPreview: function () { forEach(this.previews, function (t) { var xe = getData(t, DATA_PREVIEW); setStyle(t, { width: xe.width, height: xe.height }), t.innerHTML = xe.html, removeData(t, DATA_PREVIEW) }) }, preview: function () { var t = this.imageData, xe = this.canvasData, Ee = this.cropBoxData, _e = Ee.width, Re = Ee.height, Ce = t.width, Me = t.height, De = Ee.left - xe.left - t.left, Pe = Ee.top - xe.top - t.top; !this.cropped || this.disabled || (setStyle(this.viewBoxImage, assign({ width: Ce, height: Me }, getTransforms(assign({ translateX: -De, translateY: -Pe }, t)))), forEach(this.previews, function (Oe) { var je = getData(Oe, DATA_PREVIEW), Be = je.width, Ie = je.height, Fe = Be, ze = Ie, qe = 1; _e && (qe = Be / _e, ze = Re * qe), Re && ze > Ie && (qe = Ie / Re, Fe = _e * qe, ze = Ie), setStyle(Oe, { width: Fe, height: ze }), setStyle(Oe.getElementsByTagName("img")[0], assign({ width: Ce * qe, height: Me * qe }, getTransforms(assign({ translateX: -De * qe, translateY: -Pe * qe }, t)))) })) } }, events = { bind: function () { var t = this.element, xe = this.options, Ee = this.cropper; isFunction(xe.cropstart) && addListener(t, EVENT_CROP_START, xe.cropstart), isFunction(xe.cropmove) && addListener(t, EVENT_CROP_MOVE, xe.cropmove), isFunction(xe.cropend) && addListener(t, EVENT_CROP_END, xe.cropend), isFunction(xe.crop) && addListener(t, EVENT_CROP, xe.crop), isFunction(xe.zoom) && addListener(t, EVENT_ZOOM, xe.zoom), addListener(Ee, EVENT_POINTER_DOWN, this.onCropStart = this.cropStart.bind(this)), xe.zoomable && xe.zoomOnWheel && addListener(Ee, EVENT_WHEEL, this.onWheel = this.wheel.bind(this), { passive: !1, capture: !0 }), xe.toggleDragModeOnDblclick && addListener(Ee, EVENT_DBLCLICK, this.onDblclick = this.dblclick.bind(this)), addListener(t.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove = this.cropMove.bind(this)), addListener(t.ownerDocument, EVENT_POINTER_UP, this.onCropEnd = this.cropEnd.bind(this)), xe.responsive && addListener(window, EVENT_RESIZE, this.onResize = this.resize.bind(this)) }, unbind: function () { var t = this.element, xe = this.options, Ee = this.cropper; isFunction(xe.cropstart) && removeListener(t, EVENT_CROP_START, xe.cropstart), isFunction(xe.cropmove) && removeListener(t, EVENT_CROP_MOVE, xe.cropmove), isFunction(xe.cropend) && removeListener(t, EVENT_CROP_END, xe.cropend), isFunction(xe.crop) && removeListener(t, EVENT_CROP, xe.crop), isFunction(xe.zoom) && removeListener(t, EVENT_ZOOM, xe.zoom), removeListener(Ee, EVENT_POINTER_DOWN, this.onCropStart), xe.zoomable && xe.zoomOnWheel && removeListener(Ee, EVENT_WHEEL, this.onWheel, { passive: !1, capture: !0 }), xe.toggleDragModeOnDblclick && removeListener(Ee, EVENT_DBLCLICK, this.onDblclick), removeListener(t.ownerDocument, EVENT_POINTER_MOVE, this.onCropMove), removeListener(t.ownerDocument, EVENT_POINTER_UP, this.onCropEnd), xe.responsive && removeListener(window, EVENT_RESIZE, this.onResize) } }, handlers = { resize: function () { if (!this.disabled) { var t = this.options, xe = this.container, Ee = this.containerData, _e = xe.offsetWidth / Ee.width, Re = xe.offsetHeight / Ee.height, Ce = Math.abs(_e - 1) > Math.abs(Re - 1) ? _e : Re; if (Ce !== 1) { var Me, De; t.restore && (Me = this.getCanvasData(), De = this.getCropBoxData()), this.render(), t.restore && (this.setCanvasData(forEach(Me, function (Pe, Oe) { Me[Oe] = Pe * Ce })), this.setCropBoxData(forEach(De, function (Pe, Oe) { De[Oe] = Pe * Ce }))) } } }, dblclick: function () { this.disabled || this.options.dragMode === DRAG_MODE_NONE || this.setDragMode(hasClass(this.dragBox, CLASS_CROP) ? DRAG_MODE_MOVE : DRAG_MODE_CROP) }, wheel: function (t) { var xe = this, Ee = Number(this.options.wheelZoomRatio) || .1, _e = 1; this.disabled || (t.preventDefault(), !this.wheeling && (this.wheeling = !0, setTimeout(function () { xe.wheeling = !1 }, 50), t.deltaY ? _e = t.deltaY > 0 ? 1 : -1 : t.wheelDelta ? _e = -t.wheelDelta / 120 : t.detail && (_e = t.detail > 0 ? 1 : -1), this.zoom(-_e * Ee, t))) }, cropStart: function (t) { var xe = t.buttons, Ee = t.button; if (!(this.disabled || (t.type === "mousedown" || t.type === "pointerdown" && t.pointerType === "mouse") && (isNumber(xe) && xe !== 1 || isNumber(Ee) && Ee !== 0 || t.ctrlKey))) { var _e = this.options, Re = this.pointers, Ce; t.changedTouches ? forEach(t.changedTouches, function (Me) { Re[Me.identifier] = getPointer(Me) }) : Re[t.pointerId || 0] = getPointer(t), Object.keys(Re).length > 1 && _e.zoomable && _e.zoomOnTouch ? Ce = ACTION_ZOOM : Ce = getData(t.target, DATA_ACTION), REGEXP_ACTIONS.test(Ce) && dispatchEvent(this.element, EVENT_CROP_START, { originalEvent: t, action: Ce }) !== !1 && (t.preventDefault(), this.action = Ce, this.cropping = !1, Ce === ACTION_CROP && (this.cropping = !0, addClass(this.dragBox, CLASS_MODAL))) } }, cropMove: function (t) { var xe = this.action; if (!(this.disabled || !xe)) { var Ee = this.pointers; t.preventDefault(), dispatchEvent(this.element, EVENT_CROP_MOVE, { originalEvent: t, action: xe }) !== !1 && (t.changedTouches ? forEach(t.changedTouches, function (_e) { assign(Ee[_e.identifier] || {}, getPointer(_e, !0)) }) : assign(Ee[t.pointerId || 0] || {}, getPointer(t, !0)), this.change(t)) } }, cropEnd: function (t) { if (!this.disabled) { var xe = this.action, Ee = this.pointers; t.changedTouches ? forEach(t.changedTouches, function (_e) { delete Ee[_e.identifier] }) : delete Ee[t.pointerId || 0], xe && (t.preventDefault(), Object.keys(Ee).length || (this.action = ""), this.cropping && (this.cropping = !1, toggleClass(this.dragBox, CLASS_MODAL, this.cropped && this.options.modal)), dispatchEvent(this.element, EVENT_CROP_END, { originalEvent: t, action: xe })) } } }, change = { change: function (t) { var xe = this.options, Ee = this.canvasData, _e = this.containerData, Re = this.cropBoxData, Ce = this.pointers, Me = this.action, De = xe.aspectRatio, Pe = Re.left, Oe = Re.top, je = Re.width, Be = Re.height, Ie = Pe + je, Fe = Oe + Be, ze = 0, qe = 0, He = _e.width, Ge = _e.height, Ze = !0, sn; !De && t.shiftKey && (De = je && Be ? je / Be : 1), this.limited && (ze = Re.minLeft, qe = Re.minTop, He = ze + Math.min(_e.width, Ee.width, Ee.left + Ee.width), Ge = qe + Math.min(_e.height, Ee.height, Ee.top + Ee.height)); var Xe = Ce[Object.keys(Ce)[0]], St = { x: Xe.endX - Xe.startX, y: Xe.endY - Xe.startY }, un = function (bn) { switch (bn) { case ACTION_EAST: Ie + St.x > He && (St.x = He - Ie); break; case ACTION_WEST: Pe + St.x < ze && (St.x = ze - Pe); break; case ACTION_NORTH: Oe + St.y < qe && (St.y = qe - Oe); break; case ACTION_SOUTH: Fe + St.y > Ge && (St.y = Ge - Fe); break } }; switch (Me) { case ACTION_ALL: Pe += St.x, Oe += St.y; break; case ACTION_EAST: if (St.x >= 0 && (Ie >= He || De && (Oe <= qe || Fe >= Ge))) { Ze = !1; break } un(ACTION_EAST), je += St.x, je < 0 && (Me = ACTION_WEST, je = -je, Pe -= je), De && (Be = je / De, Oe += (Re.height - Be) / 2); break; case ACTION_NORTH: if (St.y <= 0 && (Oe <= qe || De && (Pe <= ze || Ie >= He))) { Ze = !1; break } un(ACTION_NORTH), Be -= St.y, Oe += St.y, Be < 0 && (Me = ACTION_SOUTH, Be = -Be, Oe -= Be), De && (je = Be * De, Pe += (Re.width - je) / 2); break; case ACTION_WEST: if (St.x <= 0 && (Pe <= ze || De && (Oe <= qe || Fe >= Ge))) { Ze = !1; break } un(ACTION_WEST), je -= St.x, Pe += St.x, je < 0 && (Me = ACTION_EAST, je = -je, Pe -= je), De && (Be = je / De, Oe += (Re.height - Be) / 2); break; case ACTION_SOUTH: if (St.y >= 0 && (Fe >= Ge || De && (Pe <= ze || Ie >= He))) { Ze = !1; break } un(ACTION_SOUTH), Be += St.y, Be < 0 && (Me = ACTION_NORTH, Be = -Be, Oe -= Be), De && (je = Be * De, Pe += (Re.width - je) / 2); break; case ACTION_NORTH_EAST: if (De) { if (St.y <= 0 && (Oe <= qe || Ie >= He)) { Ze = !1; break } un(ACTION_NORTH), Be -= St.y, Oe += St.y, je = Be * De } else un(ACTION_NORTH), un(ACTION_EAST), St.x >= 0 ? Ie < He ? je += St.x : St.y <= 0 && Oe <= qe && (Ze = !1) : je += St.x, St.y <= 0 ? Oe > qe && (Be -= St.y, Oe += St.y) : (Be -= St.y, Oe += St.y); je < 0 && Be < 0 ? (Me = ACTION_SOUTH_WEST, Be = -Be, je = -je, Oe -= Be, Pe -= je) : je < 0 ? (Me = ACTION_NORTH_WEST, je = -je, Pe -= je) : Be < 0 && (Me = ACTION_SOUTH_EAST, Be = -Be, Oe -= Be); break; case ACTION_NORTH_WEST: if (De) { if (St.y <= 0 && (Oe <= qe || Pe <= ze)) { Ze = !1; break } un(ACTION_NORTH), Be -= St.y, Oe += St.y, je = Be * De, Pe += Re.width - je } else un(ACTION_NORTH), un(ACTION_WEST), St.x <= 0 ? Pe > ze ? (je -= St.x, Pe += St.x) : St.y <= 0 && Oe <= qe && (Ze = !1) : (je -= St.x, Pe += St.x), St.y <= 0 ? Oe > qe && (Be -= St.y, Oe += St.y) : (Be -= St.y, Oe += St.y); je < 0 && Be < 0 ? (Me = ACTION_SOUTH_EAST, Be = -Be, je = -je, Oe -= Be, Pe -= je) : je < 0 ? (Me = ACTION_NORTH_EAST, je = -je, Pe -= je) : Be < 0 && (Me = ACTION_SOUTH_WEST, Be = -Be, Oe -= Be); break; case ACTION_SOUTH_WEST: if (De) { if (St.x <= 0 && (Pe <= ze || Fe >= Ge)) { Ze = !1; break } un(ACTION_WEST), je -= St.x, Pe += St.x, Be = je / De } else un(ACTION_SOUTH), un(ACTION_WEST), St.x <= 0 ? Pe > ze ? (je -= St.x, Pe += St.x) : St.y >= 0 && Fe >= Ge && (Ze = !1) : (je -= St.x, Pe += St.x), St.y >= 0 ? Fe < Ge && (Be += St.y) : Be += St.y; je < 0 && Be < 0 ? (Me = ACTION_NORTH_EAST, Be = -Be, je = -je, Oe -= Be, Pe -= je) : je < 0 ? (Me = ACTION_SOUTH_EAST, je = -je, Pe -= je) : Be < 0 && (Me = ACTION_NORTH_WEST, Be = -Be, Oe -= Be); break; case ACTION_SOUTH_EAST: if (De) { if (St.x >= 0 && (Ie >= He || Fe >= Ge)) { Ze = !1; break } un(ACTION_EAST), je += St.x, Be = je / De } else un(ACTION_SOUTH), un(ACTION_EAST), St.x >= 0 ? Ie < He ? je += St.x : St.y >= 0 && Fe >= Ge && (Ze = !1) : je += St.x, St.y >= 0 ? Fe < Ge && (Be += St.y) : Be += St.y; je < 0 && Be < 0 ? (Me = ACTION_NORTH_WEST, Be = -Be, je = -je, Oe -= Be, Pe -= je) : je < 0 ? (Me = ACTION_SOUTH_WEST, je = -je, Pe -= je) : Be < 0 && (Me = ACTION_NORTH_EAST, Be = -Be, Oe -= Be); break; case ACTION_MOVE: this.move(St.x, St.y), Ze = !1; break; case ACTION_ZOOM: this.zoom(getMaxZoomRatio(Ce), t), Ze = !1; break; case ACTION_CROP: if (!St.x || !St.y) { Ze = !1; break } sn = getOffset(this.cropper), Pe = Xe.startX - sn.left, Oe = Xe.startY - sn.top, je = Re.minWidth, Be = Re.minHeight, St.x > 0 ? Me = St.y > 0 ? ACTION_SOUTH_EAST : ACTION_NORTH_EAST : St.x < 0 && (Pe -= je, Me = St.y > 0 ? ACTION_SOUTH_WEST : ACTION_NORTH_WEST), St.y < 0 && (Oe -= Be), this.cropped || (removeClass(this.cropBox, CLASS_HIDDEN), this.cropped = !0, this.limited && this.limitCropBox(!0, !0)); break }Ze && (Re.width = je, Re.height = Be, Re.left = Pe, Re.top = Oe, this.action = Me, this.renderCropBox()), forEach(Ce, function (on) { on.startX = on.endX, on.startY = on.endY }) } }, methods = { crop: function () { return this.ready && !this.cropped && !this.disabled && (this.cropped = !0, this.limitCropBox(!0, !0), this.options.modal && addClass(this.dragBox, CLASS_MODAL), removeClass(this.cropBox, CLASS_HIDDEN), this.setCropBoxData(this.initialCropBoxData)), this }, reset: function () { return this.ready && !this.disabled && (this.imageData = assign({}, this.initialImageData), this.canvasData = assign({}, this.initialCanvasData), this.cropBoxData = assign({}, this.initialCropBoxData), this.renderCanvas(), this.cropped && this.renderCropBox()), this }, clear: function () { return this.cropped && !this.disabled && (assign(this.cropBoxData, { left: 0, top: 0, width: 0, height: 0 }), this.cropped = !1, this.renderCropBox(), this.limitCanvas(!0, !0), this.renderCanvas(), removeClass(this.dragBox, CLASS_MODAL), addClass(this.cropBox, CLASS_HIDDEN)), this }, replace: function (t) { var xe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1; return !this.disabled && t && (this.isImg && (this.element.src = t), xe ? (this.url = t, this.image.src = t, this.ready && (this.viewBoxImage.src = t, forEach(this.previews, function (Ee) { Ee.getElementsByTagName("img")[0].src = t }))) : (this.isImg && (this.replaced = !0), this.options.data = null, this.uncreate(), this.load(t))), this }, enable: function () { return this.ready && this.disabled && (this.disabled = !1, removeClass(this.cropper, CLASS_DISABLED)), this }, disable: function () { return this.ready && !this.disabled && (this.disabled = !0, addClass(this.cropper, CLASS_DISABLED)), this }, destroy: function () { var t = this.element; return t[NAMESPACE] ? (t[NAMESPACE] = void 0, this.isImg && this.replaced && (t.src = this.originalUrl), this.uncreate(), this) : this }, move: function (t) { var xe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, Ee = this.canvasData, _e = Ee.left, Re = Ee.top; return this.moveTo(isUndefined(t) ? t : _e + Number(t), isUndefined(xe) ? xe : Re + Number(xe)) }, moveTo: function (t) { var xe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, Ee = this.canvasData, _e = !1; return t = Number(t), xe = Number(xe), this.ready && !this.disabled && this.options.movable && (isNumber(t) && (Ee.left = t, _e = !0), isNumber(xe) && (Ee.top = xe, _e = !0), _e && this.renderCanvas(!0)), this }, zoom: function (t, xe) { var Ee = this.canvasData; return t = Number(t), t < 0 ? t = 1 / (1 - t) : t = 1 + t, this.zoomTo(Ee.width * t / Ee.naturalWidth, null, xe) }, zoomTo: function (t, xe, Ee) { var _e = this.options, Re = this.canvasData, Ce = Re.width, Me = Re.height, De = Re.naturalWidth, Pe = Re.naturalHeight; if (t = Number(t), t >= 0 && this.ready && !this.disabled && _e.zoomable) { var Oe = De * t, je = Pe * t; if (dispatchEvent(this.element, EVENT_ZOOM, { ratio: t, oldRatio: Ce / De, originalEvent: Ee }) === !1) return this; if (Ee) { var Be = this.pointers, Ie = getOffset(this.cropper), Fe = Be && Object.keys(Be).length ? getPointersCenter(Be) : { pageX: Ee.pageX, pageY: Ee.pageY }; Re.left -= (Oe - Ce) * ((Fe.pageX - Ie.left - Re.left) / Ce), Re.top -= (je - Me) * ((Fe.pageY - Ie.top - Re.top) / Me) } else isPlainObject(xe) && isNumber(xe.x) && isNumber(xe.y) ? (Re.left -= (Oe - Ce) * ((xe.x - Re.left) / Ce), Re.top -= (je - Me) * ((xe.y - Re.top) / Me)) : (Re.left -= (Oe - Ce) / 2, Re.top -= (je - Me) / 2); Re.width = Oe, Re.height = je, this.renderCanvas(!0) } return this }, rotate: function (t) { return this.rotateTo((this.imageData.rotate || 0) + Number(t)) }, rotateTo: function (t) { return t = Number(t), isNumber(t) && this.ready && !this.disabled && this.options.rotatable && (this.imageData.rotate = t % 360, this.renderCanvas(!0, !0)), this }, scaleX: function (t) { var xe = this.imageData.scaleY; return this.scale(t, isNumber(xe) ? xe : 1) }, scaleY: function (t) { var xe = this.imageData.scaleX; return this.scale(isNumber(xe) ? xe : 1, t) }, scale: function (t) { var xe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : t, Ee = this.imageData, _e = !1; return t = Number(t), xe = Number(xe), this.ready && !this.disabled && this.options.scalable && (isNumber(t) && (Ee.scaleX = t, _e = !0), isNumber(xe) && (Ee.scaleY = xe, _e = !0), _e && this.renderCanvas(!0, !0)), this }, getData: function () { var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, xe = this.options, Ee = this.imageData, _e = this.canvasData, Re = this.cropBoxData, Ce; if (this.ready && this.cropped) { Ce = { x: Re.left - _e.left, y: Re.top - _e.top, width: Re.width, height: Re.height }; var Me = Ee.width / Ee.naturalWidth; if (forEach(Ce, function (Oe, je) { Ce[je] = Oe / Me }), t) { var De = Math.round(Ce.y + Ce.height), Pe = Math.round(Ce.x + Ce.width); Ce.x = Math.round(Ce.x), Ce.y = Math.round(Ce.y), Ce.width = Pe - Ce.x, Ce.height = De - Ce.y } } else Ce = { x: 0, y: 0, width: 0, height: 0 }; return xe.rotatable && (Ce.rotate = Ee.rotate || 0), xe.scalable && (Ce.scaleX = Ee.scaleX || 1, Ce.scaleY = Ee.scaleY || 1), Ce }, setData: function (t) { var xe = this.options, Ee = this.imageData, _e = this.canvasData, Re = {}; if (this.ready && !this.disabled && isPlainObject(t)) { var Ce = !1; xe.rotatable && isNumber(t.rotate) && t.rotate !== Ee.rotate && (Ee.rotate = t.rotate, Ce = !0), xe.scalable && (isNumber(t.scaleX) && t.scaleX !== Ee.scaleX && (Ee.scaleX = t.scaleX, Ce = !0), isNumber(t.scaleY) && t.scaleY !== Ee.scaleY && (Ee.scaleY = t.scaleY, Ce = !0)), Ce && this.renderCanvas(!0, !0); var Me = Ee.width / Ee.naturalWidth; isNumber(t.x) && (Re.left = t.x * Me + _e.left), isNumber(t.y) && (Re.top = t.y * Me + _e.top), isNumber(t.width) && (Re.width = t.width * Me), isNumber(t.height) && (Re.height = t.height * Me), this.setCropBoxData(Re) } return this }, getContainerData: function () { return this.ready ? assign({}, this.containerData) : {} }, getImageData: function () { return this.sized ? assign({}, this.imageData) : {} }, getCanvasData: function () { var t = this.canvasData, xe = {}; return this.ready && forEach(["left", "top", "width", "height", "naturalWidth", "naturalHeight"], function (Ee) { xe[Ee] = t[Ee] }), xe }, setCanvasData: function (t) { var xe = this.canvasData, Ee = xe.aspectRatio; return this.ready && !this.disabled && isPlainObject(t) && (isNumber(t.left) && (xe.left = t.left), isNumber(t.top) && (xe.top = t.top), isNumber(t.width) ? (xe.width = t.width, xe.height = t.width / Ee) : isNumber(t.height) && (xe.height = t.height, xe.width = t.height * Ee), this.renderCanvas(!0)), this }, getCropBoxData: function () { var t = this.cropBoxData, xe; return this.ready && this.cropped && (xe = { left: t.left, top: t.top, width: t.width, height: t.height }), xe || {} }, setCropBoxData: function (t) { var xe = this.cropBoxData, Ee = this.options.aspectRatio, _e, Re; return this.ready && this.cropped && !this.disabled && isPlainObject(t) && (isNumber(t.left) && (xe.left = t.left), isNumber(t.top) && (xe.top = t.top), isNumber(t.width) && t.width !== xe.width && (_e = !0, xe.width = t.width), isNumber(t.height) && t.height !== xe.height && (Re = !0, xe.height = t.height), Ee && (_e ? xe.height = xe.width / Ee : Re && (xe.width = xe.height * Ee)), this.renderCropBox()), this }, getCroppedCanvas: function () { var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}; if (!this.ready || !window.HTMLCanvasElement) return null; var xe = this.canvasData, Ee = getSourceCanvas(this.image, this.imageData, xe, t); if (!this.cropped) return Ee; var _e = this.getData(t.rounded), Re = _e.x, Ce = _e.y, Me = _e.width, De = _e.height, Pe = Ee.width / Math.floor(xe.naturalWidth); Pe !== 1 && (Re *= Pe, Ce *= Pe, Me *= Pe, De *= Pe); var Oe = Me / De, je = getAdjustedSizes({ aspectRatio: Oe, width: t.maxWidth || 1 / 0, height: t.maxHeight || 1 / 0 }), Be = getAdjustedSizes({ aspectRatio: Oe, width: t.minWidth || 0, height: t.minHeight || 0 }, "cover"), Ie = getAdjustedSizes({ aspectRatio: Oe, width: t.width || (Pe !== 1 ? Ee.width : Me), height: t.height || (Pe !== 1 ? Ee.height : De) }), Fe = Ie.width, ze = Ie.height; Fe = Math.min(je.width, Math.max(Be.width, Fe)), ze = Math.min(je.height, Math.max(Be.height, ze)); var qe = document.createElement("canvas"), He = qe.getContext("2d"); qe.width = normalizeDecimalNumber(Fe), qe.height = normalizeDecimalNumber(ze), He.fillStyle = t.fillColor || "transparent", He.fillRect(0, 0, Fe, ze); var Ge = t.imageSmoothingEnabled, Ze = Ge === void 0 ? !0 : Ge, sn = t.imageSmoothingQuality; He.imageSmoothingEnabled = Ze, sn && (He.imageSmoothingQuality = sn); var Xe = Ee.width, St = Ee.height, un = Re, on = Ce, bn, Tn, fn, En, Pn, Rn; un <= -Me || un > Xe ? (un = 0, bn = 0, fn = 0, Pn = 0) : un <= 0 ? (fn = -un, un = 0, bn = Math.min(Xe, Me + un), Pn = bn) : un <= Xe && (fn = 0, bn = Math.min(Me, Xe - un), Pn = bn), bn <= 0 || on <= -De || on > St ? (on = 0, Tn = 0, En = 0, Rn = 0) : on <= 0 ? (En = -on, on = 0, Tn = Math.min(St, De + on), Rn = Tn) : on <= St && (En = 0, Tn = Math.min(De, St - on), Rn = Tn); var In = [un, on, bn, Tn]; if (Pn > 0 && Rn > 0) { var xn = Fe / Me; In.push(fn * xn, En * xn, Pn * xn, Rn * xn) } return He.drawImage.apply(He, [Ee].concat(_toConsumableArray(In.map(function (vn) { return Math.floor(normalizeDecimalNumber(vn)) })))), qe }, setAspectRatio: function (t) { var xe = this.options; return !this.disabled && !isUndefined(t) && (xe.aspectRatio = Math.max(0, t) || NaN, this.ready && (this.initCropBox(), this.cropped && this.renderCropBox())), this }, setDragMode: function (t) { var xe = this.options, Ee = this.dragBox, _e = this.face; if (this.ready && !this.disabled) { var Re = t === DRAG_MODE_CROP, Ce = xe.movable && t === DRAG_MODE_MOVE; t = Re || Ce ? t : DRAG_MODE_NONE, xe.dragMode = t, setData(Ee, DATA_ACTION, t), toggleClass(Ee, CLASS_CROP, Re), toggleClass(Ee, CLASS_MOVE, Ce), xe.cropBoxMovable || (setData(_e, DATA_ACTION, t), toggleClass(_e, CLASS_CROP, Re), toggleClass(_e, CLASS_MOVE, Ce)) } return this } }, AnotherCropper = WINDOW.Cropper, Cropper = function () { function e(t) { var xe = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}; if (_classCallCheck(this, e), !t || !REGEXP_TAG_NAME.test(t.tagName)) throw new Error("The first argument is required and must be an <img> or <canvas> element."); this.element = t, this.options = assign({}, DEFAULTS, isPlainObject(xe) && xe), this.cropped = !1, this.disabled = !1, this.pointers = {}, this.ready = !1, this.reloading = !1, this.replaced = !1, this.sized = !1, this.sizing = !1, this.init() } return _createClass(e, [{ key: "init", value: function () { var xe = this.element, Ee = xe.tagName.toLowerCase(), _e; if (!xe[NAMESPACE]) { if (xe[NAMESPACE] = this, Ee === "img") { if (this.isImg = !0, _e = xe.getAttribute("src") || "", this.originalUrl = _e, !_e) return; _e = xe.src } else Ee === "canvas" && window.HTMLCanvasElement && (_e = xe.toDataURL()); this.load(_e) } } }, { key: "load", value: function (xe) { var Ee = this; if (xe) { this.url = xe, this.imageData = {}; var _e = this.element, Re = this.options; if (!Re.rotatable && !Re.scalable && (Re.checkOrientation = !1), !Re.checkOrientation || !window.ArrayBuffer) { this.clone(); return } if (REGEXP_DATA_URL.test(xe)) { REGEXP_DATA_URL_JPEG.test(xe) ? this.read(dataURLToArrayBuffer(xe)) : this.clone(); return } var Ce = new XMLHttpRequest, Me = this.clone.bind(this); this.reloading = !0, this.xhr = Ce, Ce.onabort = Me, Ce.onerror = Me, Ce.ontimeout = Me, Ce.onprogress = function () { Ce.getResponseHeader("content-type") !== MIME_TYPE_JPEG && Ce.abort() }, Ce.onload = function () { Ee.read(Ce.response) }, Ce.onloadend = function () { Ee.reloading = !1, Ee.xhr = null }, Re.checkCrossOrigin && isCrossOriginURL(xe) && _e.crossOrigin && (xe = addTimestamp(xe)), Ce.open("GET", xe, !0), Ce.responseType = "arraybuffer", Ce.withCredentials = _e.crossOrigin === "use-credentials", Ce.send() } } }, { key: "read", value: function (xe) { var Ee = this.options, _e = this.imageData, Re = resetAndGetOrientation(xe), Ce = 0, Me = 1, De = 1; if (Re > 1) { this.url = arrayBufferToDataURL(xe, MIME_TYPE_JPEG); var Pe = parseOrientation(Re); Ce = Pe.rotate, Me = Pe.scaleX, De = Pe.scaleY } Ee.rotatable && (_e.rotate = Ce), Ee.scalable && (_e.scaleX = Me, _e.scaleY = De), this.clone() } }, { key: "clone", value: function () { var xe = this.element, Ee = this.url, _e = xe.crossOrigin, Re = Ee; this.options.checkCrossOrigin && isCrossOriginURL(Ee) && (_e || (_e = "anonymous"), Re = addTimestamp(Ee)), this.crossOrigin = _e, this.crossOriginUrl = Re; var Ce = document.createElement("img"); _e && (Ce.crossOrigin = _e), Ce.src = Re || Ee, Ce.alt = xe.alt || "The image to crop", this.image = Ce, Ce.onload = this.start.bind(this), Ce.onerror = this.stop.bind(this), addClass(Ce, CLASS_HIDE), xe.parentNode.insertBefore(Ce, xe.nextSibling) } }, { key: "start", value: function () { var xe = this, Ee = this.image; Ee.onload = null, Ee.onerror = null, this.sizing = !0; var _e = WINDOW.navigator && /(?:iPad|iPhone|iPod).*?AppleWebKit/i.test(WINDOW.navigator.userAgent), Re = function (Pe, Oe) { assign(xe.imageData, { naturalWidth: Pe, naturalHeight: Oe, aspectRatio: Pe / Oe }), xe.initialImageData = assign({}, xe.imageData), xe.sizing = !1, xe.sized = !0, xe.build() }; if (Ee.naturalWidth && !_e) { Re(Ee.naturalWidth, Ee.naturalHeight); return } var Ce = document.createElement("img"), Me = document.body || document.documentElement; this.sizingImage = Ce, Ce.onload = function () { Re(Ce.width, Ce.height), _e || Me.removeChild(Ce) }, Ce.src = Ee.src, _e || (Ce.style.cssText = "left:0;max-height:none!important;max-width:none!important;min-height:0!important;min-width:0!important;opacity:0;position:absolute;top:0;z-index:-1;", Me.appendChild(Ce)) } }, { key: "stop", value: function () { var xe = this.image; xe.onload = null, xe.onerror = null, xe.parentNode.removeChild(xe), this.image = null } }, { key: "build", value: function () { if (!(!this.sized || this.ready)) { var xe = this.element, Ee = this.options, _e = this.image, Re = xe.parentNode, Ce = document.createElement("div"); Ce.innerHTML = TEMPLATE; var Me = Ce.querySelector(".".concat(NAMESPACE, "-container")), De = Me.querySelector(".".concat(NAMESPACE, "-canvas")), Pe = Me.querySelector(".".concat(NAMESPACE, "-drag-box")), Oe = Me.querySelector(".".concat(NAMESPACE, "-crop-box")), je = Oe.querySelector(".".concat(NAMESPACE, "-face")); this.container = Re, this.cropper = Me, this.canvas = De, this.dragBox = Pe, this.cropBox = Oe, this.viewBox = Me.querySelector(".".concat(NAMESPACE, "-view-box")), this.face = je, De.appendChild(_e), addClass(xe, CLASS_HIDDEN), Re.insertBefore(Me, xe.nextSibling), removeClass(_e, CLASS_HIDE), this.initPreview(), this.bind(), Ee.initialAspectRatio = Math.max(0, Ee.initialAspectRatio) || NaN, Ee.aspectRatio = Math.max(0, Ee.aspectRatio) || NaN, Ee.viewMode = Math.max(0, Math.min(3, Math.round(Ee.viewMode))) || 0, addClass(Oe, CLASS_HIDDEN), Ee.guides || addClass(Oe.getElementsByClassName("".concat(NAMESPACE, "-dashed")), CLASS_HIDDEN), Ee.center || addClass(Oe.getElementsByClassName("".concat(NAMESPACE, "-center")), CLASS_HIDDEN), Ee.background && addClass(Me, "".concat(NAMESPACE, "-bg")), Ee.highlight || addClass(je, CLASS_INVISIBLE), Ee.cropBoxMovable && (addClass(je, CLASS_MOVE), setData(je, DATA_ACTION, ACTION_ALL)), Ee.cropBoxResizable || (addClass(Oe.getElementsByClassName("".concat(NAMESPACE, "-line")), CLASS_HIDDEN), addClass(Oe.getElementsByClassName("".concat(NAMESPACE, "-point")), CLASS_HIDDEN)), this.render(), this.ready = !0, this.setDragMode(Ee.dragMode), Ee.autoCrop && this.crop(), this.setData(Ee.data), isFunction(Ee.ready) && addListener(xe, EVENT_READY, Ee.ready, { once: !0 }), dispatchEvent(xe, EVENT_READY) } } }, { key: "unbuild", value: function () { if (this.ready) { this.ready = !1, this.unbind(), this.resetPreview(); var xe = this.cropper.parentNode; xe && xe.removeChild(this.cropper), removeClass(this.element, CLASS_HIDDEN) } } }, { key: "uncreate", value: function () { this.ready ? (this.unbuild(), this.ready = !1, this.cropped = !1) : this.sizing ? (this.sizingImage.onload = null, this.sizing = !1, this.sized = !1) : this.reloading ? (this.xhr.onabort = null, this.xhr.abort()) : this.image && this.stop() } }], [{ key: "noConflict", value: function () { return window.Cropper = AnotherCropper, e } }, { key: "setDefaults", value: function (xe) { assign(DEFAULTS, isPlainObject(xe) && xe) } }]) }(); assign(Cropper.prototype, render, preview, events, handlers, change, methods); var n$1 = function () { return n$1 = Object.assign || function (e) { for (var t, xe = 1, Ee = arguments.length; xe < Ee; xe++)for (var _e in t = arguments[xe]) Object.prototype.hasOwnProperty.call(t, _e) && (e[_e] = t[_e]); return e }, n$1.apply(this, arguments) }; function a$1(e, t) { var xe = {}; for (var Ee in e) Object.prototype.hasOwnProperty.call(e, Ee) && t.indexOf(Ee) < 0 && (xe[Ee] = e[Ee]); if (e != null && typeof Object.getOwnPropertySymbols == "function") { var _e = 0; for (Ee = Object.getOwnPropertySymbols(e); _e < Ee.length; _e++)t.indexOf(Ee[_e]) < 0 && Object.prototype.propertyIsEnumerable.call(e, Ee[_e]) && (xe[Ee[_e]] = e[Ee[_e]]) } return xe } var c$1 = ["aspectRatio", "autoCrop", "autoCropArea", "background", "center", "checkCrossOrigin", "checkOrientation", "cropBoxMovable", "cropBoxResizable", "data", "dragMode", "guides", "highlight", "initialAspectRatio", "minCanvasHeight", "minCanvasWidth", "minContainerHeight", "minContainerWidth", "minCropBoxHeight", "minCropBoxWidth", "modal", "movable", "preview", "responsive", "restore", "rotatable", "scalable", "toggleDragModeOnDblclick", "viewMode", "wheelZoomRatio", "zoomOnTouch", "zoomOnWheel", "zoomable", "cropstart", "cropmove", "cropend", "crop", "zoom", "ready"], i$2 = { opacity: 0, maxWidth: "100%" }, l$1 = React.forwardRef(function (e, t) { var xe = a$1(e, []), Ee = xe.dragMode, _e = Ee === void 0 ? "crop" : Ee, Re = xe.src, Ce = xe.style, Me = xe.className, De = xe.crossOrigin, Pe = xe.scaleX, Oe = xe.scaleY, je = xe.enable, Be = xe.zoomTo, Ie = xe.rotateTo, Fe = xe.alt, ze = Fe === void 0 ? "picture" : Fe, qe = xe.ready, He = xe.onInitialized, Ge = a$1(xe, ["dragMode", "src", "style", "className", "crossOrigin", "scaleX", "scaleY", "enable", "zoomTo", "rotateTo", "alt", "ready", "onInitialized"]), Ze = { scaleY: Oe, scaleX: Pe, enable: je, zoomTo: Be, rotateTo: Ie }, sn = function () { for (var St = [], un = 0; un < arguments.length; un++)St[un] = arguments[un]; var on = reactExports.useRef(null); return React.useEffect(function () { St.forEach(function (bn) { bn && (typeof bn == "function" ? bn(on.current) : bn.current = on.current) }) }, [St]), on }(t, reactExports.useRef(null)); reactExports.useEffect(function () { var St; !((St = sn.current) === null || St === void 0) && St.cropper && typeof Be == "number" && sn.current.cropper.zoomTo(Be) }, [xe.zoomTo]), reactExports.useEffect(function () { var St; !((St = sn.current) === null || St === void 0) && St.cropper && Re !== void 0 && sn.current.cropper.reset().clear().replace(Re) }, [Re]), reactExports.useEffect(function () { if (sn.current !== null) { var St = new Cropper(sn.current, n$1(n$1({ dragMode: _e }, Ge), { ready: function (un) { un.currentTarget !== null && function (on, bn) { bn === void 0 && (bn = {}); var Tn = bn.enable, fn = Tn === void 0 || Tn, En = bn.scaleX, Pn = En === void 0 ? 1 : En, Rn = bn.scaleY, In = Rn === void 0 ? 1 : Rn, xn = bn.zoomTo, vn = xn === void 0 ? 0 : xn, tn = bn.rotateTo; fn ? on.enable() : on.disable(), on.scaleX(Pn), on.scaleY(In), tn !== void 0 && on.rotateTo(tn), vn > 0 && on.zoomTo(vn) }(un.currentTarget.cropper, Ze), qe && qe(un) } })); He && He(St) } return function () { var un, on; (on = (un = sn.current) === null || un === void 0 ? void 0 : un.cropper) === null || on === void 0 || on.destroy() } }, [sn]); var Xe = function (St) { return c$1.reduce(function (un, on) { var bn = un, Tn = on; return bn[Tn], a$1(bn, [typeof Tn == "symbol" ? Tn : Tn + ""]) }, St) }(n$1(n$1({}, Ge), { crossOrigin: De, src: Re, alt: ze })); return React.createElement("div", { style: Ce, className: Me }, React.createElement("img", n$1({}, Xe, { style: i$2, ref: sn }))) }); function commonjsRequire(e) { throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.') } var pdf$1 = { exports: {} }; const __viteBrowserExternal = {}, __viteBrowserExternal$1 = Object.freeze(Object.defineProperty({ __proto__: null, default: __viteBrowserExternal }, Symbol.toStringTag, { value: "Module" })), require$$5 = getAugmentedNamespace(__viteBrowserExternal$1); var hasRequiredPdf; function requirePdf() {
  return hasRequiredPdf || (hasRequiredPdf = 1, function (module, exports) {
    (function (t, xe) { module.exports = t.pdfjsLib = xe() })(globalThis, () => (() => {
      var __webpack_modules__ = [, (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.VerbosityLevel = t.Util = t.UnknownErrorException = t.UnexpectedResponseException = t.TextRenderingMode = t.RenderingIntentFlag = t.PromiseCapability = t.PermissionFlag = t.PasswordResponses = t.PasswordException = t.PageActionEventType = t.OPS = t.MissingPDFException = t.MAX_IMAGE_SIZE_TO_CACHE = t.LINE_FACTOR = t.LINE_DESCENT_FACTOR = t.InvalidPDFException = t.ImageKind = t.IDENTITY_MATRIX = t.FormatError = t.FeatureTest = t.FONT_IDENTITY_MATRIX = t.DocumentActionEventType = t.CMapCompressionType = t.BaseException = t.BASELINE_FACTOR = t.AnnotationType = t.AnnotationReplyType = t.AnnotationPrefix = t.AnnotationMode = t.AnnotationFlag = t.AnnotationFieldFlag = t.AnnotationEditorType = t.AnnotationEditorPrefix = t.AnnotationEditorParamsType = t.AnnotationBorderStyleType = t.AnnotationActionEventType = t.AbortException = void 0, t.assert = nn, t.bytesToString = On, t.createValidAbsoluteUrl = dn, t.getModificationDate = Dr, t.getUuid = wi, t.getVerbosityLevel = In, t.info = xn, t.isArrayBuffer = Or, t.isArrayEqual = Ir, t.isNodeJS = void 0, t.normalizeUnicode = Tr, t.objectFromMap = Fn, t.objectSize = sr, t.setVerbosityLevel = Rn, t.shadow = Je, t.string32 = zn, t.stringToBytes = kn, t.stringToPDFString = ur, t.stringToUTF8String = Er, t.unreachable = tn, t.utf8StringToString = _r, t.warn = vn; const xe = typeof process == "object" && process + "" == "[object process]" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== "browser"); t.isNodeJS = xe; const Ee = [1, 0, 0, 1, 0, 0]; t.IDENTITY_MATRIX = Ee; const _e = [.001, 0, 0, .001, 0, 0]; t.FONT_IDENTITY_MATRIX = _e; const Re = 1e7; t.MAX_IMAGE_SIZE_TO_CACHE = Re; const Ce = 1.35; t.LINE_FACTOR = Ce; const Me = .35; t.LINE_DESCENT_FACTOR = Me; const De = Me / Ce; t.BASELINE_FACTOR = De; const Pe = { ANY: 1, DISPLAY: 2, PRINT: 4, SAVE: 8, ANNOTATIONS_FORMS: 16, ANNOTATIONS_STORAGE: 32, ANNOTATIONS_DISABLE: 64, OPLIST: 256 }; t.RenderingIntentFlag = Pe; const Oe = { DISABLE: 0, ENABLE: 1, ENABLE_FORMS: 2, ENABLE_STORAGE: 3 }; t.AnnotationMode = Oe; const je = "pdfjs_internal_editor_"; t.AnnotationEditorPrefix = je; const Be = { DISABLE: -1, NONE: 0, FREETEXT: 3, STAMP: 13, INK: 15 }; t.AnnotationEditorType = Be; const Ie = { RESIZE: 1, CREATE: 2, FREETEXT_SIZE: 11, FREETEXT_COLOR: 12, FREETEXT_OPACITY: 13, INK_COLOR: 21, INK_THICKNESS: 22, INK_OPACITY: 23 }; t.AnnotationEditorParamsType = Ie; const Fe = { PRINT: 4, MODIFY_CONTENTS: 8, COPY: 16, MODIFY_ANNOTATIONS: 32, FILL_INTERACTIVE_FORMS: 256, COPY_FOR_ACCESSIBILITY: 512, ASSEMBLE: 1024, PRINT_HIGH_QUALITY: 2048 }; t.PermissionFlag = Fe; const ze = { FILL: 0, STROKE: 1, FILL_STROKE: 2, INVISIBLE: 3, FILL_ADD_TO_PATH: 4, STROKE_ADD_TO_PATH: 5, FILL_STROKE_ADD_TO_PATH: 6, ADD_TO_PATH: 7, FILL_STROKE_MASK: 3, ADD_TO_PATH_FLAG: 4 }; t.TextRenderingMode = ze; const qe = { GRAYSCALE_1BPP: 1, RGB_24BPP: 2, RGBA_32BPP: 3 }; t.ImageKind = qe; const He = { TEXT: 1, LINK: 2, FREETEXT: 3, LINE: 4, SQUARE: 5, CIRCLE: 6, POLYGON: 7, POLYLINE: 8, HIGHLIGHT: 9, UNDERLINE: 10, SQUIGGLY: 11, STRIKEOUT: 12, STAMP: 13, CARET: 14, INK: 15, POPUP: 16, FILEATTACHMENT: 17, SOUND: 18, MOVIE: 19, WIDGET: 20, SCREEN: 21, PRINTERMARK: 22, TRAPNET: 23, WATERMARK: 24, THREED: 25, REDACT: 26 }; t.AnnotationType = He; const Ge = { GROUP: "Group", REPLY: "R" }; t.AnnotationReplyType = Ge; const Ze = { INVISIBLE: 1, HIDDEN: 2, PRINT: 4, NOZOOM: 8, NOROTATE: 16, NOVIEW: 32, READONLY: 64, LOCKED: 128, TOGGLENOVIEW: 256, LOCKEDCONTENTS: 512 }; t.AnnotationFlag = Ze; const sn = { READONLY: 1, REQUIRED: 2, NOEXPORT: 4, MULTILINE: 4096, PASSWORD: 8192, NOTOGGLETOOFF: 16384, RADIO: 32768, PUSHBUTTON: 65536, COMBO: 131072, EDIT: 262144, SORT: 524288, FILESELECT: 1048576, MULTISELECT: 2097152, DONOTSPELLCHECK: 4194304, DONOTSCROLL: 8388608, COMB: 16777216, RICHTEXT: 33554432, RADIOSINUNISON: 33554432, COMMITONSELCHANGE: 67108864 }; t.AnnotationFieldFlag = sn; const Xe = { SOLID: 1, DASHED: 2, BEVELED: 3, INSET: 4, UNDERLINE: 5 }; t.AnnotationBorderStyleType = Xe; const St = { E: "Mouse Enter", X: "Mouse Exit", D: "Mouse Down", U: "Mouse Up", Fo: "Focus", Bl: "Blur", PO: "PageOpen", PC: "PageClose", PV: "PageVisible", PI: "PageInvisible", K: "Keystroke", F: "Format", V: "Validate", C: "Calculate" }; t.AnnotationActionEventType = St; const un = { WC: "WillClose", WS: "WillSave", DS: "DidSave", WP: "WillPrint", DP: "DidPrint" }; t.DocumentActionEventType = un; const on = { O: "PageOpen", C: "PageClose" }; t.PageActionEventType = on; const bn = { ERRORS: 0, WARNINGS: 1, INFOS: 5 }; t.VerbosityLevel = bn; const Tn = { NONE: 0, BINARY: 1 }; t.CMapCompressionType = Tn; const fn = { dependency: 1, setLineWidth: 2, setLineCap: 3, setLineJoin: 4, setMiterLimit: 5, setDash: 6, setRenderingIntent: 7, setFlatness: 8, setGState: 9, save: 10, restore: 11, transform: 12, moveTo: 13, lineTo: 14, curveTo: 15, curveTo2: 16, curveTo3: 17, closePath: 18, rectangle: 19, stroke: 20, closeStroke: 21, fill: 22, eoFill: 23, fillStroke: 24, eoFillStroke: 25, closeFillStroke: 26, closeEOFillStroke: 27, endPath: 28, clip: 29, eoClip: 30, beginText: 31, endText: 32, setCharSpacing: 33, setWordSpacing: 34, setHScale: 35, setLeading: 36, setFont: 37, setTextRenderingMode: 38, setTextRise: 39, moveText: 40, setLeadingMoveText: 41, setTextMatrix: 42, nextLine: 43, showText: 44, showSpacedText: 45, nextLineShowText: 46, nextLineSetSpacingShowText: 47, setCharWidth: 48, setCharWidthAndBounds: 49, setStrokeColorSpace: 50, setFillColorSpace: 51, setStrokeColor: 52, setStrokeColorN: 53, setFillColor: 54, setFillColorN: 55, setStrokeGray: 56, setFillGray: 57, setStrokeRGBColor: 58, setFillRGBColor: 59, setStrokeCMYKColor: 60, setFillCMYKColor: 61, shadingFill: 62, beginInlineImage: 63, beginImageData: 64, endInlineImage: 65, paintXObject: 66, markPoint: 67, markPointProps: 68, beginMarkedContent: 69, beginMarkedContentProps: 70, endMarkedContent: 71, beginCompat: 72, endCompat: 73, paintFormXObjectBegin: 74, paintFormXObjectEnd: 75, beginGroup: 76, endGroup: 77, beginAnnotation: 80, endAnnotation: 81, paintImageMaskXObject: 83, paintImageMaskXObjectGroup: 84, paintImageXObject: 85, paintInlineImageXObject: 86, paintInlineImageXObjectGroup: 87, paintImageXObjectRepeat: 88, paintImageMaskXObjectRepeat: 89, paintSolidColorImageMask: 90, constructPath: 91 }; t.OPS = fn; const En = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }; t.PasswordResponses = En; let Pn = bn.WARNINGS; function Rn(mr) { Number.isInteger(mr) && (Pn = mr) } function In() { return Pn } function xn(mr) { Pn >= bn.INFOS && console.log(`Info: ${mr}`) } function vn(mr) { Pn >= bn.WARNINGS && console.log(`Warning: ${mr}`) } function tn(mr) { throw new Error(mr) } function nn(mr, Kn) { mr || tn(Kn) } function We(mr) { switch (mr?.protocol) { case "http:": case "https:": case "ftp:": case "mailto:": case "tel:": return !0; default: return !1 } } function dn(mr, Kn = null, Qn = null) { if (!mr) return null; try { if (Qn && typeof mr == "string" && (Qn.addDefaultProtocol && mr.startsWith("www.") && mr.match(/\./g)?.length >= 2 && (mr = `http://${mr}`), Qn.tryConvertEncoding)) try { mr = Er(mr) } catch { } const Rr = Kn ? new URL(mr, Kn) : new URL(mr); if (We(Rr)) return Rr } catch { } return null } function Je(mr, Kn, Qn, Rr = !1) { return Object.defineProperty(mr, Kn, { value: Qn, enumerable: !Rr, configurable: !0, writable: !1 }), Qn } const rn = function () { function Kn(Qn, Rr) { this.constructor === Kn && tn("Cannot initialize BaseException."), this.message = Qn, this.name = Rr } return Kn.prototype = new Error, Kn.constructor = Kn, Kn }(); t.BaseException = rn; class hn extends rn { constructor(Kn, Qn) { super(Kn, "PasswordException"), this.code = Qn } } t.PasswordException = hn; class mn extends rn { constructor(Kn, Qn) { super(Kn, "UnknownErrorException"), this.details = Qn } } t.UnknownErrorException = mn; class Ye extends rn { constructor(Kn) { super(Kn, "InvalidPDFException") } } t.InvalidPDFException = Ye; class an extends rn { constructor(Kn) { super(Kn, "MissingPDFException") } } t.MissingPDFException = an; class pn extends rn { constructor(Kn, Qn) { super(Kn, "UnexpectedResponseException"), this.status = Qn } } t.UnexpectedResponseException = pn; class yn extends rn { constructor(Kn) { super(Kn, "FormatError") } } t.FormatError = yn; class _n extends rn { constructor(Kn) { super(Kn, "AbortException") } } t.AbortException = _n; function On(mr) { (typeof mr != "object" || mr?.length === void 0) && tn("Invalid argument for bytesToString"); const Kn = mr.length, Qn = 8192; if (Kn < Qn) return String.fromCharCode.apply(null, mr); const Rr = []; for (let kr = 0; kr < Kn; kr += Qn) { const di = Math.min(kr + Qn, Kn), ei = mr.subarray(kr, di); Rr.push(String.fromCharCode.apply(null, ei)) } return Rr.join("") } function kn(mr) { typeof mr != "string" && tn("Invalid argument for stringToBytes"); const Kn = mr.length, Qn = new Uint8Array(Kn); for (let Rr = 0; Rr < Kn; ++Rr)Qn[Rr] = mr.charCodeAt(Rr) & 255; return Qn } function zn(mr) { return String.fromCharCode(mr >> 24 & 255, mr >> 16 & 255, mr >> 8 & 255, mr & 255) } function sr(mr) { return Object.keys(mr).length } function Fn(mr) { const Kn = Object.create(null); for (const [Qn, Rr] of mr) Kn[Qn] = Rr; return Kn } function Cn() { const mr = new Uint8Array(4); return mr[0] = 1, new Uint32Array(mr.buffer, 0, 1)[0] === 1 } function Vn() { try { return new Function(""), !0 } catch { return !1 } } class Yn { static get isLittleEndian() { return Je(this, "isLittleEndian", Cn()) } static get isEvalSupported() { return Je(this, "isEvalSupported", Vn()) } static get isOffscreenCanvasSupported() { return Je(this, "isOffscreenCanvasSupported", typeof OffscreenCanvas < "u") } static get platform() { return typeof navigator > "u" ? Je(this, "platform", { isWin: !1, isMac: !1 }) : Je(this, "platform", { isWin: navigator.platform.includes("Win"), isMac: navigator.platform.includes("Mac") }) } static get isCSSRoundSupported() { return Je(this, "isCSSRoundSupported", globalThis.CSS?.supports?.("width: round(1.5px, 1px)")) } } t.FeatureTest = Yn; const qn = [...Array(256).keys()].map(mr => mr.toString(16).padStart(2, "0")); class rr { static makeHexColor(Kn, Qn, Rr) { return `#${qn[Kn]}${qn[Qn]}${qn[Rr]}` } static scaleMinMax(Kn, Qn) { let Rr; Kn[0] ? (Kn[0] < 0 && (Rr = Qn[0], Qn[0] = Qn[1], Qn[1] = Rr), Qn[0] *= Kn[0], Qn[1] *= Kn[0], Kn[3] < 0 && (Rr = Qn[2], Qn[2] = Qn[3], Qn[3] = Rr), Qn[2] *= Kn[3], Qn[3] *= Kn[3]) : (Rr = Qn[0], Qn[0] = Qn[2], Qn[2] = Rr, Rr = Qn[1], Qn[1] = Qn[3], Qn[3] = Rr, Kn[1] < 0 && (Rr = Qn[2], Qn[2] = Qn[3], Qn[3] = Rr), Qn[2] *= Kn[1], Qn[3] *= Kn[1], Kn[2] < 0 && (Rr = Qn[0], Qn[0] = Qn[1], Qn[1] = Rr), Qn[0] *= Kn[2], Qn[1] *= Kn[2]), Qn[0] += Kn[4], Qn[1] += Kn[4], Qn[2] += Kn[5], Qn[3] += Kn[5] } static transform(Kn, Qn) { return [Kn[0] * Qn[0] + Kn[2] * Qn[1], Kn[1] * Qn[0] + Kn[3] * Qn[1], Kn[0] * Qn[2] + Kn[2] * Qn[3], Kn[1] * Qn[2] + Kn[3] * Qn[3], Kn[0] * Qn[4] + Kn[2] * Qn[5] + Kn[4], Kn[1] * Qn[4] + Kn[3] * Qn[5] + Kn[5]] } static applyTransform(Kn, Qn) { const Rr = Kn[0] * Qn[0] + Kn[1] * Qn[2] + Qn[4], kr = Kn[0] * Qn[1] + Kn[1] * Qn[3] + Qn[5]; return [Rr, kr] } static applyInverseTransform(Kn, Qn) { const Rr = Qn[0] * Qn[3] - Qn[1] * Qn[2], kr = (Kn[0] * Qn[3] - Kn[1] * Qn[2] + Qn[2] * Qn[5] - Qn[4] * Qn[3]) / Rr, di = (-Kn[0] * Qn[1] + Kn[1] * Qn[0] + Qn[4] * Qn[1] - Qn[5] * Qn[0]) / Rr; return [kr, di] } static getAxialAlignedBoundingBox(Kn, Qn) { const Rr = this.applyTransform(Kn, Qn), kr = this.applyTransform(Kn.slice(2, 4), Qn), di = this.applyTransform([Kn[0], Kn[3]], Qn), ei = this.applyTransform([Kn[2], Kn[1]], Qn); return [Math.min(Rr[0], kr[0], di[0], ei[0]), Math.min(Rr[1], kr[1], di[1], ei[1]), Math.max(Rr[0], kr[0], di[0], ei[0]), Math.max(Rr[1], kr[1], di[1], ei[1])] } static inverseTransform(Kn) { const Qn = Kn[0] * Kn[3] - Kn[1] * Kn[2]; return [Kn[3] / Qn, -Kn[1] / Qn, -Kn[2] / Qn, Kn[0] / Qn, (Kn[2] * Kn[5] - Kn[4] * Kn[3]) / Qn, (Kn[4] * Kn[1] - Kn[5] * Kn[0]) / Qn] } static singularValueDecompose2dScale(Kn) { const Qn = [Kn[0], Kn[2], Kn[1], Kn[3]], Rr = Kn[0] * Qn[0] + Kn[1] * Qn[2], kr = Kn[0] * Qn[1] + Kn[1] * Qn[3], di = Kn[2] * Qn[0] + Kn[3] * Qn[2], ei = Kn[2] * Qn[1] + Kn[3] * Qn[3], Wi = (Rr + ei) / 2, $i = Math.sqrt((Rr + ei) ** 2 - 4 * (Rr * ei - di * kr)) / 2, xi = Wi + $i || 1, Ar = Wi - $i || 1; return [Math.sqrt(xi), Math.sqrt(Ar)] } static normalizeRect(Kn) { const Qn = Kn.slice(0); return Kn[0] > Kn[2] && (Qn[0] = Kn[2], Qn[2] = Kn[0]), Kn[1] > Kn[3] && (Qn[1] = Kn[3], Qn[3] = Kn[1]), Qn } static intersect(Kn, Qn) { const Rr = Math.max(Math.min(Kn[0], Kn[2]), Math.min(Qn[0], Qn[2])), kr = Math.min(Math.max(Kn[0], Kn[2]), Math.max(Qn[0], Qn[2])); if (Rr > kr) return null; const di = Math.max(Math.min(Kn[1], Kn[3]), Math.min(Qn[1], Qn[3])), ei = Math.min(Math.max(Kn[1], Kn[3]), Math.max(Qn[1], Qn[3])); return di > ei ? null : [Rr, di, kr, ei] } static bezierBoundingBox(Kn, Qn, Rr, kr, di, ei, Wi, $i) { const xi = [], Ar = [[], []]; let Ur, hi, ii, fi, yi, Lr, pi, ni; for (let ms = 0; ms < 2; ++ms) { if (ms === 0 ? (hi = 6 * Kn - 12 * Rr + 6 * di, Ur = -3 * Kn + 9 * Rr - 9 * di + 3 * Wi, ii = 3 * Rr - 3 * Kn) : (hi = 6 * Qn - 12 * kr + 6 * ei, Ur = -3 * Qn + 9 * kr - 9 * ei + 3 * $i, ii = 3 * kr - 3 * Qn), Math.abs(Ur) < 1e-12) { if (Math.abs(hi) < 1e-12) continue; fi = -ii / hi, 0 < fi && fi < 1 && xi.push(fi); continue } pi = hi * hi - 4 * ii * Ur, ni = Math.sqrt(pi), !(pi < 0) && (yi = (-hi + ni) / (2 * Ur), 0 < yi && yi < 1 && xi.push(yi), Lr = (-hi - ni) / (2 * Ur), 0 < Lr && Lr < 1 && xi.push(Lr)) } let oi = xi.length, si; const bi = oi; for (; oi--;)fi = xi[oi], si = 1 - fi, Ar[0][oi] = si * si * si * Kn + 3 * si * si * fi * Rr + 3 * si * fi * fi * di + fi * fi * fi * Wi, Ar[1][oi] = si * si * si * Qn + 3 * si * si * fi * kr + 3 * si * fi * fi * ei + fi * fi * fi * $i; return Ar[0][bi] = Kn, Ar[1][bi] = Qn, Ar[0][bi + 1] = Wi, Ar[1][bi + 1] = $i, Ar[0].length = Ar[1].length = bi + 2, [Math.min(...Ar[0]), Math.min(...Ar[1]), Math.max(...Ar[0]), Math.max(...Ar[1])] } } t.Util = rr; const hr = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 728, 711, 710, 729, 733, 731, 730, 732, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 8226, 8224, 8225, 8230, 8212, 8211, 402, 8260, 8249, 8250, 8722, 8240, 8222, 8220, 8221, 8216, 8217, 8218, 8482, 64257, 64258, 321, 338, 352, 376, 381, 305, 322, 339, 353, 382, 0, 8364]; function ur(mr) { if (mr[0] >= "ï") { let Qn; if (mr[0] === "þ" && mr[1] === "ÿ" ? Qn = "utf-16be" : mr[0] === "ÿ" && mr[1] === "þ" ? Qn = "utf-16le" : mr[0] === "ï" && mr[1] === "»" && mr[2] === "¿" && (Qn = "utf-8"), Qn) try { const Rr = new TextDecoder(Qn, { fatal: !0 }), kr = kn(mr); return Rr.decode(kr) } catch (Rr) { vn(`stringToPDFString: "${Rr}".`) } } const Kn = []; for (let Qn = 0, Rr = mr.length; Qn < Rr; Qn++) { const kr = hr[mr.charCodeAt(Qn)]; Kn.push(kr ? String.fromCharCode(kr) : mr.charAt(Qn)) } return Kn.join("") } function Er(mr) { return decodeURIComponent(escape(mr)) } function _r(mr) { return unescape(encodeURIComponent(mr)) } function Or(mr) { return typeof mr == "object" && mr?.byteLength !== void 0 } function Ir(mr, Kn) { if (mr.length !== Kn.length) return !1; for (let Qn = 0, Rr = mr.length; Qn < Rr; Qn++)if (mr[Qn] !== Kn[Qn]) return !1; return !0 } function Dr(mr = new Date) { return [mr.getUTCFullYear().toString(), (mr.getUTCMonth() + 1).toString().padStart(2, "0"), mr.getUTCDate().toString().padStart(2, "0"), mr.getUTCHours().toString().padStart(2, "0"), mr.getUTCMinutes().toString().padStart(2, "0"), mr.getUTCSeconds().toString().padStart(2, "0")].join("") } class Wr { #e = !1; constructor() { this.promise = new Promise((Kn, Qn) => { this.resolve = Rr => { this.#e = !0, Kn(Rr) }, this.reject = Rr => { this.#e = !0, Qn(Rr) } }) } get settled() { return this.#e } } t.PromiseCapability = Wr; let Cr = null, zr = null; function Tr(mr) { return Cr || (Cr = /([\u00a0\u00b5\u037e\u0eb3\u2000-\u200a\u202f\u2126\ufb00-\ufb04\ufb06\ufb20-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufba1\ufba4-\ufba9\ufbae-\ufbb1\ufbd3-\ufbdc\ufbde-\ufbe7\ufbea-\ufbf8\ufbfc-\ufbfd\ufc00-\ufc5d\ufc64-\ufcf1\ufcf5-\ufd3d\ufd88\ufdf4\ufdfa-\ufdfb\ufe71\ufe77\ufe79\ufe7b\ufe7d]+)|(\ufb05+)/gu, zr = new Map([["ﬅ", "ſt"]])), mr.replaceAll(Cr, (Kn, Qn, Rr) => Qn ? Qn.normalize("NFKC") : zr.get(Rr)) } function wi() { if (typeof crypto < "u" && typeof crypto?.randomUUID == "function") return crypto.randomUUID(); const mr = new Uint8Array(32); if (typeof crypto < "u" && typeof crypto?.getRandomValues == "function") crypto.getRandomValues(mr); else for (let Kn = 0; Kn < 32; Kn++)mr[Kn] = Math.floor(Math.random() * 255); return On(mr) } const Jr = "pdfjs_internal_id_"; t.AnnotationPrefix = Jr }, (__unused_webpack_module, exports, __w_pdfjs_require__) => { Object.defineProperty(exports, "__esModule", { value: !0 }), exports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0, Object.defineProperty(exports, "SVGGraphics", { enumerable: !0, get: function () { return _displaySvg.SVGGraphics } }), exports.build = void 0, exports.getDocument = getDocument, exports.version = void 0; var _util = __w_pdfjs_require__(1), _annotation_storage = __w_pdfjs_require__(3), _display_utils = __w_pdfjs_require__(6), _font_loader = __w_pdfjs_require__(9), _displayNode_utils = __w_pdfjs_require__(10), _canvas = __w_pdfjs_require__(11), _worker_options = __w_pdfjs_require__(14), _message_handler = __w_pdfjs_require__(15), _metadata = __w_pdfjs_require__(16), _optional_content_config = __w_pdfjs_require__(17), _transport_stream = __w_pdfjs_require__(18), _displayFetch_stream = __w_pdfjs_require__(19), _displayNetwork = __w_pdfjs_require__(22), _displayNode_stream = __w_pdfjs_require__(23), _displaySvg = __w_pdfjs_require__(24), _xfa_text = __w_pdfjs_require__(25); const DEFAULT_RANGE_CHUNK_SIZE = 65536, RENDERING_CANCELLED_TIMEOUT = 100, DELAYED_CLEANUP_TIMEOUT = 5e3, DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory; exports.DefaultCanvasFactory = DefaultCanvasFactory; const DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory; exports.DefaultCMapReaderFactory = DefaultCMapReaderFactory; const DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory; exports.DefaultFilterFactory = DefaultFilterFactory; const DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory; exports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory; function getDocument(e) { if (typeof e == "string" || e instanceof URL ? e = { url: e } : (0, _util.isArrayBuffer)(e) && (e = { data: e }), typeof e != "object") throw new Error("Invalid parameter in getDocument, need parameter object."); if (!e.url && !e.data && !e.range) throw new Error("Invalid parameter object: need either .data, .range or .url"); const t = new PDFDocumentLoadingTask, { docId: xe } = t, Ee = e.url ? getUrlProp(e.url) : null, _e = e.data ? getDataProp(e.data) : null, Re = e.httpHeaders || null, Ce = e.withCredentials === !0, Me = e.password ?? null, De = e.range instanceof PDFDataRangeTransport ? e.range : null, Pe = Number.isInteger(e.rangeChunkSize) && e.rangeChunkSize > 0 ? e.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE; let Oe = e.worker instanceof PDFWorker ? e.worker : null; const je = e.verbosity, Be = typeof e.docBaseUrl == "string" && !(0, _display_utils.isDataScheme)(e.docBaseUrl) ? e.docBaseUrl : null, Ie = typeof e.cMapUrl == "string" ? e.cMapUrl : null, Fe = e.cMapPacked !== !1, ze = e.CMapReaderFactory || DefaultCMapReaderFactory, qe = typeof e.standardFontDataUrl == "string" ? e.standardFontDataUrl : null, He = e.StandardFontDataFactory || DefaultStandardFontDataFactory, Ge = e.stopAtErrors !== !0, Ze = Number.isInteger(e.maxImageSize) && e.maxImageSize > -1 ? e.maxImageSize : -1, sn = e.isEvalSupported !== !1, Xe = typeof e.isOffscreenCanvasSupported == "boolean" ? e.isOffscreenCanvasSupported : !_util.isNodeJS, St = Number.isInteger(e.canvasMaxAreaInBytes) ? e.canvasMaxAreaInBytes : -1, un = typeof e.disableFontFace == "boolean" ? e.disableFontFace : _util.isNodeJS, on = e.fontExtraProperties === !0, bn = e.enableXfa === !0, Tn = e.ownerDocument || globalThis.document, fn = e.disableRange === !0, En = e.disableStream === !0, Pn = e.disableAutoFetch === !0, Rn = e.pdfBug === !0, In = De ? De.length : e.length ?? NaN, xn = typeof e.useSystemFonts == "boolean" ? e.useSystemFonts : !_util.isNodeJS && !un, vn = typeof e.useWorkerFetch == "boolean" ? e.useWorkerFetch : ze === _display_utils.DOMCMapReaderFactory && He === _display_utils.DOMStandardFontDataFactory && Ie && qe && (0, _display_utils.isValidFetchUrl)(Ie, document.baseURI) && (0, _display_utils.isValidFetchUrl)(qe, document.baseURI), tn = e.canvasFactory || new DefaultCanvasFactory({ ownerDocument: Tn }), nn = e.filterFactory || new DefaultFilterFactory({ docId: xe, ownerDocument: Tn }), We = null; (0, _util.setVerbosityLevel)(je); const dn = { canvasFactory: tn, filterFactory: nn }; if (vn || (dn.cMapReaderFactory = new ze({ baseUrl: Ie, isCompressed: Fe }), dn.standardFontDataFactory = new He({ baseUrl: qe })), !Oe) { const hn = { verbosity: je, port: _worker_options.GlobalWorkerOptions.workerPort }; Oe = hn.port ? PDFWorker.fromPort(hn) : new PDFWorker(hn), t._worker = Oe } const Je = { docId: xe, apiVersion: "3.11.174", data: _e, password: Me, disableAutoFetch: Pn, rangeChunkSize: Pe, length: In, docBaseUrl: Be, enableXfa: bn, evaluatorOptions: { maxImageSize: Ze, disableFontFace: un, ignoreErrors: Ge, isEvalSupported: sn, isOffscreenCanvasSupported: Xe, canvasMaxAreaInBytes: St, fontExtraProperties: on, useSystemFonts: xn, cMapUrl: vn ? Ie : null, standardFontDataUrl: vn ? qe : null } }, rn = { ignoreErrors: Ge, isEvalSupported: sn, disableFontFace: un, fontExtraProperties: on, enableXfa: bn, ownerDocument: Tn, disableAutoFetch: Pn, pdfBug: Rn, styleElement: We }; return Oe.promise.then(function () { if (t.destroyed) throw new Error("Loading aborted"); const hn = _fetchDocument(Oe, Je), mn = new Promise(function (Ye) { let an; De ? an = new _transport_stream.PDFDataTransportStream({ length: In, initialData: De.initialData, progressiveDone: De.progressiveDone, contentDispositionFilename: De.contentDispositionFilename, disableRange: fn, disableStream: En }, De) : _e || (an = (yn => _util.isNodeJS ? new _displayNode_stream.PDFNodeStream(yn) : (0, _display_utils.isValidFetchUrl)(yn.url) ? new _displayFetch_stream.PDFFetchStream(yn) : new _displayNetwork.PDFNetworkStream(yn))({ url: Ee, length: In, httpHeaders: Re, withCredentials: Ce, rangeChunkSize: Pe, disableRange: fn, disableStream: En })), Ye(an) }); return Promise.all([hn, mn]).then(function ([Ye, an]) { if (t.destroyed) throw new Error("Loading aborted"); const pn = new _message_handler.MessageHandler(xe, Ye, Oe.port), yn = new WorkerTransport(pn, t, an, rn, dn); t._transport = yn, pn.send("Ready", null) }) }).catch(t._capability.reject), t } async function _fetchDocument(e, t) { if (e.destroyed) throw new Error("Worker was destroyed"); const xe = await e.messageHandler.sendWithPromise("GetDocRequest", t, t.data ? [t.data.buffer] : null); if (e.destroyed) throw new Error("Worker was destroyed"); return xe } function getUrlProp(e) { if (e instanceof URL) return e.href; try { return new URL(e, window.location).href } catch { if (_util.isNodeJS && typeof e == "string") return e } throw new Error("Invalid PDF url data: either string or URL-object is expected in the url property.") } function getDataProp(e) { if (_util.isNodeJS && typeof Buffer < "u" && e instanceof Buffer) throw new Error("Please provide binary data as `Uint8Array`, rather than `Buffer`."); if (e instanceof Uint8Array && e.byteLength === e.buffer.byteLength) return e; if (typeof e == "string") return (0, _util.stringToBytes)(e); if (typeof e == "object" && !isNaN(e?.length) || (0, _util.isArrayBuffer)(e)) return new Uint8Array(e); throw new Error("Invalid PDF binary data: either TypedArray, string, or array-like object is expected in the data property.") } class PDFDocumentLoadingTask { static #e = 0; constructor() { this._capability = new _util.PromiseCapability, this._transport = null, this._worker = null, this.docId = `d${PDFDocumentLoadingTask.#e++}`, this.destroyed = !1, this.onPassword = null, this.onProgress = null } get promise() { return this._capability.promise } async destroy() { this.destroyed = !0; try { this._worker?.port && (this._worker._pendingDestroy = !0), await this._transport?.destroy() } catch (t) { throw this._worker?.port && delete this._worker._pendingDestroy, t } this._transport = null, this._worker && (this._worker.destroy(), this._worker = null) } } exports.PDFDocumentLoadingTask = PDFDocumentLoadingTask; class PDFDataRangeTransport { constructor(t, xe, Ee = !1, _e = null) { this.length = t, this.initialData = xe, this.progressiveDone = Ee, this.contentDispositionFilename = _e, this._rangeListeners = [], this._progressListeners = [], this._progressiveReadListeners = [], this._progressiveDoneListeners = [], this._readyCapability = new _util.PromiseCapability } addRangeListener(t) { this._rangeListeners.push(t) } addProgressListener(t) { this._progressListeners.push(t) } addProgressiveReadListener(t) { this._progressiveReadListeners.push(t) } addProgressiveDoneListener(t) { this._progressiveDoneListeners.push(t) } onDataRange(t, xe) { for (const Ee of this._rangeListeners) Ee(t, xe) } onDataProgress(t, xe) { this._readyCapability.promise.then(() => { for (const Ee of this._progressListeners) Ee(t, xe) }) } onDataProgressiveRead(t) { this._readyCapability.promise.then(() => { for (const xe of this._progressiveReadListeners) xe(t) }) } onDataProgressiveDone() { this._readyCapability.promise.then(() => { for (const t of this._progressiveDoneListeners) t() }) } transportReady() { this._readyCapability.resolve() } requestDataRange(t, xe) { (0, _util.unreachable)("Abstract method PDFDataRangeTransport.requestDataRange") } abort() { } } exports.PDFDataRangeTransport = PDFDataRangeTransport; class PDFDocumentProxy { constructor(t, xe) { this._pdfInfo = t, this._transport = xe, Object.defineProperty(this, "getJavaScript", { value: () => ((0, _display_utils.deprecated)("`PDFDocumentProxy.getJavaScript`, please use `PDFDocumentProxy.getJSActions` instead."), this.getJSActions().then(Ee => { if (!Ee) return Ee; const _e = []; for (const Re in Ee) _e.push(...Ee[Re]); return _e })) }) } get annotationStorage() { return this._transport.annotationStorage } get filterFactory() { return this._transport.filterFactory } get numPages() { return this._pdfInfo.numPages } get fingerprints() { return this._pdfInfo.fingerprints } get isPureXfa() { return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa) } get allXfaHtml() { return this._transport._htmlForXfa } getPage(t) { return this._transport.getPage(t) } getPageIndex(t) { return this._transport.getPageIndex(t) } getDestinations() { return this._transport.getDestinations() } getDestination(t) { return this._transport.getDestination(t) } getPageLabels() { return this._transport.getPageLabels() } getPageLayout() { return this._transport.getPageLayout() } getPageMode() { return this._transport.getPageMode() } getViewerPreferences() { return this._transport.getViewerPreferences() } getOpenAction() { return this._transport.getOpenAction() } getAttachments() { return this._transport.getAttachments() } getJSActions() { return this._transport.getDocJSActions() } getOutline() { return this._transport.getOutline() } getOptionalContentConfig() { return this._transport.getOptionalContentConfig() } getPermissions() { return this._transport.getPermissions() } getMetadata() { return this._transport.getMetadata() } getMarkInfo() { return this._transport.getMarkInfo() } getData() { return this._transport.getData() } saveDocument() { return this._transport.saveDocument() } getDownloadInfo() { return this._transport.downloadInfoCapability.promise } cleanup(t = !1) { return this._transport.startCleanup(t || this.isPureXfa) } destroy() { return this.loadingTask.destroy() } get loadingParams() { return this._transport.loadingParams } get loadingTask() { return this._transport.loadingTask } getFieldObjects() { return this._transport.getFieldObjects() } hasJSActions() { return this._transport.hasJSActions() } getCalculationOrderIds() { return this._transport.getCalculationOrderIds() } } exports.PDFDocumentProxy = PDFDocumentProxy; class PDFPageProxy { #e = null; #t = !1; constructor(t, xe, Ee, _e = !1) { this._pageIndex = t, this._pageInfo = xe, this._transport = Ee, this._stats = _e ? new _display_utils.StatTimer : null, this._pdfBug = _e, this.commonObjs = Ee.commonObjs, this.objs = new PDFObjects, this._maybeCleanupAfterRender = !1, this._intentStates = new Map, this.destroyed = !1 } get pageNumber() { return this._pageIndex + 1 } get rotate() { return this._pageInfo.rotate } get ref() { return this._pageInfo.ref } get userUnit() { return this._pageInfo.userUnit } get view() { return this._pageInfo.view } getViewport({ scale: t, rotation: xe = this.rotate, offsetX: Ee = 0, offsetY: _e = 0, dontFlip: Re = !1 } = {}) { return new _display_utils.PageViewport({ viewBox: this.view, scale: t, rotation: xe, offsetX: Ee, offsetY: _e, dontFlip: Re }) } getAnnotations({ intent: t = "display" } = {}) { const xe = this._transport.getRenderingIntent(t); return this._transport.getAnnotations(this._pageIndex, xe.renderingIntent) } getJSActions() { return this._transport.getPageJSActions(this._pageIndex) } get filterFactory() { return this._transport.filterFactory } get isPureXfa() { return (0, _util.shadow)(this, "isPureXfa", !!this._transport._htmlForXfa) } async getXfa() { return this._transport._htmlForXfa?.children[this._pageIndex] || null } render({ canvasContext: t, viewport: xe, intent: Ee = "display", annotationMode: _e = _util.AnnotationMode.ENABLE, transform: Re = null, background: Ce = null, optionalContentConfigPromise: Me = null, annotationCanvasMap: De = null, pageColors: Pe = null, printAnnotationStorage: Oe = null }) { this._stats?.time("Overall"); const je = this._transport.getRenderingIntent(Ee, _e, Oe); this.#t = !1, this.#r(), Me || (Me = this._transport.getOptionalContentConfig()); let Be = this._intentStates.get(je.cacheKey); Be || (Be = Object.create(null), this._intentStates.set(je.cacheKey, Be)), Be.streamReaderCancelTimeout && (clearTimeout(Be.streamReaderCancelTimeout), Be.streamReaderCancelTimeout = null); const Ie = !!(je.renderingIntent & _util.RenderingIntentFlag.PRINT); Be.displayReadyCapability || (Be.displayReadyCapability = new _util.PromiseCapability, Be.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(je)); const Fe = He => { Be.renderTasks.delete(ze), (this._maybeCleanupAfterRender || Ie) && (this.#t = !0), this.#n(!Ie), He ? (ze.capability.reject(He), this._abortOperatorList({ intentState: Be, reason: He instanceof Error ? He : new Error(He) })) : ze.capability.resolve(), this._stats?.timeEnd("Rendering"), this._stats?.timeEnd("Overall") }, ze = new InternalRenderTask({ callback: Fe, params: { canvasContext: t, viewport: xe, transform: Re, background: Ce }, objs: this.objs, commonObjs: this.commonObjs, annotationCanvasMap: De, operatorList: Be.operatorList, pageIndex: this._pageIndex, canvasFactory: this._transport.canvasFactory, filterFactory: this._transport.filterFactory, useRequestAnimationFrame: !Ie, pdfBug: this._pdfBug, pageColors: Pe }); (Be.renderTasks ||= new Set).add(ze); const qe = ze.task; return Promise.all([Be.displayReadyCapability.promise, Me]).then(([He, Ge]) => { if (this.destroyed) { Fe(); return } this._stats?.time("Rendering"), ze.initializeGraphics({ transparency: He, optionalContentConfig: Ge }), ze.operatorListChanged() }).catch(Fe), qe } getOperatorList({ intent: t = "display", annotationMode: xe = _util.AnnotationMode.ENABLE, printAnnotationStorage: Ee = null } = {}) { function _e() { Ce.operatorList.lastChunk && (Ce.opListReadCapability.resolve(Ce.operatorList), Ce.renderTasks.delete(Me)) } const Re = this._transport.getRenderingIntent(t, xe, Ee, !0); let Ce = this._intentStates.get(Re.cacheKey); Ce || (Ce = Object.create(null), this._intentStates.set(Re.cacheKey, Ce)); let Me; return Ce.opListReadCapability || (Me = Object.create(null), Me.operatorListChanged = _e, Ce.opListReadCapability = new _util.PromiseCapability, (Ce.renderTasks ||= new Set).add(Me), Ce.operatorList = { fnArray: [], argsArray: [], lastChunk: !1, separateAnnots: null }, this._stats?.time("Page Request"), this._pumpOperatorList(Re)), Ce.opListReadCapability.promise } streamTextContent({ includeMarkedContent: t = !1, disableNormalization: xe = !1 } = {}) { return this._transport.messageHandler.sendWithStream("GetTextContent", { pageIndex: this._pageIndex, includeMarkedContent: t === !0, disableNormalization: xe === !0 }, { highWaterMark: 100, size(_e) { return _e.items.length } }) } getTextContent(t = {}) { if (this._transport._htmlForXfa) return this.getXfa().then(Ee => _xfa_text.XfaText.textContent(Ee)); const xe = this.streamTextContent(t); return new Promise(function (Ee, _e) { function Re() { Ce.read().then(function ({ value: De, done: Pe }) { if (Pe) { Ee(Me); return } Object.assign(Me.styles, De.styles), Me.items.push(...De.items), Re() }, _e) } const Ce = xe.getReader(), Me = { items: [], styles: Object.create(null) }; Re() }) } getStructTree() { return this._transport.getStructTree(this._pageIndex) } _destroy() { this.destroyed = !0; const t = []; for (const xe of this._intentStates.values()) if (this._abortOperatorList({ intentState: xe, reason: new Error("Page was destroyed."), force: !0 }), !xe.opListReadCapability) for (const Ee of xe.renderTasks) t.push(Ee.completed), Ee.cancel(); return this.objs.clear(), this.#t = !1, this.#r(), Promise.all(t) } cleanup(t = !1) { this.#t = !0; const xe = this.#n(!1); return t && xe && (this._stats &&= new _display_utils.StatTimer), xe } #n(t = !1) { if (this.#r(), !this.#t || this.destroyed) return !1; if (t) return this.#e = setTimeout(() => { this.#e = null, this.#n(!1) }, DELAYED_CLEANUP_TIMEOUT), !1; for (const { renderTasks: xe, operatorList: Ee } of this._intentStates.values()) if (xe.size > 0 || !Ee.lastChunk) return !1; return this._intentStates.clear(), this.objs.clear(), this.#t = !1, !0 } #r() { this.#e && (clearTimeout(this.#e), this.#e = null) } _startRenderPage(t, xe) { const Ee = this._intentStates.get(xe); Ee && (this._stats?.timeEnd("Page Request"), Ee.displayReadyCapability?.resolve(t)) } _renderPageChunk(t, xe) { for (let Ee = 0, _e = t.length; Ee < _e; Ee++)xe.operatorList.fnArray.push(t.fnArray[Ee]), xe.operatorList.argsArray.push(t.argsArray[Ee]); xe.operatorList.lastChunk = t.lastChunk, xe.operatorList.separateAnnots = t.separateAnnots; for (const Ee of xe.renderTasks) Ee.operatorListChanged(); t.lastChunk && this.#n(!0) } _pumpOperatorList({ renderingIntent: t, cacheKey: xe, annotationStorageSerializable: Ee }) { const { map: _e, transfers: Re } = Ee, Me = this._transport.messageHandler.sendWithStream("GetOperatorList", { pageIndex: this._pageIndex, intent: t, cacheKey: xe, annotationStorage: _e }, Re).getReader(), De = this._intentStates.get(xe); De.streamReader = Me; const Pe = () => { Me.read().then(({ value: Oe, done: je }) => { if (je) { De.streamReader = null; return } this._transport.destroyed || (this._renderPageChunk(Oe, De), Pe()) }, Oe => { if (De.streamReader = null, !this._transport.destroyed) { if (De.operatorList) { De.operatorList.lastChunk = !0; for (const je of De.renderTasks) je.operatorListChanged(); this.#n(!0) } if (De.displayReadyCapability) De.displayReadyCapability.reject(Oe); else if (De.opListReadCapability) De.opListReadCapability.reject(Oe); else throw Oe } }) }; Pe() } _abortOperatorList({ intentState: t, reason: xe, force: Ee = !1 }) { if (t.streamReader) { if (t.streamReaderCancelTimeout && (clearTimeout(t.streamReaderCancelTimeout), t.streamReaderCancelTimeout = null), !Ee) { if (t.renderTasks.size > 0) return; if (xe instanceof _display_utils.RenderingCancelledException) { let _e = RENDERING_CANCELLED_TIMEOUT; xe.extraDelay > 0 && xe.extraDelay < 1e3 && (_e += xe.extraDelay), t.streamReaderCancelTimeout = setTimeout(() => { t.streamReaderCancelTimeout = null, this._abortOperatorList({ intentState: t, reason: xe, force: !0 }) }, _e); return } } if (t.streamReader.cancel(new _util.AbortException(xe.message)).catch(() => { }), t.streamReader = null, !this._transport.destroyed) { for (const [_e, Re] of this._intentStates) if (Re === t) { this._intentStates.delete(_e); break } this.cleanup() } } } get stats() { return this._stats } } exports.PDFPageProxy = PDFPageProxy; class LoopbackPort { #e = new Set; #t = Promise.resolve(); postMessage(t, xe) { const Ee = { data: structuredClone(t, xe ? { transfer: xe } : null) }; this.#t.then(() => { for (const _e of this.#e) _e.call(this, Ee) }) } addEventListener(t, xe) { this.#e.add(xe) } removeEventListener(t, xe) { this.#e.delete(xe) } terminate() { this.#e.clear() } } exports.LoopbackPort = LoopbackPort; const PDFWorkerUtil = { isWorkerDisabled: !1, fallbackWorkerSrc: null, fakeWorkerId: 0 }; exports.PDFWorkerUtil = PDFWorkerUtil; { if (_util.isNodeJS && typeof commonjsRequire == "function") PDFWorkerUtil.isWorkerDisabled = !0, PDFWorkerUtil.fallbackWorkerSrc = "./pdf.worker.js"; else if (typeof document == "object") { const e = document?.currentScript?.src; e && (PDFWorkerUtil.fallbackWorkerSrc = e.replace(/(\.(?:min\.)?js)(\?.*)?$/i, ".worker$1$2")) } PDFWorkerUtil.isSameOrigin = function (e, t) { let xe; try { if (xe = new URL(e), !xe.origin || xe.origin === "null") return !1 } catch { return !1 } const Ee = new URL(t, xe); return xe.origin === Ee.origin }, PDFWorkerUtil.createCDNWrapper = function (e) { const t = `importScripts("${e}");`; return URL.createObjectURL(new Blob([t])) } } class PDFWorker { static #workerPorts; constructor({ name: e = null, port: t = null, verbosity: xe = (0, _util.getVerbosityLevel)() } = {}) { if (this.name = e, this.destroyed = !1, this.verbosity = xe, this._readyCapability = new _util.PromiseCapability, this._port = null, this._webWorker = null, this._messageHandler = null, t) { if (PDFWorker.#workerPorts?.has(t)) throw new Error("Cannot use more than one PDFWorker per port."); (PDFWorker.#workerPorts ||= new WeakMap).set(t, this), this._initializeFromPort(t); return } this._initialize() } get promise() { return this._readyCapability.promise } get port() { return this._port } get messageHandler() { return this._messageHandler } _initializeFromPort(e) { this._port = e, this._messageHandler = new _message_handler.MessageHandler("main", "worker", e), this._messageHandler.on("ready", function () { }), this._readyCapability.resolve(), this._messageHandler.send("configure", { verbosity: this.verbosity }) } _initialize() { if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) { let { workerSrc: e } = PDFWorker; try { PDFWorkerUtil.isSameOrigin(window.location.href, e) || (e = PDFWorkerUtil.createCDNWrapper(new URL(e, window.location).href)); const t = new Worker(e), xe = new _message_handler.MessageHandler("main", "worker", t), Ee = () => { t.removeEventListener("error", _e), xe.destroy(), t.terminate(), this.destroyed ? this._readyCapability.reject(new Error("Worker was destroyed")) : this._setupFakeWorker() }, _e = () => { this._webWorker || Ee() }; t.addEventListener("error", _e), xe.on("test", Ce => { if (t.removeEventListener("error", _e), this.destroyed) { Ee(); return } Ce ? (this._messageHandler = xe, this._port = t, this._webWorker = t, this._readyCapability.resolve(), xe.send("configure", { verbosity: this.verbosity })) : (this._setupFakeWorker(), xe.destroy(), t.terminate()) }), xe.on("ready", Ce => { if (t.removeEventListener("error", _e), this.destroyed) { Ee(); return } try { Re() } catch { this._setupFakeWorker() } }); const Re = () => { const Ce = new Uint8Array; xe.send("test", Ce, [Ce.buffer]) }; Re(); return } catch { (0, _util.info)("The worker has been disabled.") } } this._setupFakeWorker() } _setupFakeWorker() { PDFWorkerUtil.isWorkerDisabled || ((0, _util.warn)("Setting up fake worker."), PDFWorkerUtil.isWorkerDisabled = !0), PDFWorker._setupFakeWorkerGlobal.then(e => { if (this.destroyed) { this._readyCapability.reject(new Error("Worker was destroyed")); return } const t = new LoopbackPort; this._port = t; const xe = `fake${PDFWorkerUtil.fakeWorkerId++}`, Ee = new _message_handler.MessageHandler(xe + "_worker", xe, t); e.setup(Ee, t); const _e = new _message_handler.MessageHandler(xe, xe + "_worker", t); this._messageHandler = _e, this._readyCapability.resolve(), _e.send("configure", { verbosity: this.verbosity }) }).catch(e => { this._readyCapability.reject(new Error(`Setting up fake worker failed: "${e.message}".`)) }) } destroy() { this.destroyed = !0, this._webWorker && (this._webWorker.terminate(), this._webWorker = null), PDFWorker.#workerPorts?.delete(this._port), this._port = null, this._messageHandler && (this._messageHandler.destroy(), this._messageHandler = null) } static fromPort(e) { if (!e?.port) throw new Error("PDFWorker.fromPort - invalid method signature."); const t = this.#workerPorts?.get(e.port); if (t) { if (t._pendingDestroy) throw new Error("PDFWorker.fromPort - the worker is being destroyed.\nPlease remember to await `PDFDocumentLoadingTask.destroy()`-calls."); return t } return new PDFWorker(e) } static get workerSrc() { if (_worker_options.GlobalWorkerOptions.workerSrc) return _worker_options.GlobalWorkerOptions.workerSrc; if (PDFWorkerUtil.fallbackWorkerSrc !== null) return _util.isNodeJS || (0, _display_utils.deprecated)('No "GlobalWorkerOptions.workerSrc" specified.'), PDFWorkerUtil.fallbackWorkerSrc; throw new Error('No "GlobalWorkerOptions.workerSrc" specified.') } static get _mainThreadWorkerMessageHandler() { try { return globalThis.pdfjsWorker?.WorkerMessageHandler || null } catch { return null } } static get _setupFakeWorkerGlobal() { const loader = async () => { const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler; if (mainWorkerMessageHandler) return mainWorkerMessageHandler; if (_util.isNodeJS && typeof commonjsRequire == "function") { const worker = eval("require")(this.workerSrc); return worker.WorkerMessageHandler } return await (0, _display_utils.loadScript)(this.workerSrc), window.pdfjsWorker.WorkerMessageHandler }; return (0, _util.shadow)(this, "_setupFakeWorkerGlobal", loader()) } } exports.PDFWorker = PDFWorker; class WorkerTransport { #e = new Map; #t = new Map; #n = new Map; #r = null; constructor(t, xe, Ee, _e, Re) { this.messageHandler = t, this.loadingTask = xe, this.commonObjs = new PDFObjects, this.fontLoader = new _font_loader.FontLoader({ ownerDocument: _e.ownerDocument, styleElement: _e.styleElement }), this._params = _e, this.canvasFactory = Re.canvasFactory, this.filterFactory = Re.filterFactory, this.cMapReaderFactory = Re.cMapReaderFactory, this.standardFontDataFactory = Re.standardFontDataFactory, this.destroyed = !1, this.destroyCapability = null, this._networkStream = Ee, this._fullReader = null, this._lastProgress = null, this.downloadInfoCapability = new _util.PromiseCapability, this.setupMessageHandler() } #a(t, xe = null) { const Ee = this.#e.get(t); if (Ee) return Ee; const _e = this.messageHandler.sendWithPromise(t, xe); return this.#e.set(t, _e), _e } get annotationStorage() { return (0, _util.shadow)(this, "annotationStorage", new _annotation_storage.AnnotationStorage) } getRenderingIntent(t, xe = _util.AnnotationMode.ENABLE, Ee = null, _e = !1) { let Re = _util.RenderingIntentFlag.DISPLAY, Ce = _annotation_storage.SerializableEmpty; switch (t) { case "any": Re = _util.RenderingIntentFlag.ANY; break; case "display": break; case "print": Re = _util.RenderingIntentFlag.PRINT; break; default: (0, _util.warn)(`getRenderingIntent - invalid intent: ${t}`) }switch (xe) { case _util.AnnotationMode.DISABLE: Re += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE; break; case _util.AnnotationMode.ENABLE: break; case _util.AnnotationMode.ENABLE_FORMS: Re += _util.RenderingIntentFlag.ANNOTATIONS_FORMS; break; case _util.AnnotationMode.ENABLE_STORAGE: Re += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE, Ce = (Re & _util.RenderingIntentFlag.PRINT && Ee instanceof _annotation_storage.PrintAnnotationStorage ? Ee : this.annotationStorage).serializable; break; default: (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${xe}`) }return _e && (Re += _util.RenderingIntentFlag.OPLIST), { renderingIntent: Re, cacheKey: `${Re}_${Ce.hash}`, annotationStorageSerializable: Ce } } destroy() { if (this.destroyCapability) return this.destroyCapability.promise; this.destroyed = !0, this.destroyCapability = new _util.PromiseCapability, this.#r?.reject(new Error("Worker was destroyed during onPassword callback")); const t = []; for (const Ee of this.#t.values()) t.push(Ee._destroy()); this.#t.clear(), this.#n.clear(), this.hasOwnProperty("annotationStorage") && this.annotationStorage.resetModified(); const xe = this.messageHandler.sendWithPromise("Terminate", null); return t.push(xe), Promise.all(t).then(() => { this.commonObjs.clear(), this.fontLoader.clear(), this.#e.clear(), this.filterFactory.destroy(), this._networkStream?.cancelAllRequests(new _util.AbortException("Worker was terminated.")), this.messageHandler && (this.messageHandler.destroy(), this.messageHandler = null), this.destroyCapability.resolve() }, this.destroyCapability.reject), this.destroyCapability.promise } setupMessageHandler() { const { messageHandler: t, loadingTask: xe } = this; t.on("GetReader", (Ee, _e) => { (0, _util.assert)(this._networkStream, "GetReader - no `IPDFStream` instance available."), this._fullReader = this._networkStream.getFullReader(), this._fullReader.onProgress = Re => { this._lastProgress = { loaded: Re.loaded, total: Re.total } }, _e.onPull = () => { this._fullReader.read().then(function ({ value: Re, done: Ce }) { if (Ce) { _e.close(); return } (0, _util.assert)(Re instanceof ArrayBuffer, "GetReader - expected an ArrayBuffer."), _e.enqueue(new Uint8Array(Re), 1, [Re]) }).catch(Re => { _e.error(Re) }) }, _e.onCancel = Re => { this._fullReader.cancel(Re), _e.ready.catch(Ce => { if (!this.destroyed) throw Ce }) } }), t.on("ReaderHeadersReady", Ee => { const _e = new _util.PromiseCapability, Re = this._fullReader; return Re.headersReady.then(() => { (!Re.isStreamingSupported || !Re.isRangeSupported) && (this._lastProgress && xe.onProgress?.(this._lastProgress), Re.onProgress = Ce => { xe.onProgress?.({ loaded: Ce.loaded, total: Ce.total }) }), _e.resolve({ isStreamingSupported: Re.isStreamingSupported, isRangeSupported: Re.isRangeSupported, contentLength: Re.contentLength }) }, _e.reject), _e.promise }), t.on("GetRangeReader", (Ee, _e) => { (0, _util.assert)(this._networkStream, "GetRangeReader - no `IPDFStream` instance available."); const Re = this._networkStream.getRangeReader(Ee.begin, Ee.end); if (!Re) { _e.close(); return } _e.onPull = () => { Re.read().then(function ({ value: Ce, done: Me }) { if (Me) { _e.close(); return } (0, _util.assert)(Ce instanceof ArrayBuffer, "GetRangeReader - expected an ArrayBuffer."), _e.enqueue(new Uint8Array(Ce), 1, [Ce]) }).catch(Ce => { _e.error(Ce) }) }, _e.onCancel = Ce => { Re.cancel(Ce), _e.ready.catch(Me => { if (!this.destroyed) throw Me }) } }), t.on("GetDoc", ({ pdfInfo: Ee }) => { this._numPages = Ee.numPages, this._htmlForXfa = Ee.htmlForXfa, delete Ee.htmlForXfa, xe._capability.resolve(new PDFDocumentProxy(Ee, this)) }), t.on("DocException", function (Ee) { let _e; switch (Ee.name) { case "PasswordException": _e = new _util.PasswordException(Ee.message, Ee.code); break; case "InvalidPDFException": _e = new _util.InvalidPDFException(Ee.message); break; case "MissingPDFException": _e = new _util.MissingPDFException(Ee.message); break; case "UnexpectedResponseException": _e = new _util.UnexpectedResponseException(Ee.message, Ee.status); break; case "UnknownErrorException": _e = new _util.UnknownErrorException(Ee.message, Ee.details); break; default: (0, _util.unreachable)("DocException - expected a valid Error.") }xe._capability.reject(_e) }), t.on("PasswordRequest", Ee => { if (this.#r = new _util.PromiseCapability, xe.onPassword) { const _e = Re => { Re instanceof Error ? this.#r.reject(Re) : this.#r.resolve({ password: Re }) }; try { xe.onPassword(_e, Ee.code) } catch (Re) { this.#r.reject(Re) } } else this.#r.reject(new _util.PasswordException(Ee.message, Ee.code)); return this.#r.promise }), t.on("DataLoaded", Ee => { xe.onProgress?.({ loaded: Ee.length, total: Ee.length }), this.downloadInfoCapability.resolve(Ee) }), t.on("StartRenderPage", Ee => { if (this.destroyed) return; this.#t.get(Ee.pageIndex)._startRenderPage(Ee.transparency, Ee.cacheKey) }), t.on("commonobj", ([Ee, _e, Re]) => { if (!this.destroyed && !this.commonObjs.has(Ee)) switch (_e) { case "Font": const Ce = this._params; if ("error" in Re) { const Pe = Re.error; (0, _util.warn)(`Error during font loading: ${Pe}`), this.commonObjs.resolve(Ee, Pe); break } const Me = Ce.pdfBug && globalThis.FontInspector?.enabled ? (Pe, Oe) => globalThis.FontInspector.fontAdded(Pe, Oe) : null, De = new _font_loader.FontFaceObject(Re, { isEvalSupported: Ce.isEvalSupported, disableFontFace: Ce.disableFontFace, ignoreErrors: Ce.ignoreErrors, inspectFont: Me }); this.fontLoader.bind(De).catch(Pe => t.sendWithPromise("FontFallback", { id: Ee })).finally(() => { !Ce.fontExtraProperties && De.data && (De.data = null), this.commonObjs.resolve(Ee, De) }); break; case "FontPath": case "Image": case "Pattern": this.commonObjs.resolve(Ee, Re); break; default: throw new Error(`Got unknown common object type ${_e}`) } }), t.on("obj", ([Ee, _e, Re, Ce]) => { if (this.destroyed) return; const Me = this.#t.get(_e); if (!Me.objs.has(Ee)) switch (Re) { case "Image": if (Me.objs.resolve(Ee, Ce), Ce) { let De; if (Ce.bitmap) { const { width: Pe, height: Oe } = Ce; De = Pe * Oe * 4 } else De = Ce.data?.length || 0; De > _util.MAX_IMAGE_SIZE_TO_CACHE && (Me._maybeCleanupAfterRender = !0) } break; case "Pattern": Me.objs.resolve(Ee, Ce); break; default: throw new Error(`Got unknown object type ${Re}`) } }), t.on("DocProgress", Ee => { this.destroyed || xe.onProgress?.({ loaded: Ee.loaded, total: Ee.total }) }), t.on("FetchBuiltInCMap", Ee => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.cMapReaderFactory ? this.cMapReaderFactory.fetch(Ee) : Promise.reject(new Error("CMapReaderFactory not initialized, see the `useWorkerFetch` parameter."))), t.on("FetchStandardFontData", Ee => this.destroyed ? Promise.reject(new Error("Worker was destroyed.")) : this.standardFontDataFactory ? this.standardFontDataFactory.fetch(Ee) : Promise.reject(new Error("StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter."))) } getData() { return this.messageHandler.sendWithPromise("GetData", null) } saveDocument() { this.annotationStorage.size <= 0 && (0, _util.warn)("saveDocument called while `annotationStorage` is empty, please use the getData-method instead."); const { map: t, transfers: xe } = this.annotationStorage.serializable; return this.messageHandler.sendWithPromise("SaveDocument", { isPureXfa: !!this._htmlForXfa, numPages: this._numPages, annotationStorage: t, filename: this._fullReader?.filename ?? null }, xe).finally(() => { this.annotationStorage.resetModified() }) } getPage(t) { if (!Number.isInteger(t) || t <= 0 || t > this._numPages) return Promise.reject(new Error("Invalid page request.")); const xe = t - 1, Ee = this.#n.get(xe); if (Ee) return Ee; const _e = this.messageHandler.sendWithPromise("GetPage", { pageIndex: xe }).then(Re => { if (this.destroyed) throw new Error("Transport destroyed"); const Ce = new PDFPageProxy(xe, Re, this, this._params.pdfBug); return this.#t.set(xe, Ce), Ce }); return this.#n.set(xe, _e), _e } getPageIndex(t) { return typeof t != "object" || t === null || !Number.isInteger(t.num) || t.num < 0 || !Number.isInteger(t.gen) || t.gen < 0 ? Promise.reject(new Error("Invalid pageIndex request.")) : this.messageHandler.sendWithPromise("GetPageIndex", { num: t.num, gen: t.gen }) } getAnnotations(t, xe) { return this.messageHandler.sendWithPromise("GetAnnotations", { pageIndex: t, intent: xe }) } getFieldObjects() { return this.#a("GetFieldObjects") } hasJSActions() { return this.#a("HasJSActions") } getCalculationOrderIds() { return this.messageHandler.sendWithPromise("GetCalculationOrderIds", null) } getDestinations() { return this.messageHandler.sendWithPromise("GetDestinations", null) } getDestination(t) { return typeof t != "string" ? Promise.reject(new Error("Invalid destination request.")) : this.messageHandler.sendWithPromise("GetDestination", { id: t }) } getPageLabels() { return this.messageHandler.sendWithPromise("GetPageLabels", null) } getPageLayout() { return this.messageHandler.sendWithPromise("GetPageLayout", null) } getPageMode() { return this.messageHandler.sendWithPromise("GetPageMode", null) } getViewerPreferences() { return this.messageHandler.sendWithPromise("GetViewerPreferences", null) } getOpenAction() { return this.messageHandler.sendWithPromise("GetOpenAction", null) } getAttachments() { return this.messageHandler.sendWithPromise("GetAttachments", null) } getDocJSActions() { return this.#a("GetDocJSActions") } getPageJSActions(t) { return this.messageHandler.sendWithPromise("GetPageJSActions", { pageIndex: t }) } getStructTree(t) { return this.messageHandler.sendWithPromise("GetStructTree", { pageIndex: t }) } getOutline() { return this.messageHandler.sendWithPromise("GetOutline", null) } getOptionalContentConfig() { return this.messageHandler.sendWithPromise("GetOptionalContentConfig", null).then(t => new _optional_content_config.OptionalContentConfig(t)) } getPermissions() { return this.messageHandler.sendWithPromise("GetPermissions", null) } getMetadata() { const t = "GetMetadata", xe = this.#e.get(t); if (xe) return xe; const Ee = this.messageHandler.sendWithPromise(t, null).then(_e => ({ info: _e[0], metadata: _e[1] ? new _metadata.Metadata(_e[1]) : null, contentDispositionFilename: this._fullReader?.filename ?? null, contentLength: this._fullReader?.contentLength ?? null })); return this.#e.set(t, Ee), Ee } getMarkInfo() { return this.messageHandler.sendWithPromise("GetMarkInfo", null) } async startCleanup(t = !1) { if (!this.destroyed) { await this.messageHandler.sendWithPromise("Cleanup", null); for (const xe of this.#t.values()) if (!xe.cleanup()) throw new Error(`startCleanup: Page ${xe.pageNumber} is currently rendering.`); this.commonObjs.clear(), t || this.fontLoader.clear(), this.#e.clear(), this.filterFactory.destroy(!0) } } get loadingParams() { const { disableAutoFetch: t, enableXfa: xe } = this._params; return (0, _util.shadow)(this, "loadingParams", { disableAutoFetch: t, enableXfa: xe }) } } class PDFObjects { #e = Object.create(null); #t(t) { return this.#e[t] ||= { capability: new _util.PromiseCapability, data: null } } get(t, xe = null) { if (xe) { const _e = this.#t(t); return _e.capability.promise.then(() => xe(_e.data)), null } const Ee = this.#e[t]; if (!Ee?.capability.settled) throw new Error(`Requesting object that isn't resolved yet ${t}.`); return Ee.data } has(t) { return this.#e[t]?.capability.settled || !1 } resolve(t, xe = null) { const Ee = this.#t(t); Ee.data = xe, Ee.capability.resolve() } clear() { for (const t in this.#e) { const { data: xe } = this.#e[t]; xe?.bitmap?.close() } this.#e = Object.create(null) } } class RenderTask { #e = null; constructor(t) { this.#e = t, this.onContinue = null } get promise() { return this.#e.capability.promise } cancel(t = 0) { this.#e.cancel(null, t) } get separateAnnots() { const { separateAnnots: t } = this.#e.operatorList; if (!t) return !1; const { annotationCanvasMap: xe } = this.#e; return t.form || t.canvas && xe?.size > 0 } } exports.RenderTask = RenderTask; class InternalRenderTask { static #e = new WeakSet; constructor({ callback: t, params: xe, objs: Ee, commonObjs: _e, annotationCanvasMap: Re, operatorList: Ce, pageIndex: Me, canvasFactory: De, filterFactory: Pe, useRequestAnimationFrame: Oe = !1, pdfBug: je = !1, pageColors: Be = null }) { this.callback = t, this.params = xe, this.objs = Ee, this.commonObjs = _e, this.annotationCanvasMap = Re, this.operatorListIdx = null, this.operatorList = Ce, this._pageIndex = Me, this.canvasFactory = De, this.filterFactory = Pe, this._pdfBug = je, this.pageColors = Be, this.running = !1, this.graphicsReadyCallback = null, this.graphicsReady = !1, this._useRequestAnimationFrame = Oe === !0 && typeof window < "u", this.cancelled = !1, this.capability = new _util.PromiseCapability, this.task = new RenderTask(this), this._cancelBound = this.cancel.bind(this), this._continueBound = this._continue.bind(this), this._scheduleNextBound = this._scheduleNext.bind(this), this._nextBound = this._next.bind(this), this._canvas = xe.canvasContext.canvas } get completed() { return this.capability.promise.catch(function () { }) } initializeGraphics({ transparency: t = !1, optionalContentConfig: xe }) { if (this.cancelled) return; if (this._canvas) { if (InternalRenderTask.#e.has(this._canvas)) throw new Error("Cannot use the same canvas during multiple render() operations. Use different canvas or ensure previous operations were cancelled or completed."); InternalRenderTask.#e.add(this._canvas) } this._pdfBug && globalThis.StepperManager?.enabled && (this.stepper = globalThis.StepperManager.create(this._pageIndex), this.stepper.init(this.operatorList), this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint()); const { canvasContext: Ee, viewport: _e, transform: Re, background: Ce } = this.params; this.gfx = new _canvas.CanvasGraphics(Ee, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: xe }, this.annotationCanvasMap, this.pageColors), this.gfx.beginDrawing({ transform: Re, viewport: _e, transparency: t, background: Ce }), this.operatorListIdx = 0, this.graphicsReady = !0, this.graphicsReadyCallback?.() } cancel(t = null, xe = 0) { this.running = !1, this.cancelled = !0, this.gfx?.endDrawing(), InternalRenderTask.#e.delete(this._canvas), this.callback(t || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, xe)) } operatorListChanged() { if (!this.graphicsReady) { this.graphicsReadyCallback ||= this._continueBound; return } this.stepper?.updateOperatorList(this.operatorList), !this.running && this._continue() } _continue() { this.running = !0, !this.cancelled && (this.task.onContinue ? this.task.onContinue(this._scheduleNextBound) : this._scheduleNext()) } _scheduleNext() { this._useRequestAnimationFrame ? window.requestAnimationFrame(() => { this._nextBound().catch(this._cancelBound) }) : Promise.resolve().then(this._nextBound).catch(this._cancelBound) } async _next() { this.cancelled || (this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper), this.operatorListIdx === this.operatorList.argsArray.length && (this.running = !1, this.operatorList.lastChunk && (this.gfx.endDrawing(), InternalRenderTask.#e.delete(this._canvas), this.callback()))) } } const version = "3.11.174"; exports.version = version; const build = "ce8716743"; exports.build = build }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.SerializableEmpty = t.PrintAnnotationStorage = t.AnnotationStorage = void 0; var Ee = xe(1), _e = xe(4), Re = xe(8); const Ce = Object.freeze({ map: null, hash: "", transfers: void 0 }); t.SerializableEmpty = Ce; class Me { #e = !1; #t = new Map; constructor() { this.onSetModified = null, this.onResetModified = null, this.onAnnotationEditor = null } getValue(Oe, je) { const Be = this.#t.get(Oe); return Be === void 0 ? je : Object.assign(je, Be) } getRawValue(Oe) { return this.#t.get(Oe) } remove(Oe) { if (this.#t.delete(Oe), this.#t.size === 0 && this.resetModified(), typeof this.onAnnotationEditor == "function") { for (const je of this.#t.values()) if (je instanceof _e.AnnotationEditor) return; this.onAnnotationEditor(null) } } setValue(Oe, je) { const Be = this.#t.get(Oe); let Ie = !1; if (Be !== void 0) for (const [Fe, ze] of Object.entries(je)) Be[Fe] !== ze && (Ie = !0, Be[Fe] = ze); else Ie = !0, this.#t.set(Oe, je); Ie && this.#n(), je instanceof _e.AnnotationEditor && typeof this.onAnnotationEditor == "function" && this.onAnnotationEditor(je.constructor._type) } has(Oe) { return this.#t.has(Oe) } getAll() { return this.#t.size > 0 ? (0, Ee.objectFromMap)(this.#t) : null } setAll(Oe) { for (const [je, Be] of Object.entries(Oe)) this.setValue(je, Be) } get size() { return this.#t.size } #n() { this.#e || (this.#e = !0, typeof this.onSetModified == "function" && this.onSetModified()) } resetModified() { this.#e && (this.#e = !1, typeof this.onResetModified == "function" && this.onResetModified()) } get print() { return new De(this) } get serializable() { if (this.#t.size === 0) return Ce; const Oe = new Map, je = new Re.MurmurHash3_64, Be = [], Ie = Object.create(null); let Fe = !1; for (const [ze, qe] of this.#t) { const He = qe instanceof _e.AnnotationEditor ? qe.serialize(!1, Ie) : qe; He && (Oe.set(ze, He), je.update(`${ze}:${JSON.stringify(He)}`), Fe ||= !!He.bitmap) } if (Fe) for (const ze of Oe.values()) ze.bitmap && Be.push(ze.bitmap); return Oe.size > 0 ? { map: Oe, hash: je.hexdigest(), transfers: Be } : Ce } } t.AnnotationStorage = Me; class De extends Me { #e; constructor(Oe) { super(); const { map: je, hash: Be, transfers: Ie } = Oe.serializable, Fe = structuredClone(je, Ie ? { transfer: Ie } : null); this.#e = { map: Fe, hash: Be, transfers: Ie } } get print() { (0, Ee.unreachable)("Should not call PrintAnnotationStorage.print") } get serializable() { return this.#e } } t.PrintAnnotationStorage = De }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.AnnotationEditor = void 0; var Ee = xe(5), _e = xe(1), Re = xe(6); class Ce { #e = ""; #t = !1; #n = null; #r = null; #a = null; #o = !1; #s = null; #l = this.focusin.bind(this); #c = this.focusout.bind(this); #i = !1; #p = !1; #u = !1; _initialOptions = Object.create(null); _uiManager = null; _focusEventsAllowed = !0; _l10nPromise = null; #h = !1; #f = Ce._zIndex++; static _borderLineWidth = -1; static _colorManager = new Ee.ColorManager; static _zIndex = 1; static SMALL_EDITOR_SIZE = 0; constructor(Pe) { this.constructor === Ce && (0, _e.unreachable)("Cannot initialize AnnotationEditor."), this.parent = Pe.parent, this.id = Pe.id, this.width = this.height = null, this.pageIndex = Pe.parent.pageIndex, this.name = Pe.name, this.div = null, this._uiManager = Pe.uiManager, this.annotationElementId = null, this._willKeepAspectRatio = !1, this._initialOptions.isCentered = Pe.isCentered, this._structTreeParentId = null; const { rotation: Oe, rawDims: { pageWidth: je, pageHeight: Be, pageX: Ie, pageY: Fe } } = this.parent.viewport; this.rotation = Oe, this.pageRotation = (360 + Oe - this._uiManager.viewParameters.rotation) % 360, this.pageDimensions = [je, Be], this.pageTranslation = [Ie, Fe]; const [ze, qe] = this.parentDimensions; this.x = Pe.x / ze, this.y = Pe.y / qe, this.isAttachedToDOM = !1, this.deleted = !1 } get editorType() { return Object.getPrototypeOf(this).constructor._type } static get _defaultLineColor() { return (0, _e.shadow)(this, "_defaultLineColor", this._colorManager.getHexCode("CanvasText")) } static deleteAnnotationElement(Pe) { const Oe = new Me({ id: Pe.parent.getNextId(), parent: Pe.parent, uiManager: Pe._uiManager }); Oe.annotationElementId = Pe.annotationElementId, Oe.deleted = !0, Oe._uiManager.addToAnnotationStorage(Oe) } static initialize(Pe, Oe = null) { if (Ce._l10nPromise ||= new Map(["editor_alt_text_button_label", "editor_alt_text_edit_button_label", "editor_alt_text_decorative_tooltip"].map(Be => [Be, Pe.get(Be)])), Oe?.strings) for (const Be of Oe.strings) Ce._l10nPromise.set(Be, Pe.get(Be)); if (Ce._borderLineWidth !== -1) return; const je = getComputedStyle(document.documentElement); Ce._borderLineWidth = parseFloat(je.getPropertyValue("--outline-width")) || 0 } static updateDefaultParams(Pe, Oe) { } static get defaultPropertiesToUpdate() { return [] } static isHandlingMimeForPasting(Pe) { return !1 } static paste(Pe, Oe) { (0, _e.unreachable)("Not implemented") } get propertiesToUpdate() { return [] } get _isDraggable() { return this.#h } set _isDraggable(Pe) { this.#h = Pe, this.div?.classList.toggle("draggable", Pe) } center() { const [Pe, Oe] = this.pageDimensions; switch (this.parentRotation) { case 90: this.x -= this.height * Oe / (Pe * 2), this.y += this.width * Pe / (Oe * 2); break; case 180: this.x += this.width / 2, this.y += this.height / 2; break; case 270: this.x += this.height * Oe / (Pe * 2), this.y -= this.width * Pe / (Oe * 2); break; default: this.x -= this.width / 2, this.y -= this.height / 2; break }this.fixAndSetPosition() } addCommands(Pe) { this._uiManager.addCommands(Pe) } get currentLayer() { return this._uiManager.currentLayer } setInBackground() { this.div.style.zIndex = 0 } setInForeground() { this.div.style.zIndex = this.#f } setParent(Pe) { Pe !== null && (this.pageIndex = Pe.pageIndex, this.pageDimensions = Pe.pageDimensions), this.parent = Pe } focusin(Pe) { this._focusEventsAllowed && (this.#i ? this.#i = !1 : this.parent.setSelected(this)) } focusout(Pe) { !this._focusEventsAllowed || !this.isAttachedToDOM || Pe.relatedTarget?.closest(`#${this.id}`) || (Pe.preventDefault(), this.parent?.isMultipleSelection || this.commitOrRemove()) } commitOrRemove() { this.isEmpty() ? this.remove() : this.commit() } commit() { this.addToAnnotationStorage() } addToAnnotationStorage() { this._uiManager.addToAnnotationStorage(this) } setAt(Pe, Oe, je, Be) { const [Ie, Fe] = this.parentDimensions;[je, Be] = this.screenToPageTranslation(je, Be), this.x = (Pe + je) / Ie, this.y = (Oe + Be) / Fe, this.fixAndSetPosition() } #v([Pe, Oe], je, Be) { [je, Be] = this.screenToPageTranslation(je, Be), this.x += je / Pe, this.y += Be / Oe, this.fixAndSetPosition() } translate(Pe, Oe) { this.#v(this.parentDimensions, Pe, Oe) } translateInPage(Pe, Oe) { this.#v(this.pageDimensions, Pe, Oe), this.div.scrollIntoView({ block: "nearest" }) } drag(Pe, Oe) { const [je, Be] = this.parentDimensions; if (this.x += Pe / je, this.y += Oe / Be, this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) { const { x: He, y: Ge } = this.div.getBoundingClientRect(); this.parent.findNewParent(this, He, Ge) && (this.x -= Math.floor(this.x), this.y -= Math.floor(this.y)) } let { x: Ie, y: Fe } = this; const [ze, qe] = this.#m(); Ie += ze, Fe += qe, this.div.style.left = `${(100 * Ie).toFixed(2)}%`, this.div.style.top = `${(100 * Fe).toFixed(2)}%`, this.div.scrollIntoView({ block: "nearest" }) } #m() { const [Pe, Oe] = this.parentDimensions, { _borderLineWidth: je } = Ce, Be = je / Pe, Ie = je / Oe; switch (this.rotation) { case 90: return [-Be, Ie]; case 180: return [Be, Ie]; case 270: return [Be, -Ie]; default: return [-Be, -Ie] } } fixAndSetPosition() { const [Pe, Oe] = this.pageDimensions; let { x: je, y: Be, width: Ie, height: Fe } = this; switch (Ie *= Pe, Fe *= Oe, je *= Pe, Be *= Oe, this.rotation) { case 0: je = Math.max(0, Math.min(Pe - Ie, je)), Be = Math.max(0, Math.min(Oe - Fe, Be)); break; case 90: je = Math.max(0, Math.min(Pe - Fe, je)), Be = Math.min(Oe, Math.max(Ie, Be)); break; case 180: je = Math.min(Pe, Math.max(Ie, je)), Be = Math.min(Oe, Math.max(Fe, Be)); break; case 270: je = Math.min(Pe, Math.max(Fe, je)), Be = Math.max(0, Math.min(Oe - Ie, Be)); break }this.x = je /= Pe, this.y = Be /= Oe; const [ze, qe] = this.#m(); je += ze, Be += qe; const { style: He } = this.div; He.left = `${(100 * je).toFixed(2)}%`, He.top = `${(100 * Be).toFixed(2)}%`, this.moveInDOM() } static #g(Pe, Oe, je) { switch (je) { case 90: return [Oe, -Pe]; case 180: return [-Pe, -Oe]; case 270: return [-Oe, Pe]; default: return [Pe, Oe] } } screenToPageTranslation(Pe, Oe) { return Ce.#g(Pe, Oe, this.parentRotation) } pageTranslationToScreen(Pe, Oe) { return Ce.#g(Pe, Oe, 360 - this.parentRotation) } #d(Pe) { switch (Pe) { case 90: { const [Oe, je] = this.pageDimensions; return [0, -Oe / je, je / Oe, 0] } case 180: return [-1, 0, 0, -1]; case 270: { const [Oe, je] = this.pageDimensions; return [0, Oe / je, -je / Oe, 0] } default: return [1, 0, 0, 1] } } get parentScale() { return this._uiManager.viewParameters.realScale } get parentRotation() { return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360 } get parentDimensions() { const { parentScale: Pe, pageDimensions: [Oe, je] } = this, Be = Oe * Pe, Ie = je * Pe; return _e.FeatureTest.isCSSRoundSupported ? [Math.round(Be), Math.round(Ie)] : [Be, Ie] } setDims(Pe, Oe) { const [je, Be] = this.parentDimensions; this.div.style.width = `${(100 * Pe / je).toFixed(2)}%`, this.#o || (this.div.style.height = `${(100 * Oe / Be).toFixed(2)}%`), this.#n?.classList.toggle("small", Pe < Ce.SMALL_EDITOR_SIZE || Oe < Ce.SMALL_EDITOR_SIZE) } fixDims() { const { style: Pe } = this.div, { height: Oe, width: je } = Pe, Be = je.endsWith("%"), Ie = !this.#o && Oe.endsWith("%"); if (Be && Ie) return; const [Fe, ze] = this.parentDimensions; Be || (Pe.width = `${(100 * parseFloat(je) / Fe).toFixed(2)}%`), !this.#o && !Ie && (Pe.height = `${(100 * parseFloat(Oe) / ze).toFixed(2)}%`) } getInitialTranslation() { return [0, 0] } #b() { if (this.#s) return; this.#s = document.createElement("div"), this.#s.classList.add("resizers"); const Pe = ["topLeft", "topRight", "bottomRight", "bottomLeft"]; this._willKeepAspectRatio || Pe.push("topMiddle", "middleRight", "bottomMiddle", "middleLeft"); for (const Oe of Pe) { const je = document.createElement("div"); this.#s.append(je), je.classList.add("resizer", Oe), je.addEventListener("pointerdown", this.#y.bind(this, Oe)), je.addEventListener("contextmenu", Re.noContextMenu) } this.div.prepend(this.#s) } #y(Pe, Oe) { Oe.preventDefault(); const { isMac: je } = _e.FeatureTest.platform; if (Oe.button !== 0 || Oe.ctrlKey && je) return; const Be = this.#x.bind(this, Pe), Ie = this._isDraggable; this._isDraggable = !1; const Fe = { passive: !0, capture: !0 }; window.addEventListener("pointermove", Be, Fe); const ze = this.x, qe = this.y, He = this.width, Ge = this.height, Ze = this.parent.div.style.cursor, sn = this.div.style.cursor; this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(Oe.target).cursor; const Xe = () => { this._isDraggable = Ie, window.removeEventListener("pointerup", Xe), window.removeEventListener("blur", Xe), window.removeEventListener("pointermove", Be, Fe), this.parent.div.style.cursor = Ze, this.div.style.cursor = sn; const St = this.x, un = this.y, on = this.width, bn = this.height; St === ze && un === qe && on === He && bn === Ge || this.addCommands({ cmd: () => { this.width = on, this.height = bn, this.x = St, this.y = un; const [Tn, fn] = this.parentDimensions; this.setDims(Tn * on, fn * bn), this.fixAndSetPosition() }, undo: () => { this.width = He, this.height = Ge, this.x = ze, this.y = qe; const [Tn, fn] = this.parentDimensions; this.setDims(Tn * He, fn * Ge), this.fixAndSetPosition() }, mustExec: !0 }) }; window.addEventListener("pointerup", Xe), window.addEventListener("blur", Xe) } #x(Pe, Oe) { const [je, Be] = this.parentDimensions, Ie = this.x, Fe = this.y, ze = this.width, qe = this.height, He = Ce.MIN_SIZE / je, Ge = Ce.MIN_SIZE / Be, Ze = mn => Math.round(mn * 1e4) / 1e4, sn = this.#d(this.rotation), Xe = (mn, Ye) => [sn[0] * mn + sn[2] * Ye, sn[1] * mn + sn[3] * Ye], St = this.#d(360 - this.rotation), un = (mn, Ye) => [St[0] * mn + St[2] * Ye, St[1] * mn + St[3] * Ye]; let on, bn, Tn = !1, fn = !1; switch (Pe) { case "topLeft": Tn = !0, on = (mn, Ye) => [0, 0], bn = (mn, Ye) => [mn, Ye]; break; case "topMiddle": on = (mn, Ye) => [mn / 2, 0], bn = (mn, Ye) => [mn / 2, Ye]; break; case "topRight": Tn = !0, on = (mn, Ye) => [mn, 0], bn = (mn, Ye) => [0, Ye]; break; case "middleRight": fn = !0, on = (mn, Ye) => [mn, Ye / 2], bn = (mn, Ye) => [0, Ye / 2]; break; case "bottomRight": Tn = !0, on = (mn, Ye) => [mn, Ye], bn = (mn, Ye) => [0, 0]; break; case "bottomMiddle": on = (mn, Ye) => [mn / 2, Ye], bn = (mn, Ye) => [mn / 2, 0]; break; case "bottomLeft": Tn = !0, on = (mn, Ye) => [0, Ye], bn = (mn, Ye) => [mn, 0]; break; case "middleLeft": fn = !0, on = (mn, Ye) => [0, Ye / 2], bn = (mn, Ye) => [mn, Ye / 2]; break }const En = on(ze, qe), Pn = bn(ze, qe); let Rn = Xe(...Pn); const In = Ze(Ie + Rn[0]), xn = Ze(Fe + Rn[1]); let vn = 1, tn = 1, [nn, We] = this.screenToPageTranslation(Oe.movementX, Oe.movementY); if ([nn, We] = un(nn / je, We / Be), Tn) { const mn = Math.hypot(ze, qe); vn = tn = Math.max(Math.min(Math.hypot(Pn[0] - En[0] - nn, Pn[1] - En[1] - We) / mn, 1 / ze, 1 / qe), He / ze, Ge / qe) } else fn ? vn = Math.max(He, Math.min(1, Math.abs(Pn[0] - En[0] - nn))) / ze : tn = Math.max(Ge, Math.min(1, Math.abs(Pn[1] - En[1] - We))) / qe; const dn = Ze(ze * vn), Je = Ze(qe * tn); Rn = Xe(...bn(dn, Je)); const rn = In - Rn[0], hn = xn - Rn[1]; this.width = dn, this.height = Je, this.x = rn, this.y = hn, this.setDims(je * dn, Be * Je), this.fixAndSetPosition() } async addAltTextButton() { if (this.#n) return; const Pe = this.#n = document.createElement("button"); Pe.className = "altText"; const Oe = await Ce._l10nPromise.get("editor_alt_text_button_label"); Pe.textContent = Oe, Pe.setAttribute("aria-label", Oe), Pe.tabIndex = "0", Pe.addEventListener("contextmenu", Re.noContextMenu), Pe.addEventListener("pointerdown", je => je.stopPropagation()), Pe.addEventListener("click", je => { je.preventDefault(), this._uiManager.editAltText(this) }, { capture: !0 }), Pe.addEventListener("keydown", je => { je.target === Pe && je.key === "Enter" && (je.preventDefault(), this._uiManager.editAltText(this)) }), this.#S(), this.div.append(Pe), Ce.SMALL_EDITOR_SIZE || (Ce.SMALL_EDITOR_SIZE = Math.min(128, Math.round(Pe.getBoundingClientRect().width * 1.4))) } async#S() { const Pe = this.#n; if (!Pe) return; if (!this.#e && !this.#t) { Pe.classList.remove("done"), this.#r?.remove(); return } Ce._l10nPromise.get("editor_alt_text_edit_button_label").then(je => { Pe.setAttribute("aria-label", je) }); let Oe = this.#r; if (!Oe) { this.#r = Oe = document.createElement("span"), Oe.className = "tooltip", Oe.setAttribute("role", "tooltip"); const je = Oe.id = `alt-text-tooltip-${this.id}`; Pe.setAttribute("aria-describedby", je); const Be = 100; Pe.addEventListener("mouseenter", () => { this.#a = setTimeout(() => { this.#a = null, this.#r.classList.add("show"), this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", subtype: this.editorType, data: { action: "alt_text_tooltip" } } }) }, Be) }), Pe.addEventListener("mouseleave", () => { clearTimeout(this.#a), this.#a = null, this.#r?.classList.remove("show") }) } Pe.classList.add("done"), Oe.innerText = this.#t ? await Ce._l10nPromise.get("editor_alt_text_decorative_tooltip") : this.#e, Oe.parentNode || Pe.append(Oe) } getClientDimensions() { return this.div.getBoundingClientRect() } get altTextData() { return { altText: this.#e, decorative: this.#t } } set altTextData({ altText: Pe, decorative: Oe }) { this.#e === Pe && this.#t === Oe || (this.#e = Pe, this.#t = Oe, this.#S()) } render() { this.div = document.createElement("div"), this.div.setAttribute("data-editor-rotation", (360 - this.rotation) % 360), this.div.className = this.name, this.div.setAttribute("id", this.id), this.div.setAttribute("tabIndex", 0), this.setInForeground(), this.div.addEventListener("focusin", this.#l), this.div.addEventListener("focusout", this.#c); const [Pe, Oe] = this.parentDimensions; this.parentRotation % 180 !== 0 && (this.div.style.maxWidth = `${(100 * Oe / Pe).toFixed(2)}%`, this.div.style.maxHeight = `${(100 * Pe / Oe).toFixed(2)}%`); const [je, Be] = this.getInitialTranslation(); return this.translate(je, Be), (0, Ee.bindEvents)(this, this.div, ["pointerdown"]), this.div } pointerdown(Pe) { const { isMac: Oe } = _e.FeatureTest.platform; if (Pe.button !== 0 || Pe.ctrlKey && Oe) { Pe.preventDefault(); return } this.#i = !0, this.#_(Pe) } #_(Pe) { if (!this._isDraggable) return; const Oe = this._uiManager.isSelected(this); this._uiManager.setUpDragSession(); let je, Be; Oe && (je = { passive: !0, capture: !0 }, Be = Fe => { const [ze, qe] = this.screenToPageTranslation(Fe.movementX, Fe.movementY); this._uiManager.dragSelectedEditors(ze, qe) }, window.addEventListener("pointermove", Be, je)); const Ie = () => { if (window.removeEventListener("pointerup", Ie), window.removeEventListener("blur", Ie), Oe && window.removeEventListener("pointermove", Be, je), this.#i = !1, !this._uiManager.endDragSession()) { const { isMac: Fe } = _e.FeatureTest.platform; Pe.ctrlKey && !Fe || Pe.shiftKey || Pe.metaKey && Fe ? this.parent.toggleSelected(this) : this.parent.setSelected(this) } }; window.addEventListener("pointerup", Ie), window.addEventListener("blur", Ie) } moveInDOM() { this.parent?.moveEditorInDOM(this) } _setParentAndPosition(Pe, Oe, je) { Pe.changeParent(this), this.x = Oe, this.y = je, this.fixAndSetPosition() } getRect(Pe, Oe) { const je = this.parentScale, [Be, Ie] = this.pageDimensions, [Fe, ze] = this.pageTranslation, qe = Pe / je, He = Oe / je, Ge = this.x * Be, Ze = this.y * Ie, sn = this.width * Be, Xe = this.height * Ie; switch (this.rotation) { case 0: return [Ge + qe + Fe, Ie - Ze - He - Xe + ze, Ge + qe + sn + Fe, Ie - Ze - He + ze]; case 90: return [Ge + He + Fe, Ie - Ze + qe + ze, Ge + He + Xe + Fe, Ie - Ze + qe + sn + ze]; case 180: return [Ge - qe - sn + Fe, Ie - Ze + He + ze, Ge - qe + Fe, Ie - Ze + He + Xe + ze]; case 270: return [Ge - He - Xe + Fe, Ie - Ze - qe - sn + ze, Ge - He + Fe, Ie - Ze - qe + ze]; default: throw new Error("Invalid rotation") } } getRectInCurrentCoords(Pe, Oe) { const [je, Be, Ie, Fe] = Pe, ze = Ie - je, qe = Fe - Be; switch (this.rotation) { case 0: return [je, Oe - Fe, ze, qe]; case 90: return [je, Oe - Be, qe, ze]; case 180: return [Ie, Oe - Be, ze, qe]; case 270: return [Ie, Oe - Fe, qe, ze]; default: throw new Error("Invalid rotation") } } onceAdded() { } isEmpty() { return !1 } enableEditMode() { this.#u = !0 } disableEditMode() { this.#u = !1 } isInEditMode() { return this.#u } shouldGetKeyboardEvents() { return !1 } needsToBeRebuilt() { return this.div && !this.isAttachedToDOM } rebuild() { this.div?.addEventListener("focusin", this.#l), this.div?.addEventListener("focusout", this.#c) } serialize(Pe = !1, Oe = null) { (0, _e.unreachable)("An editor must be serializable") } static deserialize(Pe, Oe, je) { const Be = new this.prototype.constructor({ parent: Oe, id: Oe.getNextId(), uiManager: je }); Be.rotation = Pe.rotation; const [Ie, Fe] = Be.pageDimensions, [ze, qe, He, Ge] = Be.getRectInCurrentCoords(Pe.rect, Fe); return Be.x = ze / Ie, Be.y = qe / Fe, Be.width = He / Ie, Be.height = Ge / Fe, Be } remove() { this.div.removeEventListener("focusin", this.#l), this.div.removeEventListener("focusout", this.#c), this.isEmpty() || this.commit(), this.parent ? this.parent.remove(this) : this._uiManager.removeEditor(this), this.#n?.remove(), this.#n = null, this.#r = null } get isResizable() { return !1 } makeResizable() { this.isResizable && (this.#b(), this.#s.classList.remove("hidden")) } select() { this.makeResizable(), this.div?.classList.add("selectedEditor") } unselect() { this.#s?.classList.add("hidden"), this.div?.classList.remove("selectedEditor"), this.div?.contains(document.activeElement) && this._uiManager.currentLayer.div.focus() } updateParams(Pe, Oe) { } disableEditing() { this.#n && (this.#n.hidden = !0) } enableEditing() { this.#n && (this.#n.hidden = !1) } enterInEditMode() { } get contentDiv() { return this.div } get isEditing() { return this.#p } set isEditing(Pe) { this.#p = Pe, this.parent && (Pe ? (this.parent.setSelected(this), this.parent.setActiveEditor(this)) : this.parent.setActiveEditor(null)) } setAspectRatio(Pe, Oe) { this.#o = !0; const je = Pe / Oe, { style: Be } = this.div; Be.aspectRatio = je, Be.height = "auto" } static get MIN_SIZE() { return 16 } } t.AnnotationEditor = Ce; class Me extends Ce { constructor(Pe) { super(Pe), this.annotationElementId = Pe.annotationElementId, this.deleted = !0 } serialize() { return { id: this.annotationElementId, deleted: !0, pageIndex: this.pageIndex } } } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.KeyboardManager = t.CommandManager = t.ColorManager = t.AnnotationEditorUIManager = void 0, t.bindEvents = Re, t.opacityToHex = Ce; var Ee = xe(1), _e = xe(6); function Re(Ie, Fe, ze) { for (const qe of ze) Fe.addEventListener(qe, Ie[qe].bind(Ie)) } function Ce(Ie) { return Math.round(Math.min(255, Math.max(1, 255 * Ie))).toString(16).padStart(2, "0") } class Me { #e = 0; getId() { return `${Ee.AnnotationEditorPrefix}${this.#e++}` } } class De { #e = (0, Ee.getUuid)(); #t = 0; #n = null; static get _isSVGFittingCanvas() { const Fe = 'data:image/svg+xml;charset=UTF-8,<svg viewBox="0 0 1 1" width="1" height="1" xmlns="http://www.w3.org/2000/svg"><rect width="1" height="1" style="fill:red;"/></svg>', qe = new OffscreenCanvas(1, 3).getContext("2d"), He = new Image; He.src = Fe; const Ge = He.decode().then(() => (qe.drawImage(He, 0, 0, 1, 1, 0, 0, 1, 3), new Uint32Array(qe.getImageData(0, 0, 1, 1).data.buffer)[0] === 0)); return (0, Ee.shadow)(this, "_isSVGFittingCanvas", Ge) } async#r(Fe, ze) { this.#n ||= new Map; let qe = this.#n.get(Fe); if (qe === null) return null; if (qe?.bitmap) return qe.refCounter += 1, qe; try { qe ||= { bitmap: null, id: `image_${this.#e}_${this.#t++}`, refCounter: 0, isSvg: !1 }; let He; if (typeof ze == "string") { qe.url = ze; const Ge = await fetch(ze); if (!Ge.ok) throw new Error(Ge.statusText); He = await Ge.blob() } else He = qe.file = ze; if (He.type === "image/svg+xml") { const Ge = De._isSVGFittingCanvas, Ze = new FileReader, sn = new Image, Xe = new Promise((St, un) => { sn.onload = () => { qe.bitmap = sn, qe.isSvg = !0, St() }, Ze.onload = async () => { const on = qe.svgUrl = Ze.result; sn.src = await Ge ? `${on}#svgView(preserveAspectRatio(none))` : on }, sn.onerror = Ze.onerror = un }); Ze.readAsDataURL(He), await Xe } else qe.bitmap = await createImageBitmap(He); qe.refCounter = 1 } catch (He) { console.error(He), qe = null } return this.#n.set(Fe, qe), qe && this.#n.set(qe.id, qe), qe } async getFromFile(Fe) { const { lastModified: ze, name: qe, size: He, type: Ge } = Fe; return this.#r(`${ze}_${qe}_${He}_${Ge}`, Fe) } async getFromUrl(Fe) { return this.#r(Fe, Fe) } async getFromId(Fe) { this.#n ||= new Map; const ze = this.#n.get(Fe); return ze ? ze.bitmap ? (ze.refCounter += 1, ze) : ze.file ? this.getFromFile(ze.file) : this.getFromUrl(ze.url) : null } getSvgUrl(Fe) { const ze = this.#n.get(Fe); return ze?.isSvg ? ze.svgUrl : null } deleteId(Fe) { this.#n ||= new Map; const ze = this.#n.get(Fe); ze && (ze.refCounter -= 1, ze.refCounter === 0 && (ze.bitmap = null)) } isValidId(Fe) { return Fe.startsWith(`image_${this.#e}_`) } } class Pe { #e = []; #t = !1; #n; #r = -1; constructor(Fe = 128) { this.#n = Fe } add({ cmd: Fe, undo: ze, mustExec: qe, type: He = NaN, overwriteIfSameType: Ge = !1, keepUndo: Ze = !1 }) { if (qe && Fe(), this.#t) return; const sn = { cmd: Fe, undo: ze, type: He }; if (this.#r === -1) { this.#e.length > 0 && (this.#e.length = 0), this.#r = 0, this.#e.push(sn); return } if (Ge && this.#e[this.#r].type === He) { Ze && (sn.undo = this.#e[this.#r].undo), this.#e[this.#r] = sn; return } const Xe = this.#r + 1; Xe === this.#n ? this.#e.splice(0, 1) : (this.#r = Xe, Xe < this.#e.length && this.#e.splice(Xe)), this.#e.push(sn) } undo() { this.#r !== -1 && (this.#t = !0, this.#e[this.#r].undo(), this.#t = !1, this.#r -= 1) } redo() { this.#r < this.#e.length - 1 && (this.#r += 1, this.#t = !0, this.#e[this.#r].cmd(), this.#t = !1) } hasSomethingToUndo() { return this.#r !== -1 } hasSomethingToRedo() { return this.#r < this.#e.length - 1 } destroy() { this.#e = null } } t.CommandManager = Pe; class Oe { constructor(Fe) { this.buffer = [], this.callbacks = new Map, this.allKeys = new Set; const { isMac: ze } = Ee.FeatureTest.platform; for (const [qe, He, Ge = {}] of Fe) for (const Ze of qe) { const sn = Ze.startsWith("mac+"); ze && sn ? (this.callbacks.set(Ze.slice(4), { callback: He, options: Ge }), this.allKeys.add(Ze.split("+").at(-1))) : !ze && !sn && (this.callbacks.set(Ze, { callback: He, options: Ge }), this.allKeys.add(Ze.split("+").at(-1))) } } #e(Fe) { Fe.altKey && this.buffer.push("alt"), Fe.ctrlKey && this.buffer.push("ctrl"), Fe.metaKey && this.buffer.push("meta"), Fe.shiftKey && this.buffer.push("shift"), this.buffer.push(Fe.key); const ze = this.buffer.join("+"); return this.buffer.length = 0, ze } exec(Fe, ze) { if (!this.allKeys.has(ze.key)) return; const qe = this.callbacks.get(this.#e(ze)); if (!qe) return; const { callback: He, options: { bubbles: Ge = !1, args: Ze = [], checker: sn = null } } = qe; sn && !sn(Fe, ze) || (He.bind(Fe, ...Ze)(), Ge || (ze.stopPropagation(), ze.preventDefault())) } } t.KeyboardManager = Oe; class je { static _colorsMapping = new Map([["CanvasText", [0, 0, 0]], ["Canvas", [255, 255, 255]]]); get _colors() { const Fe = new Map([["CanvasText", null], ["Canvas", null]]); return (0, _e.getColorValues)(Fe), (0, Ee.shadow)(this, "_colors", Fe) } convert(Fe) { const ze = (0, _e.getRGB)(Fe); if (!window.matchMedia("(forced-colors: active)").matches) return ze; for (const [qe, He] of this._colors) if (He.every((Ge, Ze) => Ge === ze[Ze])) return je._colorsMapping.get(qe); return ze } getHexCode(Fe) { const ze = this._colors.get(Fe); return ze ? Ee.Util.makeHexColor(...ze) : Fe } } t.ColorManager = je; class Be { #e = null; #t = new Map; #n = new Map; #r = null; #a = null; #o = new Pe; #s = 0; #l = new Set; #c = null; #i = null; #p = new Set; #u = null; #h = new Me; #f = !1; #v = !1; #m = null; #g = Ee.AnnotationEditorType.NONE; #d = new Set; #b = null; #y = this.blur.bind(this); #x = this.focus.bind(this); #S = this.copy.bind(this); #_ = this.cut.bind(this); #N = this.paste.bind(this); #D = this.keydown.bind(this); #k = this.onEditingAction.bind(this); #E = this.onPageChanging.bind(this); #M = this.onScaleChanging.bind(this); #P = this.onRotationChanging.bind(this); #O = { isEditing: !1, isEmpty: !0, hasSomethingToUndo: !1, hasSomethingToRedo: !1, hasSelectedEditor: !1 }; #w = [0, 0]; #T = null; #R = null; #I = null; static TRANSLATE_SMALL = 1; static TRANSLATE_BIG = 10; static get _keyboardManager() { const Fe = Be.prototype, ze = Ge => { const { activeElement: Ze } = document; return Ze && Ge.#R.contains(Ze) && Ge.hasSomethingToControl() }, qe = this.TRANSLATE_SMALL, He = this.TRANSLATE_BIG; return (0, Ee.shadow)(this, "_keyboardManager", new Oe([[["ctrl+a", "mac+meta+a"], Fe.selectAll], [["ctrl+z", "mac+meta+z"], Fe.undo], [["ctrl+y", "ctrl+shift+z", "mac+meta+shift+z", "ctrl+shift+Z", "mac+meta+shift+Z"], Fe.redo], [["Backspace", "alt+Backspace", "ctrl+Backspace", "shift+Backspace", "mac+Backspace", "mac+alt+Backspace", "mac+ctrl+Backspace", "Delete", "ctrl+Delete", "shift+Delete", "mac+Delete"], Fe.delete], [["Escape", "mac+Escape"], Fe.unselectAll], [["ArrowLeft", "mac+ArrowLeft"], Fe.translateSelectedEditors, { args: [-qe, 0], checker: ze }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], Fe.translateSelectedEditors, { args: [-He, 0], checker: ze }], [["ArrowRight", "mac+ArrowRight"], Fe.translateSelectedEditors, { args: [qe, 0], checker: ze }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], Fe.translateSelectedEditors, { args: [He, 0], checker: ze }], [["ArrowUp", "mac+ArrowUp"], Fe.translateSelectedEditors, { args: [0, -qe], checker: ze }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], Fe.translateSelectedEditors, { args: [0, -He], checker: ze }], [["ArrowDown", "mac+ArrowDown"], Fe.translateSelectedEditors, { args: [0, qe], checker: ze }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], Fe.translateSelectedEditors, { args: [0, He], checker: ze }]])) } constructor(Fe, ze, qe, He, Ge, Ze) { this.#R = Fe, this.#I = ze, this.#r = qe, this._eventBus = He, this._eventBus._on("editingaction", this.#k), this._eventBus._on("pagechanging", this.#E), this._eventBus._on("scalechanging", this.#M), this._eventBus._on("rotationchanging", this.#P), this.#a = Ge.annotationStorage, this.#u = Ge.filterFactory, this.#b = Ze, this.viewParameters = { realScale: _e.PixelsPerInch.PDF_TO_CSS_UNITS, rotation: 0 } } destroy() { this.#L(), this.#B(), this._eventBus._off("editingaction", this.#k), this._eventBus._off("pagechanging", this.#E), this._eventBus._off("scalechanging", this.#M), this._eventBus._off("rotationchanging", this.#P); for (const Fe of this.#n.values()) Fe.destroy(); this.#n.clear(), this.#t.clear(), this.#p.clear(), this.#e = null, this.#d.clear(), this.#o.destroy(), this.#r.destroy() } get hcmFilter() { return (0, Ee.shadow)(this, "hcmFilter", this.#b ? this.#u.addHCMFilter(this.#b.foreground, this.#b.background) : "none") } get direction() { return (0, Ee.shadow)(this, "direction", getComputedStyle(this.#R).direction) } editAltText(Fe) { this.#r?.editAltText(this, Fe) } onPageChanging({ pageNumber: Fe }) { this.#s = Fe - 1 } focusMainContainer() { this.#R.focus() } findParent(Fe, ze) { for (const qe of this.#n.values()) { const { x: He, y: Ge, width: Ze, height: sn } = qe.div.getBoundingClientRect(); if (Fe >= He && Fe <= He + Ze && ze >= Ge && ze <= Ge + sn) return qe } return null } disableUserSelect(Fe = !1) { this.#I.classList.toggle("noUserSelect", Fe) } addShouldRescale(Fe) { this.#p.add(Fe) } removeShouldRescale(Fe) { this.#p.delete(Fe) } onScaleChanging({ scale: Fe }) { this.commitOrRemove(), this.viewParameters.realScale = Fe * _e.PixelsPerInch.PDF_TO_CSS_UNITS; for (const ze of this.#p) ze.onScaleChanging() } onRotationChanging({ pagesRotation: Fe }) { this.commitOrRemove(), this.viewParameters.rotation = Fe } addToAnnotationStorage(Fe) { !Fe.isEmpty() && this.#a && !this.#a.has(Fe.id) && this.#a.setValue(Fe.id, Fe) } #F() { window.addEventListener("focus", this.#x), window.addEventListener("blur", this.#y) } #B() { window.removeEventListener("focus", this.#x), window.removeEventListener("blur", this.#y) } blur() { if (!this.hasSelection) return; const { activeElement: Fe } = document; for (const ze of this.#d) if (ze.div.contains(Fe)) { this.#m = [ze, Fe], ze._focusEventsAllowed = !1; break } } focus() { if (!this.#m) return; const [Fe, ze] = this.#m; this.#m = null, ze.addEventListener("focusin", () => { Fe._focusEventsAllowed = !0 }, { once: !0 }), ze.focus() } #U() { window.addEventListener("keydown", this.#D, { capture: !0 }) } #L() { window.removeEventListener("keydown", this.#D, { capture: !0 }) } #j() { document.addEventListener("copy", this.#S), document.addEventListener("cut", this.#_), document.addEventListener("paste", this.#N) } #C() { document.removeEventListener("copy", this.#S), document.removeEventListener("cut", this.#_), document.removeEventListener("paste", this.#N) } addEditListeners() { this.#U(), this.#j() } removeEditListeners() { this.#L(), this.#C() } copy(Fe) { if (Fe.preventDefault(), this.#e?.commitOrRemove(), !this.hasSelection) return; const ze = []; for (const qe of this.#d) { const He = qe.serialize(!0); He && ze.push(He) } ze.length !== 0 && Fe.clipboardData.setData("application/pdfjs", JSON.stringify(ze)) } cut(Fe) { this.copy(Fe), this.delete() } paste(Fe) { Fe.preventDefault(); const { clipboardData: ze } = Fe; for (const Ge of ze.items) for (const Ze of this.#i) if (Ze.isHandlingMimeForPasting(Ge.type)) { Ze.paste(Ge, this.currentLayer); return } let qe = ze.getData("application/pdfjs"); if (!qe) return; try { qe = JSON.parse(qe) } catch (Ge) { (0, Ee.warn)(`paste: "${Ge.message}".`); return } if (!Array.isArray(qe)) return; this.unselectAll(); const He = this.currentLayer; try { const Ge = []; for (const Xe of qe) { const St = He.deserialize(Xe); if (!St) return; Ge.push(St) } const Ze = () => { for (const Xe of Ge) this.#q(Xe); this.#$(Ge) }, sn = () => { for (const Xe of Ge) Xe.remove() }; this.addCommands({ cmd: Ze, undo: sn, mustExec: !0 }) } catch (Ge) { (0, Ee.warn)(`paste: "${Ge.message}".`) } } keydown(Fe) { this.getActive()?.shouldGetKeyboardEvents() || Be._keyboardManager.exec(this, Fe) } onEditingAction(Fe) { ["undo", "redo", "delete", "selectAll"].includes(Fe.name) && this[Fe.name]() } #A(Fe) { Object.entries(Fe).some(([qe, He]) => this.#O[qe] !== He) && this._eventBus.dispatch("annotationeditorstateschanged", { source: this, details: Object.assign(this.#O, Fe) }) } #z(Fe) { this._eventBus.dispatch("annotationeditorparamschanged", { source: this, details: Fe }) } setEditingState(Fe) { Fe ? (this.#F(), this.#U(), this.#j(), this.#A({ isEditing: this.#g !== Ee.AnnotationEditorType.NONE, isEmpty: this.#H(), hasSomethingToUndo: this.#o.hasSomethingToUndo(), hasSomethingToRedo: this.#o.hasSomethingToRedo(), hasSelectedEditor: !1 })) : (this.#B(), this.#L(), this.#C(), this.#A({ isEditing: !1 }), this.disableUserSelect(!1)) } registerEditorTypes(Fe) { if (!this.#i) { this.#i = Fe; for (const ze of this.#i) this.#z(ze.defaultPropertiesToUpdate) } } getId() { return this.#h.getId() } get currentLayer() { return this.#n.get(this.#s) } getLayer(Fe) { return this.#n.get(Fe) } get currentPageIndex() { return this.#s } addLayer(Fe) { this.#n.set(Fe.pageIndex, Fe), this.#f ? Fe.enable() : Fe.disable() } removeLayer(Fe) { this.#n.delete(Fe.pageIndex) } updateMode(Fe, ze = null) { if (this.#g !== Fe) { if (this.#g = Fe, Fe === Ee.AnnotationEditorType.NONE) { this.setEditingState(!1), this.#G(); return } this.setEditingState(!0), this.#V(), this.unselectAll(); for (const qe of this.#n.values()) qe.updateMode(Fe); if (ze) { for (const qe of this.#t.values()) if (qe.annotationElementId === ze) { this.setSelected(qe), qe.enterInEditMode(); break } } } } updateToolbar(Fe) { Fe !== this.#g && this._eventBus.dispatch("switchannotationeditormode", { source: this, mode: Fe }) } updateParams(Fe, ze) { if (this.#i) { if (Fe === Ee.AnnotationEditorParamsType.CREATE) { this.currentLayer.addNewEditor(Fe); return } for (const qe of this.#d) qe.updateParams(Fe, ze); for (const qe of this.#i) qe.updateDefaultParams(Fe, ze) } } enableWaiting(Fe = !1) { if (this.#v !== Fe) { this.#v = Fe; for (const ze of this.#n.values()) Fe ? ze.disableClick() : ze.enableClick(), ze.div.classList.toggle("waiting", Fe) } } #V() { if (!this.#f) { this.#f = !0; for (const Fe of this.#n.values()) Fe.enable() } } #G() { if (this.unselectAll(), this.#f) { this.#f = !1; for (const Fe of this.#n.values()) Fe.disable() } } getEditors(Fe) { const ze = []; for (const qe of this.#t.values()) qe.pageIndex === Fe && ze.push(qe); return ze } getEditor(Fe) { return this.#t.get(Fe) } addEditor(Fe) { this.#t.set(Fe.id, Fe) } removeEditor(Fe) { this.#t.delete(Fe.id), this.unselect(Fe), (!Fe.annotationElementId || !this.#l.has(Fe.annotationElementId)) && this.#a?.remove(Fe.id) } addDeletedAnnotationElement(Fe) { this.#l.add(Fe.annotationElementId), Fe.deleted = !0 } isDeletedAnnotationElement(Fe) { return this.#l.has(Fe) } removeDeletedAnnotationElement(Fe) { this.#l.delete(Fe.annotationElementId), Fe.deleted = !1 } #q(Fe) { const ze = this.#n.get(Fe.pageIndex); ze ? ze.addOrRebuild(Fe) : this.addEditor(Fe) } setActiveEditor(Fe) { this.#e !== Fe && (this.#e = Fe, Fe && this.#z(Fe.propertiesToUpdate)) } toggleSelected(Fe) { if (this.#d.has(Fe)) { this.#d.delete(Fe), Fe.unselect(), this.#A({ hasSelectedEditor: this.hasSelection }); return } this.#d.add(Fe), Fe.select(), this.#z(Fe.propertiesToUpdate), this.#A({ hasSelectedEditor: !0 }) } setSelected(Fe) { for (const ze of this.#d) ze !== Fe && ze.unselect(); this.#d.clear(), this.#d.add(Fe), Fe.select(), this.#z(Fe.propertiesToUpdate), this.#A({ hasSelectedEditor: !0 }) } isSelected(Fe) { return this.#d.has(Fe) } unselect(Fe) { Fe.unselect(), this.#d.delete(Fe), this.#A({ hasSelectedEditor: this.hasSelection }) } get hasSelection() { return this.#d.size !== 0 } undo() { this.#o.undo(), this.#A({ hasSomethingToUndo: this.#o.hasSomethingToUndo(), hasSomethingToRedo: !0, isEmpty: this.#H() }) } redo() { this.#o.redo(), this.#A({ hasSomethingToUndo: !0, hasSomethingToRedo: this.#o.hasSomethingToRedo(), isEmpty: this.#H() }) } addCommands(Fe) { this.#o.add(Fe), this.#A({ hasSomethingToUndo: !0, hasSomethingToRedo: !1, isEmpty: this.#H() }) } #H() { if (this.#t.size === 0) return !0; if (this.#t.size === 1) for (const Fe of this.#t.values()) return Fe.isEmpty(); return !1 } delete() { if (this.commitOrRemove(), !this.hasSelection) return; const Fe = [...this.#d], ze = () => { for (const He of Fe) He.remove() }, qe = () => { for (const He of Fe) this.#q(He) }; this.addCommands({ cmd: ze, undo: qe, mustExec: !0 }) } commitOrRemove() { this.#e?.commitOrRemove() } hasSomethingToControl() { return this.#e || this.hasSelection } #$(Fe) { this.#d.clear(); for (const ze of Fe) ze.isEmpty() || (this.#d.add(ze), ze.select()); this.#A({ hasSelectedEditor: !0 }) } selectAll() { for (const Fe of this.#d) Fe.commit(); this.#$(this.#t.values()) } unselectAll() { if (this.#e) { this.#e.commitOrRemove(); return } if (this.hasSelection) { for (const Fe of this.#d) Fe.unselect(); this.#d.clear(), this.#A({ hasSelectedEditor: !1 }) } } translateSelectedEditors(Fe, ze, qe = !1) { if (qe || this.commitOrRemove(), !this.hasSelection) return; this.#w[0] += Fe, this.#w[1] += ze; const [He, Ge] = this.#w, Ze = [...this.#d], sn = 1e3; this.#T && clearTimeout(this.#T), this.#T = setTimeout(() => { this.#T = null, this.#w[0] = this.#w[1] = 0, this.addCommands({ cmd: () => { for (const Xe of Ze) this.#t.has(Xe.id) && Xe.translateInPage(He, Ge) }, undo: () => { for (const Xe of Ze) this.#t.has(Xe.id) && Xe.translateInPage(-He, -Ge) }, mustExec: !1 }) }, sn); for (const Xe of Ze) Xe.translateInPage(Fe, ze) } setUpDragSession() { if (this.hasSelection) { this.disableUserSelect(!0), this.#c = new Map; for (const Fe of this.#d) this.#c.set(Fe, { savedX: Fe.x, savedY: Fe.y, savedPageIndex: Fe.pageIndex, newX: 0, newY: 0, newPageIndex: -1 }) } } endDragSession() { if (!this.#c) return !1; this.disableUserSelect(!1); const Fe = this.#c; this.#c = null; let ze = !1; for (const [{ x: He, y: Ge, pageIndex: Ze }, sn] of Fe) sn.newX = He, sn.newY = Ge, sn.newPageIndex = Ze, ze ||= He !== sn.savedX || Ge !== sn.savedY || Ze !== sn.savedPageIndex; if (!ze) return !1; const qe = (He, Ge, Ze, sn) => { if (this.#t.has(He.id)) { const Xe = this.#n.get(sn); Xe ? He._setParentAndPosition(Xe, Ge, Ze) : (He.pageIndex = sn, He.x = Ge, He.y = Ze) } }; return this.addCommands({ cmd: () => { for (const [He, { newX: Ge, newY: Ze, newPageIndex: sn }] of Fe) qe(He, Ge, Ze, sn) }, undo: () => { for (const [He, { savedX: Ge, savedY: Ze, savedPageIndex: sn }] of Fe) qe(He, Ge, Ze, sn) }, mustExec: !0 }), !0 } dragSelectedEditors(Fe, ze) { if (this.#c) for (const qe of this.#c.keys()) qe.drag(Fe, ze) } rebuild(Fe) { if (Fe.parent === null) { const ze = this.getLayer(Fe.pageIndex); ze ? (ze.changeParent(Fe), ze.addOrRebuild(Fe)) : (this.addEditor(Fe), this.addToAnnotationStorage(Fe), Fe.rebuild()) } else Fe.parent.addOrRebuild(Fe) } isActive(Fe) { return this.#e === Fe } getActive() { return this.#e } getMode() { return this.#g } get imageManager() { return (0, Ee.shadow)(this, "imageManager", new De) } } t.AnnotationEditorUIManager = Be }, (e, t, xe) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.StatTimer = t.RenderingCancelledException = t.PixelsPerInch = t.PageViewport = t.PDFDateString = t.DOMStandardFontDataFactory = t.DOMSVGFactory = t.DOMFilterFactory = t.DOMCanvasFactory = t.DOMCMapReaderFactory = void 0, t.deprecated = un, t.getColorValues = En, t.getCurrentTransform = Pn, t.getCurrentTransformInverse = Rn, t.getFilenameFromUrl = He, t.getPdfFilenameFromUrl = Ge, t.getRGB = fn, t.getXfaPageViewport = Tn, t.isDataScheme = ze, t.isPdfFile = qe, t.isValidFetchUrl = sn, t.loadScript = St, t.noContextMenu = Xe, t.setLayerDimensions = In; var Ee = xe(7), _e = xe(1); const Re = "http://www.w3.org/2000/svg"; class Ce { static CSS = 96; static PDF = 72; static PDF_TO_CSS_UNITS = this.CSS / this.PDF } t.PixelsPerInch = Ce; class Me extends Ee.BaseFilterFactory { #e; #t; #n; #r; #a; #o; #s; #l; #c; #i; #p = 0; constructor({ docId: vn, ownerDocument: tn = globalThis.document } = {}) { super(), this.#n = vn, this.#r = tn } get #u() { return this.#e ||= new Map } get #h() { if (!this.#t) { const vn = this.#r.createElement("div"), { style: tn } = vn; tn.visibility = "hidden", tn.contain = "strict", tn.width = tn.height = 0, tn.position = "absolute", tn.top = tn.left = 0, tn.zIndex = -1; const nn = this.#r.createElementNS(Re, "svg"); nn.setAttribute("width", 0), nn.setAttribute("height", 0), this.#t = this.#r.createElementNS(Re, "defs"), vn.append(nn), nn.append(this.#t), this.#r.body.append(vn) } return this.#t } addFilter(vn) { if (!vn) return "none"; let tn = this.#u.get(vn); if (tn) return tn; let nn, We, dn, Je; if (vn.length === 1) { const Ye = vn[0], an = new Array(256); for (let pn = 0; pn < 256; pn++)an[pn] = Ye[pn] / 255; Je = nn = We = dn = an.join(",") } else { const [Ye, an, pn] = vn, yn = new Array(256), _n = new Array(256), On = new Array(256); for (let kn = 0; kn < 256; kn++)yn[kn] = Ye[kn] / 255, _n[kn] = an[kn] / 255, On[kn] = pn[kn] / 255; nn = yn.join(","), We = _n.join(","), dn = On.join(","), Je = `${nn}${We}${dn}` } if (tn = this.#u.get(Je), tn) return this.#u.set(vn, tn), tn; const rn = `g_${this.#n}_transfer_map_${this.#p++}`, hn = `url(#${rn})`; this.#u.set(vn, hn), this.#u.set(Je, hn); const mn = this.#v(rn); return this.#g(nn, We, dn, mn), hn } addHCMFilter(vn, tn) { const nn = `${vn}-${tn}`; if (this.#o === nn) return this.#s; if (this.#o = nn, this.#s = "none", this.#a?.remove(), !vn || !tn) return this.#s; const We = this.#d(vn); vn = _e.Util.makeHexColor(...We); const dn = this.#d(tn); if (tn = _e.Util.makeHexColor(...dn), this.#h.style.color = "", vn === "#000000" && tn === "#ffffff" || vn === tn) return this.#s; const Je = new Array(256); for (let an = 0; an <= 255; an++) { const pn = an / 255; Je[an] = pn <= .03928 ? pn / 12.92 : ((pn + .055) / 1.055) ** 2.4 } const rn = Je.join(","), hn = `g_${this.#n}_hcm_filter`, mn = this.#l = this.#v(hn); this.#g(rn, rn, rn, mn), this.#f(mn); const Ye = (an, pn) => { const yn = We[an] / 255, _n = dn[an] / 255, On = new Array(pn + 1); for (let kn = 0; kn <= pn; kn++)On[kn] = yn + kn / pn * (_n - yn); return On.join(",") }; return this.#g(Ye(0, 5), Ye(1, 5), Ye(2, 5), mn), this.#s = `url(#${hn})`, this.#s } addHighlightHCMFilter(vn, tn, nn, We) { const dn = `${vn}-${tn}-${nn}-${We}`; if (this.#c === dn) return this.#i; if (this.#c = dn, this.#i = "none", this.#l?.remove(), !vn || !tn) return this.#i; const [Je, rn] = [vn, tn].map(this.#d.bind(this)); let hn = Math.round(.2126 * Je[0] + .7152 * Je[1] + .0722 * Je[2]), mn = Math.round(.2126 * rn[0] + .7152 * rn[1] + .0722 * rn[2]), [Ye, an] = [nn, We].map(this.#d.bind(this)); mn < hn && ([hn, mn, Ye, an] = [mn, hn, an, Ye]), this.#h.style.color = ""; const pn = (On, kn, zn) => { const sr = new Array(256), Fn = (mn - hn) / zn, Cn = On / 255, Vn = (kn - On) / (255 * zn); let Yn = 0; for (let qn = 0; qn <= zn; qn++) { const rr = Math.round(hn + qn * Fn), hr = Cn + qn * Vn; for (let ur = Yn; ur <= rr; ur++)sr[ur] = hr; Yn = rr + 1 } for (let qn = Yn; qn < 256; qn++)sr[qn] = sr[Yn - 1]; return sr.join(",") }, yn = `g_${this.#n}_hcm_highlight_filter`, _n = this.#l = this.#v(yn); return this.#f(_n), this.#g(pn(Ye[0], an[0], 5), pn(Ye[1], an[1], 5), pn(Ye[2], an[2], 5), _n), this.#i = `url(#${yn})`, this.#i } destroy(vn = !1) { vn && (this.#s || this.#i) || (this.#t && (this.#t.parentNode.parentNode.remove(), this.#t = null), this.#e && (this.#e.clear(), this.#e = null), this.#p = 0) } #f(vn) { const tn = this.#r.createElementNS(Re, "feColorMatrix"); tn.setAttribute("type", "matrix"), tn.setAttribute("values", "0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0"), vn.append(tn) } #v(vn) { const tn = this.#r.createElementNS(Re, "filter"); return tn.setAttribute("color-interpolation-filters", "sRGB"), tn.setAttribute("id", vn), this.#h.append(tn), tn } #m(vn, tn, nn) { const We = this.#r.createElementNS(Re, tn); We.setAttribute("type", "discrete"), We.setAttribute("tableValues", nn), vn.append(We) } #g(vn, tn, nn, We) { const dn = this.#r.createElementNS(Re, "feComponentTransfer"); We.append(dn), this.#m(dn, "feFuncR", vn), this.#m(dn, "feFuncG", tn), this.#m(dn, "feFuncB", nn) } #d(vn) { return this.#h.style.color = vn, fn(getComputedStyle(this.#h).getPropertyValue("color")) } } t.DOMFilterFactory = Me; class De extends Ee.BaseCanvasFactory { constructor({ ownerDocument: vn = globalThis.document } = {}) { super(), this._document = vn } _createCanvas(vn, tn) { const nn = this._document.createElement("canvas"); return nn.width = vn, nn.height = tn, nn } } t.DOMCanvasFactory = De; async function Pe(xn, vn = !1) { if (sn(xn, document.baseURI)) { const tn = await fetch(xn); if (!tn.ok) throw new Error(tn.statusText); return vn ? new Uint8Array(await tn.arrayBuffer()) : (0, _e.stringToBytes)(await tn.text()) } return new Promise((tn, nn) => { const We = new XMLHttpRequest; We.open("GET", xn, !0), vn && (We.responseType = "arraybuffer"), We.onreadystatechange = () => { if (We.readyState === XMLHttpRequest.DONE) { if (We.status === 200 || We.status === 0) { let dn; if (vn && We.response ? dn = new Uint8Array(We.response) : !vn && We.responseText && (dn = (0, _e.stringToBytes)(We.responseText)), dn) { tn(dn); return } } nn(new Error(We.statusText)) } }, We.send(null) }) } class Oe extends Ee.BaseCMapReaderFactory { _fetchData(vn, tn) { return Pe(vn, this.isCompressed).then(nn => ({ cMapData: nn, compressionType: tn })) } } t.DOMCMapReaderFactory = Oe; class je extends Ee.BaseStandardFontDataFactory { _fetchData(vn) { return Pe(vn, !0) } } t.DOMStandardFontDataFactory = je; class Be extends Ee.BaseSVGFactory { _createSVG(vn) { return document.createElementNS(Re, vn) } } t.DOMSVGFactory = Be; class Ie { constructor({ viewBox: vn, scale: tn, rotation: nn, offsetX: We = 0, offsetY: dn = 0, dontFlip: Je = !1 }) { this.viewBox = vn, this.scale = tn, this.rotation = nn, this.offsetX = We, this.offsetY = dn; const rn = (vn[2] + vn[0]) / 2, hn = (vn[3] + vn[1]) / 2; let mn, Ye, an, pn; switch (nn %= 360, nn < 0 && (nn += 360), nn) { case 180: mn = -1, Ye = 0, an = 0, pn = 1; break; case 90: mn = 0, Ye = 1, an = 1, pn = 0; break; case 270: mn = 0, Ye = -1, an = -1, pn = 0; break; case 0: mn = 1, Ye = 0, an = 0, pn = -1; break; default: throw new Error("PageViewport: Invalid rotation, must be a multiple of 90 degrees.") }Je && (an = -an, pn = -pn); let yn, _n, On, kn; mn === 0 ? (yn = Math.abs(hn - vn[1]) * tn + We, _n = Math.abs(rn - vn[0]) * tn + dn, On = (vn[3] - vn[1]) * tn, kn = (vn[2] - vn[0]) * tn) : (yn = Math.abs(rn - vn[0]) * tn + We, _n = Math.abs(hn - vn[1]) * tn + dn, On = (vn[2] - vn[0]) * tn, kn = (vn[3] - vn[1]) * tn), this.transform = [mn * tn, Ye * tn, an * tn, pn * tn, yn - mn * tn * rn - an * tn * hn, _n - Ye * tn * rn - pn * tn * hn], this.width = On, this.height = kn } get rawDims() { const { viewBox: vn } = this; return (0, _e.shadow)(this, "rawDims", { pageWidth: vn[2] - vn[0], pageHeight: vn[3] - vn[1], pageX: vn[0], pageY: vn[1] }) } clone({ scale: vn = this.scale, rotation: tn = this.rotation, offsetX: nn = this.offsetX, offsetY: We = this.offsetY, dontFlip: dn = !1 } = {}) { return new Ie({ viewBox: this.viewBox.slice(), scale: vn, rotation: tn, offsetX: nn, offsetY: We, dontFlip: dn }) } convertToViewportPoint(vn, tn) { return _e.Util.applyTransform([vn, tn], this.transform) } convertToViewportRectangle(vn) { const tn = _e.Util.applyTransform([vn[0], vn[1]], this.transform), nn = _e.Util.applyTransform([vn[2], vn[3]], this.transform); return [tn[0], tn[1], nn[0], nn[1]] } convertToPdfPoint(vn, tn) { return _e.Util.applyInverseTransform([vn, tn], this.transform) } } t.PageViewport = Ie; class Fe extends _e.BaseException { constructor(vn, tn = 0) { super(vn, "RenderingCancelledException"), this.extraDelay = tn } } t.RenderingCancelledException = Fe; function ze(xn) { const vn = xn.length; let tn = 0; for (; tn < vn && xn[tn].trim() === "";)tn++; return xn.substring(tn, tn + 5).toLowerCase() === "data:" } function qe(xn) { return typeof xn == "string" && /\.pdf$/i.test(xn) } function He(xn, vn = !1) { return vn || ([xn] = xn.split(/[#?]/, 1)), xn.substring(xn.lastIndexOf("/") + 1) } function Ge(xn, vn = "document.pdf") { if (typeof xn != "string") return vn; if (ze(xn)) return (0, _e.warn)('getPdfFilenameFromUrl: ignore "data:"-URL for performance reasons.'), vn; const tn = /^(?:(?:[^:]+:)?\/\/[^/]+)?([^?#]*)(\?[^#]*)?(#.*)?$/, nn = /[^/?#=]+\.pdf\b(?!.*\.pdf\b)/i, We = tn.exec(xn); let dn = nn.exec(We[1]) || nn.exec(We[2]) || nn.exec(We[3]); if (dn && (dn = dn[0], dn.includes("%"))) try { dn = nn.exec(decodeURIComponent(dn))[0] } catch { } return dn || vn } class Ze {
          started = Object.create(null); times = []; time(vn) { vn in this.started && (0, _e.warn)(`Timer is already running for ${vn}`), this.started[vn] = Date.now() } timeEnd(vn) { vn in this.started || (0, _e.warn)(`Timer has not been started for ${vn}`), this.times.push({ name: vn, start: this.started[vn], end: Date.now() }), delete this.started[vn] } toString() {
            const vn = []; let tn = 0; for (const { name: nn } of this.times) tn = Math.max(nn.length, tn); for (const { name: nn, start: We, end: dn } of this.times) vn.push(`${nn.padEnd(tn)} ${dn - We}ms
`); return vn.join("")
          }
        } t.StatTimer = Ze; function sn(xn, vn) { try { const { protocol: tn } = vn ? new URL(xn, vn) : new URL(xn); return tn === "http:" || tn === "https:" } catch { return !1 } } function Xe(xn) { xn.preventDefault() } function St(xn, vn = !1) { return new Promise((tn, nn) => { const We = document.createElement("script"); We.src = xn, We.onload = function (dn) { vn && We.remove(), tn(dn) }, We.onerror = function () { nn(new Error(`Cannot load script at: ${We.src}`)) }, (document.head || document.documentElement).append(We) }) } function un(xn) { console.log("Deprecated API usage: " + xn) } let on; class bn { static toDateObject(vn) { if (!vn || typeof vn != "string") return null; on ||= new RegExp("^D:(\\d{4})(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?(\\d{2})?([Z|+|-])?(\\d{2})?'?(\\d{2})?'?"); const tn = on.exec(vn); if (!tn) return null; const nn = parseInt(tn[1], 10); let We = parseInt(tn[2], 10); We = We >= 1 && We <= 12 ? We - 1 : 0; let dn = parseInt(tn[3], 10); dn = dn >= 1 && dn <= 31 ? dn : 1; let Je = parseInt(tn[4], 10); Je = Je >= 0 && Je <= 23 ? Je : 0; let rn = parseInt(tn[5], 10); rn = rn >= 0 && rn <= 59 ? rn : 0; let hn = parseInt(tn[6], 10); hn = hn >= 0 && hn <= 59 ? hn : 0; const mn = tn[7] || "Z"; let Ye = parseInt(tn[8], 10); Ye = Ye >= 0 && Ye <= 23 ? Ye : 0; let an = parseInt(tn[9], 10) || 0; return an = an >= 0 && an <= 59 ? an : 0, mn === "-" ? (Je += Ye, rn += an) : mn === "+" && (Je -= Ye, rn -= an), new Date(Date.UTC(nn, We, dn, Je, rn, hn)) } } t.PDFDateString = bn; function Tn(xn, { scale: vn = 1, rotation: tn = 0 }) { const { width: nn, height: We } = xn.attributes.style, dn = [0, 0, parseInt(nn), parseInt(We)]; return new Ie({ viewBox: dn, scale: vn, rotation: tn }) } function fn(xn) { if (xn.startsWith("#")) { const vn = parseInt(xn.slice(1), 16); return [(vn & 16711680) >> 16, (vn & 65280) >> 8, vn & 255] } return xn.startsWith("rgb(") ? xn.slice(4, -1).split(",").map(vn => parseInt(vn)) : xn.startsWith("rgba(") ? xn.slice(5, -1).split(",").map(vn => parseInt(vn)).slice(0, 3) : ((0, _e.warn)(`Not a valid color format: "${xn}"`), [0, 0, 0]) } function En(xn) { const vn = document.createElement("span"); vn.style.visibility = "hidden", document.body.append(vn); for (const tn of xn.keys()) { vn.style.color = tn; const nn = window.getComputedStyle(vn).color; xn.set(tn, fn(nn)) } vn.remove() } function Pn(xn) { const { a: vn, b: tn, c: nn, d: We, e: dn, f: Je } = xn.getTransform(); return [vn, tn, nn, We, dn, Je] } function Rn(xn) { const { a: vn, b: tn, c: nn, d: We, e: dn, f: Je } = xn.getTransform().invertSelf(); return [vn, tn, nn, We, dn, Je] } function In(xn, vn, tn = !1, nn = !0) { if (vn instanceof Ie) { const { pageWidth: We, pageHeight: dn } = vn.rawDims, { style: Je } = xn, rn = _e.FeatureTest.isCSSRoundSupported, hn = `var(--scale-factor) * ${We}px`, mn = `var(--scale-factor) * ${dn}px`, Ye = rn ? `round(${hn}, 1px)` : `calc(${hn})`, an = rn ? `round(${mn}, 1px)` : `calc(${mn})`; !tn || vn.rotation % 180 === 0 ? (Je.width = Ye, Je.height = an) : (Je.width = an, Je.height = Ye) } nn && xn.setAttribute("data-main-rotation", vn.rotation) }
      }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.BaseStandardFontDataFactory = t.BaseSVGFactory = t.BaseFilterFactory = t.BaseCanvasFactory = t.BaseCMapReaderFactory = void 0; var Ee = xe(1); class _e { constructor() { this.constructor === _e && (0, Ee.unreachable)("Cannot initialize BaseFilterFactory.") } addFilter(Oe) { return "none" } addHCMFilter(Oe, je) { return "none" } addHighlightHCMFilter(Oe, je, Be, Ie) { return "none" } destroy(Oe = !1) { } } t.BaseFilterFactory = _e; class Re { constructor() { this.constructor === Re && (0, Ee.unreachable)("Cannot initialize BaseCanvasFactory.") } create(Oe, je) { if (Oe <= 0 || je <= 0) throw new Error("Invalid canvas size"); const Be = this._createCanvas(Oe, je); return { canvas: Be, context: Be.getContext("2d") } } reset(Oe, je, Be) { if (!Oe.canvas) throw new Error("Canvas is not specified"); if (je <= 0 || Be <= 0) throw new Error("Invalid canvas size"); Oe.canvas.width = je, Oe.canvas.height = Be } destroy(Oe) { if (!Oe.canvas) throw new Error("Canvas is not specified"); Oe.canvas.width = 0, Oe.canvas.height = 0, Oe.canvas = null, Oe.context = null } _createCanvas(Oe, je) { (0, Ee.unreachable)("Abstract method `_createCanvas` called.") } } t.BaseCanvasFactory = Re; class Ce { constructor({ baseUrl: Oe = null, isCompressed: je = !0 }) { this.constructor === Ce && (0, Ee.unreachable)("Cannot initialize BaseCMapReaderFactory."), this.baseUrl = Oe, this.isCompressed = je } async fetch({ name: Oe }) { if (!this.baseUrl) throw new Error('The CMap "baseUrl" parameter must be specified, ensure that the "cMapUrl" and "cMapPacked" API parameters are provided.'); if (!Oe) throw new Error("CMap name must be specified."); const je = this.baseUrl + Oe + (this.isCompressed ? ".bcmap" : ""), Be = this.isCompressed ? Ee.CMapCompressionType.BINARY : Ee.CMapCompressionType.NONE; return this._fetchData(je, Be).catch(Ie => { throw new Error(`Unable to load ${this.isCompressed ? "binary " : ""}CMap at: ${je}`) }) } _fetchData(Oe, je) { (0, Ee.unreachable)("Abstract method `_fetchData` called.") } } t.BaseCMapReaderFactory = Ce; class Me { constructor({ baseUrl: Oe = null }) { this.constructor === Me && (0, Ee.unreachable)("Cannot initialize BaseStandardFontDataFactory."), this.baseUrl = Oe } async fetch({ filename: Oe }) { if (!this.baseUrl) throw new Error('The standard font "baseUrl" parameter must be specified, ensure that the "standardFontDataUrl" API parameter is provided.'); if (!Oe) throw new Error("Font filename must be specified."); const je = `${this.baseUrl}${Oe}`; return this._fetchData(je).catch(Be => { throw new Error(`Unable to load font data at: ${je}`) }) } _fetchData(Oe) { (0, Ee.unreachable)("Abstract method `_fetchData` called.") } } t.BaseStandardFontDataFactory = Me; class De { constructor() { this.constructor === De && (0, Ee.unreachable)("Cannot initialize BaseSVGFactory.") } create(Oe, je, Be = !1) { if (Oe <= 0 || je <= 0) throw new Error("Invalid SVG dimensions"); const Ie = this._createSVG("svg:svg"); return Ie.setAttribute("version", "1.1"), Be || (Ie.setAttribute("width", `${Oe}px`), Ie.setAttribute("height", `${je}px`)), Ie.setAttribute("preserveAspectRatio", "none"), Ie.setAttribute("viewBox", `0 0 ${Oe} ${je}`), Ie } createElement(Oe) { if (typeof Oe != "string") throw new Error("Invalid SVG element type"); return this._createSVG(Oe) } _createSVG(Oe) { (0, Ee.unreachable)("Abstract method `_createSVG` called.") } } t.BaseSVGFactory = De }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.MurmurHash3_64 = void 0; var Ee = xe(1); const _e = 3285377520, Re = 4294901760, Ce = 65535; class Me { constructor(Pe) { this.h1 = Pe ? Pe & 4294967295 : _e, this.h2 = Pe ? Pe & 4294967295 : _e } update(Pe) { let Oe, je; if (typeof Pe == "string") { Oe = new Uint8Array(Pe.length * 2), je = 0; for (let un = 0, on = Pe.length; un < on; un++) { const bn = Pe.charCodeAt(un); bn <= 255 ? Oe[je++] = bn : (Oe[je++] = bn >>> 8, Oe[je++] = bn & 255) } } else if ((0, Ee.isArrayBuffer)(Pe)) Oe = Pe.slice(), je = Oe.byteLength; else throw new Error("Wrong data format in MurmurHash3_64_update. Input must be a string or array."); const Be = je >> 2, Ie = je - Be * 4, Fe = new Uint32Array(Oe.buffer, 0, Be); let ze = 0, qe = 0, He = this.h1, Ge = this.h2; const Ze = 3432918353, sn = 461845907, Xe = Ze & Ce, St = sn & Ce; for (let un = 0; un < Be; un++)un & 1 ? (ze = Fe[un], ze = ze * Ze & Re | ze * Xe & Ce, ze = ze << 15 | ze >>> 17, ze = ze * sn & Re | ze * St & Ce, He ^= ze, He = He << 13 | He >>> 19, He = He * 5 + 3864292196) : (qe = Fe[un], qe = qe * Ze & Re | qe * Xe & Ce, qe = qe << 15 | qe >>> 17, qe = qe * sn & Re | qe * St & Ce, Ge ^= qe, Ge = Ge << 13 | Ge >>> 19, Ge = Ge * 5 + 3864292196); switch (ze = 0, Ie) { case 3: ze ^= Oe[Be * 4 + 2] << 16; case 2: ze ^= Oe[Be * 4 + 1] << 8; case 1: ze ^= Oe[Be * 4], ze = ze * Ze & Re | ze * Xe & Ce, ze = ze << 15 | ze >>> 17, ze = ze * sn & Re | ze * St & Ce, Be & 1 ? He ^= ze : Ge ^= ze }this.h1 = He, this.h2 = Ge } hexdigest() { let Pe = this.h1, Oe = this.h2; return Pe ^= Oe >>> 1, Pe = Pe * 3981806797 & Re | Pe * 36045 & Ce, Oe = Oe * 4283543511 & Re | ((Oe << 16 | Pe >>> 16) * 2950163797 & Re) >>> 16, Pe ^= Oe >>> 1, Pe = Pe * 444984403 & Re | Pe * 60499 & Ce, Oe = Oe * 3301882366 & Re | ((Oe << 16 | Pe >>> 16) * 3120437893 & Re) >>> 16, Pe ^= Oe >>> 1, (Pe >>> 0).toString(16).padStart(8, "0") + (Oe >>> 0).toString(16).padStart(8, "0") } } t.MurmurHash3_64 = Me }, (e, t, xe) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.FontLoader = t.FontFaceObject = void 0; var Ee = xe(1); class _e { #e = new Set; constructor({ ownerDocument: Me = globalThis.document, styleElement: De = null }) { this._document = Me, this.nativeFontFaces = new Set, this.styleElement = null, this.loadingRequests = [], this.loadTestFontId = 0 } addNativeFontFace(Me) { this.nativeFontFaces.add(Me), this._document.fonts.add(Me) } removeNativeFontFace(Me) { this.nativeFontFaces.delete(Me), this._document.fonts.delete(Me) } insertRule(Me) { this.styleElement || (this.styleElement = this._document.createElement("style"), this._document.documentElement.getElementsByTagName("head")[0].append(this.styleElement)); const De = this.styleElement.sheet; De.insertRule(Me, De.cssRules.length) } clear() { for (const Me of this.nativeFontFaces) this._document.fonts.delete(Me); this.nativeFontFaces.clear(), this.#e.clear(), this.styleElement && (this.styleElement.remove(), this.styleElement = null) } async loadSystemFont(Me) { if (!(!Me || this.#e.has(Me.loadedName))) { if ((0, Ee.assert)(!this.disableFontFace, "loadSystemFont shouldn't be called when `disableFontFace` is set."), this.isFontLoadingAPISupported) { const { loadedName: De, src: Pe, style: Oe } = Me, je = new FontFace(De, Pe, Oe); this.addNativeFontFace(je); try { await je.load(), this.#e.add(De) } catch { (0, Ee.warn)(`Cannot load system font: ${Me.baseFontName}, installing it could help to improve PDF rendering.`), this.removeNativeFontFace(je) } return } (0, Ee.unreachable)("Not implemented: loadSystemFont without the Font Loading API.") } } async bind(Me) { if (Me.attached || Me.missingFile && !Me.systemFontInfo) return; if (Me.attached = !0, Me.systemFontInfo) { await this.loadSystemFont(Me.systemFontInfo); return } if (this.isFontLoadingAPISupported) { const Pe = Me.createNativeFontFace(); if (Pe) { this.addNativeFontFace(Pe); try { await Pe.loaded } catch (Oe) { throw (0, Ee.warn)(`Failed to load font '${Pe.family}': '${Oe}'.`), Me.disableFontFace = !0, Oe } } return } const De = Me.createFontFaceRule(); if (De) { if (this.insertRule(De), this.isSyncFontLoadingSupported) return; await new Promise(Pe => { const Oe = this._queueLoadingCallback(Pe); this._prepareFontLoadEvent(Me, Oe) }) } } get isFontLoadingAPISupported() { const Me = !!this._document?.fonts; return (0, Ee.shadow)(this, "isFontLoadingAPISupported", Me) } get isSyncFontLoadingSupported() { let Me = !1; return (Ee.isNodeJS || typeof navigator < "u" && /Mozilla\/5.0.*?rv:\d+.*? Gecko/.test(navigator.userAgent)) && (Me = !0), (0, Ee.shadow)(this, "isSyncFontLoadingSupported", Me) } _queueLoadingCallback(Me) { function De() { for ((0, Ee.assert)(!Oe.done, "completeRequest() cannot be called twice."), Oe.done = !0; Pe.length > 0 && Pe[0].done;) { const je = Pe.shift(); setTimeout(je.callback, 0) } } const { loadingRequests: Pe } = this, Oe = { done: !1, complete: De, callback: Me }; return Pe.push(Oe), Oe } get _loadTestFont() { const Me = atob("T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQAFQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAAALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgAAAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACMAooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4DIP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAAAAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUAAQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgABAAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABYAAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAAAC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAAAAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQACAQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTjFQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA=="); return (0, Ee.shadow)(this, "_loadTestFont", Me) } _prepareFontLoadEvent(Me, De) { function Pe(Tn, fn) { return Tn.charCodeAt(fn) << 24 | Tn.charCodeAt(fn + 1) << 16 | Tn.charCodeAt(fn + 2) << 8 | Tn.charCodeAt(fn + 3) & 255 } function Oe(Tn, fn, En, Pn) { const Rn = Tn.substring(0, fn), In = Tn.substring(fn + En); return Rn + Pn + In } let je, Be; const Ie = this._document.createElement("canvas"); Ie.width = 1, Ie.height = 1; const Fe = Ie.getContext("2d"); let ze = 0; function qe(Tn, fn) { if (++ze > 30) { (0, Ee.warn)("Load test font never loaded."), fn(); return } if (Fe.font = "30px " + Tn, Fe.fillText(".", 0, 20), Fe.getImageData(0, 0, 1, 1).data[3] > 0) { fn(); return } setTimeout(qe.bind(null, Tn, fn)) } const He = `lt${Date.now()}${this.loadTestFontId++}`; let Ge = this._loadTestFont; Ge = Oe(Ge, 976, He.length, He); const sn = 16, Xe = 1482184792; let St = Pe(Ge, sn); for (je = 0, Be = He.length - 3; je < Be; je += 4)St = St - Xe + Pe(He, je) | 0; je < He.length && (St = St - Xe + Pe(He + "XXX", je) | 0), Ge = Oe(Ge, sn, 4, (0, Ee.string32)(St)); const un = `url(data:font/opentype;base64,${btoa(Ge)});`, on = `@font-face {font-family:"${He}";src:${un}}`; this.insertRule(on); const bn = this._document.createElement("div"); bn.style.visibility = "hidden", bn.style.width = bn.style.height = "10px", bn.style.position = "absolute", bn.style.top = bn.style.left = "0px"; for (const Tn of [Me.loadedName, He]) { const fn = this._document.createElement("span"); fn.textContent = "Hi", fn.style.fontFamily = Tn, bn.append(fn) } this._document.body.append(bn), qe(He, () => { bn.remove(), De.complete() }) } } t.FontLoader = _e; class Re {
          constructor(Me, { isEvalSupported: De = !0, disableFontFace: Pe = !1, ignoreErrors: Oe = !1, inspectFont: je = null }) { this.compiledGlyphs = Object.create(null); for (const Be in Me) this[Be] = Me[Be]; this.isEvalSupported = De !== !1, this.disableFontFace = Pe === !0, this.ignoreErrors = Oe === !0, this._inspectFont = je } createNativeFontFace() { if (!this.data || this.disableFontFace) return null; let Me; if (!this.cssFontInfo) Me = new FontFace(this.loadedName, this.data, {}); else { const De = { weight: this.cssFontInfo.fontWeight }; this.cssFontInfo.italicAngle && (De.style = `oblique ${this.cssFontInfo.italicAngle}deg`), Me = new FontFace(this.cssFontInfo.fontFamily, this.data, De) } return this._inspectFont?.(this), Me } createFontFaceRule() { if (!this.data || this.disableFontFace) return null; const Me = (0, Ee.bytesToString)(this.data), De = `url(data:${this.mimetype};base64,${btoa(Me)});`; let Pe; if (!this.cssFontInfo) Pe = `@font-face {font-family:"${this.loadedName}";src:${De}}`; else { let Oe = `font-weight: ${this.cssFontInfo.fontWeight};`; this.cssFontInfo.italicAngle && (Oe += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`), Pe = `@font-face {font-family:"${this.cssFontInfo.fontFamily}";${Oe}src:${De}}` } return this._inspectFont?.(this, De), Pe } getPathGenerator(Me, De) {
            if (this.compiledGlyphs[De] !== void 0) return this.compiledGlyphs[De]; let Pe; try { Pe = Me.get(this.loadedName + "_path_" + De) } catch (Oe) { if (!this.ignoreErrors) throw Oe; return (0, Ee.warn)(`getPathGenerator - ignoring character: "${Oe}".`), this.compiledGlyphs[De] = function (je, Be) { } } if (this.isEvalSupported && Ee.FeatureTest.isEvalSupported) {
              const Oe = []; for (const je of Pe) {
                const Be = je.args !== void 0 ? je.args.join(",") : ""; Oe.push("c.", je.cmd, "(", Be, `);
`)
              } return this.compiledGlyphs[De] = new Function("c", "size", Oe.join(""))
            } return this.compiledGlyphs[De] = function (Oe, je) { for (const Be of Pe) Be.cmd === "scale" && (Be.args = [je, -je]), Oe[Be.cmd].apply(Oe, Be.args) }
          }
        } t.FontFaceObject = Re
      }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.NodeStandardFontDataFactory = t.NodeFilterFactory = t.NodeCanvasFactory = t.NodeCMapReaderFactory = void 0; var Ee = xe(7); xe(1); const _e = function (Pe) { return new Promise((Oe, je) => { require$$5.readFile(Pe, (Ie, Fe) => { if (Ie || !Fe) { je(new Error(Ie)); return } Oe(new Uint8Array(Fe)) }) }) }; class Re extends Ee.BaseFilterFactory { } t.NodeFilterFactory = Re; class Ce extends Ee.BaseCanvasFactory { _createCanvas(Oe, je) { return require$$5.createCanvas(Oe, je) } } t.NodeCanvasFactory = Ce; class Me extends Ee.BaseCMapReaderFactory { _fetchData(Oe, je) { return _e(Oe).then(Be => ({ cMapData: Be, compressionType: je })) } } t.NodeCMapReaderFactory = Me; class De extends Ee.BaseStandardFontDataFactory { _fetchData(Oe) { return _e(Oe) } } t.NodeStandardFontDataFactory = De }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.CanvasGraphics = void 0; var Ee = xe(1), _e = xe(6), Re = xe(12), Ce = xe(13); const Me = 16, De = 100, Pe = 4096, Oe = 15, je = 10, Be = 1e3, Ie = 16; function Fe(tn, nn) { if (tn._removeMirroring) throw new Error("Context is already forwarding operations."); tn.__originalSave = tn.save, tn.__originalRestore = tn.restore, tn.__originalRotate = tn.rotate, tn.__originalScale = tn.scale, tn.__originalTranslate = tn.translate, tn.__originalTransform = tn.transform, tn.__originalSetTransform = tn.setTransform, tn.__originalResetTransform = tn.resetTransform, tn.__originalClip = tn.clip, tn.__originalMoveTo = tn.moveTo, tn.__originalLineTo = tn.lineTo, tn.__originalBezierCurveTo = tn.bezierCurveTo, tn.__originalRect = tn.rect, tn.__originalClosePath = tn.closePath, tn.__originalBeginPath = tn.beginPath, tn._removeMirroring = () => { tn.save = tn.__originalSave, tn.restore = tn.__originalRestore, tn.rotate = tn.__originalRotate, tn.scale = tn.__originalScale, tn.translate = tn.__originalTranslate, tn.transform = tn.__originalTransform, tn.setTransform = tn.__originalSetTransform, tn.resetTransform = tn.__originalResetTransform, tn.clip = tn.__originalClip, tn.moveTo = tn.__originalMoveTo, tn.lineTo = tn.__originalLineTo, tn.bezierCurveTo = tn.__originalBezierCurveTo, tn.rect = tn.__originalRect, tn.closePath = tn.__originalClosePath, tn.beginPath = tn.__originalBeginPath, delete tn._removeMirroring }, tn.save = function () { nn.save(), this.__originalSave() }, tn.restore = function () { nn.restore(), this.__originalRestore() }, tn.translate = function (dn, Je) { nn.translate(dn, Je), this.__originalTranslate(dn, Je) }, tn.scale = function (dn, Je) { nn.scale(dn, Je), this.__originalScale(dn, Je) }, tn.transform = function (dn, Je, rn, hn, mn, Ye) { nn.transform(dn, Je, rn, hn, mn, Ye), this.__originalTransform(dn, Je, rn, hn, mn, Ye) }, tn.setTransform = function (dn, Je, rn, hn, mn, Ye) { nn.setTransform(dn, Je, rn, hn, mn, Ye), this.__originalSetTransform(dn, Je, rn, hn, mn, Ye) }, tn.resetTransform = function () { nn.resetTransform(), this.__originalResetTransform() }, tn.rotate = function (dn) { nn.rotate(dn), this.__originalRotate(dn) }, tn.clip = function (dn) { nn.clip(dn), this.__originalClip(dn) }, tn.moveTo = function (We, dn) { nn.moveTo(We, dn), this.__originalMoveTo(We, dn) }, tn.lineTo = function (We, dn) { nn.lineTo(We, dn), this.__originalLineTo(We, dn) }, tn.bezierCurveTo = function (We, dn, Je, rn, hn, mn) { nn.bezierCurveTo(We, dn, Je, rn, hn, mn), this.__originalBezierCurveTo(We, dn, Je, rn, hn, mn) }, tn.rect = function (We, dn, Je, rn) { nn.rect(We, dn, Je, rn), this.__originalRect(We, dn, Je, rn) }, tn.closePath = function () { nn.closePath(), this.__originalClosePath() }, tn.beginPath = function () { nn.beginPath(), this.__originalBeginPath() } } class ze { constructor(nn) { this.canvasFactory = nn, this.cache = Object.create(null) } getCanvas(nn, We, dn) { let Je; return this.cache[nn] !== void 0 ? (Je = this.cache[nn], this.canvasFactory.reset(Je, We, dn)) : (Je = this.canvasFactory.create(We, dn), this.cache[nn] = Je), Je } delete(nn) { delete this.cache[nn] } clear() { for (const nn in this.cache) { const We = this.cache[nn]; this.canvasFactory.destroy(We), delete this.cache[nn] } } } function qe(tn, nn, We, dn, Je, rn, hn, mn, Ye, an) { const [pn, yn, _n, On, kn, zn] = (0, _e.getCurrentTransform)(tn); if (yn === 0 && _n === 0) { const Cn = hn * pn + kn, Vn = Math.round(Cn), Yn = mn * On + zn, qn = Math.round(Yn), rr = (hn + Ye) * pn + kn, hr = Math.abs(Math.round(rr) - Vn) || 1, ur = (mn + an) * On + zn, Er = Math.abs(Math.round(ur) - qn) || 1; return tn.setTransform(Math.sign(pn), 0, 0, Math.sign(On), Vn, qn), tn.drawImage(nn, We, dn, Je, rn, 0, 0, hr, Er), tn.setTransform(pn, yn, _n, On, kn, zn), [hr, Er] } if (pn === 0 && On === 0) { const Cn = mn * _n + kn, Vn = Math.round(Cn), Yn = hn * yn + zn, qn = Math.round(Yn), rr = (mn + an) * _n + kn, hr = Math.abs(Math.round(rr) - Vn) || 1, ur = (hn + Ye) * yn + zn, Er = Math.abs(Math.round(ur) - qn) || 1; return tn.setTransform(0, Math.sign(yn), Math.sign(_n), 0, Vn, qn), tn.drawImage(nn, We, dn, Je, rn, 0, 0, Er, hr), tn.setTransform(pn, yn, _n, On, kn, zn), [Er, hr] } tn.drawImage(nn, We, dn, Je, rn, hn, mn, Ye, an); const sr = Math.hypot(pn, yn), Fn = Math.hypot(_n, On); return [sr * Ye, Fn * an] } function He(tn) { const { width: nn, height: We } = tn; if (nn > Be || We > Be) return null; const dn = 1e3, Je = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]), rn = nn + 1; let hn = new Uint8Array(rn * (We + 1)), mn, Ye, an; const pn = nn + 7 & -8; let yn = new Uint8Array(pn * We), _n = 0; for (const Fn of tn.data) { let Cn = 128; for (; Cn > 0;)yn[_n++] = Fn & Cn ? 0 : 255, Cn >>= 1 } let On = 0; for (_n = 0, yn[_n] !== 0 && (hn[0] = 1, ++On), Ye = 1; Ye < nn; Ye++)yn[_n] !== yn[_n + 1] && (hn[Ye] = yn[_n] ? 2 : 1, ++On), _n++; for (yn[_n] !== 0 && (hn[Ye] = 2, ++On), mn = 1; mn < We; mn++) { _n = mn * pn, an = mn * rn, yn[_n - pn] !== yn[_n] && (hn[an] = yn[_n] ? 1 : 8, ++On); let Fn = (yn[_n] ? 4 : 0) + (yn[_n - pn] ? 8 : 0); for (Ye = 1; Ye < nn; Ye++)Fn = (Fn >> 2) + (yn[_n + 1] ? 4 : 0) + (yn[_n - pn + 1] ? 8 : 0), Je[Fn] && (hn[an + Ye] = Je[Fn], ++On), _n++; if (yn[_n - pn] !== yn[_n] && (hn[an + Ye] = yn[_n] ? 2 : 4, ++On), On > dn) return null } for (_n = pn * (We - 1), an = mn * rn, yn[_n] !== 0 && (hn[an] = 8, ++On), Ye = 1; Ye < nn; Ye++)yn[_n] !== yn[_n + 1] && (hn[an + Ye] = yn[_n] ? 4 : 8, ++On), _n++; if (yn[_n] !== 0 && (hn[an + Ye] = 4, ++On), On > dn) return null; const kn = new Int32Array([0, rn, -1, 0, -rn, 0, 0, 0, 1]), zn = new Path2D; for (mn = 0; On && mn <= We; mn++) { let Fn = mn * rn; const Cn = Fn + nn; for (; Fn < Cn && !hn[Fn];)Fn++; if (Fn === Cn) continue; zn.moveTo(Fn % rn, mn); const Vn = Fn; let Yn = hn[Fn]; do { const qn = kn[Yn]; do Fn += qn; while (!hn[Fn]); const rr = hn[Fn]; rr !== 5 && rr !== 10 ? (Yn = rr, hn[Fn] = 0) : (Yn = rr & 51 * Yn >> 4, hn[Fn] &= Yn >> 2 | Yn << 2), zn.lineTo(Fn % rn, Fn / rn | 0), hn[Fn] || --On } while (Vn !== Fn); --mn } return yn = null, hn = null, function (Fn) { Fn.save(), Fn.scale(1 / nn, -1 / We), Fn.translate(0, -We), Fn.fill(zn), Fn.beginPath(), Fn.restore() } } class Ge { constructor(nn, We) { this.alphaIsShape = !1, this.fontSize = 0, this.fontSizeScale = 1, this.textMatrix = Ee.IDENTITY_MATRIX, this.textMatrixScale = 1, this.fontMatrix = Ee.FONT_IDENTITY_MATRIX, this.leading = 0, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRenderingMode = Ee.TextRenderingMode.FILL, this.textRise = 0, this.fillColor = "#000000", this.strokeColor = "#000000", this.patternFill = !1, this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.activeSMask = null, this.transferMaps = "none", this.startNewPathAndClipBox([0, 0, nn, We]) } clone() { const nn = Object.create(this); return nn.clipBox = this.clipBox.slice(), nn } setCurrentPoint(nn, We) { this.x = nn, this.y = We } updatePathMinMax(nn, We, dn) { [We, dn] = Ee.Util.applyTransform([We, dn], nn), this.minX = Math.min(this.minX, We), this.minY = Math.min(this.minY, dn), this.maxX = Math.max(this.maxX, We), this.maxY = Math.max(this.maxY, dn) } updateRectMinMax(nn, We) { const dn = Ee.Util.applyTransform(We, nn), Je = Ee.Util.applyTransform(We.slice(2), nn); this.minX = Math.min(this.minX, dn[0], Je[0]), this.minY = Math.min(this.minY, dn[1], Je[1]), this.maxX = Math.max(this.maxX, dn[0], Je[0]), this.maxY = Math.max(this.maxY, dn[1], Je[1]) } updateScalingPathMinMax(nn, We) { Ee.Util.scaleMinMax(nn, We), this.minX = Math.min(this.minX, We[0]), this.maxX = Math.max(this.maxX, We[1]), this.minY = Math.min(this.minY, We[2]), this.maxY = Math.max(this.maxY, We[3]) } updateCurvePathMinMax(nn, We, dn, Je, rn, hn, mn, Ye, an, pn) { const yn = Ee.Util.bezierBoundingBox(We, dn, Je, rn, hn, mn, Ye, an); if (pn) { pn[0] = Math.min(pn[0], yn[0], yn[2]), pn[1] = Math.max(pn[1], yn[0], yn[2]), pn[2] = Math.min(pn[2], yn[1], yn[3]), pn[3] = Math.max(pn[3], yn[1], yn[3]); return } this.updateRectMinMax(nn, yn) } getPathBoundingBox(nn = Re.PathType.FILL, We = null) { const dn = [this.minX, this.minY, this.maxX, this.maxY]; if (nn === Re.PathType.STROKE) { We || (0, Ee.unreachable)("Stroke bounding box must include transform."); const Je = Ee.Util.singularValueDecompose2dScale(We), rn = Je[0] * this.lineWidth / 2, hn = Je[1] * this.lineWidth / 2; dn[0] -= rn, dn[1] -= hn, dn[2] += rn, dn[3] += hn } return dn } updateClipFromPath() { const nn = Ee.Util.intersect(this.clipBox, this.getPathBoundingBox()); this.startNewPathAndClipBox(nn || [0, 0, 0, 0]) } isEmptyClip() { return this.minX === 1 / 0 } startNewPathAndClipBox(nn) { this.clipBox = nn, this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = 0, this.maxY = 0 } getClippedPathBoundingBox(nn = Re.PathType.FILL, We = null) { return Ee.Util.intersect(this.clipBox, this.getPathBoundingBox(nn, We)) } } function Ze(tn, nn) { if (typeof ImageData < "u" && nn instanceof ImageData) { tn.putImageData(nn, 0, 0); return } const We = nn.height, dn = nn.width, Je = We % Ie, rn = (We - Je) / Ie, hn = Je === 0 ? rn : rn + 1, mn = tn.createImageData(dn, Ie); let Ye = 0, an; const pn = nn.data, yn = mn.data; let _n, On, kn, zn; if (nn.kind === Ee.ImageKind.GRAYSCALE_1BPP) { const sr = pn.byteLength, Fn = new Uint32Array(yn.buffer, 0, yn.byteLength >> 2), Cn = Fn.length, Vn = dn + 7 >> 3, Yn = 4294967295, qn = Ee.FeatureTest.isLittleEndian ? 4278190080 : 255; for (_n = 0; _n < hn; _n++) { for (kn = _n < rn ? Ie : Je, an = 0, On = 0; On < kn; On++) { const rr = sr - Ye; let hr = 0; const ur = rr > Vn ? dn : rr * 8 - 7, Er = ur & -8; let _r = 0, Or = 0; for (; hr < Er; hr += 8)Or = pn[Ye++], Fn[an++] = Or & 128 ? Yn : qn, Fn[an++] = Or & 64 ? Yn : qn, Fn[an++] = Or & 32 ? Yn : qn, Fn[an++] = Or & 16 ? Yn : qn, Fn[an++] = Or & 8 ? Yn : qn, Fn[an++] = Or & 4 ? Yn : qn, Fn[an++] = Or & 2 ? Yn : qn, Fn[an++] = Or & 1 ? Yn : qn; for (; hr < ur; hr++)_r === 0 && (Or = pn[Ye++], _r = 128), Fn[an++] = Or & _r ? Yn : qn, _r >>= 1 } for (; an < Cn;)Fn[an++] = 0; tn.putImageData(mn, 0, _n * Ie) } } else if (nn.kind === Ee.ImageKind.RGBA_32BPP) { for (On = 0, zn = dn * Ie * 4, _n = 0; _n < rn; _n++)yn.set(pn.subarray(Ye, Ye + zn)), Ye += zn, tn.putImageData(mn, 0, On), On += Ie; _n < hn && (zn = dn * Je * 4, yn.set(pn.subarray(Ye, Ye + zn)), tn.putImageData(mn, 0, On)) } else if (nn.kind === Ee.ImageKind.RGB_24BPP) for (kn = Ie, zn = dn * kn, _n = 0; _n < hn; _n++) { for (_n >= rn && (kn = Je, zn = dn * kn), an = 0, On = zn; On--;)yn[an++] = pn[Ye++], yn[an++] = pn[Ye++], yn[an++] = pn[Ye++], yn[an++] = 255; tn.putImageData(mn, 0, _n * Ie) } else throw new Error(`bad image kind: ${nn.kind}`) } function sn(tn, nn) { if (nn.bitmap) { tn.drawImage(nn.bitmap, 0, 0); return } const We = nn.height, dn = nn.width, Je = We % Ie, rn = (We - Je) / Ie, hn = Je === 0 ? rn : rn + 1, mn = tn.createImageData(dn, Ie); let Ye = 0; const an = nn.data, pn = mn.data; for (let yn = 0; yn < hn; yn++) { const _n = yn < rn ? Ie : Je; ({ srcPos: Ye } = (0, Ce.convertBlackAndWhiteToRGBA)({ src: an, srcPos: Ye, dest: pn, width: dn, height: _n, nonBlackColor: 0 })), tn.putImageData(mn, 0, yn * Ie) } } function Xe(tn, nn) { const We = ["strokeStyle", "fillStyle", "fillRule", "globalAlpha", "lineWidth", "lineCap", "lineJoin", "miterLimit", "globalCompositeOperation", "font", "filter"]; for (const dn of We) tn[dn] !== void 0 && (nn[dn] = tn[dn]); tn.setLineDash !== void 0 && (nn.setLineDash(tn.getLineDash()), nn.lineDashOffset = tn.lineDashOffset) } function St(tn) { if (tn.strokeStyle = tn.fillStyle = "#000000", tn.fillRule = "nonzero", tn.globalAlpha = 1, tn.lineWidth = 1, tn.lineCap = "butt", tn.lineJoin = "miter", tn.miterLimit = 10, tn.globalCompositeOperation = "source-over", tn.font = "10px sans-serif", tn.setLineDash !== void 0 && (tn.setLineDash([]), tn.lineDashOffset = 0), !Ee.isNodeJS) { const { filter: nn } = tn; nn !== "none" && nn !== "" && (tn.filter = "none") } } function un(tn, nn, We, dn) { const Je = tn.length; for (let rn = 3; rn < Je; rn += 4) { const hn = tn[rn]; if (hn === 0) tn[rn - 3] = nn, tn[rn - 2] = We, tn[rn - 1] = dn; else if (hn < 255) { const mn = 255 - hn; tn[rn - 3] = tn[rn - 3] * hn + nn * mn >> 8, tn[rn - 2] = tn[rn - 2] * hn + We * mn >> 8, tn[rn - 1] = tn[rn - 1] * hn + dn * mn >> 8 } } } function on(tn, nn, We) { const dn = tn.length, Je = 1 / 255; for (let rn = 3; rn < dn; rn += 4) { const hn = We ? We[tn[rn]] : tn[rn]; nn[rn] = nn[rn] * hn * Je | 0 } } function bn(tn, nn, We) { const dn = tn.length; for (let Je = 3; Je < dn; Je += 4) { const rn = tn[Je - 3] * 77 + tn[Je - 2] * 152 + tn[Je - 1] * 28; nn[Je] = We ? nn[Je] * We[rn >> 8] >> 8 : nn[Je] * rn >> 16 } } function Tn(tn, nn, We, dn, Je, rn, hn, mn, Ye, an, pn) { const yn = !!rn, _n = yn ? rn[0] : 0, On = yn ? rn[1] : 0, kn = yn ? rn[2] : 0, zn = Je === "Luminosity" ? bn : on, Fn = Math.min(dn, Math.ceil(1048576 / We)); for (let Cn = 0; Cn < dn; Cn += Fn) { const Vn = Math.min(Fn, dn - Cn), Yn = tn.getImageData(mn - an, Cn + (Ye - pn), We, Vn), qn = nn.getImageData(mn, Cn + Ye, We, Vn); yn && un(Yn.data, _n, On, kn), zn(Yn.data, qn.data, hn), nn.putImageData(qn, mn, Cn + Ye) } } function fn(tn, nn, We, dn) { const Je = dn[0], rn = dn[1], hn = dn[2] - Je, mn = dn[3] - rn; hn === 0 || mn === 0 || (Tn(nn.context, We, hn, mn, nn.subtype, nn.backdrop, nn.transferMap, Je, rn, nn.offsetX, nn.offsetY), tn.save(), tn.globalAlpha = 1, tn.globalCompositeOperation = "source-over", tn.setTransform(1, 0, 0, 1, 0, 0), tn.drawImage(We.canvas, 0, 0), tn.restore()) } function En(tn, nn) { const We = Ee.Util.singularValueDecompose2dScale(tn); We[0] = Math.fround(We[0]), We[1] = Math.fround(We[1]); const dn = Math.fround((globalThis.devicePixelRatio || 1) * _e.PixelsPerInch.PDF_TO_CSS_UNITS); return nn !== void 0 ? nn : We[0] <= dn || We[1] <= dn } const Pn = ["butt", "round", "square"], Rn = ["miter", "round", "bevel"], In = {}, xn = {}; class vn { constructor(nn, We, dn, Je, rn, { optionalContentConfig: hn, markedContentStack: mn = null }, Ye, an) { this.ctx = nn, this.current = new Ge(this.ctx.canvas.width, this.ctx.canvas.height), this.stateStack = [], this.pendingClip = null, this.pendingEOFill = !1, this.res = null, this.xobjs = null, this.commonObjs = We, this.objs = dn, this.canvasFactory = Je, this.filterFactory = rn, this.groupStack = [], this.processingType3 = null, this.baseTransform = null, this.baseTransformStack = [], this.groupLevel = 0, this.smaskStack = [], this.smaskCounter = 0, this.tempSMask = null, this.suspendedCtx = null, this.contentVisible = !0, this.markedContentStack = mn || [], this.optionalContentConfig = hn, this.cachedCanvases = new ze(this.canvasFactory), this.cachedPatterns = new Map, this.annotationCanvasMap = Ye, this.viewportScale = 1, this.outputScaleX = 1, this.outputScaleY = 1, this.pageColors = an, this._cachedScaleForStroking = [-1, 0], this._cachedGetSinglePixelWidth = null, this._cachedBitmapsMap = new Map } getObject(nn, We = null) { return typeof nn == "string" ? nn.startsWith("g_") ? this.commonObjs.get(nn) : this.objs.get(nn) : We } beginDrawing({ transform: nn, viewport: We, transparency: dn = !1, background: Je = null }) { const rn = this.ctx.canvas.width, hn = this.ctx.canvas.height, mn = this.ctx.fillStyle; if (this.ctx.fillStyle = Je || "#ffffff", this.ctx.fillRect(0, 0, rn, hn), this.ctx.fillStyle = mn, dn) { const Ye = this.cachedCanvases.getCanvas("transparent", rn, hn); this.compositeCtx = this.ctx, this.transparentCanvas = Ye.canvas, this.ctx = Ye.context, this.ctx.save(), this.ctx.transform(...(0, _e.getCurrentTransform)(this.compositeCtx)) } this.ctx.save(), St(this.ctx), nn && (this.ctx.transform(...nn), this.outputScaleX = nn[0], this.outputScaleY = nn[0]), this.ctx.transform(...We.transform), this.viewportScale = We.scale, this.baseTransform = (0, _e.getCurrentTransform)(this.ctx) } executeOperatorList(nn, We, dn, Je) { const rn = nn.argsArray, hn = nn.fnArray; let mn = We || 0; const Ye = rn.length; if (Ye === mn) return mn; const an = Ye - mn > je && typeof dn == "function", pn = an ? Date.now() + Oe : 0; let yn = 0; const _n = this.commonObjs, On = this.objs; let kn; for (; ;) { if (Je !== void 0 && mn === Je.nextBreakPoint) return Je.breakIt(mn, dn), mn; if (kn = hn[mn], kn !== Ee.OPS.dependency) this[kn].apply(this, rn[mn]); else for (const zn of rn[mn]) { const sr = zn.startsWith("g_") ? _n : On; if (!sr.has(zn)) return sr.get(zn, dn), mn } if (mn++, mn === Ye) return mn; if (an && ++yn > je) { if (Date.now() > pn) return dn(), mn; yn = 0 } } } #e() { for (; this.stateStack.length || this.inSMaskMode;)this.restore(); this.ctx.restore(), this.transparentCanvas && (this.ctx = this.compositeCtx, this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.drawImage(this.transparentCanvas, 0, 0), this.ctx.restore(), this.transparentCanvas = null) } endDrawing() { this.#e(), this.cachedCanvases.clear(), this.cachedPatterns.clear(); for (const nn of this._cachedBitmapsMap.values()) { for (const We of nn.values()) typeof HTMLCanvasElement < "u" && We instanceof HTMLCanvasElement && (We.width = We.height = 0); nn.clear() } this._cachedBitmapsMap.clear(), this.#t() } #t() { if (this.pageColors) { const nn = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background); if (nn !== "none") { const We = this.ctx.filter; this.ctx.filter = nn, this.ctx.drawImage(this.ctx.canvas, 0, 0), this.ctx.filter = We } } } _scaleImage(nn, We) { const dn = nn.width, Je = nn.height; let rn = Math.max(Math.hypot(We[0], We[1]), 1), hn = Math.max(Math.hypot(We[2], We[3]), 1), mn = dn, Ye = Je, an = "prescale1", pn, yn; for (; rn > 2 && mn > 1 || hn > 2 && Ye > 1;) { let _n = mn, On = Ye; rn > 2 && mn > 1 && (_n = mn >= 16384 ? Math.floor(mn / 2) - 1 || 1 : Math.ceil(mn / 2), rn /= mn / _n), hn > 2 && Ye > 1 && (On = Ye >= 16384 ? Math.floor(Ye / 2) - 1 || 1 : Math.ceil(Ye) / 2, hn /= Ye / On), pn = this.cachedCanvases.getCanvas(an, _n, On), yn = pn.context, yn.clearRect(0, 0, _n, On), yn.drawImage(nn, 0, 0, mn, Ye, 0, 0, _n, On), nn = pn.canvas, mn = _n, Ye = On, an = an === "prescale1" ? "prescale2" : "prescale1" } return { img: nn, paintWidth: mn, paintHeight: Ye } } _createMaskCanvas(nn) { const We = this.ctx, { width: dn, height: Je } = nn, rn = this.current.fillColor, hn = this.current.patternFill, mn = (0, _e.getCurrentTransform)(We); let Ye, an, pn, yn; if ((nn.bitmap || nn.data) && nn.count > 1) { const hr = nn.bitmap || nn.data.buffer; an = JSON.stringify(hn ? mn : [mn.slice(0, 4), rn]), Ye = this._cachedBitmapsMap.get(hr), Ye || (Ye = new Map, this._cachedBitmapsMap.set(hr, Ye)); const ur = Ye.get(an); if (ur && !hn) { const Er = Math.round(Math.min(mn[0], mn[2]) + mn[4]), _r = Math.round(Math.min(mn[1], mn[3]) + mn[5]); return { canvas: ur, offsetX: Er, offsetY: _r } } pn = ur } pn || (yn = this.cachedCanvases.getCanvas("maskCanvas", dn, Je), sn(yn.context, nn)); let _n = Ee.Util.transform(mn, [1 / dn, 0, 0, -1 / Je, 0, 0]); _n = Ee.Util.transform(_n, [1, 0, 0, 1, 0, -Je]); const On = Ee.Util.applyTransform([0, 0], _n), kn = Ee.Util.applyTransform([dn, Je], _n), zn = Ee.Util.normalizeRect([On[0], On[1], kn[0], kn[1]]), sr = Math.round(zn[2] - zn[0]) || 1, Fn = Math.round(zn[3] - zn[1]) || 1, Cn = this.cachedCanvases.getCanvas("fillCanvas", sr, Fn), Vn = Cn.context, Yn = Math.min(On[0], kn[0]), qn = Math.min(On[1], kn[1]); Vn.translate(-Yn, -qn), Vn.transform(..._n), pn || (pn = this._scaleImage(yn.canvas, (0, _e.getCurrentTransformInverse)(Vn)), pn = pn.img, Ye && hn && Ye.set(an, pn)), Vn.imageSmoothingEnabled = En((0, _e.getCurrentTransform)(Vn), nn.interpolate), qe(Vn, pn, 0, 0, pn.width, pn.height, 0, 0, dn, Je), Vn.globalCompositeOperation = "source-in"; const rr = Ee.Util.transform((0, _e.getCurrentTransformInverse)(Vn), [1, 0, 0, 1, -Yn, -qn]); return Vn.fillStyle = hn ? rn.getPattern(We, this, rr, Re.PathType.FILL) : rn, Vn.fillRect(0, 0, dn, Je), Ye && !hn && (this.cachedCanvases.delete("fillCanvas"), Ye.set(an, Cn.canvas)), { canvas: Cn.canvas, offsetX: Math.round(Yn), offsetY: Math.round(qn) } } setLineWidth(nn) { nn !== this.current.lineWidth && (this._cachedScaleForStroking[0] = -1), this.current.lineWidth = nn, this.ctx.lineWidth = nn } setLineCap(nn) { this.ctx.lineCap = Pn[nn] } setLineJoin(nn) { this.ctx.lineJoin = Rn[nn] } setMiterLimit(nn) { this.ctx.miterLimit = nn } setDash(nn, We) { const dn = this.ctx; dn.setLineDash !== void 0 && (dn.setLineDash(nn), dn.lineDashOffset = We) } setRenderingIntent(nn) { } setFlatness(nn) { } setGState(nn) { for (const [We, dn] of nn) switch (We) { case "LW": this.setLineWidth(dn); break; case "LC": this.setLineCap(dn); break; case "LJ": this.setLineJoin(dn); break; case "ML": this.setMiterLimit(dn); break; case "D": this.setDash(dn[0], dn[1]); break; case "RI": this.setRenderingIntent(dn); break; case "FL": this.setFlatness(dn); break; case "Font": this.setFont(dn[0], dn[1]); break; case "CA": this.current.strokeAlpha = dn; break; case "ca": this.current.fillAlpha = dn, this.ctx.globalAlpha = dn; break; case "BM": this.ctx.globalCompositeOperation = dn; break; case "SMask": this.current.activeSMask = dn ? this.tempSMask : null, this.tempSMask = null, this.checkSMaskState(); break; case "TR": this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(dn); break } } get inSMaskMode() { return !!this.suspendedCtx } checkSMaskState() { const nn = this.inSMaskMode; this.current.activeSMask && !nn ? this.beginSMaskMode() : !this.current.activeSMask && nn && this.endSMaskMode() } beginSMaskMode() { if (this.inSMaskMode) throw new Error("beginSMaskMode called while already in smask mode"); const nn = this.ctx.canvas.width, We = this.ctx.canvas.height, dn = "smaskGroupAt" + this.groupLevel, Je = this.cachedCanvases.getCanvas(dn, nn, We); this.suspendedCtx = this.ctx, this.ctx = Je.context; const rn = this.ctx; rn.setTransform(...(0, _e.getCurrentTransform)(this.suspendedCtx)), Xe(this.suspendedCtx, rn), Fe(rn, this.suspendedCtx), this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]) } endSMaskMode() { if (!this.inSMaskMode) throw new Error("endSMaskMode called while not in smask mode"); this.ctx._removeMirroring(), Xe(this.ctx, this.suspendedCtx), this.ctx = this.suspendedCtx, this.suspendedCtx = null } compose(nn) { if (!this.current.activeSMask) return; nn ? (nn[0] = Math.floor(nn[0]), nn[1] = Math.floor(nn[1]), nn[2] = Math.ceil(nn[2]), nn[3] = Math.ceil(nn[3])) : nn = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height]; const We = this.current.activeSMask, dn = this.suspendedCtx; fn(dn, We, this.ctx, nn), this.ctx.save(), this.ctx.setTransform(1, 0, 0, 1, 0, 0), this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height), this.ctx.restore() } save() { this.inSMaskMode ? (Xe(this.ctx, this.suspendedCtx), this.suspendedCtx.save()) : this.ctx.save(); const nn = this.current; this.stateStack.push(nn), this.current = nn.clone() } restore() { this.stateStack.length === 0 && this.inSMaskMode && this.endSMaskMode(), this.stateStack.length !== 0 && (this.current = this.stateStack.pop(), this.inSMaskMode ? (this.suspendedCtx.restore(), Xe(this.suspendedCtx, this.ctx)) : this.ctx.restore(), this.checkSMaskState(), this.pendingClip = null, this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null) } transform(nn, We, dn, Je, rn, hn) { this.ctx.transform(nn, We, dn, Je, rn, hn), this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null } constructPath(nn, We, dn) { const Je = this.ctx, rn = this.current; let hn = rn.x, mn = rn.y, Ye, an; const pn = (0, _e.getCurrentTransform)(Je), yn = pn[0] === 0 && pn[3] === 0 || pn[1] === 0 && pn[2] === 0, _n = yn ? dn.slice(0) : null; for (let On = 0, kn = 0, zn = nn.length; On < zn; On++)switch (nn[On] | 0) { case Ee.OPS.rectangle: hn = We[kn++], mn = We[kn++]; const sr = We[kn++], Fn = We[kn++], Cn = hn + sr, Vn = mn + Fn; Je.moveTo(hn, mn), sr === 0 || Fn === 0 ? Je.lineTo(Cn, Vn) : (Je.lineTo(Cn, mn), Je.lineTo(Cn, Vn), Je.lineTo(hn, Vn)), yn || rn.updateRectMinMax(pn, [hn, mn, Cn, Vn]), Je.closePath(); break; case Ee.OPS.moveTo: hn = We[kn++], mn = We[kn++], Je.moveTo(hn, mn), yn || rn.updatePathMinMax(pn, hn, mn); break; case Ee.OPS.lineTo: hn = We[kn++], mn = We[kn++], Je.lineTo(hn, mn), yn || rn.updatePathMinMax(pn, hn, mn); break; case Ee.OPS.curveTo: Ye = hn, an = mn, hn = We[kn + 4], mn = We[kn + 5], Je.bezierCurveTo(We[kn], We[kn + 1], We[kn + 2], We[kn + 3], hn, mn), rn.updateCurvePathMinMax(pn, Ye, an, We[kn], We[kn + 1], We[kn + 2], We[kn + 3], hn, mn, _n), kn += 6; break; case Ee.OPS.curveTo2: Ye = hn, an = mn, Je.bezierCurveTo(hn, mn, We[kn], We[kn + 1], We[kn + 2], We[kn + 3]), rn.updateCurvePathMinMax(pn, Ye, an, hn, mn, We[kn], We[kn + 1], We[kn + 2], We[kn + 3], _n), hn = We[kn + 2], mn = We[kn + 3], kn += 4; break; case Ee.OPS.curveTo3: Ye = hn, an = mn, hn = We[kn + 2], mn = We[kn + 3], Je.bezierCurveTo(We[kn], We[kn + 1], hn, mn, hn, mn), rn.updateCurvePathMinMax(pn, Ye, an, We[kn], We[kn + 1], hn, mn, hn, mn, _n), kn += 4; break; case Ee.OPS.closePath: Je.closePath(); break }yn && rn.updateScalingPathMinMax(pn, _n), rn.setCurrentPoint(hn, mn) } closePath() { this.ctx.closePath() } stroke(nn = !0) { const We = this.ctx, dn = this.current.strokeColor; We.globalAlpha = this.current.strokeAlpha, this.contentVisible && (typeof dn == "object" && dn?.getPattern ? (We.save(), We.strokeStyle = dn.getPattern(We, this, (0, _e.getCurrentTransformInverse)(We), Re.PathType.STROKE), this.rescaleAndStroke(!1), We.restore()) : this.rescaleAndStroke(!0)), nn && this.consumePath(this.current.getClippedPathBoundingBox()), We.globalAlpha = this.current.fillAlpha } closeStroke() { this.closePath(), this.stroke() } fill(nn = !0) { const We = this.ctx, dn = this.current.fillColor, Je = this.current.patternFill; let rn = !1; Je && (We.save(), We.fillStyle = dn.getPattern(We, this, (0, _e.getCurrentTransformInverse)(We), Re.PathType.FILL), rn = !0); const hn = this.current.getClippedPathBoundingBox(); this.contentVisible && hn !== null && (this.pendingEOFill ? (We.fill("evenodd"), this.pendingEOFill = !1) : We.fill()), rn && We.restore(), nn && this.consumePath(hn) } eoFill() { this.pendingEOFill = !0, this.fill() } fillStroke() { this.fill(!1), this.stroke(!1), this.consumePath() } eoFillStroke() { this.pendingEOFill = !0, this.fillStroke() } closeFillStroke() { this.closePath(), this.fillStroke() } closeEOFillStroke() { this.pendingEOFill = !0, this.closePath(), this.fillStroke() } endPath() { this.consumePath() } clip() { this.pendingClip = In } eoClip() { this.pendingClip = xn } beginText() { this.current.textMatrix = Ee.IDENTITY_MATRIX, this.current.textMatrixScale = 1, this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 } endText() { const nn = this.pendingTextPaths, We = this.ctx; if (nn === void 0) { We.beginPath(); return } We.save(), We.beginPath(); for (const dn of nn) We.setTransform(...dn.transform), We.translate(dn.x, dn.y), dn.addToPath(We, dn.fontSize); We.restore(), We.clip(), We.beginPath(), delete this.pendingTextPaths } setCharSpacing(nn) { this.current.charSpacing = nn } setWordSpacing(nn) { this.current.wordSpacing = nn } setHScale(nn) { this.current.textHScale = nn / 100 } setLeading(nn) { this.current.leading = -nn } setFont(nn, We) { const dn = this.commonObjs.get(nn), Je = this.current; if (!dn) throw new Error(`Can't find font for ${nn}`); if (Je.fontMatrix = dn.fontMatrix || Ee.FONT_IDENTITY_MATRIX, (Je.fontMatrix[0] === 0 || Je.fontMatrix[3] === 0) && (0, Ee.warn)("Invalid font matrix for font " + nn), We < 0 ? (We = -We, Je.fontDirection = -1) : Je.fontDirection = 1, this.current.font = dn, this.current.fontSize = We, dn.isType3Font) return; const rn = dn.loadedName || "sans-serif", hn = dn.systemFontInfo?.css || `"${rn}", ${dn.fallbackName}`; let mn = "normal"; dn.black ? mn = "900" : dn.bold && (mn = "bold"); const Ye = dn.italic ? "italic" : "normal"; let an = We; We < Me ? an = Me : We > De && (an = De), this.current.fontSizeScale = We / an, this.ctx.font = `${Ye} ${mn} ${an}px ${hn}` } setTextRenderingMode(nn) { this.current.textRenderingMode = nn } setTextRise(nn) { this.current.textRise = nn } moveText(nn, We) { this.current.x = this.current.lineX += nn, this.current.y = this.current.lineY += We } setLeadingMoveText(nn, We) { this.setLeading(-We), this.moveText(nn, We) } setTextMatrix(nn, We, dn, Je, rn, hn) { this.current.textMatrix = [nn, We, dn, Je, rn, hn], this.current.textMatrixScale = Math.hypot(nn, We), this.current.x = this.current.lineX = 0, this.current.y = this.current.lineY = 0 } nextLine() { this.moveText(0, this.current.leading) } paintChar(nn, We, dn, Je) { const rn = this.ctx, hn = this.current, mn = hn.font, Ye = hn.textRenderingMode, an = hn.fontSize / hn.fontSizeScale, pn = Ye & Ee.TextRenderingMode.FILL_STROKE_MASK, yn = !!(Ye & Ee.TextRenderingMode.ADD_TO_PATH_FLAG), _n = hn.patternFill && !mn.missingFile; let On; (mn.disableFontFace || yn || _n) && (On = mn.getPathGenerator(this.commonObjs, nn)), mn.disableFontFace || _n ? (rn.save(), rn.translate(We, dn), rn.beginPath(), On(rn, an), Je && rn.setTransform(...Je), (pn === Ee.TextRenderingMode.FILL || pn === Ee.TextRenderingMode.FILL_STROKE) && rn.fill(), (pn === Ee.TextRenderingMode.STROKE || pn === Ee.TextRenderingMode.FILL_STROKE) && rn.stroke(), rn.restore()) : ((pn === Ee.TextRenderingMode.FILL || pn === Ee.TextRenderingMode.FILL_STROKE) && rn.fillText(nn, We, dn), (pn === Ee.TextRenderingMode.STROKE || pn === Ee.TextRenderingMode.FILL_STROKE) && rn.strokeText(nn, We, dn)), yn && (this.pendingTextPaths ||= []).push({ transform: (0, _e.getCurrentTransform)(rn), x: We, y: dn, fontSize: an, addToPath: On }) } get isFontSubpixelAAEnabled() { const { context: nn } = this.cachedCanvases.getCanvas("isFontSubpixelAAEnabled", 10, 10); nn.scale(1.5, 1), nn.fillText("I", 0, 10); const We = nn.getImageData(0, 0, 10, 10).data; let dn = !1; for (let Je = 3; Je < We.length; Je += 4)if (We[Je] > 0 && We[Je] < 255) { dn = !0; break } return (0, Ee.shadow)(this, "isFontSubpixelAAEnabled", dn) } showText(nn) { const We = this.current, dn = We.font; if (dn.isType3Font) return this.showType3Text(nn); const Je = We.fontSize; if (Je === 0) return; const rn = this.ctx, hn = We.fontSizeScale, mn = We.charSpacing, Ye = We.wordSpacing, an = We.fontDirection, pn = We.textHScale * an, yn = nn.length, _n = dn.vertical, On = _n ? 1 : -1, kn = dn.defaultVMetrics, zn = Je * We.fontMatrix[0], sr = We.textRenderingMode === Ee.TextRenderingMode.FILL && !dn.disableFontFace && !We.patternFill; rn.save(), rn.transform(...We.textMatrix), rn.translate(We.x, We.y + We.textRise), an > 0 ? rn.scale(pn, -1) : rn.scale(pn, 1); let Fn; if (We.patternFill) { rn.save(); const rr = We.fillColor.getPattern(rn, this, (0, _e.getCurrentTransformInverse)(rn), Re.PathType.FILL); Fn = (0, _e.getCurrentTransform)(rn), rn.restore(), rn.fillStyle = rr } let Cn = We.lineWidth; const Vn = We.textMatrixScale; if (Vn === 0 || Cn === 0) { const rr = We.textRenderingMode & Ee.TextRenderingMode.FILL_STROKE_MASK; (rr === Ee.TextRenderingMode.STROKE || rr === Ee.TextRenderingMode.FILL_STROKE) && (Cn = this.getSinglePixelWidth()) } else Cn /= Vn; if (hn !== 1 && (rn.scale(hn, hn), Cn /= hn), rn.lineWidth = Cn, dn.isInvalidPDFjsFont) { const rr = []; let hr = 0; for (const ur of nn) rr.push(ur.unicode), hr += ur.width; rn.fillText(rr.join(""), 0, 0), We.x += hr * zn * pn, rn.restore(), this.compose(); return } let Yn = 0, qn; for (qn = 0; qn < yn; ++qn) { const rr = nn[qn]; if (typeof rr == "number") { Yn += On * rr * Je / 1e3; continue } let hr = !1; const ur = (rr.isSpace ? Ye : 0) + mn, Er = rr.fontChar, _r = rr.accent; let Or, Ir, Dr = rr.width; if (_n) { const Cr = rr.vmetric || kn, zr = -(rr.vmetric ? Cr[1] : Dr * .5) * zn, Tr = Cr[2] * zn; Dr = Cr ? -Cr[0] : Dr, Or = zr / hn, Ir = (Yn + Tr) / hn } else Or = Yn / hn, Ir = 0; if (dn.remeasure && Dr > 0) { const Cr = rn.measureText(Er).width * 1e3 / Je * hn; if (Dr < Cr && this.isFontSubpixelAAEnabled) { const zr = Dr / Cr; hr = !0, rn.save(), rn.scale(zr, 1), Or /= zr } else Dr !== Cr && (Or += (Dr - Cr) / 2e3 * Je / hn) } if (this.contentVisible && (rr.isInFont || dn.missingFile)) { if (sr && !_r) rn.fillText(Er, Or, Ir); else if (this.paintChar(Er, Or, Ir, Fn), _r) { const Cr = Or + Je * _r.offset.x / hn, zr = Ir - Je * _r.offset.y / hn; this.paintChar(_r.fontChar, Cr, zr, Fn) } } const Wr = _n ? Dr * zn - ur * an : Dr * zn + ur * an; Yn += Wr, hr && rn.restore() } _n ? We.y -= Yn : We.x += Yn * pn, rn.restore(), this.compose() } showType3Text(nn) { const We = this.ctx, dn = this.current, Je = dn.font, rn = dn.fontSize, hn = dn.fontDirection, mn = Je.vertical ? 1 : -1, Ye = dn.charSpacing, an = dn.wordSpacing, pn = dn.textHScale * hn, yn = dn.fontMatrix || Ee.FONT_IDENTITY_MATRIX, _n = nn.length, On = dn.textRenderingMode === Ee.TextRenderingMode.INVISIBLE; let kn, zn, sr, Fn; if (!(On || rn === 0)) { for (this._cachedScaleForStroking[0] = -1, this._cachedGetSinglePixelWidth = null, We.save(), We.transform(...dn.textMatrix), We.translate(dn.x, dn.y), We.scale(pn, hn), kn = 0; kn < _n; ++kn) { if (zn = nn[kn], typeof zn == "number") { Fn = mn * zn * rn / 1e3, this.ctx.translate(Fn, 0), dn.x += Fn * pn; continue } const Cn = (zn.isSpace ? an : 0) + Ye, Vn = Je.charProcOperatorList[zn.operatorListId]; if (!Vn) { (0, Ee.warn)(`Type3 character "${zn.operatorListId}" is not available.`); continue } this.contentVisible && (this.processingType3 = zn, this.save(), We.scale(rn, rn), We.transform(...yn), this.executeOperatorList(Vn), this.restore()), sr = Ee.Util.applyTransform([zn.width, 0], yn)[0] * rn + Cn, We.translate(sr, 0), dn.x += sr * pn } We.restore(), this.processingType3 = null } } setCharWidth(nn, We) { } setCharWidthAndBounds(nn, We, dn, Je, rn, hn) { this.ctx.rect(dn, Je, rn - dn, hn - Je), this.ctx.clip(), this.endPath() } getColorN_Pattern(nn) { let We; if (nn[0] === "TilingPattern") { const dn = nn[1], Je = this.baseTransform || (0, _e.getCurrentTransform)(this.ctx), rn = { createCanvasGraphics: hn => new vn(hn, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, { optionalContentConfig: this.optionalContentConfig, markedContentStack: this.markedContentStack }) }; We = new Re.TilingPattern(nn, dn, this.ctx, rn, Je) } else We = this._getPattern(nn[1], nn[2]); return We } setStrokeColorN() { this.current.strokeColor = this.getColorN_Pattern(arguments) } setFillColorN() { this.current.fillColor = this.getColorN_Pattern(arguments), this.current.patternFill = !0 } setStrokeRGBColor(nn, We, dn) { const Je = Ee.Util.makeHexColor(nn, We, dn); this.ctx.strokeStyle = Je, this.current.strokeColor = Je } setFillRGBColor(nn, We, dn) { const Je = Ee.Util.makeHexColor(nn, We, dn); this.ctx.fillStyle = Je, this.current.fillColor = Je, this.current.patternFill = !1 } _getPattern(nn, We = null) { let dn; return this.cachedPatterns.has(nn) ? dn = this.cachedPatterns.get(nn) : (dn = (0, Re.getShadingPattern)(this.getObject(nn)), this.cachedPatterns.set(nn, dn)), We && (dn.matrix = We), dn } shadingFill(nn) { if (!this.contentVisible) return; const We = this.ctx; this.save(); const dn = this._getPattern(nn); We.fillStyle = dn.getPattern(We, this, (0, _e.getCurrentTransformInverse)(We), Re.PathType.SHADING); const Je = (0, _e.getCurrentTransformInverse)(We); if (Je) { const { width: rn, height: hn } = We.canvas, [mn, Ye, an, pn] = Ee.Util.getAxialAlignedBoundingBox([0, 0, rn, hn], Je); this.ctx.fillRect(mn, Ye, an - mn, pn - Ye) } else this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10); this.compose(this.current.getClippedPathBoundingBox()), this.restore() } beginInlineImage() { (0, Ee.unreachable)("Should not call beginInlineImage") } beginImageData() { (0, Ee.unreachable)("Should not call beginImageData") } paintFormXObjectBegin(nn, We) { if (this.contentVisible && (this.save(), this.baseTransformStack.push(this.baseTransform), Array.isArray(nn) && nn.length === 6 && this.transform(...nn), this.baseTransform = (0, _e.getCurrentTransform)(this.ctx), We)) { const dn = We[2] - We[0], Je = We[3] - We[1]; this.ctx.rect(We[0], We[1], dn, Je), this.current.updateRectMinMax((0, _e.getCurrentTransform)(this.ctx), We), this.clip(), this.endPath() } } paintFormXObjectEnd() { this.contentVisible && (this.restore(), this.baseTransform = this.baseTransformStack.pop()) } beginGroup(nn) { if (!this.contentVisible) return; this.save(), this.inSMaskMode && (this.endSMaskMode(), this.current.activeSMask = null); const We = this.ctx; nn.isolated || (0, Ee.info)("TODO: Support non-isolated groups."), nn.knockout && (0, Ee.warn)("Knockout groups not supported."); const dn = (0, _e.getCurrentTransform)(We); if (nn.matrix && We.transform(...nn.matrix), !nn.bbox) throw new Error("Bounding box is required."); let Je = Ee.Util.getAxialAlignedBoundingBox(nn.bbox, (0, _e.getCurrentTransform)(We)); const rn = [0, 0, We.canvas.width, We.canvas.height]; Je = Ee.Util.intersect(Je, rn) || [0, 0, 0, 0]; const hn = Math.floor(Je[0]), mn = Math.floor(Je[1]); let Ye = Math.max(Math.ceil(Je[2]) - hn, 1), an = Math.max(Math.ceil(Je[3]) - mn, 1), pn = 1, yn = 1; Ye > Pe && (pn = Ye / Pe, Ye = Pe), an > Pe && (yn = an / Pe, an = Pe), this.current.startNewPathAndClipBox([0, 0, Ye, an]); let _n = "groupAt" + this.groupLevel; nn.smask && (_n += "_smask_" + this.smaskCounter++ % 2); const On = this.cachedCanvases.getCanvas(_n, Ye, an), kn = On.context; kn.scale(1 / pn, 1 / yn), kn.translate(-hn, -mn), kn.transform(...dn), nn.smask ? this.smaskStack.push({ canvas: On.canvas, context: kn, offsetX: hn, offsetY: mn, scaleX: pn, scaleY: yn, subtype: nn.smask.subtype, backdrop: nn.smask.backdrop, transferMap: nn.smask.transferMap || null, startTransformInverse: null }) : (We.setTransform(1, 0, 0, 1, 0, 0), We.translate(hn, mn), We.scale(pn, yn), We.save()), Xe(We, kn), this.ctx = kn, this.setGState([["BM", "source-over"], ["ca", 1], ["CA", 1]]), this.groupStack.push(We), this.groupLevel++ } endGroup(nn) { if (!this.contentVisible) return; this.groupLevel--; const We = this.ctx, dn = this.groupStack.pop(); if (this.ctx = dn, this.ctx.imageSmoothingEnabled = !1, nn.smask) this.tempSMask = this.smaskStack.pop(), this.restore(); else { this.ctx.restore(); const Je = (0, _e.getCurrentTransform)(this.ctx); this.restore(), this.ctx.save(), this.ctx.setTransform(...Je); const rn = Ee.Util.getAxialAlignedBoundingBox([0, 0, We.canvas.width, We.canvas.height], Je); this.ctx.drawImage(We.canvas, 0, 0), this.ctx.restore(), this.compose(rn) } } beginAnnotation(nn, We, dn, Je, rn) { if (this.#e(), St(this.ctx), this.ctx.save(), this.save(), this.baseTransform && this.ctx.setTransform(...this.baseTransform), Array.isArray(We) && We.length === 4) { const hn = We[2] - We[0], mn = We[3] - We[1]; if (rn && this.annotationCanvasMap) { dn = dn.slice(), dn[4] -= We[0], dn[5] -= We[1], We = We.slice(), We[0] = We[1] = 0, We[2] = hn, We[3] = mn; const [Ye, an] = Ee.Util.singularValueDecompose2dScale((0, _e.getCurrentTransform)(this.ctx)), { viewportScale: pn } = this, yn = Math.ceil(hn * this.outputScaleX * pn), _n = Math.ceil(mn * this.outputScaleY * pn); this.annotationCanvas = this.canvasFactory.create(yn, _n); const { canvas: On, context: kn } = this.annotationCanvas; this.annotationCanvasMap.set(nn, On), this.annotationCanvas.savedCtx = this.ctx, this.ctx = kn, this.ctx.save(), this.ctx.setTransform(Ye, 0, 0, -an, 0, mn * an), St(this.ctx) } else St(this.ctx), this.ctx.rect(We[0], We[1], hn, mn), this.ctx.clip(), this.endPath() } this.current = new Ge(this.ctx.canvas.width, this.ctx.canvas.height), this.transform(...dn), this.transform(...Je) } endAnnotation() { this.annotationCanvas && (this.ctx.restore(), this.#t(), this.ctx = this.annotationCanvas.savedCtx, delete this.annotationCanvas.savedCtx, delete this.annotationCanvas) } paintImageMaskXObject(nn) { if (!this.contentVisible) return; const We = nn.count; nn = this.getObject(nn.data, nn), nn.count = We; const dn = this.ctx, Je = this.processingType3; if (Je && (Je.compiled === void 0 && (Je.compiled = He(nn)), Je.compiled)) { Je.compiled(dn); return } const rn = this._createMaskCanvas(nn), hn = rn.canvas; dn.save(), dn.setTransform(1, 0, 0, 1, 0, 0), dn.drawImage(hn, rn.offsetX, rn.offsetY), dn.restore(), this.compose() } paintImageMaskXObjectRepeat(nn, We, dn = 0, Je = 0, rn, hn) { if (!this.contentVisible) return; nn = this.getObject(nn.data, nn); const mn = this.ctx; mn.save(); const Ye = (0, _e.getCurrentTransform)(mn); mn.transform(We, dn, Je, rn, 0, 0); const an = this._createMaskCanvas(nn); mn.setTransform(1, 0, 0, 1, an.offsetX - Ye[4], an.offsetY - Ye[5]); for (let pn = 0, yn = hn.length; pn < yn; pn += 2) { const _n = Ee.Util.transform(Ye, [We, dn, Je, rn, hn[pn], hn[pn + 1]]), [On, kn] = Ee.Util.applyTransform([0, 0], _n); mn.drawImage(an.canvas, On, kn) } mn.restore(), this.compose() } paintImageMaskXObjectGroup(nn) { if (!this.contentVisible) return; const We = this.ctx, dn = this.current.fillColor, Je = this.current.patternFill; for (const rn of nn) { const { data: hn, width: mn, height: Ye, transform: an } = rn, pn = this.cachedCanvases.getCanvas("maskCanvas", mn, Ye), yn = pn.context; yn.save(); const _n = this.getObject(hn, rn); sn(yn, _n), yn.globalCompositeOperation = "source-in", yn.fillStyle = Je ? dn.getPattern(yn, this, (0, _e.getCurrentTransformInverse)(We), Re.PathType.FILL) : dn, yn.fillRect(0, 0, mn, Ye), yn.restore(), We.save(), We.transform(...an), We.scale(1, -1), qe(We, pn.canvas, 0, 0, mn, Ye, 0, -1, 1, 1), We.restore() } this.compose() } paintImageXObject(nn) { if (!this.contentVisible) return; const We = this.getObject(nn); if (!We) { (0, Ee.warn)("Dependent image isn't ready yet"); return } this.paintInlineImageXObject(We) } paintImageXObjectRepeat(nn, We, dn, Je) { if (!this.contentVisible) return; const rn = this.getObject(nn); if (!rn) { (0, Ee.warn)("Dependent image isn't ready yet"); return } const hn = rn.width, mn = rn.height, Ye = []; for (let an = 0, pn = Je.length; an < pn; an += 2)Ye.push({ transform: [We, 0, 0, dn, Je[an], Je[an + 1]], x: 0, y: 0, w: hn, h: mn }); this.paintInlineImageXObjectGroup(rn, Ye) } applyTransferMapsToCanvas(nn) { return this.current.transferMaps !== "none" && (nn.filter = this.current.transferMaps, nn.drawImage(nn.canvas, 0, 0), nn.filter = "none"), nn.canvas } applyTransferMapsToBitmap(nn) { if (this.current.transferMaps === "none") return nn.bitmap; const { bitmap: We, width: dn, height: Je } = nn, rn = this.cachedCanvases.getCanvas("inlineImage", dn, Je), hn = rn.context; return hn.filter = this.current.transferMaps, hn.drawImage(We, 0, 0), hn.filter = "none", rn.canvas } paintInlineImageXObject(nn) { if (!this.contentVisible) return; const We = nn.width, dn = nn.height, Je = this.ctx; if (this.save(), !Ee.isNodeJS) { const { filter: mn } = Je; mn !== "none" && mn !== "" && (Je.filter = "none") } Je.scale(1 / We, -1 / dn); let rn; if (nn.bitmap) rn = this.applyTransferMapsToBitmap(nn); else if (typeof HTMLElement == "function" && nn instanceof HTMLElement || !nn.data) rn = nn; else { const Ye = this.cachedCanvases.getCanvas("inlineImage", We, dn).context; Ze(Ye, nn), rn = this.applyTransferMapsToCanvas(Ye) } const hn = this._scaleImage(rn, (0, _e.getCurrentTransformInverse)(Je)); Je.imageSmoothingEnabled = En((0, _e.getCurrentTransform)(Je), nn.interpolate), qe(Je, hn.img, 0, 0, hn.paintWidth, hn.paintHeight, 0, -dn, We, dn), this.compose(), this.restore() } paintInlineImageXObjectGroup(nn, We) { if (!this.contentVisible) return; const dn = this.ctx; let Je; if (nn.bitmap) Je = nn.bitmap; else { const rn = nn.width, hn = nn.height, Ye = this.cachedCanvases.getCanvas("inlineImage", rn, hn).context; Ze(Ye, nn), Je = this.applyTransferMapsToCanvas(Ye) } for (const rn of We) dn.save(), dn.transform(...rn.transform), dn.scale(1, -1), qe(dn, Je, rn.x, rn.y, rn.w, rn.h, 0, -1, 1, 1), dn.restore(); this.compose() } paintSolidColorImageMask() { this.contentVisible && (this.ctx.fillRect(0, 0, 1, 1), this.compose()) } markPoint(nn) { } markPointProps(nn, We) { } beginMarkedContent(nn) { this.markedContentStack.push({ visible: !0 }) } beginMarkedContentProps(nn, We) { nn === "OC" ? this.markedContentStack.push({ visible: this.optionalContentConfig.isVisible(We) }) : this.markedContentStack.push({ visible: !0 }), this.contentVisible = this.isContentVisible() } endMarkedContent() { this.markedContentStack.pop(), this.contentVisible = this.isContentVisible() } beginCompat() { } endCompat() { } consumePath(nn) { const We = this.current.isEmptyClip(); this.pendingClip && this.current.updateClipFromPath(), this.pendingClip || this.compose(nn); const dn = this.ctx; this.pendingClip && (We || (this.pendingClip === xn ? dn.clip("evenodd") : dn.clip()), this.pendingClip = null), this.current.startNewPathAndClipBox(this.current.clipBox), dn.beginPath() } getSinglePixelWidth() { if (!this._cachedGetSinglePixelWidth) { const nn = (0, _e.getCurrentTransform)(this.ctx); if (nn[1] === 0 && nn[2] === 0) this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(nn[0]), Math.abs(nn[3])); else { const We = Math.abs(nn[0] * nn[3] - nn[2] * nn[1]), dn = Math.hypot(nn[0], nn[2]), Je = Math.hypot(nn[1], nn[3]); this._cachedGetSinglePixelWidth = Math.max(dn, Je) / We } } return this._cachedGetSinglePixelWidth } getScaleForStroking() { if (this._cachedScaleForStroking[0] === -1) { const { lineWidth: nn } = this.current, { a: We, b: dn, c: Je, d: rn } = this.ctx.getTransform(); let hn, mn; if (dn === 0 && Je === 0) { const Ye = Math.abs(We), an = Math.abs(rn); if (Ye === an) if (nn === 0) hn = mn = 1 / Ye; else { const pn = Ye * nn; hn = mn = pn < 1 ? 1 / pn : 1 } else if (nn === 0) hn = 1 / Ye, mn = 1 / an; else { const pn = Ye * nn, yn = an * nn; hn = pn < 1 ? 1 / pn : 1, mn = yn < 1 ? 1 / yn : 1 } } else { const Ye = Math.abs(We * rn - dn * Je), an = Math.hypot(We, dn), pn = Math.hypot(Je, rn); if (nn === 0) hn = pn / Ye, mn = an / Ye; else { const yn = nn * Ye; hn = pn > yn ? pn / yn : 1, mn = an > yn ? an / yn : 1 } } this._cachedScaleForStroking[0] = hn, this._cachedScaleForStroking[1] = mn } return this._cachedScaleForStroking } rescaleAndStroke(nn) { const { ctx: We } = this, { lineWidth: dn } = this.current, [Je, rn] = this.getScaleForStroking(); if (We.lineWidth = dn || 1, Je === 1 && rn === 1) { We.stroke(); return } const hn = We.getLineDash(); if (nn && We.save(), We.scale(Je, rn), hn.length > 0) { const mn = Math.max(Je, rn); We.setLineDash(hn.map(Ye => Ye / mn)), We.lineDashOffset /= mn } We.stroke(), nn && We.restore() } isContentVisible() { for (let nn = this.markedContentStack.length - 1; nn >= 0; nn--)if (!this.markedContentStack[nn].visible) return !1; return !0 } } t.CanvasGraphics = vn; for (const tn in Ee.OPS) vn.prototype[tn] !== void 0 && (vn.prototype[Ee.OPS[tn]] = vn.prototype[tn]) }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.TilingPattern = t.PathType = void 0, t.getShadingPattern = Ie; var Ee = xe(1), _e = xe(6); const Re = { FILL: "Fill", STROKE: "Stroke", SHADING: "Shading" }; t.PathType = Re; function Ce(qe, He) { if (!He) return; const Ge = He[2] - He[0], Ze = He[3] - He[1], sn = new Path2D; sn.rect(He[0], He[1], Ge, Ze), qe.clip(sn) } class Me { constructor() { this.constructor === Me && (0, Ee.unreachable)("Cannot initialize BaseShadingPattern.") } getPattern() { (0, Ee.unreachable)("Abstract method `getPattern` called.") } } class De extends Me { constructor(He) { super(), this._type = He[1], this._bbox = He[2], this._colorStops = He[3], this._p0 = He[4], this._p1 = He[5], this._r0 = He[6], this._r1 = He[7], this.matrix = null } _createGradient(He) { let Ge; this._type === "axial" ? Ge = He.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]) : this._type === "radial" && (Ge = He.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1)); for (const Ze of this._colorStops) Ge.addColorStop(Ze[0], Ze[1]); return Ge } getPattern(He, Ge, Ze, sn) { let Xe; if (sn === Re.STROKE || sn === Re.FILL) { const St = Ge.current.getClippedPathBoundingBox(sn, (0, _e.getCurrentTransform)(He)) || [0, 0, 0, 0], un = Math.ceil(St[2] - St[0]) || 1, on = Math.ceil(St[3] - St[1]) || 1, bn = Ge.cachedCanvases.getCanvas("pattern", un, on, !0), Tn = bn.context; Tn.clearRect(0, 0, Tn.canvas.width, Tn.canvas.height), Tn.beginPath(), Tn.rect(0, 0, Tn.canvas.width, Tn.canvas.height), Tn.translate(-St[0], -St[1]), Ze = Ee.Util.transform(Ze, [1, 0, 0, 1, St[0], St[1]]), Tn.transform(...Ge.baseTransform), this.matrix && Tn.transform(...this.matrix), Ce(Tn, this._bbox), Tn.fillStyle = this._createGradient(Tn), Tn.fill(), Xe = He.createPattern(bn.canvas, "no-repeat"); const fn = new DOMMatrix(Ze); Xe.setTransform(fn) } else Ce(He, this._bbox), Xe = this._createGradient(He); return Xe } } function Pe(qe, He, Ge, Ze, sn, Xe, St, un) { const on = He.coords, bn = He.colors, Tn = qe.data, fn = qe.width * 4; let En; on[Ge + 1] > on[Ze + 1] && (En = Ge, Ge = Ze, Ze = En, En = Xe, Xe = St, St = En), on[Ze + 1] > on[sn + 1] && (En = Ze, Ze = sn, sn = En, En = St, St = un, un = En), on[Ge + 1] > on[Ze + 1] && (En = Ge, Ge = Ze, Ze = En, En = Xe, Xe = St, St = En); const Pn = (on[Ge] + He.offsetX) * He.scaleX, Rn = (on[Ge + 1] + He.offsetY) * He.scaleY, In = (on[Ze] + He.offsetX) * He.scaleX, xn = (on[Ze + 1] + He.offsetY) * He.scaleY, vn = (on[sn] + He.offsetX) * He.scaleX, tn = (on[sn + 1] + He.offsetY) * He.scaleY; if (Rn >= tn) return; const nn = bn[Xe], We = bn[Xe + 1], dn = bn[Xe + 2], Je = bn[St], rn = bn[St + 1], hn = bn[St + 2], mn = bn[un], Ye = bn[un + 1], an = bn[un + 2], pn = Math.round(Rn), yn = Math.round(tn); let _n, On, kn, zn, sr, Fn, Cn, Vn; for (let Yn = pn; Yn <= yn; Yn++) { if (Yn < xn) { const Er = Yn < Rn ? 0 : (Rn - Yn) / (Rn - xn); _n = Pn - (Pn - In) * Er, On = nn - (nn - Je) * Er, kn = We - (We - rn) * Er, zn = dn - (dn - hn) * Er } else { let Er; Yn > tn ? Er = 1 : xn === tn ? Er = 0 : Er = (xn - Yn) / (xn - tn), _n = In - (In - vn) * Er, On = Je - (Je - mn) * Er, kn = rn - (rn - Ye) * Er, zn = hn - (hn - an) * Er } let qn; Yn < Rn ? qn = 0 : Yn > tn ? qn = 1 : qn = (Rn - Yn) / (Rn - tn), sr = Pn - (Pn - vn) * qn, Fn = nn - (nn - mn) * qn, Cn = We - (We - Ye) * qn, Vn = dn - (dn - an) * qn; const rr = Math.round(Math.min(_n, sr)), hr = Math.round(Math.max(_n, sr)); let ur = fn * Yn + rr * 4; for (let Er = rr; Er <= hr; Er++)qn = (_n - Er) / (_n - sr), qn < 0 ? qn = 0 : qn > 1 && (qn = 1), Tn[ur++] = On - (On - Fn) * qn | 0, Tn[ur++] = kn - (kn - Cn) * qn | 0, Tn[ur++] = zn - (zn - Vn) * qn | 0, Tn[ur++] = 255 } } function Oe(qe, He, Ge) { const Ze = He.coords, sn = He.colors; let Xe, St; switch (He.type) { case "lattice": const un = He.verticesPerRow, on = Math.floor(Ze.length / un) - 1, bn = un - 1; for (Xe = 0; Xe < on; Xe++) { let Tn = Xe * un; for (let fn = 0; fn < bn; fn++, Tn++)Pe(qe, Ge, Ze[Tn], Ze[Tn + 1], Ze[Tn + un], sn[Tn], sn[Tn + 1], sn[Tn + un]), Pe(qe, Ge, Ze[Tn + un + 1], Ze[Tn + 1], Ze[Tn + un], sn[Tn + un + 1], sn[Tn + 1], sn[Tn + un]) } break; case "triangles": for (Xe = 0, St = Ze.length; Xe < St; Xe += 3)Pe(qe, Ge, Ze[Xe], Ze[Xe + 1], Ze[Xe + 2], sn[Xe], sn[Xe + 1], sn[Xe + 2]); break; default: throw new Error("illegal figure") } } class je extends Me { constructor(He) { super(), this._coords = He[2], this._colors = He[3], this._figures = He[4], this._bounds = He[5], this._bbox = He[7], this._background = He[8], this.matrix = null } _createMeshCanvas(He, Ge, Ze) { const un = Math.floor(this._bounds[0]), on = Math.floor(this._bounds[1]), bn = Math.ceil(this._bounds[2]) - un, Tn = Math.ceil(this._bounds[3]) - on, fn = Math.min(Math.ceil(Math.abs(bn * He[0] * 1.1)), 3e3), En = Math.min(Math.ceil(Math.abs(Tn * He[1] * 1.1)), 3e3), Pn = bn / fn, Rn = Tn / En, In = { coords: this._coords, colors: this._colors, offsetX: -un, offsetY: -on, scaleX: 1 / Pn, scaleY: 1 / Rn }, xn = fn + 4, vn = En + 4, tn = Ze.getCanvas("mesh", xn, vn, !1), nn = tn.context, We = nn.createImageData(fn, En); if (Ge) { const Je = We.data; for (let rn = 0, hn = Je.length; rn < hn; rn += 4)Je[rn] = Ge[0], Je[rn + 1] = Ge[1], Je[rn + 2] = Ge[2], Je[rn + 3] = 255 } for (const Je of this._figures) Oe(We, Je, In); return nn.putImageData(We, 2, 2), { canvas: tn.canvas, offsetX: un - 2 * Pn, offsetY: on - 2 * Rn, scaleX: Pn, scaleY: Rn } } getPattern(He, Ge, Ze, sn) { Ce(He, this._bbox); let Xe; if (sn === Re.SHADING) Xe = Ee.Util.singularValueDecompose2dScale((0, _e.getCurrentTransform)(He)); else if (Xe = Ee.Util.singularValueDecompose2dScale(Ge.baseTransform), this.matrix) { const un = Ee.Util.singularValueDecompose2dScale(this.matrix); Xe = [Xe[0] * un[0], Xe[1] * un[1]] } const St = this._createMeshCanvas(Xe, sn === Re.SHADING ? null : this._background, Ge.cachedCanvases); return sn !== Re.SHADING && (He.setTransform(...Ge.baseTransform), this.matrix && He.transform(...this.matrix)), He.translate(St.offsetX, St.offsetY), He.scale(St.scaleX, St.scaleY), He.createPattern(St.canvas, "no-repeat") } } class Be extends Me { getPattern() { return "hotpink" } } function Ie(qe) { switch (qe[0]) { case "RadialAxial": return new De(qe); case "Mesh": return new je(qe); case "Dummy": return new Be }throw new Error(`Unknown IR type: ${qe[0]}`) } const Fe = { COLORED: 1, UNCOLORED: 2 }; class ze { static MAX_PATTERN_SIZE = 3e3; constructor(He, Ge, Ze, sn, Xe) { this.operatorList = He[2], this.matrix = He[3] || [1, 0, 0, 1, 0, 0], this.bbox = He[4], this.xstep = He[5], this.ystep = He[6], this.paintType = He[7], this.tilingType = He[8], this.color = Ge, this.ctx = Ze, this.canvasGraphicsFactory = sn, this.baseTransform = Xe } createPatternCanvas(He) { const Ge = this.operatorList, Ze = this.bbox, sn = this.xstep, Xe = this.ystep, St = this.paintType, un = this.tilingType, on = this.color, bn = this.canvasGraphicsFactory; (0, Ee.info)("TilingType: " + un); const Tn = Ze[0], fn = Ze[1], En = Ze[2], Pn = Ze[3], Rn = Ee.Util.singularValueDecompose2dScale(this.matrix), In = Ee.Util.singularValueDecompose2dScale(this.baseTransform), xn = [Rn[0] * In[0], Rn[1] * In[1]], vn = this.getSizeAndScale(sn, this.ctx.canvas.width, xn[0]), tn = this.getSizeAndScale(Xe, this.ctx.canvas.height, xn[1]), nn = He.cachedCanvases.getCanvas("pattern", vn.size, tn.size, !0), We = nn.context, dn = bn.createCanvasGraphics(We); dn.groupLevel = He.groupLevel, this.setFillAndStrokeStyleToContext(dn, St, on); let Je = Tn, rn = fn, hn = En, mn = Pn; return Tn < 0 && (Je = 0, hn += Math.abs(Tn)), fn < 0 && (rn = 0, mn += Math.abs(fn)), We.translate(-(vn.scale * Je), -(tn.scale * rn)), dn.transform(vn.scale, 0, 0, tn.scale, 0, 0), We.save(), this.clipBbox(dn, Je, rn, hn, mn), dn.baseTransform = (0, _e.getCurrentTransform)(dn.ctx), dn.executeOperatorList(Ge), dn.endDrawing(), { canvas: nn.canvas, scaleX: vn.scale, scaleY: tn.scale, offsetX: Je, offsetY: rn } } getSizeAndScale(He, Ge, Ze) { He = Math.abs(He); const sn = Math.max(ze.MAX_PATTERN_SIZE, Ge); let Xe = Math.ceil(He * Ze); return Xe >= sn ? Xe = sn : Ze = Xe / He, { scale: Ze, size: Xe } } clipBbox(He, Ge, Ze, sn, Xe) { const St = sn - Ge, un = Xe - Ze; He.ctx.rect(Ge, Ze, St, un), He.current.updateRectMinMax((0, _e.getCurrentTransform)(He.ctx), [Ge, Ze, sn, Xe]), He.clip(), He.endPath() } setFillAndStrokeStyleToContext(He, Ge, Ze) { const sn = He.ctx, Xe = He.current; switch (Ge) { case Fe.COLORED: const St = this.ctx; sn.fillStyle = St.fillStyle, sn.strokeStyle = St.strokeStyle, Xe.fillColor = St.fillStyle, Xe.strokeColor = St.strokeStyle; break; case Fe.UNCOLORED: const un = Ee.Util.makeHexColor(Ze[0], Ze[1], Ze[2]); sn.fillStyle = un, sn.strokeStyle = un, Xe.fillColor = un, Xe.strokeColor = un; break; default: throw new Ee.FormatError(`Unsupported paint type: ${Ge}`) } } getPattern(He, Ge, Ze, sn) { let Xe = Ze; sn !== Re.SHADING && (Xe = Ee.Util.transform(Xe, Ge.baseTransform), this.matrix && (Xe = Ee.Util.transform(Xe, this.matrix))); const St = this.createPatternCanvas(Ge); let un = new DOMMatrix(Xe); un = un.translate(St.offsetX, St.offsetY), un = un.scale(1 / St.scaleX, 1 / St.scaleY); const on = He.createPattern(St.canvas, "repeat"); return on.setTransform(un), on } } t.TilingPattern = ze }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.convertBlackAndWhiteToRGBA = Re, t.convertToRGBA = _e, t.grayToRGBA = Me; var Ee = xe(1); function _e(De) { switch (De.kind) { case Ee.ImageKind.GRAYSCALE_1BPP: return Re(De); case Ee.ImageKind.RGB_24BPP: return Ce(De) }return null } function Re({ src: De, srcPos: Pe = 0, dest: Oe, width: je, height: Be, nonBlackColor: Ie = 4294967295, inverseDecode: Fe = !1 }) { const ze = Ee.FeatureTest.isLittleEndian ? 4278190080 : 255, [qe, He] = Fe ? [Ie, ze] : [ze, Ie], Ge = je >> 3, Ze = je & 7, sn = De.length; Oe = new Uint32Array(Oe.buffer); let Xe = 0; for (let St = 0; St < Be; St++) { for (const on = Pe + Ge; Pe < on; Pe++) { const bn = Pe < sn ? De[Pe] : 255; Oe[Xe++] = bn & 128 ? He : qe, Oe[Xe++] = bn & 64 ? He : qe, Oe[Xe++] = bn & 32 ? He : qe, Oe[Xe++] = bn & 16 ? He : qe, Oe[Xe++] = bn & 8 ? He : qe, Oe[Xe++] = bn & 4 ? He : qe, Oe[Xe++] = bn & 2 ? He : qe, Oe[Xe++] = bn & 1 ? He : qe } if (Ze === 0) continue; const un = Pe < sn ? De[Pe++] : 255; for (let on = 0; on < Ze; on++)Oe[Xe++] = un & 1 << 7 - on ? He : qe } return { srcPos: Pe, destPos: Xe } } function Ce({ src: De, srcPos: Pe = 0, dest: Oe, destPos: je = 0, width: Be, height: Ie }) { let Fe = 0; const ze = De.length >> 2, qe = new Uint32Array(De.buffer, Pe, ze); if (Ee.FeatureTest.isLittleEndian) { for (; Fe < ze - 2; Fe += 3, je += 4) { const He = qe[Fe], Ge = qe[Fe + 1], Ze = qe[Fe + 2]; Oe[je] = He | 4278190080, Oe[je + 1] = He >>> 24 | Ge << 8 | 4278190080, Oe[je + 2] = Ge >>> 16 | Ze << 16 | 4278190080, Oe[je + 3] = Ze >>> 8 | 4278190080 } for (let He = Fe * 4, Ge = De.length; He < Ge; He += 3)Oe[je++] = De[He] | De[He + 1] << 8 | De[He + 2] << 16 | 4278190080 } else { for (; Fe < ze - 2; Fe += 3, je += 4) { const He = qe[Fe], Ge = qe[Fe + 1], Ze = qe[Fe + 2]; Oe[je] = He | 255, Oe[je + 1] = He << 24 | Ge >>> 8 | 255, Oe[je + 2] = Ge << 16 | Ze >>> 16 | 255, Oe[je + 3] = Ze << 8 | 255 } for (let He = Fe * 4, Ge = De.length; He < Ge; He += 3)Oe[je++] = De[He] << 24 | De[He + 1] << 16 | De[He + 2] << 8 | 255 } return { srcPos: Pe, destPos: je } } function Me(De, Pe) { if (Ee.FeatureTest.isLittleEndian) for (let Oe = 0, je = De.length; Oe < je; Oe++)Pe[Oe] = De[Oe] * 65793 | 4278190080; else for (let Oe = 0, je = De.length; Oe < je; Oe++)Pe[Oe] = De[Oe] * 16843008 | 255 } }, (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.GlobalWorkerOptions = void 0; const xe = Object.create(null); t.GlobalWorkerOptions = xe, xe.workerPort = null, xe.workerSrc = "" }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.MessageHandler = void 0; var Ee = xe(1); const _e = { DATA: 1, ERROR: 2 }, Re = { CANCEL: 1, CANCEL_COMPLETE: 2, CLOSE: 3, ENQUEUE: 4, ERROR: 5, PULL: 6, PULL_COMPLETE: 7, START_COMPLETE: 8 }; function Ce(De) { switch (De instanceof Error || typeof De == "object" && De !== null || (0, Ee.unreachable)('wrapReason: Expected "reason" to be a (possibly cloned) Error.'), De.name) { case "AbortException": return new Ee.AbortException(De.message); case "MissingPDFException": return new Ee.MissingPDFException(De.message); case "PasswordException": return new Ee.PasswordException(De.message, De.code); case "UnexpectedResponseException": return new Ee.UnexpectedResponseException(De.message, De.status); case "UnknownErrorException": return new Ee.UnknownErrorException(De.message, De.details); default: return new Ee.UnknownErrorException(De.message, De.toString()) } } class Me { constructor(Pe, Oe, je) { this.sourceName = Pe, this.targetName = Oe, this.comObj = je, this.callbackId = 1, this.streamId = 1, this.streamSinks = Object.create(null), this.streamControllers = Object.create(null), this.callbackCapabilities = Object.create(null), this.actionHandler = Object.create(null), this._onComObjOnMessage = Be => { const Ie = Be.data; if (Ie.targetName !== this.sourceName) return; if (Ie.stream) { this.#t(Ie); return } if (Ie.callback) { const ze = Ie.callbackId, qe = this.callbackCapabilities[ze]; if (!qe) throw new Error(`Cannot resolve callback ${ze}`); if (delete this.callbackCapabilities[ze], Ie.callback === _e.DATA) qe.resolve(Ie.data); else if (Ie.callback === _e.ERROR) qe.reject(Ce(Ie.reason)); else throw new Error("Unexpected callback case"); return } const Fe = this.actionHandler[Ie.action]; if (!Fe) throw new Error(`Unknown action from worker: ${Ie.action}`); if (Ie.callbackId) { const ze = this.sourceName, qe = Ie.sourceName; new Promise(function (He) { He(Fe(Ie.data)) }).then(function (He) { je.postMessage({ sourceName: ze, targetName: qe, callback: _e.DATA, callbackId: Ie.callbackId, data: He }) }, function (He) { je.postMessage({ sourceName: ze, targetName: qe, callback: _e.ERROR, callbackId: Ie.callbackId, reason: Ce(He) }) }); return } if (Ie.streamId) { this.#e(Ie); return } Fe(Ie.data) }, je.addEventListener("message", this._onComObjOnMessage) } on(Pe, Oe) { const je = this.actionHandler; if (je[Pe]) throw new Error(`There is already an actionName called "${Pe}"`); je[Pe] = Oe } send(Pe, Oe, je) { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: Pe, data: Oe }, je) } sendWithPromise(Pe, Oe, je) { const Be = this.callbackId++, Ie = new Ee.PromiseCapability; this.callbackCapabilities[Be] = Ie; try { this.comObj.postMessage({ sourceName: this.sourceName, targetName: this.targetName, action: Pe, callbackId: Be, data: Oe }, je) } catch (Fe) { Ie.reject(Fe) } return Ie.promise } sendWithStream(Pe, Oe, je, Be) { const Ie = this.streamId++, Fe = this.sourceName, ze = this.targetName, qe = this.comObj; return new ReadableStream({ start: He => { const Ge = new Ee.PromiseCapability; return this.streamControllers[Ie] = { controller: He, startCall: Ge, pullCall: null, cancelCall: null, isClosed: !1 }, qe.postMessage({ sourceName: Fe, targetName: ze, action: Pe, streamId: Ie, data: Oe, desiredSize: He.desiredSize }, Be), Ge.promise }, pull: He => { const Ge = new Ee.PromiseCapability; return this.streamControllers[Ie].pullCall = Ge, qe.postMessage({ sourceName: Fe, targetName: ze, stream: Re.PULL, streamId: Ie, desiredSize: He.desiredSize }), Ge.promise }, cancel: He => { (0, Ee.assert)(He instanceof Error, "cancel must have a valid reason"); const Ge = new Ee.PromiseCapability; return this.streamControllers[Ie].cancelCall = Ge, this.streamControllers[Ie].isClosed = !0, qe.postMessage({ sourceName: Fe, targetName: ze, stream: Re.CANCEL, streamId: Ie, reason: Ce(He) }), Ge.promise } }, je) } #e(Pe) { const Oe = Pe.streamId, je = this.sourceName, Be = Pe.sourceName, Ie = this.comObj, Fe = this, ze = this.actionHandler[Pe.action], qe = { enqueue(He, Ge = 1, Ze) { if (this.isCancelled) return; const sn = this.desiredSize; this.desiredSize -= Ge, sn > 0 && this.desiredSize <= 0 && (this.sinkCapability = new Ee.PromiseCapability, this.ready = this.sinkCapability.promise), Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.ENQUEUE, streamId: Oe, chunk: He }, Ze) }, close() { this.isCancelled || (this.isCancelled = !0, Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.CLOSE, streamId: Oe }), delete Fe.streamSinks[Oe]) }, error(He) { (0, Ee.assert)(He instanceof Error, "error must have a valid reason"), !this.isCancelled && (this.isCancelled = !0, Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.ERROR, streamId: Oe, reason: Ce(He) })) }, sinkCapability: new Ee.PromiseCapability, onPull: null, onCancel: null, isCancelled: !1, desiredSize: Pe.desiredSize, ready: null }; qe.sinkCapability.resolve(), qe.ready = qe.sinkCapability.promise, this.streamSinks[Oe] = qe, new Promise(function (He) { He(ze(Pe.data, qe)) }).then(function () { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.START_COMPLETE, streamId: Oe, success: !0 }) }, function (He) { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.START_COMPLETE, streamId: Oe, reason: Ce(He) }) }) } #t(Pe) { const Oe = Pe.streamId, je = this.sourceName, Be = Pe.sourceName, Ie = this.comObj, Fe = this.streamControllers[Oe], ze = this.streamSinks[Oe]; switch (Pe.stream) { case Re.START_COMPLETE: Pe.success ? Fe.startCall.resolve() : Fe.startCall.reject(Ce(Pe.reason)); break; case Re.PULL_COMPLETE: Pe.success ? Fe.pullCall.resolve() : Fe.pullCall.reject(Ce(Pe.reason)); break; case Re.PULL: if (!ze) { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.PULL_COMPLETE, streamId: Oe, success: !0 }); break } ze.desiredSize <= 0 && Pe.desiredSize > 0 && ze.sinkCapability.resolve(), ze.desiredSize = Pe.desiredSize, new Promise(function (qe) { qe(ze.onPull?.()) }).then(function () { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.PULL_COMPLETE, streamId: Oe, success: !0 }) }, function (qe) { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.PULL_COMPLETE, streamId: Oe, reason: Ce(qe) }) }); break; case Re.ENQUEUE: if ((0, Ee.assert)(Fe, "enqueue should have stream controller"), Fe.isClosed) break; Fe.controller.enqueue(Pe.chunk); break; case Re.CLOSE: if ((0, Ee.assert)(Fe, "close should have stream controller"), Fe.isClosed) break; Fe.isClosed = !0, Fe.controller.close(), this.#n(Fe, Oe); break; case Re.ERROR: (0, Ee.assert)(Fe, "error should have stream controller"), Fe.controller.error(Ce(Pe.reason)), this.#n(Fe, Oe); break; case Re.CANCEL_COMPLETE: Pe.success ? Fe.cancelCall.resolve() : Fe.cancelCall.reject(Ce(Pe.reason)), this.#n(Fe, Oe); break; case Re.CANCEL: if (!ze) break; new Promise(function (qe) { qe(ze.onCancel?.(Ce(Pe.reason))) }).then(function () { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.CANCEL_COMPLETE, streamId: Oe, success: !0 }) }, function (qe) { Ie.postMessage({ sourceName: je, targetName: Be, stream: Re.CANCEL_COMPLETE, streamId: Oe, reason: Ce(qe) }) }), ze.sinkCapability.reject(Ce(Pe.reason)), ze.isCancelled = !0, delete this.streamSinks[Oe]; break; default: throw new Error("Unexpected stream case") } } async#n(Pe, Oe) { await Promise.allSettled([Pe.startCall?.promise, Pe.pullCall?.promise, Pe.cancelCall?.promise]), delete this.streamControllers[Oe] } destroy() { this.comObj.removeEventListener("message", this._onComObjOnMessage) } } t.MessageHandler = Me }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.Metadata = void 0; var Ee = xe(1); class _e { #e; #t; constructor({ parsedData: Ce, rawData: Me }) { this.#e = Ce, this.#t = Me } getRaw() { return this.#t } get(Ce) { return this.#e.get(Ce) ?? null } getAll() { return (0, Ee.objectFromMap)(this.#e) } has(Ce) { return this.#e.has(Ce) } } t.Metadata = _e }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.OptionalContentConfig = void 0; var Ee = xe(1), _e = xe(8); const Re = Symbol("INTERNAL"); class Ce { #e = !0; constructor(Pe, Oe) { this.name = Pe, this.intent = Oe } get visible() { return this.#e } _setVisible(Pe, Oe) { Pe !== Re && (0, Ee.unreachable)("Internal method `_setVisible` called."), this.#e = Oe } } class Me { #e = null; #t = new Map; #n = null; #r = null; constructor(Pe) { if (this.name = null, this.creator = null, Pe !== null) { this.name = Pe.name, this.creator = Pe.creator, this.#r = Pe.order; for (const Oe of Pe.groups) this.#t.set(Oe.id, new Ce(Oe.name, Oe.intent)); if (Pe.baseState === "OFF") for (const Oe of this.#t.values()) Oe._setVisible(Re, !1); for (const Oe of Pe.on) this.#t.get(Oe)._setVisible(Re, !0); for (const Oe of Pe.off) this.#t.get(Oe)._setVisible(Re, !1); this.#n = this.getHash() } } #a(Pe) { const Oe = Pe.length; if (Oe < 2) return !0; const je = Pe[0]; for (let Be = 1; Be < Oe; Be++) { const Ie = Pe[Be]; let Fe; if (Array.isArray(Ie)) Fe = this.#a(Ie); else if (this.#t.has(Ie)) Fe = this.#t.get(Ie).visible; else return (0, Ee.warn)(`Optional content group not found: ${Ie}`), !0; switch (je) { case "And": if (!Fe) return !1; break; case "Or": if (Fe) return !0; break; case "Not": return !Fe; default: return !0 } } return je === "And" } isVisible(Pe) { if (this.#t.size === 0) return !0; if (!Pe) return (0, Ee.warn)("Optional content group not defined."), !0; if (Pe.type === "OCG") return this.#t.has(Pe.id) ? this.#t.get(Pe.id).visible : ((0, Ee.warn)(`Optional content group not found: ${Pe.id}`), !0); if (Pe.type === "OCMD") { if (Pe.expression) return this.#a(Pe.expression); if (!Pe.policy || Pe.policy === "AnyOn") { for (const Oe of Pe.ids) { if (!this.#t.has(Oe)) return (0, Ee.warn)(`Optional content group not found: ${Oe}`), !0; if (this.#t.get(Oe).visible) return !0 } return !1 } else if (Pe.policy === "AllOn") { for (const Oe of Pe.ids) { if (!this.#t.has(Oe)) return (0, Ee.warn)(`Optional content group not found: ${Oe}`), !0; if (!this.#t.get(Oe).visible) return !1 } return !0 } else if (Pe.policy === "AnyOff") { for (const Oe of Pe.ids) { if (!this.#t.has(Oe)) return (0, Ee.warn)(`Optional content group not found: ${Oe}`), !0; if (!this.#t.get(Oe).visible) return !0 } return !1 } else if (Pe.policy === "AllOff") { for (const Oe of Pe.ids) { if (!this.#t.has(Oe)) return (0, Ee.warn)(`Optional content group not found: ${Oe}`), !0; if (this.#t.get(Oe).visible) return !1 } return !0 } return (0, Ee.warn)(`Unknown optional content policy ${Pe.policy}.`), !0 } return (0, Ee.warn)(`Unknown group type ${Pe.type}.`), !0 } setVisibility(Pe, Oe = !0) { if (!this.#t.has(Pe)) { (0, Ee.warn)(`Optional content group not found: ${Pe}`); return } this.#t.get(Pe)._setVisible(Re, !!Oe), this.#e = null } get hasInitialVisibility() { return this.#n === null || this.getHash() === this.#n } getOrder() { return this.#t.size ? this.#r ? this.#r.slice() : [...this.#t.keys()] : null } getGroups() { return this.#t.size > 0 ? (0, Ee.objectFromMap)(this.#t) : null } getGroup(Pe) { return this.#t.get(Pe) || null } getHash() { if (this.#e !== null) return this.#e; const Pe = new _e.MurmurHash3_64; for (const [Oe, je] of this.#t) Pe.update(`${Oe}:${je.visible}`); return this.#e = Pe.hexdigest() } } t.OptionalContentConfig = Me }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.PDFDataTransportStream = void 0; var Ee = xe(1), _e = xe(6); class Re { constructor({ length: Pe, initialData: Oe, progressiveDone: je = !1, contentDispositionFilename: Be = null, disableRange: Ie = !1, disableStream: Fe = !1 }, ze) { if ((0, Ee.assert)(ze, 'PDFDataTransportStream - missing required "pdfDataRangeTransport" argument.'), this._queuedChunks = [], this._progressiveDone = je, this._contentDispositionFilename = Be, Oe?.length > 0) { const qe = Oe instanceof Uint8Array && Oe.byteLength === Oe.buffer.byteLength ? Oe.buffer : new Uint8Array(Oe).buffer; this._queuedChunks.push(qe) } this._pdfDataRangeTransport = ze, this._isStreamingSupported = !Fe, this._isRangeSupported = !Ie, this._contentLength = Pe, this._fullRequestReader = null, this._rangeReaders = [], this._pdfDataRangeTransport.addRangeListener((qe, He) => { this._onReceiveData({ begin: qe, chunk: He }) }), this._pdfDataRangeTransport.addProgressListener((qe, He) => { this._onProgress({ loaded: qe, total: He }) }), this._pdfDataRangeTransport.addProgressiveReadListener(qe => { this._onReceiveData({ chunk: qe }) }), this._pdfDataRangeTransport.addProgressiveDoneListener(() => { this._onProgressiveDone() }), this._pdfDataRangeTransport.transportReady() } _onReceiveData({ begin: Pe, chunk: Oe }) { const je = Oe instanceof Uint8Array && Oe.byteLength === Oe.buffer.byteLength ? Oe.buffer : new Uint8Array(Oe).buffer; if (Pe === void 0) this._fullRequestReader ? this._fullRequestReader._enqueue(je) : this._queuedChunks.push(je); else { const Be = this._rangeReaders.some(function (Ie) { return Ie._begin !== Pe ? !1 : (Ie._enqueue(je), !0) }); (0, Ee.assert)(Be, "_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.") } } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0 } _onProgress(Pe) { Pe.total === void 0 ? this._rangeReaders[0]?.onProgress?.({ loaded: Pe.loaded }) : this._fullRequestReader?.onProgress?.({ loaded: Pe.loaded, total: Pe.total }) } _onProgressiveDone() { this._fullRequestReader?.progressiveDone(), this._progressiveDone = !0 } _removeRangeReader(Pe) { const Oe = this._rangeReaders.indexOf(Pe); Oe >= 0 && this._rangeReaders.splice(Oe, 1) } getFullReader() { (0, Ee.assert)(!this._fullRequestReader, "PDFDataTransportStream.getFullReader can only be called once."); const Pe = this._queuedChunks; return this._queuedChunks = null, new Ce(this, Pe, this._progressiveDone, this._contentDispositionFilename) } getRangeReader(Pe, Oe) { if (Oe <= this._progressiveDataLength) return null; const je = new Me(this, Pe, Oe); return this._pdfDataRangeTransport.requestDataRange(Pe, Oe), this._rangeReaders.push(je), je } cancelAllRequests(Pe) { this._fullRequestReader?.cancel(Pe); for (const Oe of this._rangeReaders.slice(0)) Oe.cancel(Pe); this._pdfDataRangeTransport.abort() } } t.PDFDataTransportStream = Re; class Ce { constructor(Pe, Oe, je = !1, Be = null) { this._stream = Pe, this._done = je || !1, this._filename = (0, _e.isPdfFile)(Be) ? Be : null, this._queuedChunks = Oe || [], this._loaded = 0; for (const Ie of this._queuedChunks) this._loaded += Ie.byteLength; this._requests = [], this._headersReady = Promise.resolve(), Pe._fullRequestReader = this, this.onProgress = null } _enqueue(Pe) { this._done || (this._requests.length > 0 ? this._requests.shift().resolve({ value: Pe, done: !1 }) : this._queuedChunks.push(Pe), this._loaded += Pe.byteLength) } get headersReady() { return this._headersReady } get filename() { return this._filename } get isRangeSupported() { return this._stream._isRangeSupported } get isStreamingSupported() { return this._stream._isStreamingSupported } get contentLength() { return this._stream._contentLength } async read() { if (this._queuedChunks.length > 0) return { value: this._queuedChunks.shift(), done: !1 }; if (this._done) return { value: void 0, done: !0 }; const Pe = new Ee.PromiseCapability; return this._requests.push(Pe), Pe.promise } cancel(Pe) { this._done = !0; for (const Oe of this._requests) Oe.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } progressiveDone() { this._done || (this._done = !0) } } class Me { constructor(Pe, Oe, je) { this._stream = Pe, this._begin = Oe, this._end = je, this._queuedChunk = null, this._requests = [], this._done = !1, this.onProgress = null } _enqueue(Pe) { if (!this._done) { if (this._requests.length === 0) this._queuedChunk = Pe; else { this._requests.shift().resolve({ value: Pe, done: !1 }); for (const je of this._requests) je.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } this._done = !0, this._stream._removeRangeReader(this) } } get isStreamingSupported() { return !1 } async read() { if (this._queuedChunk) { const Oe = this._queuedChunk; return this._queuedChunk = null, { value: Oe, done: !1 } } if (this._done) return { value: void 0, done: !0 }; const Pe = new Ee.PromiseCapability; return this._requests.push(Pe), Pe.promise } cancel(Pe) { this._done = !0; for (const Oe of this._requests) Oe.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._stream._removeRangeReader(this) } } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.PDFFetchStream = void 0; var Ee = xe(1), _e = xe(20); function Re(je, Be, Ie) { return { method: "GET", headers: je, signal: Ie.signal, mode: "cors", credentials: Be ? "include" : "same-origin", redirect: "follow" } } function Ce(je) { const Be = new Headers; for (const Ie in je) { const Fe = je[Ie]; Fe !== void 0 && Be.append(Ie, Fe) } return Be } function Me(je) { return je instanceof Uint8Array ? je.buffer : je instanceof ArrayBuffer ? je : ((0, Ee.warn)(`getArrayBuffer - unexpected data format: ${je}`), new Uint8Array(je).buffer) } class De { constructor(Be) { this.source = Be, this.isHttp = /^https?:/i.test(Be.url), this.httpHeaders = this.isHttp && Be.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [] } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0 } getFullReader() { return (0, Ee.assert)(!this._fullRequestReader, "PDFFetchStream.getFullReader can only be called once."), this._fullRequestReader = new Pe(this), this._fullRequestReader } getRangeReader(Be, Ie) { if (Ie <= this._progressiveDataLength) return null; const Fe = new Oe(this, Be, Ie); return this._rangeRequestReaders.push(Fe), Fe } cancelAllRequests(Be) { this._fullRequestReader?.cancel(Be); for (const Ie of this._rangeRequestReaders.slice(0)) Ie.cancel(Be) } } t.PDFFetchStream = De; class Pe { constructor(Be) { this._stream = Be, this._reader = null, this._loaded = 0, this._filename = null; const Ie = Be.source; this._withCredentials = Ie.withCredentials || !1, this._contentLength = Ie.length, this._headersCapability = new Ee.PromiseCapability, this._disableRange = Ie.disableRange || !1, this._rangeChunkSize = Ie.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._abortController = new AbortController, this._isStreamingSupported = !Ie.disableStream, this._isRangeSupported = !Ie.disableRange, this._headers = Ce(this._stream.httpHeaders); const Fe = Ie.url; fetch(Fe, Re(this._headers, this._withCredentials, this._abortController)).then(ze => { if (!(0, _e.validateResponseStatus)(ze.status)) throw (0, _e.createResponseStatusError)(ze.status, Fe); this._reader = ze.body.getReader(), this._headersCapability.resolve(); const qe = Ze => ze.headers.get(Ze), { allowRangeRequests: He, suggestedLength: Ge } = (0, _e.validateRangeRequestCapabilities)({ getResponseHeader: qe, isHttp: this._stream.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = He, this._contentLength = Ge || this._contentLength, this._filename = (0, _e.extractFilenameFromHeader)(qe), !this._isStreamingSupported && this._isRangeSupported && this.cancel(new Ee.AbortException("Streaming is disabled.")) }).catch(this._headersCapability.reject), this.onProgress = null } get headersReady() { return this._headersCapability.promise } get filename() { return this._filename } get contentLength() { return this._contentLength } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } async read() { await this._headersCapability.promise; const { value: Be, done: Ie } = await this._reader.read(); return Ie ? { value: Be, done: Ie } : (this._loaded += Be.byteLength, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: Me(Be), done: !1 }) } cancel(Be) { this._reader?.cancel(Be), this._abortController.abort() } } class Oe { constructor(Be, Ie, Fe) { this._stream = Be, this._reader = null, this._loaded = 0; const ze = Be.source; this._withCredentials = ze.withCredentials || !1, this._readCapability = new Ee.PromiseCapability, this._isStreamingSupported = !ze.disableStream, this._abortController = new AbortController, this._headers = Ce(this._stream.httpHeaders), this._headers.append("Range", `bytes=${Ie}-${Fe - 1}`); const qe = ze.url; fetch(qe, Re(this._headers, this._withCredentials, this._abortController)).then(He => { if (!(0, _e.validateResponseStatus)(He.status)) throw (0, _e.createResponseStatusError)(He.status, qe); this._readCapability.resolve(), this._reader = He.body.getReader() }).catch(this._readCapability.reject), this.onProgress = null } get isStreamingSupported() { return this._isStreamingSupported } async read() { await this._readCapability.promise; const { value: Be, done: Ie } = await this._reader.read(); return Ie ? { value: Be, done: Ie } : (this._loaded += Be.byteLength, this.onProgress?.({ loaded: this._loaded }), { value: Me(Be), done: !1 }) } cancel(Be) { this._reader?.cancel(Be), this._abortController.abort() } } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.createResponseStatusError = De, t.extractFilenameFromHeader = Me, t.validateRangeRequestCapabilities = Ce, t.validateResponseStatus = Pe; var Ee = xe(1), _e = xe(21), Re = xe(6); function Ce({ getResponseHeader: Oe, isHttp: je, rangeChunkSize: Be, disableRange: Ie }) { const Fe = { allowRangeRequests: !1, suggestedLength: void 0 }, ze = parseInt(Oe("Content-Length"), 10); return !Number.isInteger(ze) || (Fe.suggestedLength = ze, ze <= 2 * Be) || Ie || !je || Oe("Accept-Ranges") !== "bytes" || (Oe("Content-Encoding") || "identity") !== "identity" || (Fe.allowRangeRequests = !0), Fe } function Me(Oe) { const je = Oe("Content-Disposition"); if (je) { let Be = (0, _e.getFilenameFromContentDispositionHeader)(je); if (Be.includes("%")) try { Be = decodeURIComponent(Be) } catch { } if ((0, Re.isPdfFile)(Be)) return Be } return null } function De(Oe, je) { return Oe === 404 || Oe === 0 && je.startsWith("file:") ? new Ee.MissingPDFException('Missing PDF "' + je + '".') : new Ee.UnexpectedResponseException(`Unexpected server response (${Oe}) while retrieving PDF "${je}".`, Oe) } function Pe(Oe) { return Oe === 200 || Oe === 206 } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.getFilenameFromContentDispositionHeader = _e; var Ee = xe(1); function _e(Re) { let Ce = !0, Me = De("filename\\*", "i").exec(Re); if (Me) { Me = Me[1]; let ze = Be(Me); return ze = unescape(ze), ze = Ie(ze), ze = Fe(ze), Oe(ze) } if (Me = je(Re), Me) { const ze = Fe(Me); return Oe(ze) } if (Me = De("filename", "i").exec(Re), Me) { Me = Me[1]; let ze = Be(Me); return ze = Fe(ze), Oe(ze) } function De(ze, qe) { return new RegExp("(?:^|;)\\s*" + ze + '\\s*=\\s*([^";\\s][^;\\s]*|"(?:[^"\\\\]|\\\\"?)+"?)', qe) } function Pe(ze, qe) { if (ze) { if (!/^[\x00-\xFF]+$/.test(qe)) return qe; try { const He = new TextDecoder(ze, { fatal: !0 }), Ge = (0, Ee.stringToBytes)(qe); qe = He.decode(Ge), Ce = !1 } catch { } } return qe } function Oe(ze) { return Ce && /[\x80-\xff]/.test(ze) && (ze = Pe("utf-8", ze), Ce && (ze = Pe("iso-8859-1", ze))), ze } function je(ze) { const qe = []; let He; const Ge = De("filename\\*((?!0\\d)\\d+)(\\*?)", "ig"); for (; (He = Ge.exec(ze)) !== null;) { let [, sn, Xe, St] = He; if (sn = parseInt(sn, 10), sn in qe) { if (sn === 0) break; continue } qe[sn] = [Xe, St] } const Ze = []; for (let sn = 0; sn < qe.length && sn in qe; ++sn) { let [Xe, St] = qe[sn]; St = Be(St), Xe && (St = unescape(St), sn === 0 && (St = Ie(St))), Ze.push(St) } return Ze.join("") } function Be(ze) { if (ze.startsWith('"')) { const qe = ze.slice(1).split('\\"'); for (let He = 0; He < qe.length; ++He) { const Ge = qe[He].indexOf('"'); Ge !== -1 && (qe[He] = qe[He].slice(0, Ge), qe.length = He + 1), qe[He] = qe[He].replaceAll(/\\(.)/g, "$1") } ze = qe.join('"') } return ze } function Ie(ze) { const qe = ze.indexOf("'"); if (qe === -1) return ze; const He = ze.slice(0, qe), Ze = ze.slice(qe + 1).replace(/^[^']*'/, ""); return Pe(He, Ze) } function Fe(ze) { return !ze.startsWith("=?") || /[\x00-\x19\x80-\xff]/.test(ze) ? ze : ze.replaceAll(/=\?([\w-]*)\?([QqBb])\?((?:[^?]|\?(?!=))*)\?=/g, function (qe, He, Ge, Ze) { if (Ge === "q" || Ge === "Q") return Ze = Ze.replaceAll("_", " "), Ze = Ze.replaceAll(/=([0-9a-fA-F]{2})/g, function (sn, Xe) { return String.fromCharCode(parseInt(Xe, 16)) }), Pe(He, Ze); try { Ze = atob(Ze) } catch { } return Pe(He, Ze) }) } return "" } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.PDFNetworkStream = void 0; var Ee = xe(1), _e = xe(20); const Re = 200, Ce = 206; function Me(Be) { const Ie = Be.response; return typeof Ie != "string" ? Ie : (0, Ee.stringToBytes)(Ie).buffer } class De { constructor(Ie, Fe = {}) { this.url = Ie, this.isHttp = /^https?:/i.test(Ie), this.httpHeaders = this.isHttp && Fe.httpHeaders || Object.create(null), this.withCredentials = Fe.withCredentials || !1, this.currXhrId = 0, this.pendingRequests = Object.create(null) } requestRange(Ie, Fe, ze) { const qe = { begin: Ie, end: Fe }; for (const He in ze) qe[He] = ze[He]; return this.request(qe) } requestFull(Ie) { return this.request(Ie) } request(Ie) { const Fe = new XMLHttpRequest, ze = this.currXhrId++, qe = this.pendingRequests[ze] = { xhr: Fe }; Fe.open("GET", this.url), Fe.withCredentials = this.withCredentials; for (const He in this.httpHeaders) { const Ge = this.httpHeaders[He]; Ge !== void 0 && Fe.setRequestHeader(He, Ge) } return this.isHttp && "begin" in Ie && "end" in Ie ? (Fe.setRequestHeader("Range", `bytes=${Ie.begin}-${Ie.end - 1}`), qe.expectedStatus = Ce) : qe.expectedStatus = Re, Fe.responseType = "arraybuffer", Ie.onError && (Fe.onerror = function (He) { Ie.onError(Fe.status) }), Fe.onreadystatechange = this.onStateChange.bind(this, ze), Fe.onprogress = this.onProgress.bind(this, ze), qe.onHeadersReceived = Ie.onHeadersReceived, qe.onDone = Ie.onDone, qe.onError = Ie.onError, qe.onProgress = Ie.onProgress, Fe.send(null), ze } onProgress(Ie, Fe) { const ze = this.pendingRequests[Ie]; ze && ze.onProgress?.(Fe) } onStateChange(Ie, Fe) { const ze = this.pendingRequests[Ie]; if (!ze) return; const qe = ze.xhr; if (qe.readyState >= 2 && ze.onHeadersReceived && (ze.onHeadersReceived(), delete ze.onHeadersReceived), qe.readyState !== 4 || !(Ie in this.pendingRequests)) return; if (delete this.pendingRequests[Ie], qe.status === 0 && this.isHttp) { ze.onError?.(qe.status); return } const He = qe.status || Re; if (!(He === Re && ze.expectedStatus === Ce) && He !== ze.expectedStatus) { ze.onError?.(qe.status); return } const Ze = Me(qe); if (He === Ce) { const sn = qe.getResponseHeader("Content-Range"), Xe = /bytes (\d+)-(\d+)\/(\d+)/.exec(sn); ze.onDone({ begin: parseInt(Xe[1], 10), chunk: Ze }) } else Ze ? ze.onDone({ begin: 0, chunk: Ze }) : ze.onError?.(qe.status) } getRequestXhr(Ie) { return this.pendingRequests[Ie].xhr } isPendingRequest(Ie) { return Ie in this.pendingRequests } abortRequest(Ie) { const Fe = this.pendingRequests[Ie].xhr; delete this.pendingRequests[Ie], Fe.abort() } } class Pe { constructor(Ie) { this._source = Ie, this._manager = new De(Ie.url, { httpHeaders: Ie.httpHeaders, withCredentials: Ie.withCredentials }), this._rangeChunkSize = Ie.rangeChunkSize, this._fullRequestReader = null, this._rangeRequestReaders = [] } _onRangeRequestReaderClosed(Ie) { const Fe = this._rangeRequestReaders.indexOf(Ie); Fe >= 0 && this._rangeRequestReaders.splice(Fe, 1) } getFullReader() { return (0, Ee.assert)(!this._fullRequestReader, "PDFNetworkStream.getFullReader can only be called once."), this._fullRequestReader = new Oe(this._manager, this._source), this._fullRequestReader } getRangeReader(Ie, Fe) { const ze = new je(this._manager, Ie, Fe); return ze.onClosed = this._onRangeRequestReaderClosed.bind(this), this._rangeRequestReaders.push(ze), ze } cancelAllRequests(Ie) { this._fullRequestReader?.cancel(Ie); for (const Fe of this._rangeRequestReaders.slice(0)) Fe.cancel(Ie) } } t.PDFNetworkStream = Pe; class Oe { constructor(Ie, Fe) { this._manager = Ie; const ze = { onHeadersReceived: this._onHeadersReceived.bind(this), onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = Fe.url, this._fullRequestId = Ie.requestFull(ze), this._headersReceivedCapability = new Ee.PromiseCapability, this._disableRange = Fe.disableRange || !1, this._contentLength = Fe.length, this._rangeChunkSize = Fe.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !1, this._isRangeSupported = !1, this._cachedChunks = [], this._requests = [], this._done = !1, this._storedError = void 0, this._filename = null, this.onProgress = null } _onHeadersReceived() { const Ie = this._fullRequestId, Fe = this._manager.getRequestXhr(Ie), ze = Ge => Fe.getResponseHeader(Ge), { allowRangeRequests: qe, suggestedLength: He } = (0, _e.validateRangeRequestCapabilities)({ getResponseHeader: ze, isHttp: this._manager.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); qe && (this._isRangeSupported = !0), this._contentLength = He || this._contentLength, this._filename = (0, _e.extractFilenameFromHeader)(ze), this._isRangeSupported && this._manager.abortRequest(Ie), this._headersReceivedCapability.resolve() } _onDone(Ie) { if (Ie && (this._requests.length > 0 ? this._requests.shift().resolve({ value: Ie.chunk, done: !1 }) : this._cachedChunks.push(Ie.chunk)), this._done = !0, !(this._cachedChunks.length > 0)) { for (const Fe of this._requests) Fe.resolve({ value: void 0, done: !0 }); this._requests.length = 0 } } _onError(Ie) { this._storedError = (0, _e.createResponseStatusError)(Ie, this._url), this._headersReceivedCapability.reject(this._storedError); for (const Fe of this._requests) Fe.reject(this._storedError); this._requests.length = 0, this._cachedChunks.length = 0 } _onProgress(Ie) { this.onProgress?.({ loaded: Ie.loaded, total: Ie.lengthComputable ? Ie.total : this._contentLength }) } get filename() { return this._filename } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } get contentLength() { return this._contentLength } get headersReady() { return this._headersReceivedCapability.promise } async read() { if (this._storedError) throw this._storedError; if (this._cachedChunks.length > 0) return { value: this._cachedChunks.shift(), done: !1 }; if (this._done) return { value: void 0, done: !0 }; const Ie = new Ee.PromiseCapability; return this._requests.push(Ie), Ie.promise } cancel(Ie) { this._done = !0, this._headersReceivedCapability.reject(Ie); for (const Fe of this._requests) Fe.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._manager.isPendingRequest(this._fullRequestId) && this._manager.abortRequest(this._fullRequestId), this._fullRequestReader = null } } class je { constructor(Ie, Fe, ze) { this._manager = Ie; const qe = { onDone: this._onDone.bind(this), onError: this._onError.bind(this), onProgress: this._onProgress.bind(this) }; this._url = Ie.url, this._requestId = Ie.requestRange(Fe, ze, qe), this._requests = [], this._queuedChunk = null, this._done = !1, this._storedError = void 0, this.onProgress = null, this.onClosed = null } _close() { this.onClosed?.(this) } _onDone(Ie) { const Fe = Ie.chunk; this._requests.length > 0 ? this._requests.shift().resolve({ value: Fe, done: !1 }) : this._queuedChunk = Fe, this._done = !0; for (const ze of this._requests) ze.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._close() } _onError(Ie) { this._storedError = (0, _e.createResponseStatusError)(Ie, this._url); for (const Fe of this._requests) Fe.reject(this._storedError); this._requests.length = 0, this._queuedChunk = null } _onProgress(Ie) { this.isStreamingSupported || this.onProgress?.({ loaded: Ie.loaded }) } get isStreamingSupported() { return !1 } async read() { if (this._storedError) throw this._storedError; if (this._queuedChunk !== null) { const Fe = this._queuedChunk; return this._queuedChunk = null, { value: Fe, done: !1 } } if (this._done) return { value: void 0, done: !0 }; const Ie = new Ee.PromiseCapability; return this._requests.push(Ie), Ie.promise } cancel(Ie) { this._done = !0; for (const Fe of this._requests) Fe.resolve({ value: void 0, done: !0 }); this._requests.length = 0, this._manager.isPendingRequest(this._requestId) && this._manager.abortRequest(this._requestId), this._close() } } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.PDFNodeStream = void 0; var Ee = xe(1), _e = xe(20); const Re = /^file:\/\/\/[a-zA-Z]:\//; function Ce(ze) { const qe = require$$5, He = qe.parse(ze); return He.protocol === "file:" || He.host ? He : /^[a-z]:[/\\]/i.test(ze) ? qe.parse(`file:///${ze}`) : (He.host || (He.protocol = "file:"), He) } class Me { constructor(qe) { this.source = qe, this.url = Ce(qe.url), this.isHttp = this.url.protocol === "http:" || this.url.protocol === "https:", this.isFsUrl = this.url.protocol === "file:", this.httpHeaders = this.isHttp && qe.httpHeaders || {}, this._fullRequestReader = null, this._rangeRequestReaders = [] } get _progressiveDataLength() { return this._fullRequestReader?._loaded ?? 0 } getFullReader() { return (0, Ee.assert)(!this._fullRequestReader, "PDFNodeStream.getFullReader can only be called once."), this._fullRequestReader = this.isFsUrl ? new Ie(this) : new je(this), this._fullRequestReader } getRangeReader(qe, He) { if (He <= this._progressiveDataLength) return null; const Ge = this.isFsUrl ? new Fe(this, qe, He) : new Be(this, qe, He); return this._rangeRequestReaders.push(Ge), Ge } cancelAllRequests(qe) { this._fullRequestReader?.cancel(qe); for (const He of this._rangeRequestReaders.slice(0)) He.cancel(qe) } } t.PDFNodeStream = Me; class De { constructor(qe) { this._url = qe.url, this._done = !1, this._storedError = null, this.onProgress = null; const He = qe.source; this._contentLength = He.length, this._loaded = 0, this._filename = null, this._disableRange = He.disableRange || !1, this._rangeChunkSize = He.rangeChunkSize, !this._rangeChunkSize && !this._disableRange && (this._disableRange = !0), this._isStreamingSupported = !He.disableStream, this._isRangeSupported = !He.disableRange, this._readableStream = null, this._readCapability = new Ee.PromiseCapability, this._headersCapability = new Ee.PromiseCapability } get headersReady() { return this._headersCapability.promise } get filename() { return this._filename } get contentLength() { return this._contentLength } get isRangeSupported() { return this._isRangeSupported } get isStreamingSupported() { return this._isStreamingSupported } async read() { if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 }; if (this._storedError) throw this._storedError; const qe = this._readableStream.read(); return qe === null ? (this._readCapability = new Ee.PromiseCapability, this.read()) : (this._loaded += qe.length, this.onProgress?.({ loaded: this._loaded, total: this._contentLength }), { value: new Uint8Array(qe).buffer, done: !1 }) } cancel(qe) { if (!this._readableStream) { this._error(qe); return } this._readableStream.destroy(qe) } _error(qe) { this._storedError = qe, this._readCapability.resolve() } _setReadableStream(qe) { this._readableStream = qe, qe.on("readable", () => { this._readCapability.resolve() }), qe.on("end", () => { qe.destroy(), this._done = !0, this._readCapability.resolve() }), qe.on("error", He => { this._error(He) }), !this._isStreamingSupported && this._isRangeSupported && this._error(new Ee.AbortException("streaming is disabled")), this._storedError && this._readableStream.destroy(this._storedError) } } class Pe { constructor(qe) { this._url = qe.url, this._done = !1, this._storedError = null, this.onProgress = null, this._loaded = 0, this._readableStream = null, this._readCapability = new Ee.PromiseCapability; const He = qe.source; this._isStreamingSupported = !He.disableStream } get isStreamingSupported() { return this._isStreamingSupported } async read() { if (await this._readCapability.promise, this._done) return { value: void 0, done: !0 }; if (this._storedError) throw this._storedError; const qe = this._readableStream.read(); return qe === null ? (this._readCapability = new Ee.PromiseCapability, this.read()) : (this._loaded += qe.length, this.onProgress?.({ loaded: this._loaded }), { value: new Uint8Array(qe).buffer, done: !1 }) } cancel(qe) { if (!this._readableStream) { this._error(qe); return } this._readableStream.destroy(qe) } _error(qe) { this._storedError = qe, this._readCapability.resolve() } _setReadableStream(qe) { this._readableStream = qe, qe.on("readable", () => { this._readCapability.resolve() }), qe.on("end", () => { qe.destroy(), this._done = !0, this._readCapability.resolve() }), qe.on("error", He => { this._error(He) }), this._storedError && this._readableStream.destroy(this._storedError) } } function Oe(ze, qe) { return { protocol: ze.protocol, auth: ze.auth, host: ze.hostname, port: ze.port, path: ze.path, method: "GET", headers: qe } } class je extends De { constructor(qe) { super(qe); const He = Ge => { if (Ge.statusCode === 404) { const St = new Ee.MissingPDFException(`Missing PDF "${this._url}".`); this._storedError = St, this._headersCapability.reject(St); return } this._headersCapability.resolve(), this._setReadableStream(Ge); const Ze = St => this._readableStream.headers[St.toLowerCase()], { allowRangeRequests: sn, suggestedLength: Xe } = (0, _e.validateRangeRequestCapabilities)({ getResponseHeader: Ze, isHttp: qe.isHttp, rangeChunkSize: this._rangeChunkSize, disableRange: this._disableRange }); this._isRangeSupported = sn, this._contentLength = Xe || this._contentLength, this._filename = (0, _e.extractFilenameFromHeader)(Ze) }; if (this._request = null, this._url.protocol === "http:") { const Ge = require$$5; this._request = Ge.request(Oe(this._url, qe.httpHeaders), He) } else { const Ge = require$$5; this._request = Ge.request(Oe(this._url, qe.httpHeaders), He) } this._request.on("error", Ge => { this._storedError = Ge, this._headersCapability.reject(Ge) }), this._request.end() } } class Be extends Pe { constructor(qe, He, Ge) { super(qe), this._httpHeaders = {}; for (const sn in qe.httpHeaders) { const Xe = qe.httpHeaders[sn]; Xe !== void 0 && (this._httpHeaders[sn] = Xe) } this._httpHeaders.Range = `bytes=${He}-${Ge - 1}`; const Ze = sn => { if (sn.statusCode === 404) { const Xe = new Ee.MissingPDFException(`Missing PDF "${this._url}".`); this._storedError = Xe; return } this._setReadableStream(sn) }; if (this._request = null, this._url.protocol === "http:") { const sn = require$$5; this._request = sn.request(Oe(this._url, this._httpHeaders), Ze) } else { const sn = require$$5; this._request = sn.request(Oe(this._url, this._httpHeaders), Ze) } this._request.on("error", sn => { this._storedError = sn }), this._request.end() } } class Ie extends De { constructor(qe) { super(qe); let He = decodeURIComponent(this._url.path); Re.test(this._url.href) && (He = He.replace(/^\//, "")); const Ge = require$$5; Ge.lstat(He, (Ze, sn) => { if (Ze) { Ze.code === "ENOENT" && (Ze = new Ee.MissingPDFException(`Missing PDF "${He}".`)), this._storedError = Ze, this._headersCapability.reject(Ze); return } this._contentLength = sn.size, this._setReadableStream(Ge.createReadStream(He)), this._headersCapability.resolve() }) } } class Fe extends Pe { constructor(qe, He, Ge) { super(qe); let Ze = decodeURIComponent(this._url.path); Re.test(this._url.href) && (Ze = Ze.replace(/^\//, "")); const sn = require$$5; this._setReadableStream(sn.createReadStream(Ze, { start: He, end: Ge - 1 })) } } }, (e, t, xe) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.SVGGraphics = void 0; var Ee = xe(6), _e = xe(1); const Re = { fontStyle: "normal", fontWeight: "normal", fillColor: "#000000" }, Ce = "http://www.w3.org/XML/1998/namespace", Me = "http://www.w3.org/1999/xlink", De = ["butt", "round", "square"], Pe = ["miter", "round", "bevel"], Oe = function (sn, Xe = "", St = !1) { if (URL.createObjectURL && typeof Blob < "u" && !St) return URL.createObjectURL(new Blob([sn], { type: Xe })); const un = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="; let on = `data:${Xe};base64,`; for (let bn = 0, Tn = sn.length; bn < Tn; bn += 3) { const fn = sn[bn] & 255, En = sn[bn + 1] & 255, Pn = sn[bn + 2] & 255, Rn = fn >> 2, In = (fn & 3) << 4 | En >> 4, xn = bn + 1 < Tn ? (En & 15) << 2 | Pn >> 6 : 64, vn = bn + 2 < Tn ? Pn & 63 : 64; on += un[Rn] + un[In] + un[xn] + un[vn] } return on }, je = function () { const sn = new Uint8Array([137, 80, 78, 71, 13, 10, 26, 10]), Xe = 12, St = new Int32Array(256); for (let Pn = 0; Pn < 256; Pn++) { let Rn = Pn; for (let In = 0; In < 8; In++)Rn = Rn & 1 ? 3988292384 ^ Rn >> 1 & 2147483647 : Rn >> 1 & 2147483647; St[Pn] = Rn } function un(Pn, Rn, In) { let xn = -1; for (let vn = Rn; vn < In; vn++) { const tn = (xn ^ Pn[vn]) & 255, nn = St[tn]; xn = xn >>> 8 ^ nn } return xn ^ -1 } function on(Pn, Rn, In, xn) { let vn = xn; const tn = Rn.length; In[vn] = tn >> 24 & 255, In[vn + 1] = tn >> 16 & 255, In[vn + 2] = tn >> 8 & 255, In[vn + 3] = tn & 255, vn += 4, In[vn] = Pn.charCodeAt(0) & 255, In[vn + 1] = Pn.charCodeAt(1) & 255, In[vn + 2] = Pn.charCodeAt(2) & 255, In[vn + 3] = Pn.charCodeAt(3) & 255, vn += 4, In.set(Rn, vn), vn += Rn.length; const nn = un(In, xn + 4, vn); In[vn] = nn >> 24 & 255, In[vn + 1] = nn >> 16 & 255, In[vn + 2] = nn >> 8 & 255, In[vn + 3] = nn & 255 } function bn(Pn, Rn, In) { let xn = 1, vn = 0; for (let tn = Rn; tn < In; ++tn)xn = (xn + (Pn[tn] & 255)) % 65521, vn = (vn + xn) % 65521; return vn << 16 | xn } function Tn(Pn) { if (!_e.isNodeJS) return fn(Pn); try { const Rn = parseInt(process.versions.node) >= 8 ? Pn : Buffer.from(Pn), In = require$$5.deflateSync(Rn, { level: 9 }); return In instanceof Uint8Array ? In : new Uint8Array(In) } catch (Rn) { (0, _e.warn)("Not compressing PNG because zlib.deflateSync is unavailable: " + Rn) } return fn(Pn) } function fn(Pn) { let Rn = Pn.length; const In = 65535, xn = Math.ceil(Rn / In), vn = new Uint8Array(2 + Rn + xn * 5 + 4); let tn = 0; vn[tn++] = 120, vn[tn++] = 156; let nn = 0; for (; Rn > In;)vn[tn++] = 0, vn[tn++] = 255, vn[tn++] = 255, vn[tn++] = 0, vn[tn++] = 0, vn.set(Pn.subarray(nn, nn + In), tn), tn += In, nn += In, Rn -= In; vn[tn++] = 1, vn[tn++] = Rn & 255, vn[tn++] = Rn >> 8 & 255, vn[tn++] = ~Rn & 65535 & 255, vn[tn++] = (~Rn & 65535) >> 8 & 255, vn.set(Pn.subarray(nn), tn), tn += Pn.length - nn; const We = bn(Pn, 0, Pn.length); return vn[tn++] = We >> 24 & 255, vn[tn++] = We >> 16 & 255, vn[tn++] = We >> 8 & 255, vn[tn++] = We & 255, vn } function En(Pn, Rn, In, xn) { const vn = Pn.width, tn = Pn.height; let nn, We, dn; const Je = Pn.data; switch (Rn) { case _e.ImageKind.GRAYSCALE_1BPP: We = 0, nn = 1, dn = vn + 7 >> 3; break; case _e.ImageKind.RGB_24BPP: We = 2, nn = 8, dn = vn * 3; break; case _e.ImageKind.RGBA_32BPP: We = 6, nn = 8, dn = vn * 4; break; default: throw new Error("invalid format") }const rn = new Uint8Array((1 + dn) * tn); let hn = 0, mn = 0; for (let On = 0; On < tn; ++On)rn[hn++] = 0, rn.set(Je.subarray(mn, mn + dn), hn), mn += dn, hn += dn; if (Rn === _e.ImageKind.GRAYSCALE_1BPP && xn) { hn = 0; for (let On = 0; On < tn; On++) { hn++; for (let kn = 0; kn < dn; kn++)rn[hn++] ^= 255 } } const Ye = new Uint8Array([vn >> 24 & 255, vn >> 16 & 255, vn >> 8 & 255, vn & 255, tn >> 24 & 255, tn >> 16 & 255, tn >> 8 & 255, tn & 255, nn, We, 0, 0, 0]), an = Tn(rn), pn = sn.length + Xe * 3 + Ye.length + an.length, yn = new Uint8Array(pn); let _n = 0; return yn.set(sn, _n), _n += sn.length, on("IHDR", Ye, yn, _n), _n += Xe + Ye.length, on("IDATA", an, yn, _n), _n += Xe + an.length, on("IEND", new Uint8Array(0), yn, _n), Oe(yn, "image/png", In) } return function (Rn, In, xn) { const vn = Rn.kind === void 0 ? _e.ImageKind.GRAYSCALE_1BPP : Rn.kind; return En(Rn, vn, In, xn) } }(); class Be { constructor() { this.fontSizeScale = 1, this.fontWeight = Re.fontWeight, this.fontSize = 0, this.textMatrix = _e.IDENTITY_MATRIX, this.fontMatrix = _e.FONT_IDENTITY_MATRIX, this.leading = 0, this.textRenderingMode = _e.TextRenderingMode.FILL, this.textMatrixScale = 1, this.x = 0, this.y = 0, this.lineX = 0, this.lineY = 0, this.charSpacing = 0, this.wordSpacing = 0, this.textHScale = 1, this.textRise = 0, this.fillColor = Re.fillColor, this.strokeColor = "#000000", this.fillAlpha = 1, this.strokeAlpha = 1, this.lineWidth = 1, this.lineJoin = "", this.lineCap = "", this.miterLimit = 0, this.dashArray = [], this.dashPhase = 0, this.dependencies = [], this.activeClipUrl = null, this.clipGroup = null, this.maskId = "" } clone() { return Object.create(this) } setCurrentPoint(Xe, St) { this.x = Xe, this.y = St } } function Ie(sn) { let Xe = []; const St = []; for (const un of sn) { if (un.fn === "save") { Xe.push({ fnId: 92, fn: "group", items: [] }), St.push(Xe), Xe = Xe.at(-1).items; continue } un.fn === "restore" ? Xe = St.pop() : Xe.push(un) } return Xe } function Fe(sn) { if (Number.isInteger(sn)) return sn.toString(); const Xe = sn.toFixed(10); let St = Xe.length - 1; if (Xe[St] !== "0") return Xe; do St--; while (Xe[St] === "0"); return Xe.substring(0, Xe[St] === "." ? St : St + 1) } function ze(sn) { if (sn[4] === 0 && sn[5] === 0) { if (sn[1] === 0 && sn[2] === 0) return sn[0] === 1 && sn[3] === 1 ? "" : `scale(${Fe(sn[0])} ${Fe(sn[3])})`; if (sn[0] === sn[3] && sn[1] === -sn[2]) { const Xe = Math.acos(sn[0]) * 180 / Math.PI; return `rotate(${Fe(Xe)})` } } else if (sn[0] === 1 && sn[1] === 0 && sn[2] === 0 && sn[3] === 1) return `translate(${Fe(sn[4])} ${Fe(sn[5])})`; return `matrix(${Fe(sn[0])} ${Fe(sn[1])} ${Fe(sn[2])} ${Fe(sn[3])} ${Fe(sn[4])} ${Fe(sn[5])})` } let qe = 0, He = 0, Ge = 0; class Ze {
          constructor(Xe, St, un = !1) { (0, Ee.deprecated)("The SVG back-end is no longer maintained and *may* be removed in the future."), this.svgFactory = new Ee.DOMSVGFactory, this.current = new Be, this.transformMatrix = _e.IDENTITY_MATRIX, this.transformStack = [], this.extraStack = [], this.commonObjs = Xe, this.objs = St, this.pendingClip = null, this.pendingEOFill = !1, this.embedFonts = !1, this.embeddedFonts = Object.create(null), this.cssStyle = null, this.forceDataSchema = !!un, this._operatorIdMapping = []; for (const on in _e.OPS) this._operatorIdMapping[_e.OPS[on]] = on } getObject(Xe, St = null) { return typeof Xe == "string" ? Xe.startsWith("g_") ? this.commonObjs.get(Xe) : this.objs.get(Xe) : St } save() { this.transformStack.push(this.transformMatrix); const Xe = this.current; this.extraStack.push(Xe), this.current = Xe.clone() } restore() { this.transformMatrix = this.transformStack.pop(), this.current = this.extraStack.pop(), this.pendingClip = null, this.tgrp = null } group(Xe) { this.save(), this.executeOpTree(Xe), this.restore() } loadDependencies(Xe) { const St = Xe.fnArray, un = Xe.argsArray; for (let on = 0, bn = St.length; on < bn; on++)if (St[on] === _e.OPS.dependency) for (const Tn of un[on]) { const fn = Tn.startsWith("g_") ? this.commonObjs : this.objs, En = new Promise(Pn => { fn.get(Tn, Pn) }); this.current.dependencies.push(En) } return Promise.all(this.current.dependencies) } transform(Xe, St, un, on, bn, Tn) { const fn = [Xe, St, un, on, bn, Tn]; this.transformMatrix = _e.Util.transform(this.transformMatrix, fn), this.tgrp = null } getSVG(Xe, St) { this.viewport = St; const un = this._initialize(St); return this.loadDependencies(Xe).then(() => (this.transformMatrix = _e.IDENTITY_MATRIX, this.executeOpTree(this.convertOpList(Xe)), un)) } convertOpList(Xe) { const St = this._operatorIdMapping, un = Xe.argsArray, on = Xe.fnArray, bn = []; for (let Tn = 0, fn = on.length; Tn < fn; Tn++) { const En = on[Tn]; bn.push({ fnId: En, fn: St[En], args: un[Tn] }) } return Ie(bn) } executeOpTree(Xe) { for (const St of Xe) { const un = St.fn, on = St.fnId, bn = St.args; switch (on | 0) { case _e.OPS.beginText: this.beginText(); break; case _e.OPS.dependency: break; case _e.OPS.setLeading: this.setLeading(bn); break; case _e.OPS.setLeadingMoveText: this.setLeadingMoveText(bn[0], bn[1]); break; case _e.OPS.setFont: this.setFont(bn); break; case _e.OPS.showText: this.showText(bn[0]); break; case _e.OPS.showSpacedText: this.showText(bn[0]); break; case _e.OPS.endText: this.endText(); break; case _e.OPS.moveText: this.moveText(bn[0], bn[1]); break; case _e.OPS.setCharSpacing: this.setCharSpacing(bn[0]); break; case _e.OPS.setWordSpacing: this.setWordSpacing(bn[0]); break; case _e.OPS.setHScale: this.setHScale(bn[0]); break; case _e.OPS.setTextMatrix: this.setTextMatrix(bn[0], bn[1], bn[2], bn[3], bn[4], bn[5]); break; case _e.OPS.setTextRise: this.setTextRise(bn[0]); break; case _e.OPS.setTextRenderingMode: this.setTextRenderingMode(bn[0]); break; case _e.OPS.setLineWidth: this.setLineWidth(bn[0]); break; case _e.OPS.setLineJoin: this.setLineJoin(bn[0]); break; case _e.OPS.setLineCap: this.setLineCap(bn[0]); break; case _e.OPS.setMiterLimit: this.setMiterLimit(bn[0]); break; case _e.OPS.setFillRGBColor: this.setFillRGBColor(bn[0], bn[1], bn[2]); break; case _e.OPS.setStrokeRGBColor: this.setStrokeRGBColor(bn[0], bn[1], bn[2]); break; case _e.OPS.setStrokeColorN: this.setStrokeColorN(bn); break; case _e.OPS.setFillColorN: this.setFillColorN(bn); break; case _e.OPS.shadingFill: this.shadingFill(bn[0]); break; case _e.OPS.setDash: this.setDash(bn[0], bn[1]); break; case _e.OPS.setRenderingIntent: this.setRenderingIntent(bn[0]); break; case _e.OPS.setFlatness: this.setFlatness(bn[0]); break; case _e.OPS.setGState: this.setGState(bn[0]); break; case _e.OPS.fill: this.fill(); break; case _e.OPS.eoFill: this.eoFill(); break; case _e.OPS.stroke: this.stroke(); break; case _e.OPS.fillStroke: this.fillStroke(); break; case _e.OPS.eoFillStroke: this.eoFillStroke(); break; case _e.OPS.clip: this.clip("nonzero"); break; case _e.OPS.eoClip: this.clip("evenodd"); break; case _e.OPS.paintSolidColorImageMask: this.paintSolidColorImageMask(); break; case _e.OPS.paintImageXObject: this.paintImageXObject(bn[0]); break; case _e.OPS.paintInlineImageXObject: this.paintInlineImageXObject(bn[0]); break; case _e.OPS.paintImageMaskXObject: this.paintImageMaskXObject(bn[0]); break; case _e.OPS.paintFormXObjectBegin: this.paintFormXObjectBegin(bn[0], bn[1]); break; case _e.OPS.paintFormXObjectEnd: this.paintFormXObjectEnd(); break; case _e.OPS.closePath: this.closePath(); break; case _e.OPS.closeStroke: this.closeStroke(); break; case _e.OPS.closeFillStroke: this.closeFillStroke(); break; case _e.OPS.closeEOFillStroke: this.closeEOFillStroke(); break; case _e.OPS.nextLine: this.nextLine(); break; case _e.OPS.transform: this.transform(bn[0], bn[1], bn[2], bn[3], bn[4], bn[5]); break; case _e.OPS.constructPath: this.constructPath(bn[0], bn[1]); break; case _e.OPS.endPath: this.endPath(); break; case 92: this.group(St.items); break; default: (0, _e.warn)(`Unimplemented operator ${un}`); break } } } setWordSpacing(Xe) { this.current.wordSpacing = Xe } setCharSpacing(Xe) { this.current.charSpacing = Xe } nextLine() { this.moveText(0, this.current.leading) } setTextMatrix(Xe, St, un, on, bn, Tn) { const fn = this.current; fn.textMatrix = fn.lineMatrix = [Xe, St, un, on, bn, Tn], fn.textMatrixScale = Math.hypot(Xe, St), fn.x = fn.lineX = 0, fn.y = fn.lineY = 0, fn.xcoords = [], fn.ycoords = [], fn.tspan = this.svgFactory.createElement("svg:tspan"), fn.tspan.setAttributeNS(null, "font-family", fn.fontFamily), fn.tspan.setAttributeNS(null, "font-size", `${Fe(fn.fontSize)}px`), fn.tspan.setAttributeNS(null, "y", Fe(-fn.y)), fn.txtElement = this.svgFactory.createElement("svg:text"), fn.txtElement.append(fn.tspan) } beginText() { const Xe = this.current; Xe.x = Xe.lineX = 0, Xe.y = Xe.lineY = 0, Xe.textMatrix = _e.IDENTITY_MATRIX, Xe.lineMatrix = _e.IDENTITY_MATRIX, Xe.textMatrixScale = 1, Xe.tspan = this.svgFactory.createElement("svg:tspan"), Xe.txtElement = this.svgFactory.createElement("svg:text"), Xe.txtgrp = this.svgFactory.createElement("svg:g"), Xe.xcoords = [], Xe.ycoords = [] } moveText(Xe, St) { const un = this.current; un.x = un.lineX += Xe, un.y = un.lineY += St, un.xcoords = [], un.ycoords = [], un.tspan = this.svgFactory.createElement("svg:tspan"), un.tspan.setAttributeNS(null, "font-family", un.fontFamily), un.tspan.setAttributeNS(null, "font-size", `${Fe(un.fontSize)}px`), un.tspan.setAttributeNS(null, "y", Fe(-un.y)) } showText(Xe) { const St = this.current, un = St.font, on = St.fontSize; if (on === 0) return; const bn = St.fontSizeScale, Tn = St.charSpacing, fn = St.wordSpacing, En = St.fontDirection, Pn = St.textHScale * En, Rn = un.vertical, In = Rn ? 1 : -1, xn = un.defaultVMetrics, vn = on * St.fontMatrix[0]; let tn = 0; for (const dn of Xe) { if (dn === null) { tn += En * fn; continue } else if (typeof dn == "number") { tn += In * dn * on / 1e3; continue } const Je = (dn.isSpace ? fn : 0) + Tn, rn = dn.fontChar; let hn, mn, Ye = dn.width; if (Rn) { let pn; const yn = dn.vmetric || xn; pn = dn.vmetric ? yn[1] : Ye * .5, pn = -pn * vn; const _n = yn[2] * vn; Ye = yn ? -yn[0] : Ye, hn = pn / bn, mn = (tn + _n) / bn } else hn = tn / bn, mn = 0; (dn.isInFont || un.missingFile) && (St.xcoords.push(St.x + hn), Rn && St.ycoords.push(-St.y + mn), St.tspan.textContent += rn); const an = Rn ? Ye * vn - Je * En : Ye * vn + Je * En; tn += an } St.tspan.setAttributeNS(null, "x", St.xcoords.map(Fe).join(" ")), Rn ? St.tspan.setAttributeNS(null, "y", St.ycoords.map(Fe).join(" ")) : St.tspan.setAttributeNS(null, "y", Fe(-St.y)), Rn ? St.y -= tn : St.x += tn * Pn, St.tspan.setAttributeNS(null, "font-family", St.fontFamily), St.tspan.setAttributeNS(null, "font-size", `${Fe(St.fontSize)}px`), St.fontStyle !== Re.fontStyle && St.tspan.setAttributeNS(null, "font-style", St.fontStyle), St.fontWeight !== Re.fontWeight && St.tspan.setAttributeNS(null, "font-weight", St.fontWeight); const nn = St.textRenderingMode & _e.TextRenderingMode.FILL_STROKE_MASK; if (nn === _e.TextRenderingMode.FILL || nn === _e.TextRenderingMode.FILL_STROKE ? (St.fillColor !== Re.fillColor && St.tspan.setAttributeNS(null, "fill", St.fillColor), St.fillAlpha < 1 && St.tspan.setAttributeNS(null, "fill-opacity", St.fillAlpha)) : St.textRenderingMode === _e.TextRenderingMode.ADD_TO_PATH ? St.tspan.setAttributeNS(null, "fill", "transparent") : St.tspan.setAttributeNS(null, "fill", "none"), nn === _e.TextRenderingMode.STROKE || nn === _e.TextRenderingMode.FILL_STROKE) { const dn = 1 / (St.textMatrixScale || 1); this._setStrokeAttributes(St.tspan, dn) } let We = St.textMatrix; St.textRise !== 0 && (We = We.slice(), We[5] += St.textRise), St.txtElement.setAttributeNS(null, "transform", `${ze(We)} scale(${Fe(Pn)}, -1)`), St.txtElement.setAttributeNS(Ce, "xml:space", "preserve"), St.txtElement.append(St.tspan), St.txtgrp.append(St.txtElement), this._ensureTransformGroup().append(St.txtElement) } setLeadingMoveText(Xe, St) { this.setLeading(-St), this.moveText(Xe, St) } addFontStyle(Xe) {
            if (!Xe.data) throw new Error('addFontStyle: No font data available, ensure that the "fontExtraProperties" API parameter is set.'); this.cssStyle || (this.cssStyle = this.svgFactory.createElement("svg:style"), this.cssStyle.setAttributeNS(null, "type", "text/css"), this.defs.append(this.cssStyle)); const St = Oe(Xe.data, Xe.mimetype, this.forceDataSchema); this.cssStyle.textContent += `@font-face { font-family: "${Xe.loadedName}"; src: url(${St}); }
`} setFont(Xe) { const St = this.current, un = this.commonObjs.get(Xe[0]); let on = Xe[1]; St.font = un, this.embedFonts && !un.missingFile && !this.embeddedFonts[un.loadedName] && (this.addFontStyle(un), this.embeddedFonts[un.loadedName] = un), St.fontMatrix = un.fontMatrix || _e.FONT_IDENTITY_MATRIX; let bn = "normal"; un.black ? bn = "900" : un.bold && (bn = "bold"); const Tn = un.italic ? "italic" : "normal"; on < 0 ? (on = -on, St.fontDirection = -1) : St.fontDirection = 1, St.fontSize = on, St.fontFamily = un.loadedName, St.fontWeight = bn, St.fontStyle = Tn, St.tspan = this.svgFactory.createElement("svg:tspan"), St.tspan.setAttributeNS(null, "y", Fe(-St.y)), St.xcoords = [], St.ycoords = [] } endText() { const Xe = this.current; Xe.textRenderingMode & _e.TextRenderingMode.ADD_TO_PATH_FLAG && Xe.txtElement?.hasChildNodes() && (Xe.element = Xe.txtElement, this.clip("nonzero"), this.endPath()) } setLineWidth(Xe) { Xe > 0 && (this.current.lineWidth = Xe) } setLineCap(Xe) { this.current.lineCap = De[Xe] } setLineJoin(Xe) { this.current.lineJoin = Pe[Xe] } setMiterLimit(Xe) { this.current.miterLimit = Xe } setStrokeAlpha(Xe) { this.current.strokeAlpha = Xe } setStrokeRGBColor(Xe, St, un) { this.current.strokeColor = _e.Util.makeHexColor(Xe, St, un) } setFillAlpha(Xe) { this.current.fillAlpha = Xe } setFillRGBColor(Xe, St, un) { this.current.fillColor = _e.Util.makeHexColor(Xe, St, un), this.current.tspan = this.svgFactory.createElement("svg:tspan"), this.current.xcoords = [], this.current.ycoords = [] } setStrokeColorN(Xe) { this.current.strokeColor = this._makeColorN_Pattern(Xe) } setFillColorN(Xe) { this.current.fillColor = this._makeColorN_Pattern(Xe) } shadingFill(Xe) { const { width: St, height: un } = this.viewport, on = _e.Util.inverseTransform(this.transformMatrix), [bn, Tn, fn, En] = _e.Util.getAxialAlignedBoundingBox([0, 0, St, un], on), Pn = this.svgFactory.createElement("svg:rect"); Pn.setAttributeNS(null, "x", bn), Pn.setAttributeNS(null, "y", Tn), Pn.setAttributeNS(null, "width", fn - bn), Pn.setAttributeNS(null, "height", En - Tn), Pn.setAttributeNS(null, "fill", this._makeShadingPattern(Xe)), this.current.fillAlpha < 1 && Pn.setAttributeNS(null, "fill-opacity", this.current.fillAlpha), this._ensureTransformGroup().append(Pn) } _makeColorN_Pattern(Xe) { return Xe[0] === "TilingPattern" ? this._makeTilingPattern(Xe) : this._makeShadingPattern(Xe) } _makeTilingPattern(Xe) { const St = Xe[1], un = Xe[2], on = Xe[3] || _e.IDENTITY_MATRIX, [bn, Tn, fn, En] = Xe[4], Pn = Xe[5], Rn = Xe[6], In = Xe[7], xn = `shading${Ge++}`, [vn, tn, nn, We] = _e.Util.normalizeRect([..._e.Util.applyTransform([bn, Tn], on), ..._e.Util.applyTransform([fn, En], on)]), [dn, Je] = _e.Util.singularValueDecompose2dScale(on), rn = Pn * dn, hn = Rn * Je, mn = this.svgFactory.createElement("svg:pattern"); mn.setAttributeNS(null, "id", xn), mn.setAttributeNS(null, "patternUnits", "userSpaceOnUse"), mn.setAttributeNS(null, "width", rn), mn.setAttributeNS(null, "height", hn), mn.setAttributeNS(null, "x", `${vn}`), mn.setAttributeNS(null, "y", `${tn}`); const Ye = this.svg, an = this.transformMatrix, pn = this.current.fillColor, yn = this.current.strokeColor, _n = this.svgFactory.create(nn - vn, We - tn); if (this.svg = _n, this.transformMatrix = on, In === 2) { const On = _e.Util.makeHexColor(...St); this.current.fillColor = On, this.current.strokeColor = On } return this.executeOpTree(this.convertOpList(un)), this.svg = Ye, this.transformMatrix = an, this.current.fillColor = pn, this.current.strokeColor = yn, mn.append(_n.childNodes[0]), this.defs.append(mn), `url(#${xn})` } _makeShadingPattern(Xe) { switch (typeof Xe == "string" && (Xe = this.objs.get(Xe)), Xe[0]) { case "RadialAxial": const St = `shading${Ge++}`, un = Xe[3]; let on; switch (Xe[1]) { case "axial": const bn = Xe[4], Tn = Xe[5]; on = this.svgFactory.createElement("svg:linearGradient"), on.setAttributeNS(null, "id", St), on.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), on.setAttributeNS(null, "x1", bn[0]), on.setAttributeNS(null, "y1", bn[1]), on.setAttributeNS(null, "x2", Tn[0]), on.setAttributeNS(null, "y2", Tn[1]); break; case "radial": const fn = Xe[4], En = Xe[5], Pn = Xe[6], Rn = Xe[7]; on = this.svgFactory.createElement("svg:radialGradient"), on.setAttributeNS(null, "id", St), on.setAttributeNS(null, "gradientUnits", "userSpaceOnUse"), on.setAttributeNS(null, "cx", En[0]), on.setAttributeNS(null, "cy", En[1]), on.setAttributeNS(null, "r", Rn), on.setAttributeNS(null, "fx", fn[0]), on.setAttributeNS(null, "fy", fn[1]), on.setAttributeNS(null, "fr", Pn); break; default: throw new Error(`Unknown RadialAxial type: ${Xe[1]}`) }for (const bn of un) { const Tn = this.svgFactory.createElement("svg:stop"); Tn.setAttributeNS(null, "offset", bn[0]), Tn.setAttributeNS(null, "stop-color", bn[1]), on.append(Tn) } return this.defs.append(on), `url(#${St})`; case "Mesh": return (0, _e.warn)("Unimplemented pattern Mesh"), null; case "Dummy": return "hotpink"; default: throw new Error(`Unknown IR type: ${Xe[0]}`) } } setDash(Xe, St) { this.current.dashArray = Xe, this.current.dashPhase = St } constructPath(Xe, St) { const un = this.current; let on = un.x, bn = un.y, Tn = [], fn = 0; for (const En of Xe) switch (En | 0) { case _e.OPS.rectangle: on = St[fn++], bn = St[fn++]; const Pn = St[fn++], Rn = St[fn++], In = on + Pn, xn = bn + Rn; Tn.push("M", Fe(on), Fe(bn), "L", Fe(In), Fe(bn), "L", Fe(In), Fe(xn), "L", Fe(on), Fe(xn), "Z"); break; case _e.OPS.moveTo: on = St[fn++], bn = St[fn++], Tn.push("M", Fe(on), Fe(bn)); break; case _e.OPS.lineTo: on = St[fn++], bn = St[fn++], Tn.push("L", Fe(on), Fe(bn)); break; case _e.OPS.curveTo: on = St[fn + 4], bn = St[fn + 5], Tn.push("C", Fe(St[fn]), Fe(St[fn + 1]), Fe(St[fn + 2]), Fe(St[fn + 3]), Fe(on), Fe(bn)), fn += 6; break; case _e.OPS.curveTo2: Tn.push("C", Fe(on), Fe(bn), Fe(St[fn]), Fe(St[fn + 1]), Fe(St[fn + 2]), Fe(St[fn + 3])), on = St[fn + 2], bn = St[fn + 3], fn += 4; break; case _e.OPS.curveTo3: on = St[fn + 2], bn = St[fn + 3], Tn.push("C", Fe(St[fn]), Fe(St[fn + 1]), Fe(on), Fe(bn), Fe(on), Fe(bn)), fn += 4; break; case _e.OPS.closePath: Tn.push("Z"); break }Tn = Tn.join(" "), un.path && Xe.length > 0 && Xe[0] !== _e.OPS.rectangle && Xe[0] !== _e.OPS.moveTo ? Tn = un.path.getAttributeNS(null, "d") + Tn : (un.path = this.svgFactory.createElement("svg:path"), this._ensureTransformGroup().append(un.path)), un.path.setAttributeNS(null, "d", Tn), un.path.setAttributeNS(null, "fill", "none"), un.element = un.path, un.setCurrentPoint(on, bn) } endPath() { const Xe = this.current; if (Xe.path = null, !this.pendingClip) return; if (!Xe.element) { this.pendingClip = null; return } const St = `clippath${qe++}`, un = this.svgFactory.createElement("svg:clipPath"); un.setAttributeNS(null, "id", St), un.setAttributeNS(null, "transform", ze(this.transformMatrix)); const on = Xe.element.cloneNode(!0); if (this.pendingClip === "evenodd" ? on.setAttributeNS(null, "clip-rule", "evenodd") : on.setAttributeNS(null, "clip-rule", "nonzero"), this.pendingClip = null, un.append(on), this.defs.append(un), Xe.activeClipUrl) { Xe.clipGroup = null; for (const bn of this.extraStack) bn.clipGroup = null; un.setAttributeNS(null, "clip-path", Xe.activeClipUrl) } Xe.activeClipUrl = `url(#${St})`, this.tgrp = null } clip(Xe) { this.pendingClip = Xe } closePath() { const Xe = this.current; if (Xe.path) { const St = `${Xe.path.getAttributeNS(null, "d")}Z`; Xe.path.setAttributeNS(null, "d", St) } } setLeading(Xe) { this.current.leading = -Xe } setTextRise(Xe) { this.current.textRise = Xe } setTextRenderingMode(Xe) { this.current.textRenderingMode = Xe } setHScale(Xe) { this.current.textHScale = Xe / 100 } setRenderingIntent(Xe) { } setFlatness(Xe) { } setGState(Xe) { for (const [St, un] of Xe) switch (St) { case "LW": this.setLineWidth(un); break; case "LC": this.setLineCap(un); break; case "LJ": this.setLineJoin(un); break; case "ML": this.setMiterLimit(un); break; case "D": this.setDash(un[0], un[1]); break; case "RI": this.setRenderingIntent(un); break; case "FL": this.setFlatness(un); break; case "Font": this.setFont(un); break; case "CA": this.setStrokeAlpha(un); break; case "ca": this.setFillAlpha(un); break; default: (0, _e.warn)(`Unimplemented graphic state operator ${St}`); break } } fill() { const Xe = this.current; Xe.element && (Xe.element.setAttributeNS(null, "fill", Xe.fillColor), Xe.element.setAttributeNS(null, "fill-opacity", Xe.fillAlpha), this.endPath()) } stroke() { const Xe = this.current; Xe.element && (this._setStrokeAttributes(Xe.element), Xe.element.setAttributeNS(null, "fill", "none"), this.endPath()) } _setStrokeAttributes(Xe, St = 1) { const un = this.current; let on = un.dashArray; St !== 1 && on.length > 0 && (on = on.map(function (bn) { return St * bn })), Xe.setAttributeNS(null, "stroke", un.strokeColor), Xe.setAttributeNS(null, "stroke-opacity", un.strokeAlpha), Xe.setAttributeNS(null, "stroke-miterlimit", Fe(un.miterLimit)), Xe.setAttributeNS(null, "stroke-linecap", un.lineCap), Xe.setAttributeNS(null, "stroke-linejoin", un.lineJoin), Xe.setAttributeNS(null, "stroke-width", Fe(St * un.lineWidth) + "px"), Xe.setAttributeNS(null, "stroke-dasharray", on.map(Fe).join(" ")), Xe.setAttributeNS(null, "stroke-dashoffset", Fe(St * un.dashPhase) + "px") } eoFill() { this.current.element?.setAttributeNS(null, "fill-rule", "evenodd"), this.fill() } fillStroke() { this.stroke(), this.fill() } eoFillStroke() { this.current.element?.setAttributeNS(null, "fill-rule", "evenodd"), this.fillStroke() } closeStroke() { this.closePath(), this.stroke() } closeFillStroke() { this.closePath(), this.fillStroke() } closeEOFillStroke() { this.closePath(), this.eoFillStroke() } paintSolidColorImageMask() { const Xe = this.svgFactory.createElement("svg:rect"); Xe.setAttributeNS(null, "x", "0"), Xe.setAttributeNS(null, "y", "0"), Xe.setAttributeNS(null, "width", "1px"), Xe.setAttributeNS(null, "height", "1px"), Xe.setAttributeNS(null, "fill", this.current.fillColor), this._ensureTransformGroup().append(Xe) } paintImageXObject(Xe) { const St = this.getObject(Xe); if (!St) { (0, _e.warn)(`Dependent image with object ID ${Xe} is not ready yet`); return } this.paintInlineImageXObject(St) } paintInlineImageXObject(Xe, St) { const un = Xe.width, on = Xe.height, bn = je(Xe, this.forceDataSchema, !!St), Tn = this.svgFactory.createElement("svg:rect"); Tn.setAttributeNS(null, "x", "0"), Tn.setAttributeNS(null, "y", "0"), Tn.setAttributeNS(null, "width", Fe(un)), Tn.setAttributeNS(null, "height", Fe(on)), this.current.element = Tn, this.clip("nonzero"); const fn = this.svgFactory.createElement("svg:image"); fn.setAttributeNS(Me, "xlink:href", bn), fn.setAttributeNS(null, "x", "0"), fn.setAttributeNS(null, "y", Fe(-on)), fn.setAttributeNS(null, "width", Fe(un) + "px"), fn.setAttributeNS(null, "height", Fe(on) + "px"), fn.setAttributeNS(null, "transform", `scale(${Fe(1 / un)} ${Fe(-1 / on)})`), St ? St.append(fn) : this._ensureTransformGroup().append(fn) } paintImageMaskXObject(Xe) { const St = this.getObject(Xe.data, Xe); if (St.bitmap) { (0, _e.warn)("paintImageMaskXObject: ImageBitmap support is not implemented, ensure that the `isOffscreenCanvasSupported` API parameter is disabled."); return } const un = this.current, on = St.width, bn = St.height, Tn = un.fillColor; un.maskId = `mask${He++}`; const fn = this.svgFactory.createElement("svg:mask"); fn.setAttributeNS(null, "id", un.maskId); const En = this.svgFactory.createElement("svg:rect"); En.setAttributeNS(null, "x", "0"), En.setAttributeNS(null, "y", "0"), En.setAttributeNS(null, "width", Fe(on)), En.setAttributeNS(null, "height", Fe(bn)), En.setAttributeNS(null, "fill", Tn), En.setAttributeNS(null, "mask", `url(#${un.maskId})`), this.defs.append(fn), this._ensureTransformGroup().append(En), this.paintInlineImageXObject(St, fn) } paintFormXObjectBegin(Xe, St) { if (Array.isArray(Xe) && Xe.length === 6 && this.transform(Xe[0], Xe[1], Xe[2], Xe[3], Xe[4], Xe[5]), St) { const un = St[2] - St[0], on = St[3] - St[1], bn = this.svgFactory.createElement("svg:rect"); bn.setAttributeNS(null, "x", St[0]), bn.setAttributeNS(null, "y", St[1]), bn.setAttributeNS(null, "width", Fe(un)), bn.setAttributeNS(null, "height", Fe(on)), this.current.element = bn, this.clip("nonzero"), this.endPath() } } paintFormXObjectEnd() { } _initialize(Xe) { const St = this.svgFactory.create(Xe.width, Xe.height), un = this.svgFactory.createElement("svg:defs"); St.append(un), this.defs = un; const on = this.svgFactory.createElement("svg:g"); return on.setAttributeNS(null, "transform", ze(Xe.transform)), St.append(on), this.svg = on, St } _ensureClipGroup() { if (!this.current.clipGroup) { const Xe = this.svgFactory.createElement("svg:g"); Xe.setAttributeNS(null, "clip-path", this.current.activeClipUrl), this.svg.append(Xe), this.current.clipGroup = Xe } return this.current.clipGroup } _ensureTransformGroup() { return this.tgrp || (this.tgrp = this.svgFactory.createElement("svg:g"), this.tgrp.setAttributeNS(null, "transform", ze(this.transformMatrix)), this.current.activeClipUrl ? this._ensureClipGroup().append(this.tgrp) : this.svg.append(this.tgrp)), this.tgrp }
        } t.SVGGraphics = Ze
      }, (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.XfaText = void 0; class xe { static textContent(_e) { const Re = [], Ce = { items: Re, styles: Object.create(null) }; function Me(De) { if (!De) return; let Pe = null; const Oe = De.name; if (Oe === "#text") Pe = De.value; else if (xe.shouldBuildText(Oe)) De?.attributes?.textContent ? Pe = De.attributes.textContent : De.value && (Pe = De.value); else return; if (Pe !== null && Re.push({ str: Pe }), !!De.children) for (const je of De.children) Me(je) } return Me(_e), Ce } static shouldBuildText(_e) { return !(_e === "textarea" || _e === "input" || _e === "option" || _e === "select") } } t.XfaText = xe }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.TextLayerRenderTask = void 0, t.renderTextLayer = ze, t.updateTextLayer = qe; var Ee = xe(1), _e = xe(6); const Re = 1e5, Ce = 30, Me = .8, De = new Map; function Pe(He, Ge) { let Ze; if (Ge && Ee.FeatureTest.isOffscreenCanvasSupported) Ze = new OffscreenCanvas(He, He).getContext("2d", { alpha: !1 }); else { const sn = document.createElement("canvas"); sn.width = sn.height = He, Ze = sn.getContext("2d", { alpha: !1 }) } return Ze } function Oe(He, Ge) { const Ze = De.get(He); if (Ze) return Ze; const sn = Pe(Ce, Ge); sn.font = `${Ce}px ${He}`; const Xe = sn.measureText(""); let St = Xe.fontBoundingBoxAscent, un = Math.abs(Xe.fontBoundingBoxDescent); if (St) { const bn = St / (St + un); return De.set(He, bn), sn.canvas.width = sn.canvas.height = 0, bn } sn.strokeStyle = "red", sn.clearRect(0, 0, Ce, Ce), sn.strokeText("g", 0, 0); let on = sn.getImageData(0, 0, Ce, Ce).data; un = 0; for (let bn = on.length - 1 - 3; bn >= 0; bn -= 4)if (on[bn] > 0) { un = Math.ceil(bn / 4 / Ce); break } sn.clearRect(0, 0, Ce, Ce), sn.strokeText("A", 0, Ce), on = sn.getImageData(0, 0, Ce, Ce).data, St = 0; for (let bn = 0, Tn = on.length; bn < Tn; bn += 4)if (on[bn] > 0) { St = Ce - Math.floor(bn / 4 / Ce); break } if (sn.canvas.width = sn.canvas.height = 0, St) { const bn = St / (St + un); return De.set(He, bn), bn } return De.set(He, Me), Me } function je(He, Ge, Ze) { const sn = document.createElement("span"), Xe = { angle: 0, canvasWidth: 0, hasText: Ge.str !== "", hasEOL: Ge.hasEOL, fontSize: 0 }; He._textDivs.push(sn); const St = Ee.Util.transform(He._transform, Ge.transform); let un = Math.atan2(St[1], St[0]); const on = Ze[Ge.fontName]; on.vertical && (un += Math.PI / 2); const bn = Math.hypot(St[2], St[3]), Tn = bn * Oe(on.fontFamily, He._isOffscreenCanvasSupported); let fn, En; un === 0 ? (fn = St[4], En = St[5] - Tn) : (fn = St[4] + Tn * Math.sin(un), En = St[5] - Tn * Math.cos(un)); const Pn = "calc(var(--scale-factor)*", Rn = sn.style; He._container === He._rootContainer ? (Rn.left = `${(100 * fn / He._pageWidth).toFixed(2)}%`, Rn.top = `${(100 * En / He._pageHeight).toFixed(2)}%`) : (Rn.left = `${Pn}${fn.toFixed(2)}px)`, Rn.top = `${Pn}${En.toFixed(2)}px)`), Rn.fontSize = `${Pn}${bn.toFixed(2)}px)`, Rn.fontFamily = on.fontFamily, Xe.fontSize = bn, sn.setAttribute("role", "presentation"), sn.textContent = Ge.str, sn.dir = Ge.dir, He._fontInspectorEnabled && (sn.dataset.fontName = Ge.fontName), un !== 0 && (Xe.angle = un * (180 / Math.PI)); let In = !1; if (Ge.str.length > 1) In = !0; else if (Ge.str !== " " && Ge.transform[0] !== Ge.transform[3]) { const xn = Math.abs(Ge.transform[0]), vn = Math.abs(Ge.transform[3]); xn !== vn && Math.max(xn, vn) / Math.min(xn, vn) > 1.5 && (In = !0) } In && (Xe.canvasWidth = on.vertical ? Ge.height : Ge.width), He._textDivProperties.set(sn, Xe), He._isReadableStream && He._layoutText(sn) } function Be(He) { const { div: Ge, scale: Ze, properties: sn, ctx: Xe, prevFontSize: St, prevFontFamily: un } = He, { style: on } = Ge; let bn = ""; if (sn.canvasWidth !== 0 && sn.hasText) { const { fontFamily: Tn } = on, { canvasWidth: fn, fontSize: En } = sn; (St !== En || un !== Tn) && (Xe.font = `${En * Ze}px ${Tn}`, He.prevFontSize = En, He.prevFontFamily = Tn); const { width: Pn } = Xe.measureText(Ge.textContent); Pn > 0 && (bn = `scaleX(${fn * Ze / Pn})`) } sn.angle !== 0 && (bn = `rotate(${sn.angle}deg) ${bn}`), bn.length > 0 && (on.transform = bn) } function Ie(He) { if (He._canceled) return; const Ge = He._textDivs, Ze = He._capability; if (Ge.length > Re) { Ze.resolve(); return } if (!He._isReadableStream) for (const Xe of Ge) He._layoutText(Xe); Ze.resolve() } class Fe { constructor({ textContentSource: Ge, container: Ze, viewport: sn, textDivs: Xe, textDivProperties: St, textContentItemsStr: un, isOffscreenCanvasSupported: on }) { this._textContentSource = Ge, this._isReadableStream = Ge instanceof ReadableStream, this._container = this._rootContainer = Ze, this._textDivs = Xe || [], this._textContentItemsStr = un || [], this._isOffscreenCanvasSupported = on, this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled, this._reader = null, this._textDivProperties = St || new WeakMap, this._canceled = !1, this._capability = new Ee.PromiseCapability, this._layoutTextParams = { prevFontSize: null, prevFontFamily: null, div: null, scale: sn.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: Pe(0, on) }; const { pageWidth: bn, pageHeight: Tn, pageX: fn, pageY: En } = sn.rawDims; this._transform = [1, 0, 0, -1, -fn, En + Tn], this._pageWidth = bn, this._pageHeight = Tn, (0, _e.setLayerDimensions)(Ze, sn), this._capability.promise.finally(() => { this._layoutTextParams = null }).catch(() => { }) } get promise() { return this._capability.promise } cancel() { this._canceled = !0, this._reader && (this._reader.cancel(new Ee.AbortException("TextLayer task cancelled.")).catch(() => { }), this._reader = null), this._capability.reject(new Ee.AbortException("TextLayer task cancelled.")) } _processItems(Ge, Ze) { for (const sn of Ge) { if (sn.str === void 0) { if (sn.type === "beginMarkedContentProps" || sn.type === "beginMarkedContent") { const Xe = this._container; this._container = document.createElement("span"), this._container.classList.add("markedContent"), sn.id !== null && this._container.setAttribute("id", `${sn.id}`), Xe.append(this._container) } else sn.type === "endMarkedContent" && (this._container = this._container.parentNode); continue } this._textContentItemsStr.push(sn.str), je(this, sn, Ze) } } _layoutText(Ge) { const Ze = this._layoutTextParams.properties = this._textDivProperties.get(Ge); if (this._layoutTextParams.div = Ge, Be(this._layoutTextParams), Ze.hasText && this._container.append(Ge), Ze.hasEOL) { const sn = document.createElement("br"); sn.setAttribute("role", "presentation"), this._container.append(sn) } } _render() { const Ge = new Ee.PromiseCapability; let Ze = Object.create(null); if (this._isReadableStream) { const sn = () => { this._reader.read().then(({ value: Xe, done: St }) => { if (St) { Ge.resolve(); return } Object.assign(Ze, Xe.styles), this._processItems(Xe.items, Ze), sn() }, Ge.reject) }; this._reader = this._textContentSource.getReader(), sn() } else if (this._textContentSource) { const { items: sn, styles: Xe } = this._textContentSource; this._processItems(sn, Xe), Ge.resolve() } else throw new Error('No "textContentSource" parameter specified.'); Ge.promise.then(() => { Ze = null, Ie(this) }, this._capability.reject) } } t.TextLayerRenderTask = Fe; function ze(He) { !He.textContentSource && (He.textContent || He.textContentStream) && ((0, _e.deprecated)("The TextLayerRender `textContent`/`textContentStream` parameters will be removed in the future, please use `textContentSource` instead."), He.textContentSource = He.textContent || He.textContentStream); const { container: Ge, viewport: Ze } = He, sn = getComputedStyle(Ge), Xe = sn.getPropertyValue("visibility"), St = parseFloat(sn.getPropertyValue("--scale-factor")); Xe === "visible" && (!St || Math.abs(St - Ze.scale) > 1e-5) && console.error("The `--scale-factor` CSS-variable must be set, to the same value as `viewport.scale`, either on the `container`-element itself or higher up in the DOM."); const un = new Fe(He); return un._render(), un } function qe({ container: He, viewport: Ge, textDivs: Ze, textDivProperties: sn, isOffscreenCanvasSupported: Xe, mustRotate: St = !0, mustRescale: un = !0 }) { if (St && (0, _e.setLayerDimensions)(He, { rotation: Ge.rotation }), un) { const on = Pe(0, Xe), Tn = { prevFontSize: null, prevFontFamily: null, div: null, scale: Ge.scale * (globalThis.devicePixelRatio || 1), properties: null, ctx: on }; for (const fn of Ze) Tn.properties = sn.get(fn), Tn.div = fn, Be(Tn) } } }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.AnnotationEditorLayer = void 0; var Ee = xe(1), _e = xe(4), Re = xe(28), Ce = xe(33), Me = xe(6), De = xe(34); class Pe { #e; #t = !1; #n = null; #r = this.pointerup.bind(this); #a = this.pointerdown.bind(this); #o = new Map; #s = !1; #l = !1; #c = !1; #i; static _initialized = !1; constructor({ uiManager: je, pageIndex: Be, div: Ie, accessibilityManager: Fe, annotationLayer: ze, viewport: qe, l10n: He }) { const Ge = [Re.FreeTextEditor, Ce.InkEditor, De.StampEditor]; if (!Pe._initialized) { Pe._initialized = !0; for (const Ze of Ge) Ze.initialize(He) } je.registerEditorTypes(Ge), this.#i = je, this.pageIndex = Be, this.div = Ie, this.#e = Fe, this.#n = ze, this.viewport = qe, this.#i.addLayer(this) } get isEmpty() { return this.#o.size === 0 } updateToolbar(je) { this.#i.updateToolbar(je) } updateMode(je = this.#i.getMode()) { this.#f(), je === Ee.AnnotationEditorType.INK ? (this.addInkEditorIfNeeded(!1), this.disableClick()) : this.enableClick(), je !== Ee.AnnotationEditorType.NONE && (this.div.classList.toggle("freeTextEditing", je === Ee.AnnotationEditorType.FREETEXT), this.div.classList.toggle("inkEditing", je === Ee.AnnotationEditorType.INK), this.div.classList.toggle("stampEditing", je === Ee.AnnotationEditorType.STAMP), this.div.hidden = !1) } addInkEditorIfNeeded(je) { if (!je && this.#i.getMode() !== Ee.AnnotationEditorType.INK) return; if (!je) { for (const Ie of this.#o.values()) if (Ie.isEmpty()) { Ie.setInBackground(); return } } this.#u({ offsetX: 0, offsetY: 0 }, !1).setInBackground() } setEditingState(je) { this.#i.setEditingState(je) } addCommands(je) { this.#i.addCommands(je) } enable() { this.div.style.pointerEvents = "auto"; const je = new Set; for (const Ie of this.#o.values()) Ie.enableEditing(), Ie.annotationElementId && je.add(Ie.annotationElementId); if (!this.#n) return; const Be = this.#n.getEditableAnnotations(); for (const Ie of Be) { if (Ie.hide(), this.#i.isDeletedAnnotationElement(Ie.data.id) || je.has(Ie.data.id)) continue; const Fe = this.deserialize(Ie); Fe && (this.addOrRebuild(Fe), Fe.enableEditing()) } } disable() { this.#c = !0, this.div.style.pointerEvents = "none"; const je = new Set; for (const Be of this.#o.values()) { if (Be.disableEditing(), !Be.annotationElementId || Be.serialize() !== null) { je.add(Be.annotationElementId); continue } this.getEditableAnnotation(Be.annotationElementId)?.show(), Be.remove() } if (this.#n) { const Be = this.#n.getEditableAnnotations(); for (const Ie of Be) { const { id: Fe } = Ie.data; je.has(Fe) || this.#i.isDeletedAnnotationElement(Fe) || Ie.show() } } this.#f(), this.isEmpty && (this.div.hidden = !0), this.#c = !1 } getEditableAnnotation(je) { return this.#n?.getEditableAnnotation(je) || null } setActiveEditor(je) { this.#i.getActive() !== je && this.#i.setActiveEditor(je) } enableClick() { this.div.addEventListener("pointerdown", this.#a), this.div.addEventListener("pointerup", this.#r) } disableClick() { this.div.removeEventListener("pointerdown", this.#a), this.div.removeEventListener("pointerup", this.#r) } attach(je) { this.#o.set(je.id, je); const { annotationElementId: Be } = je; Be && this.#i.isDeletedAnnotationElement(Be) && this.#i.removeDeletedAnnotationElement(je) } detach(je) { this.#o.delete(je.id), this.#e?.removePointerInTextLayer(je.contentDiv), !this.#c && je.annotationElementId && this.#i.addDeletedAnnotationElement(je) } remove(je) { this.detach(je), this.#i.removeEditor(je), je.div.contains(document.activeElement) && setTimeout(() => { this.#i.focusMainContainer() }, 0), je.div.remove(), je.isAttachedToDOM = !1, this.#l || this.addInkEditorIfNeeded(!1) } changeParent(je) { je.parent !== this && (je.annotationElementId && (this.#i.addDeletedAnnotationElement(je.annotationElementId), _e.AnnotationEditor.deleteAnnotationElement(je), je.annotationElementId = null), this.attach(je), je.parent?.detach(je), je.setParent(this), je.div && je.isAttachedToDOM && (je.div.remove(), this.div.append(je.div))) } add(je) { if (this.changeParent(je), this.#i.addEditor(je), this.attach(je), !je.isAttachedToDOM) { const Be = je.render(); this.div.append(Be), je.isAttachedToDOM = !0 } je.fixAndSetPosition(), je.onceAdded(), this.#i.addToAnnotationStorage(je) } moveEditorInDOM(je) { if (!je.isAttachedToDOM) return; const { activeElement: Be } = document; je.div.contains(Be) && (je._focusEventsAllowed = !1, setTimeout(() => { je.div.contains(document.activeElement) ? je._focusEventsAllowed = !0 : (je.div.addEventListener("focusin", () => { je._focusEventsAllowed = !0 }, { once: !0 }), Be.focus()) }, 0)), je._structTreeParentId = this.#e?.moveElementInDOM(this.div, je.div, je.contentDiv, !0) } addOrRebuild(je) { je.needsToBeRebuilt() ? je.rebuild() : this.add(je) } addUndoableEditor(je) { const Be = () => je._uiManager.rebuild(je), Ie = () => { je.remove() }; this.addCommands({ cmd: Be, undo: Ie, mustExec: !1 }) } getNextId() { return this.#i.getId() } #p(je) { switch (this.#i.getMode()) { case Ee.AnnotationEditorType.FREETEXT: return new Re.FreeTextEditor(je); case Ee.AnnotationEditorType.INK: return new Ce.InkEditor(je); case Ee.AnnotationEditorType.STAMP: return new De.StampEditor(je) }return null } pasteEditor(je, Be) { this.#i.updateToolbar(je), this.#i.updateMode(je); const { offsetX: Ie, offsetY: Fe } = this.#h(), ze = this.getNextId(), qe = this.#p({ parent: this, id: ze, x: Ie, y: Fe, uiManager: this.#i, isCentered: !0, ...Be }); qe && this.add(qe) } deserialize(je) { switch (je.annotationType ?? je.annotationEditorType) { case Ee.AnnotationEditorType.FREETEXT: return Re.FreeTextEditor.deserialize(je, this, this.#i); case Ee.AnnotationEditorType.INK: return Ce.InkEditor.deserialize(je, this, this.#i); case Ee.AnnotationEditorType.STAMP: return De.StampEditor.deserialize(je, this, this.#i) }return null } #u(je, Be) { const Ie = this.getNextId(), Fe = this.#p({ parent: this, id: Ie, x: je.offsetX, y: je.offsetY, uiManager: this.#i, isCentered: Be }); return Fe && this.add(Fe), Fe } #h() { const { x: je, y: Be, width: Ie, height: Fe } = this.div.getBoundingClientRect(), ze = Math.max(0, je), qe = Math.max(0, Be), He = Math.min(window.innerWidth, je + Ie), Ge = Math.min(window.innerHeight, Be + Fe), Ze = (ze + He) / 2 - je, sn = (qe + Ge) / 2 - Be, [Xe, St] = this.viewport.rotation % 180 === 0 ? [Ze, sn] : [sn, Ze]; return { offsetX: Xe, offsetY: St } } addNewEditor() { this.#u(this.#h(), !0) } setSelected(je) { this.#i.setSelected(je) } toggleSelected(je) { this.#i.toggleSelected(je) } isSelected(je) { return this.#i.isSelected(je) } unselect(je) { this.#i.unselect(je) } pointerup(je) { const { isMac: Be } = Ee.FeatureTest.platform; if (!(je.button !== 0 || je.ctrlKey && Be) && je.target === this.div && this.#s) { if (this.#s = !1, !this.#t) { this.#t = !0; return } if (this.#i.getMode() === Ee.AnnotationEditorType.STAMP) { this.#i.unselectAll(); return } this.#u(je, !1) } } pointerdown(je) { if (this.#s) { this.#s = !1; return } const { isMac: Be } = Ee.FeatureTest.platform; if (je.button !== 0 || je.ctrlKey && Be || je.target !== this.div) return; this.#s = !0; const Ie = this.#i.getActive(); this.#t = !Ie || Ie.isEmpty() } findNewParent(je, Be, Ie) { const Fe = this.#i.findParent(Be, Ie); return Fe === null || Fe === this ? !1 : (Fe.changeParent(je), !0) } destroy() { this.#i.getActive()?.parent === this && (this.#i.commitOrRemove(), this.#i.setActiveEditor(null)); for (const je of this.#o.values()) this.#e?.removePointerInTextLayer(je.contentDiv), je.setParent(null), je.isAttachedToDOM = !1, je.div.remove(); this.div = null, this.#o.clear(), this.#i.removeLayer(this) } #f() { this.#l = !0; for (const je of this.#o.values()) je.isEmpty() && je.remove(); this.#l = !1 } render({ viewport: je }) { this.viewport = je, (0, Me.setLayerDimensions)(this.div, je); for (const Be of this.#i.getEditors(this.pageIndex)) this.add(Be); this.updateMode() } update({ viewport: je }) { this.#i.commitOrRemove(), this.viewport = je, (0, Me.setLayerDimensions)(this.div, { rotation: je.rotation }), this.updateMode() } get pageDimensions() { const { pageWidth: je, pageHeight: Be } = this.viewport.rawDims; return [je, Be] } } t.AnnotationEditorLayer = Pe }, (e, t, xe) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.FreeTextEditor = void 0; var Ee = xe(1), _e = xe(5), Re = xe(4), Ce = xe(29); class Me extends Re.AnnotationEditor {
          #e = this.editorDivBlur.bind(this); #t = this.editorDivFocus.bind(this); #n = this.editorDivInput.bind(this); #r = this.editorDivKeydown.bind(this); #a; #o = ""; #s = `${this.id}-editor`; #l; #c = null; static _freeTextDefaultContent = ""; static _internalPadding = 0; static _defaultColor = null; static _defaultFontSize = 10; static get _keyboardManager() { const Pe = Me.prototype, Oe = Ie => Ie.isEmpty(), je = _e.AnnotationEditorUIManager.TRANSLATE_SMALL, Be = _e.AnnotationEditorUIManager.TRANSLATE_BIG; return (0, Ee.shadow)(this, "_keyboardManager", new _e.KeyboardManager([[["ctrl+s", "mac+meta+s", "ctrl+p", "mac+meta+p"], Pe.commitOrRemove, { bubbles: !0 }], [["ctrl+Enter", "mac+meta+Enter", "Escape", "mac+Escape"], Pe.commitOrRemove], [["ArrowLeft", "mac+ArrowLeft"], Pe._translateEmpty, { args: [-je, 0], checker: Oe }], [["ctrl+ArrowLeft", "mac+shift+ArrowLeft"], Pe._translateEmpty, { args: [-Be, 0], checker: Oe }], [["ArrowRight", "mac+ArrowRight"], Pe._translateEmpty, { args: [je, 0], checker: Oe }], [["ctrl+ArrowRight", "mac+shift+ArrowRight"], Pe._translateEmpty, { args: [Be, 0], checker: Oe }], [["ArrowUp", "mac+ArrowUp"], Pe._translateEmpty, { args: [0, -je], checker: Oe }], [["ctrl+ArrowUp", "mac+shift+ArrowUp"], Pe._translateEmpty, { args: [0, -Be], checker: Oe }], [["ArrowDown", "mac+ArrowDown"], Pe._translateEmpty, { args: [0, je], checker: Oe }], [["ctrl+ArrowDown", "mac+shift+ArrowDown"], Pe._translateEmpty, { args: [0, Be], checker: Oe }]])) } static _type = "freetext"; constructor(Pe) { super({ ...Pe, name: "freeTextEditor" }), this.#a = Pe.color || Me._defaultColor || Re.AnnotationEditor._defaultLineColor, this.#l = Pe.fontSize || Me._defaultFontSize } static initialize(Pe) { Re.AnnotationEditor.initialize(Pe, { strings: ["free_text2_default_content", "editor_free_text2_aria_label"] }); const Oe = getComputedStyle(document.documentElement); this._internalPadding = parseFloat(Oe.getPropertyValue("--freetext-padding")) } static updateDefaultParams(Pe, Oe) { switch (Pe) { case Ee.AnnotationEditorParamsType.FREETEXT_SIZE: Me._defaultFontSize = Oe; break; case Ee.AnnotationEditorParamsType.FREETEXT_COLOR: Me._defaultColor = Oe; break } } updateParams(Pe, Oe) { switch (Pe) { case Ee.AnnotationEditorParamsType.FREETEXT_SIZE: this.#i(Oe); break; case Ee.AnnotationEditorParamsType.FREETEXT_COLOR: this.#p(Oe); break } } static get defaultPropertiesToUpdate() { return [[Ee.AnnotationEditorParamsType.FREETEXT_SIZE, Me._defaultFontSize], [Ee.AnnotationEditorParamsType.FREETEXT_COLOR, Me._defaultColor || Re.AnnotationEditor._defaultLineColor]] } get propertiesToUpdate() { return [[Ee.AnnotationEditorParamsType.FREETEXT_SIZE, this.#l], [Ee.AnnotationEditorParamsType.FREETEXT_COLOR, this.#a]] } #i(Pe) { const Oe = Be => { this.editorDiv.style.fontSize = `calc(${Be}px * var(--scale-factor))`, this.translate(0, -(Be - this.#l) * this.parentScale), this.#l = Be, this.#h() }, je = this.#l; this.addCommands({ cmd: () => { Oe(Pe) }, undo: () => { Oe(je) }, mustExec: !0, type: Ee.AnnotationEditorParamsType.FREETEXT_SIZE, overwriteIfSameType: !0, keepUndo: !0 }) } #p(Pe) { const Oe = this.#a; this.addCommands({ cmd: () => { this.#a = this.editorDiv.style.color = Pe }, undo: () => { this.#a = this.editorDiv.style.color = Oe }, mustExec: !0, type: Ee.AnnotationEditorParamsType.FREETEXT_COLOR, overwriteIfSameType: !0, keepUndo: !0 }) } _translateEmpty(Pe, Oe) { this._uiManager.translateSelectedEditors(Pe, Oe, !0) } getInitialTranslation() { const Pe = this.parentScale; return [-Me._internalPadding * Pe, -(Me._internalPadding + this.#l) * Pe] } rebuild() { this.parent && (super.rebuild(), this.div !== null && (this.isAttachedToDOM || this.parent.add(this))) } enableEditMode() { this.isInEditMode() || (this.parent.setEditingState(!1), this.parent.updateToolbar(Ee.AnnotationEditorType.FREETEXT), super.enableEditMode(), this.overlayDiv.classList.remove("enabled"), this.editorDiv.contentEditable = !0, this._isDraggable = !1, this.div.removeAttribute("aria-activedescendant"), this.editorDiv.addEventListener("keydown", this.#r), this.editorDiv.addEventListener("focus", this.#t), this.editorDiv.addEventListener("blur", this.#e), this.editorDiv.addEventListener("input", this.#n)) } disableEditMode() { this.isInEditMode() && (this.parent.setEditingState(!0), super.disableEditMode(), this.overlayDiv.classList.add("enabled"), this.editorDiv.contentEditable = !1, this.div.setAttribute("aria-activedescendant", this.#s), this._isDraggable = !0, this.editorDiv.removeEventListener("keydown", this.#r), this.editorDiv.removeEventListener("focus", this.#t), this.editorDiv.removeEventListener("blur", this.#e), this.editorDiv.removeEventListener("input", this.#n), this.div.focus({ preventScroll: !0 }), this.isEditing = !1, this.parent.div.classList.add("freeTextEditing")) } focusin(Pe) { this._focusEventsAllowed && (super.focusin(Pe), Pe.target !== this.editorDiv && this.editorDiv.focus()) } onceAdded() { if (this.width) { this.#m(); return } this.enableEditMode(), this.editorDiv.focus(), this._initialOptions?.isCentered && this.center(), this._initialOptions = null } isEmpty() { return !this.editorDiv || this.editorDiv.innerText.trim() === "" } remove() { this.isEditing = !1, this.parent && (this.parent.setEditingState(!0), this.parent.div.classList.add("freeTextEditing")), super.remove() } #u() {
            const Pe = this.editorDiv.getElementsByTagName("div"); if (Pe.length === 0) return this.editorDiv.innerText; const Oe = []; for (const je of Pe) Oe.push(je.innerText.replace(/\r\n?|\n/, "")); return Oe.join(`
`)
          } #h() { const [Pe, Oe] = this.parentDimensions; let je; if (this.isAttachedToDOM) je = this.div.getBoundingClientRect(); else { const { currentLayer: Be, div: Ie } = this, Fe = Ie.style.display; Ie.style.display = "hidden", Be.div.append(this.div), je = Ie.getBoundingClientRect(), Ie.remove(), Ie.style.display = Fe } this.rotation % 180 === this.parentRotation % 180 ? (this.width = je.width / Pe, this.height = je.height / Oe) : (this.width = je.height / Pe, this.height = je.width / Oe), this.fixAndSetPosition() } commit() { if (!this.isInEditMode()) return; super.commit(), this.disableEditMode(); const Pe = this.#o, Oe = this.#o = this.#u().trimEnd(); if (Pe === Oe) return; const je = Be => { if (this.#o = Be, !Be) { this.remove(); return } this.#f(), this._uiManager.rebuild(this), this.#h() }; this.addCommands({ cmd: () => { je(Oe) }, undo: () => { je(Pe) }, mustExec: !1 }), this.#h() } shouldGetKeyboardEvents() { return this.isInEditMode() } enterInEditMode() { this.enableEditMode(), this.editorDiv.focus() } dblclick(Pe) { this.enterInEditMode() } keydown(Pe) { Pe.target === this.div && Pe.key === "Enter" && (this.enterInEditMode(), Pe.preventDefault()) } editorDivKeydown(Pe) { Me._keyboardManager.exec(this, Pe) } editorDivFocus(Pe) { this.isEditing = !0 } editorDivBlur(Pe) { this.isEditing = !1 } editorDivInput(Pe) { this.parent.div.classList.toggle("freeTextEditing", this.isEmpty()) } disableEditing() { this.editorDiv.setAttribute("role", "comment"), this.editorDiv.removeAttribute("aria-multiline") } enableEditing() { this.editorDiv.setAttribute("role", "textbox"), this.editorDiv.setAttribute("aria-multiline", !0) } render() { if (this.div) return this.div; let Pe, Oe; this.width && (Pe = this.x, Oe = this.y), super.render(), this.editorDiv = document.createElement("div"), this.editorDiv.className = "internal", this.editorDiv.setAttribute("id", this.#s), this.enableEditing(), Re.AnnotationEditor._l10nPromise.get("editor_free_text2_aria_label").then(Be => this.editorDiv?.setAttribute("aria-label", Be)), Re.AnnotationEditor._l10nPromise.get("free_text2_default_content").then(Be => this.editorDiv?.setAttribute("default-content", Be)), this.editorDiv.contentEditable = !0; const { style: je } = this.editorDiv; if (je.fontSize = `calc(${this.#l}px * var(--scale-factor))`, je.color = this.#a, this.div.append(this.editorDiv), this.overlayDiv = document.createElement("div"), this.overlayDiv.classList.add("overlay", "enabled"), this.div.append(this.overlayDiv), (0, _e.bindEvents)(this, this.div, ["dblclick", "keydown"]), this.width) { const [Be, Ie] = this.parentDimensions; if (this.annotationElementId) { const { position: Fe } = this.#c; let [ze, qe] = this.getInitialTranslation();[ze, qe] = this.pageTranslationToScreen(ze, qe); const [He, Ge] = this.pageDimensions, [Ze, sn] = this.pageTranslation; let Xe, St; switch (this.rotation) { case 0: Xe = Pe + (Fe[0] - Ze) / He, St = Oe + this.height - (Fe[1] - sn) / Ge; break; case 90: Xe = Pe + (Fe[0] - Ze) / He, St = Oe - (Fe[1] - sn) / Ge, [ze, qe] = [qe, -ze]; break; case 180: Xe = Pe - this.width + (Fe[0] - Ze) / He, St = Oe - (Fe[1] - sn) / Ge, [ze, qe] = [-ze, -qe]; break; case 270: Xe = Pe + (Fe[0] - Ze - this.height * Ge) / He, St = Oe + (Fe[1] - sn - this.width * He) / Ge, [ze, qe] = [-qe, ze]; break }this.setAt(Xe * Be, St * Ie, ze, qe) } else this.setAt(Pe * Be, Oe * Ie, this.width * Be, this.height * Ie); this.#f(), this._isDraggable = !0, this.editorDiv.contentEditable = !1 } else this._isDraggable = !1, this.editorDiv.contentEditable = !0; return this.div } #f() {
            if (this.editorDiv.replaceChildren(), !!this.#o) for (const Pe of this.#o.split(`
`)) { const Oe = document.createElement("div"); Oe.append(Pe ? document.createTextNode(Pe) : document.createElement("br")), this.editorDiv.append(Oe) }
          } get contentDiv() { return this.editorDiv } static deserialize(Pe, Oe, je) {
            let Be = null; if (Pe instanceof Ce.FreeTextAnnotationElement) {
              const { data: { defaultAppearanceData: { fontSize: Fe, fontColor: ze }, rect: qe, rotation: He, id: Ge }, textContent: Ze, textPosition: sn, parent: { page: { pageNumber: Xe } } } = Pe; if (!Ze || Ze.length === 0) return null; Be = Pe = {
                annotationType: Ee.AnnotationEditorType.FREETEXT, color: Array.from(ze), fontSize: Fe, value: Ze.join(`
`), position: sn, pageIndex: Xe - 1, rect: qe, rotation: He, id: Ge, deleted: !1
              }
            } const Ie = super.deserialize(Pe, Oe, je); return Ie.#l = Pe.fontSize, Ie.#a = Ee.Util.makeHexColor(...Pe.color), Ie.#o = Pe.value, Ie.annotationElementId = Pe.id || null, Ie.#c = Be, Ie
          } serialize(Pe = !1) { if (this.isEmpty()) return null; if (this.deleted) return { pageIndex: this.pageIndex, id: this.annotationElementId, deleted: !0 }; const Oe = Me._internalPadding * this.parentScale, je = this.getRect(Oe, Oe), Be = Re.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#a), Ie = { annotationType: Ee.AnnotationEditorType.FREETEXT, color: Be, fontSize: this.#l, value: this.#o, pageIndex: this.pageIndex, rect: je, rotation: this.rotation, structTreeParentId: this._structTreeParentId }; return Pe ? Ie : this.annotationElementId && !this.#v(Ie) ? null : (Ie.id = this.annotationElementId, Ie) } #v(Pe) { const { value: Oe, fontSize: je, color: Be, rect: Ie, pageIndex: Fe } = this.#c; return Pe.value !== Oe || Pe.fontSize !== je || Pe.rect.some((ze, qe) => Math.abs(ze - Ie[qe]) >= 1) || Pe.color.some((ze, qe) => ze !== Be[qe]) || Pe.pageIndex !== Fe } #m(Pe = !1) { if (!this.annotationElementId) return; if (this.#h(), !Pe && (this.width === 0 || this.height === 0)) { setTimeout(() => this.#m(!0), 0); return } const Oe = Me._internalPadding * this.parentScale; this.#c.rect = this.getRect(Oe, Oe) }
        } t.FreeTextEditor = Me
      }, (e, t, xe) => {
        Object.defineProperty(t, "__esModule", { value: !0 }), t.StampAnnotationElement = t.InkAnnotationElement = t.FreeTextAnnotationElement = t.AnnotationLayer = void 0; var Ee = xe(1), _e = xe(6), Re = xe(3), Ce = xe(30), Me = xe(31), De = xe(32); const Pe = 1e3, Oe = 9, je = new WeakSet; function Be(mn) { return { width: mn[2] - mn[0], height: mn[3] - mn[1] } } class Ie { static create(Ye) { switch (Ye.data.annotationType) { case Ee.AnnotationType.LINK: return new ze(Ye); case Ee.AnnotationType.TEXT: return new qe(Ye); case Ee.AnnotationType.WIDGET: switch (Ye.data.fieldType) { case "Tx": return new Ge(Ye); case "Btn": return Ye.data.radioButton ? new Xe(Ye) : Ye.data.checkBox ? new sn(Ye) : new St(Ye); case "Ch": return new un(Ye); case "Sig": return new Ze(Ye) }return new He(Ye); case Ee.AnnotationType.POPUP: return new on(Ye); case Ee.AnnotationType.FREETEXT: return new Tn(Ye); case Ee.AnnotationType.LINE: return new fn(Ye); case Ee.AnnotationType.SQUARE: return new En(Ye); case Ee.AnnotationType.CIRCLE: return new Pn(Ye); case Ee.AnnotationType.POLYLINE: return new Rn(Ye); case Ee.AnnotationType.CARET: return new xn(Ye); case Ee.AnnotationType.INK: return new vn(Ye); case Ee.AnnotationType.POLYGON: return new In(Ye); case Ee.AnnotationType.HIGHLIGHT: return new tn(Ye); case Ee.AnnotationType.UNDERLINE: return new nn(Ye); case Ee.AnnotationType.SQUIGGLY: return new We(Ye); case Ee.AnnotationType.STRIKEOUT: return new dn(Ye); case Ee.AnnotationType.STAMP: return new Je(Ye); case Ee.AnnotationType.FILEATTACHMENT: return new rn(Ye); default: return new Fe(Ye) } } } class Fe { #e = !1; constructor(Ye, { isRenderable: an = !1, ignoreBorder: pn = !1, createQuadrilaterals: yn = !1 } = {}) { this.isRenderable = an, this.data = Ye.data, this.layer = Ye.layer, this.linkService = Ye.linkService, this.downloadManager = Ye.downloadManager, this.imageResourcesPath = Ye.imageResourcesPath, this.renderForms = Ye.renderForms, this.svgFactory = Ye.svgFactory, this.annotationStorage = Ye.annotationStorage, this.enableScripting = Ye.enableScripting, this.hasJSActions = Ye.hasJSActions, this._fieldObjects = Ye.fieldObjects, this.parent = Ye.parent, an && (this.container = this._createContainer(pn)), yn && this._createQuadrilaterals() } static _hasPopupData({ titleObj: Ye, contentsObj: an, richText: pn }) { return !!(Ye?.str || an?.str || pn?.str) } get hasPopupData() { return Fe._hasPopupData(this.data) } _createContainer(Ye) { const { data: an, parent: { page: pn, viewport: yn } } = this, _n = document.createElement("section"); _n.setAttribute("data-annotation-id", an.id), this instanceof He || (_n.tabIndex = Pe), _n.style.zIndex = this.parent.zIndex++, this.data.popupRef && _n.setAttribute("aria-haspopup", "dialog"), an.noRotate && _n.classList.add("norotate"); const { pageWidth: On, pageHeight: kn, pageX: zn, pageY: sr } = yn.rawDims; if (!an.rect || this instanceof on) { const { rotation: qn } = an; return !an.hasOwnCanvas && qn !== 0 && this.setRotation(qn, _n), _n } const { width: Fn, height: Cn } = Be(an.rect), Vn = Ee.Util.normalizeRect([an.rect[0], pn.view[3] - an.rect[1] + pn.view[1], an.rect[2], pn.view[3] - an.rect[3] + pn.view[1]]); if (!Ye && an.borderStyle.width > 0) { _n.style.borderWidth = `${an.borderStyle.width}px`; const qn = an.borderStyle.horizontalCornerRadius, rr = an.borderStyle.verticalCornerRadius; if (qn > 0 || rr > 0) { const ur = `calc(${qn}px * var(--scale-factor)) / calc(${rr}px * var(--scale-factor))`; _n.style.borderRadius = ur } else if (this instanceof Xe) { const ur = `calc(${Fn}px * var(--scale-factor)) / calc(${Cn}px * var(--scale-factor))`; _n.style.borderRadius = ur } switch (an.borderStyle.style) { case Ee.AnnotationBorderStyleType.SOLID: _n.style.borderStyle = "solid"; break; case Ee.AnnotationBorderStyleType.DASHED: _n.style.borderStyle = "dashed"; break; case Ee.AnnotationBorderStyleType.BEVELED: (0, Ee.warn)("Unimplemented border style: beveled"); break; case Ee.AnnotationBorderStyleType.INSET: (0, Ee.warn)("Unimplemented border style: inset"); break; case Ee.AnnotationBorderStyleType.UNDERLINE: _n.style.borderBottomStyle = "solid"; break }const hr = an.borderColor || null; hr ? (this.#e = !0, _n.style.borderColor = Ee.Util.makeHexColor(hr[0] | 0, hr[1] | 0, hr[2] | 0)) : _n.style.borderWidth = 0 } _n.style.left = `${100 * (Vn[0] - zn) / On}%`, _n.style.top = `${100 * (Vn[1] - sr) / kn}%`; const { rotation: Yn } = an; return an.hasOwnCanvas || Yn === 0 ? (_n.style.width = `${100 * Fn / On}%`, _n.style.height = `${100 * Cn / kn}%`) : this.setRotation(Yn, _n), _n } setRotation(Ye, an = this.container) { if (!this.data.rect) return; const { pageWidth: pn, pageHeight: yn } = this.parent.viewport.rawDims, { width: _n, height: On } = Be(this.data.rect); let kn, zn; Ye % 180 === 0 ? (kn = 100 * _n / pn, zn = 100 * On / yn) : (kn = 100 * On / pn, zn = 100 * _n / yn), an.style.width = `${kn}%`, an.style.height = `${zn}%`, an.setAttribute("data-main-rotation", (360 - Ye) % 360) } get _commonActions() { const Ye = (an, pn, yn) => { const _n = yn.detail[an], On = _n[0], kn = _n.slice(1); yn.target.style[pn] = Ce.ColorConverters[`${On}_HTML`](kn), this.annotationStorage.setValue(this.data.id, { [pn]: Ce.ColorConverters[`${On}_rgb`](kn) }) }; return (0, Ee.shadow)(this, "_commonActions", { display: an => { const { display: pn } = an.detail, yn = pn % 2 === 1; this.container.style.visibility = yn ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noView: yn, noPrint: pn === 1 || pn === 2 }) }, print: an => { this.annotationStorage.setValue(this.data.id, { noPrint: !an.detail.print }) }, hidden: an => { const { hidden: pn } = an.detail; this.container.style.visibility = pn ? "hidden" : "visible", this.annotationStorage.setValue(this.data.id, { noPrint: pn, noView: pn }) }, focus: an => { setTimeout(() => an.target.focus({ preventScroll: !1 }), 0) }, userName: an => { an.target.title = an.detail.userName }, readonly: an => { an.target.disabled = an.detail.readonly }, required: an => { this._setRequired(an.target, an.detail.required) }, bgColor: an => { Ye("bgColor", "backgroundColor", an) }, fillColor: an => { Ye("fillColor", "backgroundColor", an) }, fgColor: an => { Ye("fgColor", "color", an) }, textColor: an => { Ye("textColor", "color", an) }, borderColor: an => { Ye("borderColor", "borderColor", an) }, strokeColor: an => { Ye("strokeColor", "borderColor", an) }, rotation: an => { const pn = an.detail.rotation; this.setRotation(pn), this.annotationStorage.setValue(this.data.id, { rotation: pn }) } }) } _dispatchEventFromSandbox(Ye, an) { const pn = this._commonActions; for (const yn of Object.keys(an.detail)) (Ye[yn] || pn[yn])?.(an) } _setDefaultPropertiesFromJS(Ye) { if (!this.enableScripting) return; const an = this.annotationStorage.getRawValue(this.data.id); if (!an) return; const pn = this._commonActions; for (const [yn, _n] of Object.entries(an)) { const On = pn[yn]; if (On) { const kn = { detail: { [yn]: _n }, target: Ye }; On(kn), delete an[yn] } } } _createQuadrilaterals() { if (!this.container) return; const { quadPoints: Ye } = this.data; if (!Ye) return; const [an, pn, yn, _n] = this.data.rect; if (Ye.length === 1) { const [, { x: rr, y: hr }, { x: ur, y: Er }] = Ye[0]; if (yn === rr && _n === hr && an === ur && pn === Er) return } const { style: On } = this.container; let kn; if (this.#e) { const { borderColor: rr, borderWidth: hr } = On; On.borderWidth = 0, kn = ["url('data:image/svg+xml;utf8,", '<svg xmlns="http://www.w3.org/2000/svg"', ' preserveAspectRatio="none" viewBox="0 0 1 1">', `<g fill="transparent" stroke="${rr}" stroke-width="${hr}">`], this.container.classList.add("hasBorder") } const zn = yn - an, sr = _n - pn, { svgFactory: Fn } = this, Cn = Fn.createElement("svg"); Cn.classList.add("quadrilateralsContainer"), Cn.setAttribute("width", 0), Cn.setAttribute("height", 0); const Vn = Fn.createElement("defs"); Cn.append(Vn); const Yn = Fn.createElement("clipPath"), qn = `clippath_${this.data.id}`; Yn.setAttribute("id", qn), Yn.setAttribute("clipPathUnits", "objectBoundingBox"), Vn.append(Yn); for (const [, { x: rr, y: hr }, { x: ur, y: Er }] of Ye) { const _r = Fn.createElement("rect"), Or = (ur - an) / zn, Ir = (_n - hr) / sr, Dr = (rr - ur) / zn, Wr = (hr - Er) / sr; _r.setAttribute("x", Or), _r.setAttribute("y", Ir), _r.setAttribute("width", Dr), _r.setAttribute("height", Wr), Yn.append(_r), kn?.push(`<rect vector-effect="non-scaling-stroke" x="${Or}" y="${Ir}" width="${Dr}" height="${Wr}"/>`) } this.#e && (kn.push("</g></svg>')"), On.backgroundImage = kn.join("")), this.container.append(Cn), this.container.style.clipPath = `url(#${qn})` } _createPopup() { const { container: Ye, data: an } = this; Ye.setAttribute("aria-haspopup", "dialog"); const pn = new on({ data: { color: an.color, titleObj: an.titleObj, modificationDate: an.modificationDate, contentsObj: an.contentsObj, richText: an.richText, parentRect: an.rect, borderStyle: 0, id: `popup_${an.id}`, rotation: an.rotation }, parent: this.parent, elements: [this] }); this.parent.div.append(pn.render()) } render() { (0, Ee.unreachable)("Abstract method `AnnotationElement.render` called") } _getElementsByName(Ye, an = null) { const pn = []; if (this._fieldObjects) { const yn = this._fieldObjects[Ye]; if (yn) for (const { page: _n, id: On, exportValues: kn } of yn) { if (_n === -1 || On === an) continue; const zn = typeof kn == "string" ? kn : null, sr = document.querySelector(`[data-element-id="${On}"]`); if (sr && !je.has(sr)) { (0, Ee.warn)(`_getElementsByName - element not allowed: ${On}`); continue } pn.push({ id: On, exportValue: zn, domElement: sr }) } return pn } for (const yn of document.getElementsByName(Ye)) { const { exportValue: _n } = yn, On = yn.getAttribute("data-element-id"); On !== an && je.has(yn) && pn.push({ id: On, exportValue: _n, domElement: yn }) } return pn } show() { this.container && (this.container.hidden = !1), this.popup?.maybeShow() } hide() { this.container && (this.container.hidden = !0), this.popup?.forceHide() } getElementsToTriggerPopup() { return this.container } addHighlightArea() { const Ye = this.getElementsToTriggerPopup(); if (Array.isArray(Ye)) for (const an of Ye) an.classList.add("highlightArea"); else Ye.classList.add("highlightArea") } _editOnDoubleClick() { const { annotationEditorType: Ye, data: { id: an } } = this; this.container.addEventListener("dblclick", () => { this.linkService.eventBus?.dispatch("switchannotationeditormode", { source: this, mode: Ye, editId: an }) }) } } class ze extends Fe { constructor(Ye, an = null) { super(Ye, { isRenderable: !0, ignoreBorder: !!an?.ignoreBorder, createQuadrilaterals: !0 }), this.isTooltipOnly = Ye.data.isTooltipOnly } render() { const { data: Ye, linkService: an } = this, pn = document.createElement("a"); pn.setAttribute("data-element-id", Ye.id); let yn = !1; return Ye.url ? (an.addLinkAttributes(pn, Ye.url, Ye.newWindow), yn = !0) : Ye.action ? (this._bindNamedAction(pn, Ye.action), yn = !0) : Ye.attachment ? (this._bindAttachment(pn, Ye.attachment), yn = !0) : Ye.setOCGState ? (this.#t(pn, Ye.setOCGState), yn = !0) : Ye.dest ? (this._bindLink(pn, Ye.dest), yn = !0) : (Ye.actions && (Ye.actions.Action || Ye.actions["Mouse Up"] || Ye.actions["Mouse Down"]) && this.enableScripting && this.hasJSActions && (this._bindJSAction(pn, Ye), yn = !0), Ye.resetForm ? (this._bindResetFormAction(pn, Ye.resetForm), yn = !0) : this.isTooltipOnly && !yn && (this._bindLink(pn, ""), yn = !0)), this.container.classList.add("linkAnnotation"), yn && this.container.append(pn), this.container } #e() { this.container.setAttribute("data-internal-link", "") } _bindLink(Ye, an) { Ye.href = this.linkService.getDestinationHash(an), Ye.onclick = () => (an && this.linkService.goToDestination(an), !1), (an || an === "") && this.#e() } _bindNamedAction(Ye, an) { Ye.href = this.linkService.getAnchorUrl(""), Ye.onclick = () => (this.linkService.executeNamedAction(an), !1), this.#e() } _bindAttachment(Ye, an) { Ye.href = this.linkService.getAnchorUrl(""), Ye.onclick = () => (this.downloadManager?.openOrDownloadData(this.container, an.content, an.filename), !1), this.#e() } #t(Ye, an) { Ye.href = this.linkService.getAnchorUrl(""), Ye.onclick = () => (this.linkService.executeSetOCGState(an), !1), this.#e() } _bindJSAction(Ye, an) { Ye.href = this.linkService.getAnchorUrl(""); const pn = new Map([["Action", "onclick"], ["Mouse Up", "onmouseup"], ["Mouse Down", "onmousedown"]]); for (const yn of Object.keys(an.actions)) { const _n = pn.get(yn); _n && (Ye[_n] = () => (this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an.id, name: yn } }), !1)) } Ye.onclick || (Ye.onclick = () => !1), this.#e() } _bindResetFormAction(Ye, an) { const pn = Ye.onclick; if (pn || (Ye.href = this.linkService.getAnchorUrl("")), this.#e(), !this._fieldObjects) { (0, Ee.warn)('_bindResetFormAction - "resetForm" action not supported, ensure that the `fieldObjects` parameter is provided.'), pn || (Ye.onclick = () => !1); return } Ye.onclick = () => { pn?.(); const { fields: yn, refs: _n, include: On } = an, kn = []; if (yn.length !== 0 || _n.length !== 0) { const Fn = new Set(_n); for (const Cn of yn) { const Vn = this._fieldObjects[Cn] || []; for (const { id: Yn } of Vn) Fn.add(Yn) } for (const Cn of Object.values(this._fieldObjects)) for (const Vn of Cn) Fn.has(Vn.id) === On && kn.push(Vn) } else for (const Fn of Object.values(this._fieldObjects)) kn.push(...Fn); const zn = this.annotationStorage, sr = []; for (const Fn of kn) { const { id: Cn } = Fn; switch (sr.push(Cn), Fn.type) { case "text": { const Yn = Fn.defaultValue || ""; zn.setValue(Cn, { value: Yn }); break } case "checkbox": case "radiobutton": { const Yn = Fn.defaultValue === Fn.exportValues; zn.setValue(Cn, { value: Yn }); break } case "combobox": case "listbox": { const Yn = Fn.defaultValue || ""; zn.setValue(Cn, { value: Yn }); break } default: continue }const Vn = document.querySelector(`[data-element-id="${Cn}"]`); if (Vn) { if (!je.has(Vn)) { (0, Ee.warn)(`_bindResetFormAction - element not allowed: ${Cn}`); continue } } else continue; Vn.dispatchEvent(new Event("resetform")) } return this.enableScripting && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: "app", ids: sr, name: "ResetForm" } }), !1 } } } class qe extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0 }) } render() { this.container.classList.add("textAnnotation"); const Ye = document.createElement("img"); return Ye.src = this.imageResourcesPath + "annotation-" + this.data.name.toLowerCase() + ".svg", Ye.alt = "[{{type}} Annotation]", Ye.dataset.l10nId = "text_annotation_type", Ye.dataset.l10nArgs = JSON.stringify({ type: this.data.name }), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.append(Ye), this.container } } class He extends Fe { render() { return this.data.alternativeText && (this.container.title = this.data.alternativeText), this.container } showElementAndHideCanvas(Ye) { this.data.hasOwnCanvas && (Ye.previousSibling?.nodeName === "CANVAS" && (Ye.previousSibling.hidden = !0), Ye.hidden = !1) } _getKeyModifier(Ye) { const { isWin: an, isMac: pn } = Ee.FeatureTest.platform; return an && Ye.ctrlKey || pn && Ye.metaKey } _setEventListener(Ye, an, pn, yn, _n) { pn.includes("mouse") ? Ye.addEventListener(pn, On => { this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: yn, value: _n(On), shift: On.shiftKey, modifier: this._getKeyModifier(On) } }) }) : Ye.addEventListener(pn, On => { if (pn === "blur") { if (!an.focused || !On.relatedTarget) return; an.focused = !1 } else if (pn === "focus") { if (an.focused) return; an.focused = !0 } _n && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: this.data.id, name: yn, value: _n(On) } }) }) } _setEventListeners(Ye, an, pn, yn) { for (const [_n, On] of pn) (On === "Action" || this.data.actions?.[On]) && ((On === "Focus" || On === "Blur") && (an ||= { focused: !1 }), this._setEventListener(Ye, an, _n, On, yn), On === "Focus" && !this.data.actions?.Blur ? this._setEventListener(Ye, an, "blur", "Blur", null) : On === "Blur" && !this.data.actions?.Focus && this._setEventListener(Ye, an, "focus", "Focus", null)) } _setBackgroundColor(Ye) { const an = this.data.backgroundColor || null; Ye.style.backgroundColor = an === null ? "transparent" : Ee.Util.makeHexColor(an[0], an[1], an[2]) } _setTextStyle(Ye) { const an = ["left", "center", "right"], { fontColor: pn } = this.data.defaultAppearanceData, yn = this.data.defaultAppearanceData.fontSize || Oe, _n = Ye.style; let On; const kn = 2, zn = sr => Math.round(10 * sr) / 10; if (this.data.multiLine) { const sr = Math.abs(this.data.rect[3] - this.data.rect[1] - kn), Fn = Math.round(sr / (Ee.LINE_FACTOR * yn)) || 1, Cn = sr / Fn; On = Math.min(yn, zn(Cn / Ee.LINE_FACTOR)) } else { const sr = Math.abs(this.data.rect[3] - this.data.rect[1] - kn); On = Math.min(yn, zn(sr / Ee.LINE_FACTOR)) } _n.fontSize = `calc(${On}px * var(--scale-factor))`, _n.color = Ee.Util.makeHexColor(pn[0], pn[1], pn[2]), this.data.textAlignment !== null && (_n.textAlign = an[this.data.textAlignment]) } _setRequired(Ye, an) { an ? Ye.setAttribute("required", !0) : Ye.removeAttribute("required"), Ye.setAttribute("aria-required", an) } } class Ge extends He {
          constructor(Ye) { const an = Ye.renderForms || !Ye.data.hasAppearance && !!Ye.data.fieldValue; super(Ye, { isRenderable: an }) } setPropertyOnSiblings(Ye, an, pn, yn) { const _n = this.annotationStorage; for (const On of this._getElementsByName(Ye.name, Ye.id)) On.domElement && (On.domElement[an] = pn), _n.setValue(On.id, { [yn]: pn }) } render() {
            const Ye = this.annotationStorage, an = this.data.id; this.container.classList.add("textWidgetAnnotation"); let pn = null; if (this.renderForms) {
              const yn = Ye.getValue(an, { value: this.data.fieldValue }); let _n = yn.value || ""; const On = Ye.getValue(an, { charLimit: this.data.maxLen }).charLimit; On && _n.length > On && (_n = _n.slice(0, On)); let kn = yn.formattedValue || this.data.textContent?.join(`
`) || null; kn && this.data.comb && (kn = kn.replaceAll(/\s+/g, "")); const zn = { userValue: _n, formattedValue: kn, lastCommittedValue: null, commitKey: 1, focused: !1 }; this.data.multiLine ? (pn = document.createElement("textarea"), pn.textContent = kn ?? _n, this.data.doNotScroll && (pn.style.overflowY = "hidden")) : (pn = document.createElement("input"), pn.type = "text", pn.setAttribute("value", kn ?? _n), this.data.doNotScroll && (pn.style.overflowX = "hidden")), this.data.hasOwnCanvas && (pn.hidden = !0), je.add(pn), pn.setAttribute("data-element-id", an), pn.disabled = this.data.readOnly, pn.name = this.data.fieldName, pn.tabIndex = Pe, this._setRequired(pn, this.data.required), On && (pn.maxLength = On), pn.addEventListener("input", Fn => { Ye.setValue(an, { value: Fn.target.value }), this.setPropertyOnSiblings(pn, "value", Fn.target.value, "value"), zn.formattedValue = null }), pn.addEventListener("resetform", Fn => { const Cn = this.data.defaultFieldValue ?? ""; pn.value = zn.userValue = Cn, zn.formattedValue = null }); let sr = Fn => { const { formattedValue: Cn } = zn; Cn != null && (Fn.target.value = Cn), Fn.target.scrollLeft = 0 }; if (this.enableScripting && this.hasJSActions) { pn.addEventListener("focus", Cn => { if (zn.focused) return; const { target: Vn } = Cn; zn.userValue && (Vn.value = zn.userValue), zn.lastCommittedValue = Vn.value, zn.commitKey = 1, zn.focused = !0 }), pn.addEventListener("updatefromsandbox", Cn => { this.showElementAndHideCanvas(Cn.target); const Vn = { value(Yn) { zn.userValue = Yn.detail.value ?? "", Ye.setValue(an, { value: zn.userValue.toString() }), Yn.target.value = zn.userValue }, formattedValue(Yn) { const { formattedValue: qn } = Yn.detail; zn.formattedValue = qn, qn != null && Yn.target !== document.activeElement && (Yn.target.value = qn), Ye.setValue(an, { formattedValue: qn }) }, selRange(Yn) { Yn.target.setSelectionRange(...Yn.detail.selRange) }, charLimit: Yn => { const { charLimit: qn } = Yn.detail, { target: rr } = Yn; if (qn === 0) { rr.removeAttribute("maxLength"); return } rr.setAttribute("maxLength", qn); let hr = zn.userValue; !hr || hr.length <= qn || (hr = hr.slice(0, qn), rr.value = zn.userValue = hr, Ye.setValue(an, { value: hr }), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an, name: "Keystroke", value: hr, willCommit: !0, commitKey: 1, selStart: rr.selectionStart, selEnd: rr.selectionEnd } })) } }; this._dispatchEventFromSandbox(Vn, Cn) }), pn.addEventListener("keydown", Cn => { zn.commitKey = 1; let Vn = -1; if (Cn.key === "Escape" ? Vn = 0 : Cn.key === "Enter" && !this.data.multiLine ? Vn = 2 : Cn.key === "Tab" && (zn.commitKey = 3), Vn === -1) return; const { value: Yn } = Cn.target; zn.lastCommittedValue !== Yn && (zn.lastCommittedValue = Yn, zn.userValue = Yn, this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an, name: "Keystroke", value: Yn, willCommit: !0, commitKey: Vn, selStart: Cn.target.selectionStart, selEnd: Cn.target.selectionEnd } })) }); const Fn = sr; sr = null, pn.addEventListener("blur", Cn => { if (!zn.focused || !Cn.relatedTarget) return; zn.focused = !1; const { value: Vn } = Cn.target; zn.userValue = Vn, zn.lastCommittedValue !== Vn && this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an, name: "Keystroke", value: Vn, willCommit: !0, commitKey: zn.commitKey, selStart: Cn.target.selectionStart, selEnd: Cn.target.selectionEnd } }), Fn(Cn) }), this.data.actions?.Keystroke && pn.addEventListener("beforeinput", Cn => { zn.lastCommittedValue = null; const { data: Vn, target: Yn } = Cn, { value: qn, selectionStart: rr, selectionEnd: hr } = Yn; let ur = rr, Er = hr; switch (Cn.inputType) { case "deleteWordBackward": { const _r = qn.substring(0, rr).match(/\w*[^\w]*$/); _r && (ur -= _r[0].length); break } case "deleteWordForward": { const _r = qn.substring(rr).match(/^[^\w]*\w*/); _r && (Er += _r[0].length); break } case "deleteContentBackward": rr === hr && (ur -= 1); break; case "deleteContentForward": rr === hr && (Er += 1); break }Cn.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an, name: "Keystroke", value: qn, change: Vn || "", willCommit: !1, selStart: ur, selEnd: Er } }) }), this._setEventListeners(pn, zn, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], Cn => Cn.target.value) } if (sr && pn.addEventListener("blur", sr), this.data.comb) { const Cn = (this.data.rect[2] - this.data.rect[0]) / On; pn.classList.add("comb"), pn.style.letterSpacing = `calc(${Cn}px * var(--scale-factor) - 1ch)` }
            } else pn = document.createElement("div"), pn.textContent = this.data.fieldValue, pn.style.verticalAlign = "middle", pn.style.display = "table-cell"; return this._setTextStyle(pn), this._setBackgroundColor(pn), this._setDefaultPropertiesFromJS(pn), this.container.append(pn), this.container
          }
        } class Ze extends He { constructor(Ye) { super(Ye, { isRenderable: !!Ye.data.hasOwnCanvas }) } } class sn extends He { constructor(Ye) { super(Ye, { isRenderable: Ye.renderForms }) } render() { const Ye = this.annotationStorage, an = this.data, pn = an.id; let yn = Ye.getValue(pn, { value: an.exportValue === an.fieldValue }).value; typeof yn == "string" && (yn = yn !== "Off", Ye.setValue(pn, { value: yn })), this.container.classList.add("buttonWidgetAnnotation", "checkBox"); const _n = document.createElement("input"); return je.add(_n), _n.setAttribute("data-element-id", pn), _n.disabled = an.readOnly, this._setRequired(_n, this.data.required), _n.type = "checkbox", _n.name = an.fieldName, yn && _n.setAttribute("checked", !0), _n.setAttribute("exportValue", an.exportValue), _n.tabIndex = Pe, _n.addEventListener("change", On => { const { name: kn, checked: zn } = On.target; for (const sr of this._getElementsByName(kn, pn)) { const Fn = zn && sr.exportValue === an.exportValue; sr.domElement && (sr.domElement.checked = Fn), Ye.setValue(sr.id, { value: Fn }) } Ye.setValue(pn, { value: zn }) }), _n.addEventListener("resetform", On => { const kn = an.defaultFieldValue || "Off"; On.target.checked = kn === an.exportValue }), this.enableScripting && this.hasJSActions && (_n.addEventListener("updatefromsandbox", On => { const kn = { value(zn) { zn.target.checked = zn.detail.value !== "Off", Ye.setValue(pn, { value: zn.target.checked }) } }; this._dispatchEventFromSandbox(kn, On) }), this._setEventListeners(_n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], On => On.target.checked)), this._setBackgroundColor(_n), this._setDefaultPropertiesFromJS(_n), this.container.append(_n), this.container } } class Xe extends He { constructor(Ye) { super(Ye, { isRenderable: Ye.renderForms }) } render() { this.container.classList.add("buttonWidgetAnnotation", "radioButton"); const Ye = this.annotationStorage, an = this.data, pn = an.id; let yn = Ye.getValue(pn, { value: an.fieldValue === an.buttonValue }).value; typeof yn == "string" && (yn = yn !== an.buttonValue, Ye.setValue(pn, { value: yn })); const _n = document.createElement("input"); if (je.add(_n), _n.setAttribute("data-element-id", pn), _n.disabled = an.readOnly, this._setRequired(_n, this.data.required), _n.type = "radio", _n.name = an.fieldName, yn && _n.setAttribute("checked", !0), _n.tabIndex = Pe, _n.addEventListener("change", On => { const { name: kn, checked: zn } = On.target; for (const sr of this._getElementsByName(kn, pn)) Ye.setValue(sr.id, { value: !1 }); Ye.setValue(pn, { value: zn }) }), _n.addEventListener("resetform", On => { const kn = an.defaultFieldValue; On.target.checked = kn != null && kn === an.buttonValue }), this.enableScripting && this.hasJSActions) { const On = an.buttonValue; _n.addEventListener("updatefromsandbox", kn => { const zn = { value: sr => { const Fn = On === sr.detail.value; for (const Cn of this._getElementsByName(sr.target.name)) { const Vn = Fn && Cn.id === pn; Cn.domElement && (Cn.domElement.checked = Vn), Ye.setValue(Cn.id, { value: Vn }) } } }; this._dispatchEventFromSandbox(zn, kn) }), this._setEventListeners(_n, null, [["change", "Validate"], ["change", "Action"], ["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"]], kn => kn.target.checked) } return this._setBackgroundColor(_n), this._setDefaultPropertiesFromJS(_n), this.container.append(_n), this.container } } class St extends ze { constructor(Ye) { super(Ye, { ignoreBorder: Ye.data.hasAppearance }) } render() { const Ye = super.render(); Ye.classList.add("buttonWidgetAnnotation", "pushButton"), this.data.alternativeText && (Ye.title = this.data.alternativeText); const an = Ye.lastChild; return this.enableScripting && this.hasJSActions && an && (this._setDefaultPropertiesFromJS(an), an.addEventListener("updatefromsandbox", pn => { this._dispatchEventFromSandbox({}, pn) })), Ye } } class un extends He { constructor(Ye) { super(Ye, { isRenderable: Ye.renderForms }) } render() { this.container.classList.add("choiceWidgetAnnotation"); const Ye = this.annotationStorage, an = this.data.id, pn = Ye.getValue(an, { value: this.data.fieldValue }), yn = document.createElement("select"); je.add(yn), yn.setAttribute("data-element-id", an), yn.disabled = this.data.readOnly, this._setRequired(yn, this.data.required), yn.name = this.data.fieldName, yn.tabIndex = Pe; let _n = this.data.combo && this.data.options.length > 0; this.data.combo || (yn.size = this.data.options.length, this.data.multiSelect && (yn.multiple = !0)), yn.addEventListener("resetform", Fn => { const Cn = this.data.defaultFieldValue; for (const Vn of yn.options) Vn.selected = Vn.value === Cn }); for (const Fn of this.data.options) { const Cn = document.createElement("option"); Cn.textContent = Fn.displayValue, Cn.value = Fn.exportValue, pn.value.includes(Fn.exportValue) && (Cn.setAttribute("selected", !0), _n = !1), yn.append(Cn) } let On = null; if (_n) { const Fn = document.createElement("option"); Fn.value = " ", Fn.setAttribute("hidden", !0), Fn.setAttribute("selected", !0), yn.prepend(Fn), On = () => { Fn.remove(), yn.removeEventListener("input", On), On = null }, yn.addEventListener("input", On) } const kn = Fn => { const Cn = Fn ? "value" : "textContent", { options: Vn, multiple: Yn } = yn; return Yn ? Array.prototype.filter.call(Vn, qn => qn.selected).map(qn => qn[Cn]) : Vn.selectedIndex === -1 ? null : Vn[Vn.selectedIndex][Cn] }; let zn = kn(!1); const sr = Fn => { const Cn = Fn.target.options; return Array.prototype.map.call(Cn, Vn => ({ displayValue: Vn.textContent, exportValue: Vn.value })) }; return this.enableScripting && this.hasJSActions ? (yn.addEventListener("updatefromsandbox", Fn => { const Cn = { value(Vn) { On?.(); const Yn = Vn.detail.value, qn = new Set(Array.isArray(Yn) ? Yn : [Yn]); for (const rr of yn.options) rr.selected = qn.has(rr.value); Ye.setValue(an, { value: kn(!0) }), zn = kn(!1) }, multipleSelection(Vn) { yn.multiple = !0 }, remove(Vn) { const Yn = yn.options, qn = Vn.detail.remove; Yn[qn].selected = !1, yn.remove(qn), Yn.length > 0 && Array.prototype.findIndex.call(Yn, hr => hr.selected) === -1 && (Yn[0].selected = !0), Ye.setValue(an, { value: kn(!0), items: sr(Vn) }), zn = kn(!1) }, clear(Vn) { for (; yn.length !== 0;)yn.remove(0); Ye.setValue(an, { value: null, items: [] }), zn = kn(!1) }, insert(Vn) { const { index: Yn, displayValue: qn, exportValue: rr } = Vn.detail.insert, hr = yn.children[Yn], ur = document.createElement("option"); ur.textContent = qn, ur.value = rr, hr ? hr.before(ur) : yn.append(ur), Ye.setValue(an, { value: kn(!0), items: sr(Vn) }), zn = kn(!1) }, items(Vn) { const { items: Yn } = Vn.detail; for (; yn.length !== 0;)yn.remove(0); for (const qn of Yn) { const { displayValue: rr, exportValue: hr } = qn, ur = document.createElement("option"); ur.textContent = rr, ur.value = hr, yn.append(ur) } yn.options.length > 0 && (yn.options[0].selected = !0), Ye.setValue(an, { value: kn(!0), items: sr(Vn) }), zn = kn(!1) }, indices(Vn) { const Yn = new Set(Vn.detail.indices); for (const qn of Vn.target.options) qn.selected = Yn.has(qn.index); Ye.setValue(an, { value: kn(!0) }), zn = kn(!1) }, editable(Vn) { Vn.target.disabled = !Vn.detail.editable } }; this._dispatchEventFromSandbox(Cn, Fn) }), yn.addEventListener("input", Fn => { const Cn = kn(!0); Ye.setValue(an, { value: Cn }), Fn.preventDefault(), this.linkService.eventBus?.dispatch("dispatcheventinsandbox", { source: this, detail: { id: an, name: "Keystroke", value: zn, changeEx: Cn, willCommit: !1, commitKey: 1, keyDown: !1 } }) }), this._setEventListeners(yn, null, [["focus", "Focus"], ["blur", "Blur"], ["mousedown", "Mouse Down"], ["mouseenter", "Mouse Enter"], ["mouseleave", "Mouse Exit"], ["mouseup", "Mouse Up"], ["input", "Action"], ["input", "Validate"]], Fn => Fn.target.value)) : yn.addEventListener("input", function (Fn) { Ye.setValue(an, { value: kn(!0) }) }), this.data.combo && this._setTextStyle(yn), this._setBackgroundColor(yn), this._setDefaultPropertiesFromJS(yn), this.container.append(yn), this.container } } class on extends Fe { constructor(Ye) { const { data: an, elements: pn } = Ye; super(Ye, { isRenderable: Fe._hasPopupData(an) }), this.elements = pn } render() { this.container.classList.add("popupAnnotation"); const Ye = new bn({ container: this.container, color: this.data.color, titleObj: this.data.titleObj, modificationDate: this.data.modificationDate, contentsObj: this.data.contentsObj, richText: this.data.richText, rect: this.data.rect, parentRect: this.data.parentRect || null, parent: this.parent, elements: this.elements, open: this.data.open }), an = []; for (const pn of this.elements) pn.popup = Ye, an.push(pn.data.id), pn.addHighlightArea(); return this.container.setAttribute("aria-controls", an.map(pn => `${Ee.AnnotationPrefix}${pn}`).join(",")), this.container } } class bn { #e = null; #t = this.#d.bind(this); #n = this.#x.bind(this); #r = this.#y.bind(this); #a = this.#b.bind(this); #o = null; #s = null; #l = null; #c = null; #i = null; #p = null; #u = !1; #h = null; #f = null; #v = null; #m = null; #g = !1; constructor({ container: Ye, color: an, elements: pn, titleObj: yn, modificationDate: _n, contentsObj: On, richText: kn, parent: zn, rect: sr, parentRect: Fn, open: Cn }) { this.#s = Ye, this.#m = yn, this.#l = On, this.#v = kn, this.#i = zn, this.#o = an, this.#f = sr, this.#p = Fn, this.#c = pn; const Vn = _e.PDFDateString.toDateObject(_n); Vn && (this.#e = zn.l10n.get("annotation_date_string", { date: Vn.toLocaleDateString(), time: Vn.toLocaleTimeString() })), this.trigger = pn.flatMap(Yn => Yn.getElementsToTriggerPopup()); for (const Yn of this.trigger) Yn.addEventListener("click", this.#a), Yn.addEventListener("mouseenter", this.#r), Yn.addEventListener("mouseleave", this.#n), Yn.classList.add("popupTriggerArea"); for (const Yn of pn) Yn.container?.addEventListener("keydown", this.#t); this.#s.hidden = !0, Cn && this.#b() } render() { if (this.#h) return; const { page: { view: Ye }, viewport: { rawDims: { pageWidth: an, pageHeight: pn, pageX: yn, pageY: _n } } } = this.#i, On = this.#h = document.createElement("div"); if (On.className = "popup", this.#o) { const _r = On.style.outlineColor = Ee.Util.makeHexColor(...this.#o); CSS.supports("background-color", "color-mix(in srgb, red 30%, white)") ? On.style.backgroundColor = `color-mix(in srgb, ${_r} 30%, white)` : On.style.backgroundColor = Ee.Util.makeHexColor(...this.#o.map(Ir => Math.floor(.7 * (255 - Ir) + Ir))) } const kn = document.createElement("span"); kn.className = "header"; const zn = document.createElement("h1"); if (kn.append(zn), { dir: zn.dir, str: zn.textContent } = this.#m, On.append(kn), this.#e) { const _r = document.createElement("span"); _r.classList.add("popupDate"), this.#e.then(Or => { _r.textContent = Or }), kn.append(_r) } const sr = this.#l, Fn = this.#v; if (Fn?.str && (!sr?.str || sr.str === Fn.str)) De.XfaLayer.render({ xfaHtml: Fn.html, intent: "richText", div: On }), On.lastChild.classList.add("richText", "popupContent"); else { const _r = this._formatContents(sr); On.append(_r) } let Cn = !!this.#p, Vn = Cn ? this.#p : this.#f; for (const _r of this.#c) if (!Vn || Ee.Util.intersect(_r.data.rect, Vn) !== null) { Vn = _r.data.rect, Cn = !0; break } const Yn = Ee.Util.normalizeRect([Vn[0], Ye[3] - Vn[1] + Ye[1], Vn[2], Ye[3] - Vn[3] + Ye[1]]), rr = Cn ? Vn[2] - Vn[0] + 5 : 0, hr = Yn[0] + rr, ur = Yn[1], { style: Er } = this.#s; Er.left = `${100 * (hr - yn) / an}%`, Er.top = `${100 * (ur - _n) / pn}%`, this.#s.append(On) } _formatContents({ str: Ye, dir: an }) { const pn = document.createElement("p"); pn.classList.add("popupContent"), pn.dir = an; const yn = Ye.split(/(?:\r\n?|\n)/); for (let _n = 0, On = yn.length; _n < On; ++_n) { const kn = yn[_n]; pn.append(document.createTextNode(kn)), _n < On - 1 && pn.append(document.createElement("br")) } return pn } #d(Ye) { Ye.altKey || Ye.shiftKey || Ye.ctrlKey || Ye.metaKey || (Ye.key === "Enter" || Ye.key === "Escape" && this.#u) && this.#b() } #b() { this.#u = !this.#u, this.#u ? (this.#y(), this.#s.addEventListener("click", this.#a), this.#s.addEventListener("keydown", this.#t)) : (this.#x(), this.#s.removeEventListener("click", this.#a), this.#s.removeEventListener("keydown", this.#t)) } #y() { this.#h || this.render(), this.isVisible ? this.#u && this.#s.classList.add("focused") : (this.#s.hidden = !1, this.#s.style.zIndex = parseInt(this.#s.style.zIndex) + 1e3) } #x() { this.#s.classList.remove("focused"), !(this.#u || !this.isVisible) && (this.#s.hidden = !0, this.#s.style.zIndex = parseInt(this.#s.style.zIndex) - 1e3) } forceHide() { this.#g = this.isVisible, this.#g && (this.#s.hidden = !0) } maybeShow() { this.#g && (this.#g = !1, this.#s.hidden = !1) } get isVisible() { return this.#s.hidden === !1 } } class Tn extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }), this.textContent = Ye.data.textContent, this.textPosition = Ye.data.textPosition, this.annotationEditorType = Ee.AnnotationEditorType.FREETEXT } render() { if (this.container.classList.add("freeTextAnnotation"), this.textContent) { const Ye = document.createElement("div"); Ye.classList.add("annotationTextContent"), Ye.setAttribute("role", "comment"); for (const an of this.textContent) { const pn = document.createElement("span"); pn.textContent = an, Ye.append(pn) } this.container.append(Ye) } return !this.data.popupRef && this.hasPopupData && this._createPopup(), this._editOnDoubleClick(), this.container } } t.FreeTextAnnotationElement = Tn; class fn extends Fe { #e = null; constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }) } render() { this.container.classList.add("lineAnnotation"); const Ye = this.data, { width: an, height: pn } = Be(Ye.rect), yn = this.svgFactory.create(an, pn, !0), _n = this.#e = this.svgFactory.createElement("svg:line"); return _n.setAttribute("x1", Ye.rect[2] - Ye.lineCoordinates[0]), _n.setAttribute("y1", Ye.rect[3] - Ye.lineCoordinates[1]), _n.setAttribute("x2", Ye.rect[2] - Ye.lineCoordinates[2]), _n.setAttribute("y2", Ye.rect[3] - Ye.lineCoordinates[3]), _n.setAttribute("stroke-width", Ye.borderStyle.width || 1), _n.setAttribute("stroke", "transparent"), _n.setAttribute("fill", "transparent"), yn.append(_n), this.container.append(yn), !Ye.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } } class En extends Fe { #e = null; constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }) } render() { this.container.classList.add("squareAnnotation"); const Ye = this.data, { width: an, height: pn } = Be(Ye.rect), yn = this.svgFactory.create(an, pn, !0), _n = Ye.borderStyle.width, On = this.#e = this.svgFactory.createElement("svg:rect"); return On.setAttribute("x", _n / 2), On.setAttribute("y", _n / 2), On.setAttribute("width", an - _n), On.setAttribute("height", pn - _n), On.setAttribute("stroke-width", _n || 1), On.setAttribute("stroke", "transparent"), On.setAttribute("fill", "transparent"), yn.append(On), this.container.append(yn), !Ye.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } } class Pn extends Fe { #e = null; constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }) } render() { this.container.classList.add("circleAnnotation"); const Ye = this.data, { width: an, height: pn } = Be(Ye.rect), yn = this.svgFactory.create(an, pn, !0), _n = Ye.borderStyle.width, On = this.#e = this.svgFactory.createElement("svg:ellipse"); return On.setAttribute("cx", an / 2), On.setAttribute("cy", pn / 2), On.setAttribute("rx", an / 2 - _n / 2), On.setAttribute("ry", pn / 2 - _n / 2), On.setAttribute("stroke-width", _n || 1), On.setAttribute("stroke", "transparent"), On.setAttribute("fill", "transparent"), yn.append(On), this.container.append(yn), !Ye.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } } class Rn extends Fe { #e = null; constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }), this.containerClassName = "polylineAnnotation", this.svgElementName = "svg:polyline" } render() { this.container.classList.add(this.containerClassName); const Ye = this.data, { width: an, height: pn } = Be(Ye.rect), yn = this.svgFactory.create(an, pn, !0); let _n = []; for (const kn of Ye.vertices) { const zn = kn.x - Ye.rect[0], sr = Ye.rect[3] - kn.y; _n.push(zn + "," + sr) } _n = _n.join(" "); const On = this.#e = this.svgFactory.createElement(this.svgElementName); return On.setAttribute("points", _n), On.setAttribute("stroke-width", Ye.borderStyle.width || 1), On.setAttribute("stroke", "transparent"), On.setAttribute("fill", "transparent"), yn.append(On), this.container.append(yn), !Ye.popupRef && this.hasPopupData && this._createPopup(), this.container } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } } class In extends Rn { constructor(Ye) { super(Ye), this.containerClassName = "polygonAnnotation", this.svgElementName = "svg:polygon" } } class xn extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }) } render() { return this.container.classList.add("caretAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container } } class vn extends Fe { #e = []; constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }), this.containerClassName = "inkAnnotation", this.svgElementName = "svg:polyline", this.annotationEditorType = Ee.AnnotationEditorType.INK } render() { this.container.classList.add(this.containerClassName); const Ye = this.data, { width: an, height: pn } = Be(Ye.rect), yn = this.svgFactory.create(an, pn, !0); for (const _n of Ye.inkLists) { let On = []; for (const zn of _n) { const sr = zn.x - Ye.rect[0], Fn = Ye.rect[3] - zn.y; On.push(`${sr},${Fn}`) } On = On.join(" "); const kn = this.svgFactory.createElement(this.svgElementName); this.#e.push(kn), kn.setAttribute("points", On), kn.setAttribute("stroke-width", Ye.borderStyle.width || 1), kn.setAttribute("stroke", "transparent"), kn.setAttribute("fill", "transparent"), !Ye.popupRef && this.hasPopupData && this._createPopup(), yn.append(kn) } return this.container.append(yn), this.container } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } } t.InkAnnotationElement = vn; class tn extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("highlightAnnotation"), this.container } } class nn extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("underlineAnnotation"), this.container } } class We extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("squigglyAnnotation"), this.container } } class dn extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0, createQuadrilaterals: !0 }) } render() { return !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container.classList.add("strikeoutAnnotation"), this.container } } class Je extends Fe { constructor(Ye) { super(Ye, { isRenderable: !0, ignoreBorder: !0 }) } render() { return this.container.classList.add("stampAnnotation"), !this.data.popupRef && this.hasPopupData && this._createPopup(), this.container } } t.StampAnnotationElement = Je; class rn extends Fe { #e = null; constructor(Ye) { super(Ye, { isRenderable: !0 }); const { filename: an, content: pn } = this.data.file; this.filename = (0, _e.getFilenameFromUrl)(an, !0), this.content = pn, this.linkService.eventBus?.dispatch("fileattachmentannotation", { source: this, filename: an, content: pn }) } render() { this.container.classList.add("fileAttachmentAnnotation"); const { container: Ye, data: an } = this; let pn; an.hasAppearance || an.fillAlpha === 0 ? pn = document.createElement("div") : (pn = document.createElement("img"), pn.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(an.name) ? "paperclip" : "pushpin"}.svg`, an.fillAlpha && an.fillAlpha < 1 && (pn.style = `filter: opacity(${Math.round(an.fillAlpha * 100)}%);`)), pn.addEventListener("dblclick", this.#t.bind(this)), this.#e = pn; const { isMac: yn } = Ee.FeatureTest.platform; return Ye.addEventListener("keydown", _n => { _n.key === "Enter" && (yn ? _n.metaKey : _n.ctrlKey) && this.#t() }), !an.popupRef && this.hasPopupData ? this._createPopup() : pn.classList.add("popupTriggerArea"), Ye.append(pn), Ye } getElementsToTriggerPopup() { return this.#e } addHighlightArea() { this.container.classList.add("highlightArea") } #t() { this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename) } } class hn { #e = null; #t = null; #n = new Map; constructor({ div: Ye, accessibilityManager: an, annotationCanvasMap: pn, l10n: yn, page: _n, viewport: On }) { this.div = Ye, this.#e = an, this.#t = pn, this.l10n = yn, this.page = _n, this.viewport = On, this.zIndex = 0, this.l10n ||= Me.NullL10n } #r(Ye, an) { const pn = Ye.firstChild || Ye; pn.id = `${Ee.AnnotationPrefix}${an}`, this.div.append(Ye), this.#e?.moveElementInDOM(this.div, Ye, pn, !1) } async render(Ye) { const { annotations: an } = Ye, pn = this.div; (0, _e.setLayerDimensions)(pn, this.viewport); const yn = new Map, _n = { data: null, layer: pn, linkService: Ye.linkService, downloadManager: Ye.downloadManager, imageResourcesPath: Ye.imageResourcesPath || "", renderForms: Ye.renderForms !== !1, svgFactory: new _e.DOMSVGFactory, annotationStorage: Ye.annotationStorage || new Re.AnnotationStorage, enableScripting: Ye.enableScripting === !0, hasJSActions: Ye.hasJSActions, fieldObjects: Ye.fieldObjects, parent: this, elements: null }; for (const On of an) { if (On.noHTML) continue; const kn = On.annotationType === Ee.AnnotationType.POPUP; if (kn) { const Fn = yn.get(On.id); if (!Fn) continue; _n.elements = Fn } else { const { width: Fn, height: Cn } = Be(On.rect); if (Fn <= 0 || Cn <= 0) continue } _n.data = On; const zn = Ie.create(_n); if (!zn.isRenderable) continue; if (!kn && On.popupRef) { const Fn = yn.get(On.popupRef); Fn ? Fn.push(zn) : yn.set(On.popupRef, [zn]) } zn.annotationEditorType > 0 && this.#n.set(zn.data.id, zn); const sr = zn.render(); On.hidden && (sr.style.visibility = "hidden"), this.#r(sr, On.id) } this.#a(), await this.l10n.translate(pn) } update({ viewport: Ye }) { const an = this.div; this.viewport = Ye, (0, _e.setLayerDimensions)(an, { rotation: Ye.rotation }), this.#a(), an.hidden = !1 } #a() { if (!this.#t) return; const Ye = this.div; for (const [an, pn] of this.#t) { const yn = Ye.querySelector(`[data-annotation-id="${an}"]`); if (!yn) continue; const { firstChild: _n } = yn; _n ? _n.nodeName === "CANVAS" ? _n.replaceWith(pn) : _n.before(pn) : yn.append(pn) } this.#t.clear() } getEditableAnnotations() { return Array.from(this.#n.values()) } getEditableAnnotation(Ye) { return this.#n.get(Ye) } } t.AnnotationLayer = hn
      }, (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.ColorConverters = void 0; function xe(Re) { return Math.floor(Math.max(0, Math.min(1, Re)) * 255).toString(16).padStart(2, "0") } function Ee(Re) { return Math.max(0, Math.min(255, 255 * Re)) } class _e { static CMYK_G([Ce, Me, De, Pe]) { return ["G", 1 - Math.min(1, .3 * Ce + .59 * De + .11 * Me + Pe)] } static G_CMYK([Ce]) { return ["CMYK", 0, 0, 0, 1 - Ce] } static G_RGB([Ce]) { return ["RGB", Ce, Ce, Ce] } static G_rgb([Ce]) { return Ce = Ee(Ce), [Ce, Ce, Ce] } static G_HTML([Ce]) { const Me = xe(Ce); return `#${Me}${Me}${Me}` } static RGB_G([Ce, Me, De]) { return ["G", .3 * Ce + .59 * Me + .11 * De] } static RGB_rgb(Ce) { return Ce.map(Ee) } static RGB_HTML(Ce) { return `#${Ce.map(xe).join("")}` } static T_HTML() { return "#00000000" } static T_rgb() { return [null] } static CMYK_RGB([Ce, Me, De, Pe]) { return ["RGB", 1 - Math.min(1, Ce + Pe), 1 - Math.min(1, De + Pe), 1 - Math.min(1, Me + Pe)] } static CMYK_rgb([Ce, Me, De, Pe]) { return [Ee(1 - Math.min(1, Ce + Pe)), Ee(1 - Math.min(1, De + Pe)), Ee(1 - Math.min(1, Me + Pe))] } static CMYK_HTML(Ce) { const Me = this.CMYK_RGB(Ce).slice(1); return this.RGB_HTML(Me) } static RGB_CMYK([Ce, Me, De]) { const Pe = 1 - Ce, Oe = 1 - Me, je = 1 - De, Be = Math.min(Pe, Oe, je); return ["CMYK", Pe, Oe, je, Be] } } t.ColorConverters = _e }, (e, t) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.NullL10n = void 0, t.getL10nFallback = Ee; const xe = { of_pages: "of {{pagesCount}}", page_of_pages: "({{pageNumber}} of {{pagesCount}})", document_properties_kb: "{{size_kb}} KB ({{size_b}} bytes)", document_properties_mb: "{{size_mb}} MB ({{size_b}} bytes)", document_properties_date_string: "{{date}}, {{time}}", document_properties_page_size_unit_inches: "in", document_properties_page_size_unit_millimeters: "mm", document_properties_page_size_orientation_portrait: "portrait", document_properties_page_size_orientation_landscape: "landscape", document_properties_page_size_name_a3: "A3", document_properties_page_size_name_a4: "A4", document_properties_page_size_name_letter: "Letter", document_properties_page_size_name_legal: "Legal", document_properties_page_size_dimension_string: "{{width}} × {{height}} {{unit}} ({{orientation}})", document_properties_page_size_dimension_name_string: "{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})", document_properties_linearized_yes: "Yes", document_properties_linearized_no: "No", additional_layers: "Additional Layers", page_landmark: "Page {{page}}", thumb_page_title: "Page {{page}}", thumb_page_canvas: "Thumbnail of Page {{page}}", find_reached_top: "Reached top of document, continued from bottom", find_reached_bottom: "Reached end of document, continued from top", "find_match_count[one]": "{{current}} of {{total}} match", "find_match_count[other]": "{{current}} of {{total}} matches", "find_match_count_limit[one]": "More than {{limit}} match", "find_match_count_limit[other]": "More than {{limit}} matches", find_not_found: "Phrase not found", page_scale_width: "Page Width", page_scale_fit: "Page Fit", page_scale_auto: "Automatic Zoom", page_scale_actual: "Actual Size", page_scale_percent: "{{scale}}%", loading_error: "An error occurred while loading the PDF.", invalid_file_error: "Invalid or corrupted PDF file.", missing_file_error: "Missing PDF file.", unexpected_response_error: "Unexpected server response.", rendering_error: "An error occurred while rendering the page.", annotation_date_string: "{{date}}, {{time}}", printing_not_supported: "Warning: Printing is not fully supported by this browser.", printing_not_ready: "Warning: The PDF is not fully loaded for printing.", web_fonts_disabled: "Web fonts are disabled: unable to use embedded PDF fonts.", free_text2_default_content: "Start typing…", editor_free_text2_aria_label: "Text Editor", editor_ink2_aria_label: "Draw Editor", editor_ink_canvas_aria_label: "User-created image", editor_alt_text_button_label: "Alt text", editor_alt_text_edit_button_label: "Edit alt text", editor_alt_text_decorative_tooltip: "Marked as decorative" }; xe.print_progress_percent = "{{progress}}%"; function Ee(Ce, Me) { switch (Ce) { case "find_match_count": Ce = `find_match_count[${Me.total === 1 ? "one" : "other"}]`; break; case "find_match_count_limit": Ce = `find_match_count_limit[${Me.limit === 1 ? "one" : "other"}]`; break }return xe[Ce] || "" } function _e(Ce, Me) { return Me ? Ce.replaceAll(/\{\{\s*(\w+)\s*\}\}/g, (De, Pe) => Pe in Me ? Me[Pe] : "{{" + Pe + "}}") : Ce } const Re = { async getLanguage() { return "en-us" }, async getDirection() { return "ltr" }, async get(Ce, Me = null, De = Ee(Ce, Me)) { return _e(De, Me) }, async translate(Ce) { } }; t.NullL10n = Re }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.XfaLayer = void 0; var Ee = xe(25); class _e { static setupStorage(Ce, Me, De, Pe, Oe) { const je = Pe.getValue(Me, { value: null }); switch (De.name) { case "textarea": if (je.value !== null && (Ce.textContent = je.value), Oe === "print") break; Ce.addEventListener("input", Be => { Pe.setValue(Me, { value: Be.target.value }) }); break; case "input": if (De.attributes.type === "radio" || De.attributes.type === "checkbox") { if (je.value === De.attributes.xfaOn ? Ce.setAttribute("checked", !0) : je.value === De.attributes.xfaOff && Ce.removeAttribute("checked"), Oe === "print") break; Ce.addEventListener("change", Be => { Pe.setValue(Me, { value: Be.target.checked ? Be.target.getAttribute("xfaOn") : Be.target.getAttribute("xfaOff") }) }) } else { if (je.value !== null && Ce.setAttribute("value", je.value), Oe === "print") break; Ce.addEventListener("input", Be => { Pe.setValue(Me, { value: Be.target.value }) }) } break; case "select": if (je.value !== null) { Ce.setAttribute("value", je.value); for (const Be of De.children) Be.attributes.value === je.value ? Be.attributes.selected = !0 : Be.attributes.hasOwnProperty("selected") && delete Be.attributes.selected } Ce.addEventListener("input", Be => { const Ie = Be.target.options, Fe = Ie.selectedIndex === -1 ? "" : Ie[Ie.selectedIndex].value; Pe.setValue(Me, { value: Fe }) }); break } } static setAttributes({ html: Ce, element: Me, storage: De = null, intent: Pe, linkService: Oe }) { const { attributes: je } = Me, Be = Ce instanceof HTMLAnchorElement; je.type === "radio" && (je.name = `${je.name}-${Pe}`); for (const [Ie, Fe] of Object.entries(je)) if (Fe != null) switch (Ie) { case "class": Fe.length && Ce.setAttribute(Ie, Fe.join(" ")); break; case "dataId": break; case "id": Ce.setAttribute("data-element-id", Fe); break; case "style": Object.assign(Ce.style, Fe); break; case "textContent": Ce.textContent = Fe; break; default: (!Be || Ie !== "href" && Ie !== "newWindow") && Ce.setAttribute(Ie, Fe) }Be && Oe.addLinkAttributes(Ce, je.href, je.newWindow), De && je.dataId && this.setupStorage(Ce, je.dataId, Me, De) } static render(Ce) { const Me = Ce.annotationStorage, De = Ce.linkService, Pe = Ce.xfaHtml, Oe = Ce.intent || "display", je = document.createElement(Pe.name); Pe.attributes && this.setAttributes({ html: je, element: Pe, intent: Oe, linkService: De }); const Be = [[Pe, -1, je]], Ie = Ce.div; if (Ie.append(je), Ce.viewport) { const ze = `matrix(${Ce.viewport.transform.join(",")})`; Ie.style.transform = ze } Oe !== "richText" && Ie.setAttribute("class", "xfaLayer xfaFont"); const Fe = []; for (; Be.length > 0;) { const [ze, qe, He] = Be.at(-1); if (qe + 1 === ze.children.length) { Be.pop(); continue } const Ge = ze.children[++Be.at(-1)[1]]; if (Ge === null) continue; const { name: Ze } = Ge; if (Ze === "#text") { const Xe = document.createTextNode(Ge.value); Fe.push(Xe), He.append(Xe); continue } const sn = Ge?.attributes?.xmlns ? document.createElementNS(Ge.attributes.xmlns, Ze) : document.createElement(Ze); if (He.append(sn), Ge.attributes && this.setAttributes({ html: sn, element: Ge, storage: Me, intent: Oe, linkService: De }), Ge.children && Ge.children.length > 0) Be.push([Ge, -1, sn]); else if (Ge.value) { const Xe = document.createTextNode(Ge.value); Ee.XfaText.shouldBuildText(Ze) && Fe.push(Xe), sn.append(Xe) } } for (const ze of Ie.querySelectorAll(".xfaNonInteractive input, .xfaNonInteractive textarea")) ze.setAttribute("readOnly", !0); return { textDivs: Fe } } static update(Ce) { const Me = `matrix(${Ce.viewport.transform.join(",")})`; Ce.div.style.transform = Me, Ce.div.hidden = !1 } } t.XfaLayer = _e }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.InkEditor = void 0; var Ee = xe(1), _e = xe(4), Re = xe(29), Ce = xe(6), Me = xe(5); class De extends _e.AnnotationEditor { #e = 0; #t = 0; #n = this.canvasPointermove.bind(this); #r = this.canvasPointerleave.bind(this); #a = this.canvasPointerup.bind(this); #o = this.canvasPointerdown.bind(this); #s = new Path2D; #l = !1; #c = !1; #i = !1; #p = null; #u = 0; #h = 0; #f = null; static _defaultColor = null; static _defaultOpacity = 1; static _defaultThickness = 1; static _type = "ink"; constructor(Oe) { super({ ...Oe, name: "inkEditor" }), this.color = Oe.color || null, this.thickness = Oe.thickness || null, this.opacity = Oe.opacity || null, this.paths = [], this.bezierPath2D = [], this.allRawPaths = [], this.currentPath = [], this.scaleFactor = 1, this.translationX = this.translationY = 0, this.x = 0, this.y = 0, this._willKeepAspectRatio = !0 } static initialize(Oe) { _e.AnnotationEditor.initialize(Oe, { strings: ["editor_ink_canvas_aria_label", "editor_ink2_aria_label"] }) } static updateDefaultParams(Oe, je) { switch (Oe) { case Ee.AnnotationEditorParamsType.INK_THICKNESS: De._defaultThickness = je; break; case Ee.AnnotationEditorParamsType.INK_COLOR: De._defaultColor = je; break; case Ee.AnnotationEditorParamsType.INK_OPACITY: De._defaultOpacity = je / 100; break } } updateParams(Oe, je) { switch (Oe) { case Ee.AnnotationEditorParamsType.INK_THICKNESS: this.#v(je); break; case Ee.AnnotationEditorParamsType.INK_COLOR: this.#m(je); break; case Ee.AnnotationEditorParamsType.INK_OPACITY: this.#g(je); break } } static get defaultPropertiesToUpdate() { return [[Ee.AnnotationEditorParamsType.INK_THICKNESS, De._defaultThickness], [Ee.AnnotationEditorParamsType.INK_COLOR, De._defaultColor || _e.AnnotationEditor._defaultLineColor], [Ee.AnnotationEditorParamsType.INK_OPACITY, Math.round(De._defaultOpacity * 100)]] } get propertiesToUpdate() { return [[Ee.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || De._defaultThickness], [Ee.AnnotationEditorParamsType.INK_COLOR, this.color || De._defaultColor || _e.AnnotationEditor._defaultLineColor], [Ee.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? De._defaultOpacity))]] } #v(Oe) { const je = this.thickness; this.addCommands({ cmd: () => { this.thickness = Oe, this.#C() }, undo: () => { this.thickness = je, this.#C() }, mustExec: !0, type: Ee.AnnotationEditorParamsType.INK_THICKNESS, overwriteIfSameType: !0, keepUndo: !0 }) } #m(Oe) { const je = this.color; this.addCommands({ cmd: () => { this.color = Oe, this.#E() }, undo: () => { this.color = je, this.#E() }, mustExec: !0, type: Ee.AnnotationEditorParamsType.INK_COLOR, overwriteIfSameType: !0, keepUndo: !0 }) } #g(Oe) { Oe /= 100; const je = this.opacity; this.addCommands({ cmd: () => { this.opacity = Oe, this.#E() }, undo: () => { this.opacity = je, this.#E() }, mustExec: !0, type: Ee.AnnotationEditorParamsType.INK_OPACITY, overwriteIfSameType: !0, keepUndo: !0 }) } rebuild() { this.parent && (super.rebuild(), this.div !== null && (this.canvas || (this.#P(), this.#O()), this.isAttachedToDOM || (this.parent.add(this), this.#w()), this.#C())) } remove() { this.canvas !== null && (this.isEmpty() || this.commit(), this.canvas.width = this.canvas.height = 0, this.canvas.remove(), this.canvas = null, this.#p.disconnect(), this.#p = null, super.remove()) } setParent(Oe) { !this.parent && Oe ? this._uiManager.removeShouldRescale(this) : this.parent && Oe === null && this._uiManager.addShouldRescale(this), super.setParent(Oe) } onScaleChanging() { const [Oe, je] = this.parentDimensions, Be = this.width * Oe, Ie = this.height * je; this.setDimensions(Be, Ie) } enableEditMode() { this.#l || this.canvas === null || (super.enableEditMode(), this._isDraggable = !1, this.canvas.addEventListener("pointerdown", this.#o)) } disableEditMode() { !this.isInEditMode() || this.canvas === null || (super.disableEditMode(), this._isDraggable = !this.isEmpty(), this.div.classList.remove("editing"), this.canvas.removeEventListener("pointerdown", this.#o)) } onceAdded() { this._isDraggable = !this.isEmpty() } isEmpty() { return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0 } #d() { const { parentRotation: Oe, parentDimensions: [je, Be] } = this; switch (Oe) { case 90: return [0, Be, Be, je]; case 180: return [je, Be, je, Be]; case 270: return [je, 0, Be, je]; default: return [0, 0, je, Be] } } #b() { const { ctx: Oe, color: je, opacity: Be, thickness: Ie, parentScale: Fe, scaleFactor: ze } = this; Oe.lineWidth = Ie * Fe / ze, Oe.lineCap = "round", Oe.lineJoin = "round", Oe.miterLimit = 10, Oe.strokeStyle = `${je}${(0, Me.opacityToHex)(Be)}` } #y(Oe, je) { this.canvas.addEventListener("contextmenu", Ce.noContextMenu), this.canvas.addEventListener("pointerleave", this.#r), this.canvas.addEventListener("pointermove", this.#n), this.canvas.addEventListener("pointerup", this.#a), this.canvas.removeEventListener("pointerdown", this.#o), this.isEditing = !0, this.#i || (this.#i = !0, this.#w(), this.thickness ||= De._defaultThickness, this.color ||= De._defaultColor || _e.AnnotationEditor._defaultLineColor, this.opacity ??= De._defaultOpacity), this.currentPath.push([Oe, je]), this.#c = !1, this.#b(), this.#f = () => { this.#N(), this.#f && window.requestAnimationFrame(this.#f) }, window.requestAnimationFrame(this.#f) } #x(Oe, je) { const [Be, Ie] = this.currentPath.at(-1); if (this.currentPath.length > 1 && Oe === Be && je === Ie) return; const Fe = this.currentPath; let ze = this.#s; if (Fe.push([Oe, je]), this.#c = !0, Fe.length <= 2) { ze.moveTo(...Fe[0]), ze.lineTo(Oe, je); return } Fe.length === 3 && (this.#s = ze = new Path2D, ze.moveTo(...Fe[0])), this.#D(ze, ...Fe.at(-3), ...Fe.at(-2), Oe, je) } #S() { if (this.currentPath.length === 0) return; const Oe = this.currentPath.at(-1); this.#s.lineTo(...Oe) } #_(Oe, je) { this.#f = null, Oe = Math.min(Math.max(Oe, 0), this.canvas.width), je = Math.min(Math.max(je, 0), this.canvas.height), this.#x(Oe, je), this.#S(); let Be; if (this.currentPath.length !== 1) Be = this.#k(); else { const He = [Oe, je]; Be = [[He, He.slice(), He.slice(), He]] } const Ie = this.#s, Fe = this.currentPath; this.currentPath = [], this.#s = new Path2D; const ze = () => { this.allRawPaths.push(Fe), this.paths.push(Be), this.bezierPath2D.push(Ie), this.rebuild() }, qe = () => { this.allRawPaths.pop(), this.paths.pop(), this.bezierPath2D.pop(), this.paths.length === 0 ? this.remove() : (this.canvas || (this.#P(), this.#O()), this.#C()) }; this.addCommands({ cmd: ze, undo: qe, mustExec: !0 }) } #N() { if (!this.#c) return; this.#c = !1; const Oe = Math.ceil(this.thickness * this.parentScale), je = this.currentPath.slice(-3), Be = je.map(ze => ze[0]), Ie = je.map(ze => ze[1]); Math.min(...Be) - Oe, Math.max(...Be) + Oe, Math.min(...Ie) - Oe, Math.max(...Ie) + Oe; const { ctx: Fe } = this; Fe.save(), Fe.clearRect(0, 0, this.canvas.width, this.canvas.height); for (const ze of this.bezierPath2D) Fe.stroke(ze); Fe.stroke(this.#s), Fe.restore() } #D(Oe, je, Be, Ie, Fe, ze, qe) { const He = (je + Ie) / 2, Ge = (Be + Fe) / 2, Ze = (Ie + ze) / 2, sn = (Fe + qe) / 2; Oe.bezierCurveTo(He + 2 * (Ie - He) / 3, Ge + 2 * (Fe - Ge) / 3, Ze + 2 * (Ie - Ze) / 3, sn + 2 * (Fe - sn) / 3, Ze, sn) } #k() { const Oe = this.currentPath; if (Oe.length <= 2) return [[Oe[0], Oe[0], Oe.at(-1), Oe.at(-1)]]; const je = []; let Be, [Ie, Fe] = Oe[0]; for (Be = 1; Be < Oe.length - 2; Be++) { const [Xe, St] = Oe[Be], [un, on] = Oe[Be + 1], bn = (Xe + un) / 2, Tn = (St + on) / 2, fn = [Ie + 2 * (Xe - Ie) / 3, Fe + 2 * (St - Fe) / 3], En = [bn + 2 * (Xe - bn) / 3, Tn + 2 * (St - Tn) / 3]; je.push([[Ie, Fe], fn, En, [bn, Tn]]), [Ie, Fe] = [bn, Tn] } const [ze, qe] = Oe[Be], [He, Ge] = Oe[Be + 1], Ze = [Ie + 2 * (ze - Ie) / 3, Fe + 2 * (qe - Fe) / 3], sn = [He + 2 * (ze - He) / 3, Ge + 2 * (qe - Ge) / 3]; return je.push([[Ie, Fe], Ze, sn, [He, Ge]]), je } #E() { if (this.isEmpty()) { this.#R(); return } this.#b(); const { canvas: Oe, ctx: je } = this; je.setTransform(1, 0, 0, 1, 0, 0), je.clearRect(0, 0, Oe.width, Oe.height), this.#R(); for (const Be of this.bezierPath2D) je.stroke(Be) } commit() { this.#l || (super.commit(), this.isEditing = !1, this.disableEditMode(), this.setInForeground(), this.#l = !0, this.div.classList.add("disabled"), this.#C(!0), this.makeResizable(), this.parent.addInkEditorIfNeeded(!0), this.moveInDOM(), this.div.focus({ preventScroll: !0 })) } focusin(Oe) { this._focusEventsAllowed && (super.focusin(Oe), this.enableEditMode()) } canvasPointerdown(Oe) { Oe.button !== 0 || !this.isInEditMode() || this.#l || (this.setInForeground(), Oe.preventDefault(), Oe.type !== "mouse" && this.div.focus(), this.#y(Oe.offsetX, Oe.offsetY)) } canvasPointermove(Oe) { Oe.preventDefault(), this.#x(Oe.offsetX, Oe.offsetY) } canvasPointerup(Oe) { Oe.preventDefault(), this.#M(Oe) } canvasPointerleave(Oe) { this.#M(Oe) } #M(Oe) { this.canvas.removeEventListener("pointerleave", this.#r), this.canvas.removeEventListener("pointermove", this.#n), this.canvas.removeEventListener("pointerup", this.#a), this.canvas.addEventListener("pointerdown", this.#o), setTimeout(() => { this.canvas.removeEventListener("contextmenu", Ce.noContextMenu) }, 10), this.#_(Oe.offsetX, Oe.offsetY), this.addToAnnotationStorage(), this.setInBackground() } #P() { this.canvas = document.createElement("canvas"), this.canvas.width = this.canvas.height = 0, this.canvas.className = "inkEditorCanvas", _e.AnnotationEditor._l10nPromise.get("editor_ink_canvas_aria_label").then(Oe => this.canvas?.setAttribute("aria-label", Oe)), this.div.append(this.canvas), this.ctx = this.canvas.getContext("2d") } #O() { this.#p = new ResizeObserver(Oe => { const je = Oe[0].contentRect; je.width && je.height && this.setDimensions(je.width, je.height) }), this.#p.observe(this.div) } get isResizable() { return !this.isEmpty() && this.#l } render() { if (this.div) return this.div; let Oe, je; this.width && (Oe = this.x, je = this.y), super.render(), _e.AnnotationEditor._l10nPromise.get("editor_ink2_aria_label").then(qe => this.div?.setAttribute("aria-label", qe)); const [Be, Ie, Fe, ze] = this.#d(); if (this.setAt(Be, Ie, 0, 0), this.setDims(Fe, ze), this.#P(), this.width) { const [qe, He] = this.parentDimensions; this.setAspectRatio(this.width * qe, this.height * He), this.setAt(Oe * qe, je * He, this.width * qe, this.height * He), this.#i = !0, this.#w(), this.setDims(this.width * qe, this.height * He), this.#E(), this.div.classList.add("disabled") } else this.div.classList.add("editing"), this.enableEditMode(); return this.#O(), this.div } #w() { if (!this.#i) return; const [Oe, je] = this.parentDimensions; this.canvas.width = Math.ceil(this.width * Oe), this.canvas.height = Math.ceil(this.height * je), this.#R() } setDimensions(Oe, je) { const Be = Math.round(Oe), Ie = Math.round(je); if (this.#u === Be && this.#h === Ie) return; this.#u = Be, this.#h = Ie, this.canvas.style.visibility = "hidden"; const [Fe, ze] = this.parentDimensions; this.width = Oe / Fe, this.height = je / ze, this.fixAndSetPosition(), this.#l && this.#T(Oe, je), this.#w(), this.#E(), this.canvas.style.visibility = "visible", this.fixDims() } #T(Oe, je) { const Be = this.#j(), Ie = (Oe - Be) / this.#t, Fe = (je - Be) / this.#e; this.scaleFactor = Math.min(Ie, Fe) } #R() { const Oe = this.#j() / 2; this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + Oe, this.translationY * this.scaleFactor + Oe) } static #I(Oe) { const je = new Path2D; for (let Be = 0, Ie = Oe.length; Be < Ie; Be++) { const [Fe, ze, qe, He] = Oe[Be]; Be === 0 && je.moveTo(...Fe), je.bezierCurveTo(ze[0], ze[1], qe[0], qe[1], He[0], He[1]) } return je } static #F(Oe, je, Be) { const [Ie, Fe, ze, qe] = je; switch (Be) { case 0: for (let He = 0, Ge = Oe.length; He < Ge; He += 2)Oe[He] += Ie, Oe[He + 1] = qe - Oe[He + 1]; break; case 90: for (let He = 0, Ge = Oe.length; He < Ge; He += 2) { const Ze = Oe[He]; Oe[He] = Oe[He + 1] + Ie, Oe[He + 1] = Ze + Fe } break; case 180: for (let He = 0, Ge = Oe.length; He < Ge; He += 2)Oe[He] = ze - Oe[He], Oe[He + 1] += Fe; break; case 270: for (let He = 0, Ge = Oe.length; He < Ge; He += 2) { const Ze = Oe[He]; Oe[He] = ze - Oe[He + 1], Oe[He + 1] = qe - Ze } break; default: throw new Error("Invalid rotation") }return Oe } static #B(Oe, je, Be) { const [Ie, Fe, ze, qe] = je; switch (Be) { case 0: for (let He = 0, Ge = Oe.length; He < Ge; He += 2)Oe[He] -= Ie, Oe[He + 1] = qe - Oe[He + 1]; break; case 90: for (let He = 0, Ge = Oe.length; He < Ge; He += 2) { const Ze = Oe[He]; Oe[He] = Oe[He + 1] - Fe, Oe[He + 1] = Ze - Ie } break; case 180: for (let He = 0, Ge = Oe.length; He < Ge; He += 2)Oe[He] = ze - Oe[He], Oe[He + 1] -= Fe; break; case 270: for (let He = 0, Ge = Oe.length; He < Ge; He += 2) { const Ze = Oe[He]; Oe[He] = qe - Oe[He + 1], Oe[He + 1] = ze - Ze } break; default: throw new Error("Invalid rotation") }return Oe } #U(Oe, je, Be, Ie) { const Fe = [], ze = this.thickness / 2, qe = Oe * je + ze, He = Oe * Be + ze; for (const Ge of this.paths) { const Ze = [], sn = []; for (let Xe = 0, St = Ge.length; Xe < St; Xe++) { const [un, on, bn, Tn] = Ge[Xe], fn = Oe * un[0] + qe, En = Oe * un[1] + He, Pn = Oe * on[0] + qe, Rn = Oe * on[1] + He, In = Oe * bn[0] + qe, xn = Oe * bn[1] + He, vn = Oe * Tn[0] + qe, tn = Oe * Tn[1] + He; Xe === 0 && (Ze.push(fn, En), sn.push(fn, En)), Ze.push(Pn, Rn, In, xn, vn, tn), sn.push(Pn, Rn), Xe === St - 1 && sn.push(vn, tn) } Fe.push({ bezier: De.#F(Ze, Ie, this.rotation), points: De.#F(sn, Ie, this.rotation) }) } return Fe } #L() { let Oe = 1 / 0, je = -1 / 0, Be = 1 / 0, Ie = -1 / 0; for (const Fe of this.paths) for (const [ze, qe, He, Ge] of Fe) { const Ze = Ee.Util.bezierBoundingBox(...ze, ...qe, ...He, ...Ge); Oe = Math.min(Oe, Ze[0]), Be = Math.min(Be, Ze[1]), je = Math.max(je, Ze[2]), Ie = Math.max(Ie, Ze[3]) } return [Oe, Be, je, Ie] } #j() { return this.#l ? Math.ceil(this.thickness * this.parentScale) : 0 } #C(Oe = !1) { if (this.isEmpty()) return; if (!this.#l) { this.#E(); return } const je = this.#L(), Be = this.#j(); this.#t = Math.max(_e.AnnotationEditor.MIN_SIZE, je[2] - je[0]), this.#e = Math.max(_e.AnnotationEditor.MIN_SIZE, je[3] - je[1]); const Ie = Math.ceil(Be + this.#t * this.scaleFactor), Fe = Math.ceil(Be + this.#e * this.scaleFactor), [ze, qe] = this.parentDimensions; this.width = Ie / ze, this.height = Fe / qe, this.setAspectRatio(Ie, Fe); const He = this.translationX, Ge = this.translationY; this.translationX = -je[0], this.translationY = -je[1], this.#w(), this.#E(), this.#u = Ie, this.#h = Fe, this.setDims(Ie, Fe); const Ze = Oe ? Be / this.scaleFactor / 2 : 0; this.translate(He - this.translationX - Ze, Ge - this.translationY - Ze) } static deserialize(Oe, je, Be) { if (Oe instanceof Re.InkAnnotationElement) return null; const Ie = super.deserialize(Oe, je, Be); Ie.thickness = Oe.thickness, Ie.color = Ee.Util.makeHexColor(...Oe.color), Ie.opacity = Oe.opacity; const [Fe, ze] = Ie.pageDimensions, qe = Ie.width * Fe, He = Ie.height * ze, Ge = Ie.parentScale, Ze = Oe.thickness / 2; Ie.#l = !0, Ie.#u = Math.round(qe), Ie.#h = Math.round(He); const { paths: sn, rect: Xe, rotation: St } = Oe; for (let { bezier: on } of sn) { on = De.#B(on, Xe, St); const bn = []; Ie.paths.push(bn); let Tn = Ge * (on[0] - Ze), fn = Ge * (on[1] - Ze); for (let Pn = 2, Rn = on.length; Pn < Rn; Pn += 6) { const In = Ge * (on[Pn] - Ze), xn = Ge * (on[Pn + 1] - Ze), vn = Ge * (on[Pn + 2] - Ze), tn = Ge * (on[Pn + 3] - Ze), nn = Ge * (on[Pn + 4] - Ze), We = Ge * (on[Pn + 5] - Ze); bn.push([[Tn, fn], [In, xn], [vn, tn], [nn, We]]), Tn = nn, fn = We } const En = this.#I(bn); Ie.bezierPath2D.push(En) } const un = Ie.#L(); return Ie.#t = Math.max(_e.AnnotationEditor.MIN_SIZE, un[2] - un[0]), Ie.#e = Math.max(_e.AnnotationEditor.MIN_SIZE, un[3] - un[1]), Ie.#T(qe, He), Ie } serialize() { if (this.isEmpty()) return null; const Oe = this.getRect(0, 0), je = _e.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle); return { annotationType: Ee.AnnotationEditorType.INK, color: je, thickness: this.thickness, opacity: this.opacity, paths: this.#U(this.scaleFactor / this.parentScale, this.translationX, this.translationY, Oe), pageIndex: this.pageIndex, rect: Oe, rotation: this.rotation, structTreeParentId: this._structTreeParentId } } } t.InkEditor = De }, (e, t, xe) => { Object.defineProperty(t, "__esModule", { value: !0 }), t.StampEditor = void 0; var Ee = xe(1), _e = xe(4), Re = xe(6), Ce = xe(29); class Me extends _e.AnnotationEditor { #e = null; #t = null; #n = null; #r = null; #a = null; #o = null; #s = null; #l = null; #c = !1; #i = !1; static _type = "stamp"; constructor(Pe) { super({ ...Pe, name: "stampEditor" }), this.#r = Pe.bitmapUrl, this.#a = Pe.bitmapFile } static initialize(Pe) { _e.AnnotationEditor.initialize(Pe) } static get supportedTypes() { const Pe = ["apng", "avif", "bmp", "gif", "jpeg", "png", "svg+xml", "webp", "x-icon"]; return (0, Ee.shadow)(this, "supportedTypes", Pe.map(Oe => `image/${Oe}`)) } static get supportedTypesStr() { return (0, Ee.shadow)(this, "supportedTypesStr", this.supportedTypes.join(",")) } static isHandlingMimeForPasting(Pe) { return this.supportedTypes.includes(Pe) } static paste(Pe, Oe) { Oe.pasteEditor(Ee.AnnotationEditorType.STAMP, { bitmapFile: Pe.getAsFile() }) } #p(Pe, Oe = !1) { if (!Pe) { this.remove(); return } this.#e = Pe.bitmap, Oe || (this.#t = Pe.id, this.#c = Pe.isSvg), this.#f() } #u() { this.#n = null, this._uiManager.enableWaiting(!1), this.#o && this.div.focus() } #h() { if (this.#t) { this._uiManager.enableWaiting(!0), this._uiManager.imageManager.getFromId(this.#t).then(Oe => this.#p(Oe, !0)).finally(() => this.#u()); return } if (this.#r) { const Oe = this.#r; this.#r = null, this._uiManager.enableWaiting(!0), this.#n = this._uiManager.imageManager.getFromUrl(Oe).then(je => this.#p(je)).finally(() => this.#u()); return } if (this.#a) { const Oe = this.#a; this.#a = null, this._uiManager.enableWaiting(!0), this.#n = this._uiManager.imageManager.getFromFile(Oe).then(je => this.#p(je)).finally(() => this.#u()); return } const Pe = document.createElement("input"); Pe.type = "file", Pe.accept = Me.supportedTypesStr, this.#n = new Promise(Oe => { Pe.addEventListener("change", async () => { if (!Pe.files || Pe.files.length === 0) this.remove(); else { this._uiManager.enableWaiting(!0); const je = await this._uiManager.imageManager.getFromFile(Pe.files[0]); this.#p(je) } Oe() }), Pe.addEventListener("cancel", () => { this.remove(), Oe() }) }).finally(() => this.#u()), Pe.click() } remove() { this.#t && (this.#e = null, this._uiManager.imageManager.deleteId(this.#t), this.#o?.remove(), this.#o = null, this.#s?.disconnect(), this.#s = null), super.remove() } rebuild() { if (!this.parent) { this.#t && this.#h(); return } super.rebuild(), this.div !== null && (this.#t && this.#h(), this.isAttachedToDOM || this.parent.add(this)) } onceAdded() { this._isDraggable = !0, this.div.focus() } isEmpty() { return !(this.#n || this.#e || this.#r || this.#a) } get isResizable() { return !0 } render() { if (this.div) return this.div; let Pe, Oe; if (this.width && (Pe = this.x, Oe = this.y), super.render(), this.div.hidden = !0, this.#e ? this.#f() : this.#h(), this.width) { const [je, Be] = this.parentDimensions; this.setAt(Pe * je, Oe * Be, this.width * je, this.height * Be) } return this.div } #f() { const { div: Pe } = this; let { width: Oe, height: je } = this.#e; const [Be, Ie] = this.pageDimensions, Fe = .75; if (this.width) Oe = this.width * Be, je = this.height * Ie; else if (Oe > Fe * Be || je > Fe * Ie) { const Ge = Math.min(Fe * Be / Oe, Fe * Ie / je); Oe *= Ge, je *= Ge } const [ze, qe] = this.parentDimensions; this.setDims(Oe * ze / Be, je * qe / Ie), this._uiManager.enableWaiting(!1); const He = this.#o = document.createElement("canvas"); Pe.append(He), Pe.hidden = !1, this.#g(Oe, je), this.#b(), this.#i || (this.parent.addUndoableEditor(this), this.#i = !0), this._uiManager._eventBus.dispatch("reporttelemetry", { source: this, details: { type: "editing", subtype: this.editorType, data: { action: "inserted_image" } } }), this.addAltTextButton() } #v(Pe, Oe) { const [je, Be] = this.parentDimensions; this.width = Pe / je, this.height = Oe / Be, this.setDims(Pe, Oe), this._initialOptions?.isCentered ? this.center() : this.fixAndSetPosition(), this._initialOptions = null, this.#l !== null && clearTimeout(this.#l); const Ie = 200; this.#l = setTimeout(() => { this.#l = null, this.#g(Pe, Oe) }, Ie) } #m(Pe, Oe) { const { width: je, height: Be } = this.#e; let Ie = je, Fe = Be, ze = this.#e; for (; Ie > 2 * Pe || Fe > 2 * Oe;) { const qe = Ie, He = Fe; Ie > 2 * Pe && (Ie = Ie >= 16384 ? Math.floor(Ie / 2) - 1 : Math.ceil(Ie / 2)), Fe > 2 * Oe && (Fe = Fe >= 16384 ? Math.floor(Fe / 2) - 1 : Math.ceil(Fe / 2)); const Ge = new OffscreenCanvas(Ie, Fe); Ge.getContext("2d").drawImage(ze, 0, 0, qe, He, 0, 0, Ie, Fe), ze = Ge.transferToImageBitmap() } return ze } #g(Pe, Oe) { Pe = Math.ceil(Pe), Oe = Math.ceil(Oe); const je = this.#o; if (!je || je.width === Pe && je.height === Oe) return; je.width = Pe, je.height = Oe; const Be = this.#c ? this.#e : this.#m(Pe, Oe), Ie = je.getContext("2d"); Ie.filter = this._uiManager.hcmFilter, Ie.drawImage(Be, 0, 0, Be.width, Be.height, 0, 0, Pe, Oe) } #d(Pe) { if (Pe) { if (this.#c) { const Be = this._uiManager.imageManager.getSvgUrl(this.#t); if (Be) return Be } const Oe = document.createElement("canvas"); return { width: Oe.width, height: Oe.height } = this.#e, Oe.getContext("2d").drawImage(this.#e, 0, 0), Oe.toDataURL() } if (this.#c) { const [Oe, je] = this.pageDimensions, Be = Math.round(this.width * Oe * Re.PixelsPerInch.PDF_TO_CSS_UNITS), Ie = Math.round(this.height * je * Re.PixelsPerInch.PDF_TO_CSS_UNITS), Fe = new OffscreenCanvas(Be, Ie); return Fe.getContext("2d").drawImage(this.#e, 0, 0, this.#e.width, this.#e.height, 0, 0, Be, Ie), Fe.transferToImageBitmap() } return structuredClone(this.#e) } #b() { this.#s = new ResizeObserver(Pe => { const Oe = Pe[0].contentRect; Oe.width && Oe.height && this.#v(Oe.width, Oe.height) }), this.#s.observe(this.div) } static deserialize(Pe, Oe, je) { if (Pe instanceof Ce.StampAnnotationElement) return null; const Be = super.deserialize(Pe, Oe, je), { rect: Ie, bitmapUrl: Fe, bitmapId: ze, isSvg: qe, accessibilityData: He } = Pe; ze && je.imageManager.isValidId(ze) ? Be.#t = ze : Be.#r = Fe, Be.#c = qe; const [Ge, Ze] = Be.pageDimensions; return Be.width = (Ie[2] - Ie[0]) / Ge, Be.height = (Ie[3] - Ie[1]) / Ze, He && (Be.altTextData = He), Be } serialize(Pe = !1, Oe = null) { if (this.isEmpty()) return null; const je = { annotationType: Ee.AnnotationEditorType.STAMP, bitmapId: this.#t, pageIndex: this.pageIndex, rect: this.getRect(0, 0), rotation: this.rotation, isSvg: this.#c, structTreeParentId: this._structTreeParentId }; if (Pe) return je.bitmapUrl = this.#d(!0), je.accessibilityData = this.altTextData, je; const { decorative: Be, altText: Ie } = this.altTextData; if (!Be && Ie && (je.accessibilityData = { type: "Figure", alt: Ie }), Oe === null) return je; Oe.stamps ||= new Map; const Fe = this.#c ? (je.rect[2] - je.rect[0]) * (je.rect[3] - je.rect[1]) : null; if (!Oe.stamps.has(this.#t)) Oe.stamps.set(this.#t, { area: Fe, serialized: je }), je.bitmap = this.#d(!1); else if (this.#c) { const ze = Oe.stamps.get(this.#t); Fe > ze.area && (ze.area = Fe, ze.serialized.bitmap.close(), ze.serialized.bitmap = this.#d(!1)) } return je } } t.StampEditor = Me }], __webpack_module_cache__ = {}; function __w_pdfjs_require__(e) { var t = __webpack_module_cache__[e]; if (t !== void 0) return t.exports; var xe = __webpack_module_cache__[e] = { exports: {} }; return __webpack_modules__[e](xe, xe.exports, __w_pdfjs_require__), xe.exports } var __webpack_exports__ = {}; return (() => { var e = __webpack_exports__; Object.defineProperty(e, "__esModule", { value: !0 }), Object.defineProperty(e, "AbortException", { enumerable: !0, get: function () { return t.AbortException } }), Object.defineProperty(e, "AnnotationEditorLayer", { enumerable: !0, get: function () { return Re.AnnotationEditorLayer } }), Object.defineProperty(e, "AnnotationEditorParamsType", { enumerable: !0, get: function () { return t.AnnotationEditorParamsType } }), Object.defineProperty(e, "AnnotationEditorType", { enumerable: !0, get: function () { return t.AnnotationEditorType } }), Object.defineProperty(e, "AnnotationEditorUIManager", { enumerable: !0, get: function () { return Ce.AnnotationEditorUIManager } }), Object.defineProperty(e, "AnnotationLayer", { enumerable: !0, get: function () { return Me.AnnotationLayer } }), Object.defineProperty(e, "AnnotationMode", { enumerable: !0, get: function () { return t.AnnotationMode } }), Object.defineProperty(e, "CMapCompressionType", { enumerable: !0, get: function () { return t.CMapCompressionType } }), Object.defineProperty(e, "DOMSVGFactory", { enumerable: !0, get: function () { return Ee.DOMSVGFactory } }), Object.defineProperty(e, "FeatureTest", { enumerable: !0, get: function () { return t.FeatureTest } }), Object.defineProperty(e, "GlobalWorkerOptions", { enumerable: !0, get: function () { return De.GlobalWorkerOptions } }), Object.defineProperty(e, "ImageKind", { enumerable: !0, get: function () { return t.ImageKind } }), Object.defineProperty(e, "InvalidPDFException", { enumerable: !0, get: function () { return t.InvalidPDFException } }), Object.defineProperty(e, "MissingPDFException", { enumerable: !0, get: function () { return t.MissingPDFException } }), Object.defineProperty(e, "OPS", { enumerable: !0, get: function () { return t.OPS } }), Object.defineProperty(e, "PDFDataRangeTransport", { enumerable: !0, get: function () { return xe.PDFDataRangeTransport } }), Object.defineProperty(e, "PDFDateString", { enumerable: !0, get: function () { return Ee.PDFDateString } }), Object.defineProperty(e, "PDFWorker", { enumerable: !0, get: function () { return xe.PDFWorker } }), Object.defineProperty(e, "PasswordResponses", { enumerable: !0, get: function () { return t.PasswordResponses } }), Object.defineProperty(e, "PermissionFlag", { enumerable: !0, get: function () { return t.PermissionFlag } }), Object.defineProperty(e, "PixelsPerInch", { enumerable: !0, get: function () { return Ee.PixelsPerInch } }), Object.defineProperty(e, "PromiseCapability", { enumerable: !0, get: function () { return t.PromiseCapability } }), Object.defineProperty(e, "RenderingCancelledException", { enumerable: !0, get: function () { return Ee.RenderingCancelledException } }), Object.defineProperty(e, "SVGGraphics", { enumerable: !0, get: function () { return xe.SVGGraphics } }), Object.defineProperty(e, "UnexpectedResponseException", { enumerable: !0, get: function () { return t.UnexpectedResponseException } }), Object.defineProperty(e, "Util", { enumerable: !0, get: function () { return t.Util } }), Object.defineProperty(e, "VerbosityLevel", { enumerable: !0, get: function () { return t.VerbosityLevel } }), Object.defineProperty(e, "XfaLayer", { enumerable: !0, get: function () { return Pe.XfaLayer } }), Object.defineProperty(e, "build", { enumerable: !0, get: function () { return xe.build } }), Object.defineProperty(e, "createValidAbsoluteUrl", { enumerable: !0, get: function () { return t.createValidAbsoluteUrl } }), Object.defineProperty(e, "getDocument", { enumerable: !0, get: function () { return xe.getDocument } }), Object.defineProperty(e, "getFilenameFromUrl", { enumerable: !0, get: function () { return Ee.getFilenameFromUrl } }), Object.defineProperty(e, "getPdfFilenameFromUrl", { enumerable: !0, get: function () { return Ee.getPdfFilenameFromUrl } }), Object.defineProperty(e, "getXfaPageViewport", { enumerable: !0, get: function () { return Ee.getXfaPageViewport } }), Object.defineProperty(e, "isDataScheme", { enumerable: !0, get: function () { return Ee.isDataScheme } }), Object.defineProperty(e, "isPdfFile", { enumerable: !0, get: function () { return Ee.isPdfFile } }), Object.defineProperty(e, "loadScript", { enumerable: !0, get: function () { return Ee.loadScript } }), Object.defineProperty(e, "noContextMenu", { enumerable: !0, get: function () { return Ee.noContextMenu } }), Object.defineProperty(e, "normalizeUnicode", { enumerable: !0, get: function () { return t.normalizeUnicode } }), Object.defineProperty(e, "renderTextLayer", { enumerable: !0, get: function () { return _e.renderTextLayer } }), Object.defineProperty(e, "setLayerDimensions", { enumerable: !0, get: function () { return Ee.setLayerDimensions } }), Object.defineProperty(e, "shadow", { enumerable: !0, get: function () { return t.shadow } }), Object.defineProperty(e, "updateTextLayer", { enumerable: !0, get: function () { return _e.updateTextLayer } }), Object.defineProperty(e, "version", { enumerable: !0, get: function () { return xe.version } }); var t = __w_pdfjs_require__(1), xe = __w_pdfjs_require__(2), Ee = __w_pdfjs_require__(6), _e = __w_pdfjs_require__(26), Re = __w_pdfjs_require__(27), Ce = __w_pdfjs_require__(5), Me = __w_pdfjs_require__(29), De = __w_pdfjs_require__(14), Pe = __w_pdfjs_require__(32) })(), __webpack_exports__
    })())
  }(pdf$1)), pdf$1.exports
} var pdfExports = requirePdf(); const pdf = getDefaultExportFromCjs(pdfExports), pdfjsModule = _mergeNamespaces({ __proto__: null, default: pdf }, [pdfExports]), pdfjs = "default" in pdfjsModule ? pdf : pdfjsModule; var propTypes = { exports: {} }, ReactPropTypesSecret_1, hasRequiredReactPropTypesSecret; function requireReactPropTypesSecret() { if (hasRequiredReactPropTypesSecret) return ReactPropTypesSecret_1; hasRequiredReactPropTypesSecret = 1; var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED"; return ReactPropTypesSecret_1 = e, ReactPropTypesSecret_1 } var factoryWithThrowingShims, hasRequiredFactoryWithThrowingShims; function requireFactoryWithThrowingShims() { if (hasRequiredFactoryWithThrowingShims) return factoryWithThrowingShims; hasRequiredFactoryWithThrowingShims = 1; var e = requireReactPropTypesSecret(); function t() { } function xe() { } return xe.resetWarningCache = t, factoryWithThrowingShims = function () { function Ee(Ce, Me, De, Pe, Oe, je) { if (je !== e) { var Be = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"); throw Be.name = "Invariant Violation", Be } } Ee.isRequired = Ee; function _e() { return Ee } var Re = { array: Ee, bigint: Ee, bool: Ee, func: Ee, number: Ee, object: Ee, string: Ee, symbol: Ee, any: Ee, arrayOf: _e, element: Ee, elementType: Ee, instanceOf: _e, node: Ee, objectOf: _e, oneOf: _e, oneOfType: _e, shape: _e, exact: _e, checkPropTypes: xe, resetWarningCache: t }; return Re.PropTypes = Re, Re }, factoryWithThrowingShims } var hasRequiredPropTypes; function requirePropTypes() { return hasRequiredPropTypes || (hasRequiredPropTypes = 1, propTypes.exports = requireFactoryWithThrowingShims()()), propTypes.exports } var propTypesExports = requirePropTypes(); const PropTypes = getDefaultExportFromCjs(propTypesExports); var __spreadArray = function (e, t, xe) { if (xe || arguments.length === 2) for (var Ee = 0, _e = t.length, Re; Ee < _e; Ee++)(Re || !(Ee in t)) && (Re || (Re = Array.prototype.slice.call(t, 0, Ee)), Re[Ee] = t[Ee]); return e.concat(Re || Array.prototype.slice.call(t)) }, clipboardEvents = ["onCopy", "onCut", "onPaste"], compositionEvents = ["onCompositionEnd", "onCompositionStart", "onCompositionUpdate"], focusEvents = ["onFocus", "onBlur"], formEvents = ["onInput", "onInvalid", "onReset", "onSubmit"], imageEvents = ["onLoad", "onError"], keyboardEvents = ["onKeyDown", "onKeyPress", "onKeyUp"], mediaEvents = ["onAbort", "onCanPlay", "onCanPlayThrough", "onDurationChange", "onEmptied", "onEncrypted", "onEnded", "onError", "onLoadedData", "onLoadedMetadata", "onLoadStart", "onPause", "onPlay", "onPlaying", "onProgress", "onRateChange", "onSeeked", "onSeeking", "onStalled", "onSuspend", "onTimeUpdate", "onVolumeChange", "onWaiting"], mouseEvents = ["onClick", "onContextMenu", "onDoubleClick", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseOut", "onMouseOver", "onMouseUp"], dragEvents = ["onDrag", "onDragEnd", "onDragEnter", "onDragExit", "onDragLeave", "onDragOver", "onDragStart", "onDrop"], selectionEvents = ["onSelect"], touchEvents = ["onTouchCancel", "onTouchEnd", "onTouchMove", "onTouchStart"], pointerEvents = ["onPointerDown", "onPointerMove", "onPointerUp", "onPointerCancel", "onGotPointerCapture", "onLostPointerCapture", "onPointerEnter", "onPointerLeave", "onPointerOver", "onPointerOut"], uiEvents = ["onScroll"], wheelEvents = ["onWheel"], animationEvents = ["onAnimationStart", "onAnimationEnd", "onAnimationIteration"], transitionEvents = ["onTransitionEnd"], otherEvents = ["onToggle"], changeEvents = ["onChange"], allEvents = __spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray(__spreadArray([], clipboardEvents, !0), compositionEvents, !0), focusEvents, !0), formEvents, !0), imageEvents, !0), keyboardEvents, !0), mediaEvents, !0), mouseEvents, !0), dragEvents, !0), selectionEvents, !0), touchEvents, !0), pointerEvents, !0), uiEvents, !0), wheelEvents, !0), animationEvents, !0), transitionEvents, !0), changeEvents, !0), otherEvents, !0); function makeEventProps(e, t) { var xe = {}; return allEvents.forEach(function (Ee) { var _e = e[Ee]; _e && (t ? xe[Ee] = function (Re) { return _e(Re, t(Ee)) } : xe[Ee] = _e) }), xe } function makeCancellablePromise(e) { var t = !1, xe = new Promise(function (Ee, _e) { e.then(function (Re) { return !t && Ee(Re) }).catch(function (Re) { return !t && _e(Re) }) }); return { promise: xe, cancel: function () { t = !0 } } } var prefix = "Invariant failed"; function invariant(e, t) { if (!e) throw new Error(prefix) } var warning_1, hasRequiredWarning; function requireWarning() { if (hasRequiredWarning) return warning_1; hasRequiredWarning = 1; var e = function () { }; return warning_1 = e, warning_1 } var warningExports = requireWarning(); const warning = getDefaultExportFromCjs(warningExports); var has = Object.prototype.hasOwnProperty; function find(e, t, xe) { for (xe of e.keys()) if (dequal(xe, t)) return xe } function dequal(e, t) { var xe, Ee, _e; if (e === t) return !0; if (e && t && (xe = e.constructor) === t.constructor) { if (xe === Date) return e.getTime() === t.getTime(); if (xe === RegExp) return e.toString() === t.toString(); if (xe === Array) { if ((Ee = e.length) === t.length) for (; Ee-- && dequal(e[Ee], t[Ee]);); return Ee === -1 } if (xe === Set) { if (e.size !== t.size) return !1; for (Ee of e) if (_e = Ee, _e && typeof _e == "object" && (_e = find(t, _e), !_e) || !t.has(_e)) return !1; return !0 } if (xe === Map) { if (e.size !== t.size) return !1; for (Ee of e) if (_e = Ee[0], _e && typeof _e == "object" && (_e = find(t, _e), !_e) || !dequal(Ee[1], t.get(_e))) return !1; return !0 } if (xe === ArrayBuffer) e = new Uint8Array(e), t = new Uint8Array(t); else if (xe === DataView) { if ((Ee = e.byteLength) === t.byteLength) for (; Ee-- && e.getInt8(Ee) === t.getInt8(Ee);); return Ee === -1 } if (ArrayBuffer.isView(e)) { if ((Ee = e.byteLength) === t.byteLength) for (; Ee-- && e[Ee] === t[Ee];); return Ee === -1 } if (!xe || typeof e == "object") { Ee = 0; for (xe in e) if (has.call(e, xe) && ++Ee && !has.call(t, xe) || !(xe in t) || !dequal(e[xe], t[xe])) return !1; return Object.keys(t).length === Ee } } return e !== e && t !== t } const DocumentContext = reactExports.createContext(null); function Message({ children: e, type: t }) { return React.createElement("div", { className: `react-pdf__message react-pdf__message--${t}` }, e) } const DEFAULT_LINK_REL = "noopener noreferrer nofollow"; class LinkService { constructor() { this.externalLinkEnabled = !0, this.externalLinkRel = void 0, this.externalLinkTarget = void 0, this.isInPresentationMode = !1, this.pdfDocument = void 0, this.pdfViewer = void 0 } setDocument(t) { this.pdfDocument = t } setViewer(t) { this.pdfViewer = t } setExternalLinkRel(t) { this.externalLinkRel = t } setExternalLinkTarget(t) { this.externalLinkTarget = t } setHistory() { } get pagesCount() { return this.pdfDocument ? this.pdfDocument.numPages : 0 } get page() { return invariant(this.pdfViewer), this.pdfViewer.currentPageNumber || 0 } set page(t) { invariant(this.pdfViewer), this.pdfViewer.currentPageNumber = t } get rotation() { return 0 } set rotation(t) { } goToDestination(t) { return new Promise(xe => { invariant(this.pdfDocument), invariant(t), typeof t == "string" ? this.pdfDocument.getDestination(t).then(xe) : Array.isArray(t) ? xe(t) : t.then(xe) }).then(xe => { invariant(Array.isArray(xe)); const Ee = xe[0]; new Promise(_e => { invariant(this.pdfDocument), Ee instanceof Object ? this.pdfDocument.getPageIndex(Ee).then(Re => { _e(Re) }).catch(() => { invariant(!1) }) : typeof Ee == "number" ? _e(Ee) : invariant(!1) }).then(_e => { const Re = _e + 1; invariant(this.pdfViewer), invariant(Re >= 1 && Re <= this.pagesCount), this.pdfViewer.scrollPageIntoView({ dest: xe, pageIndex: _e, pageNumber: Re }) }) }) } navigateTo(t) { this.goToDestination(t) } goToPage(t) { const xe = t - 1; invariant(this.pdfViewer), invariant(t >= 1 && t <= this.pagesCount), this.pdfViewer.scrollPageIntoView({ pageIndex: xe, pageNumber: t }) } addLinkAttributes(t, xe, Ee) { t.href = xe, t.rel = this.externalLinkRel || DEFAULT_LINK_REL, t.target = Ee ? "_blank" : this.externalLinkTarget || "" } getDestinationHash() { return "#" } getAnchorUrl() { return "#" } setHash() { } executeNamedAction() { } cachePageRef() { } isPageVisible() { return !0 } isPageCached() { return !0 } executeSetOCGState() { } } const PasswordResponses = { NEED_PASSWORD: 1, INCORRECT_PASSWORD: 2 }, isBrowser = typeof document < "u", isLocalFileSystem = isBrowser && window.location.protocol === "file:"; function isDefined(e) { return typeof e < "u" } function isProvided(e) { return isDefined(e) && e !== null } function isString(e) { return typeof e == "string" } function isArrayBuffer(e) { return e instanceof ArrayBuffer } function isBlob(e) { return invariant(isBrowser), e instanceof Blob } function isDataURI(e) { return isString(e) && /^data:/.test(e) } function dataURItoByteString(e) { invariant(isDataURI(e)); const [t = "", xe = ""] = e.split(","); return t.split(";").indexOf("base64") !== -1 ? atob(xe) : unescape(xe) } function getDevicePixelRatio() { return isBrowser && window.devicePixelRatio || 1 } const allowFileAccessFromFilesTip = "On Chromium based browsers, you can use --allow-file-access-from-files flag for debugging purposes."; function displayCORSWarning() { warning(!isLocalFileSystem, `Loading PDF as base64 strings/URLs may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`) } function displayWorkerWarning() { warning(!isLocalFileSystem, `Loading PDF.js worker may not work on protocols other than HTTP/HTTPS. ${allowFileAccessFromFilesTip}`) } function cancelRunningTask(e) { e && e.cancel && e.cancel() } function makePageCallback(e, t) { return Object.defineProperty(e, "width", { get() { return this.view[2] * t }, configurable: !0 }), Object.defineProperty(e, "height", { get() { return this.view[3] * t }, configurable: !0 }), Object.defineProperty(e, "originalWidth", { get() { return this.view[2] }, configurable: !0 }), Object.defineProperty(e, "originalHeight", { get() { return this.view[3] }, configurable: !0 }), e } function isCancelException(e) { return e.name === "RenderingCancelledException" } function loadFromFile(e) { return new Promise((t, xe) => { const Ee = new FileReader; Ee.onload = () => { if (!Ee.result) return xe(new Error("Error while reading a file.")); t(Ee.result) }, Ee.onerror = _e => { if (!_e.target) return xe(new Error("Error while reading a file.")); const { error: Re } = _e.target; if (!Re) return xe(new Error("Error while reading a file.")); switch (Re.code) { case Re.NOT_FOUND_ERR: return xe(new Error("Error while reading a file: File not found.")); case Re.SECURITY_ERR: return xe(new Error("Error while reading a file: Security error.")); case Re.ABORT_ERR: return xe(new Error("Error while reading a file: Aborted.")); default: return xe(new Error("Error while reading a file.")) } }, Ee.readAsArrayBuffer(e) }) } function reducer(e, t) { switch (t.type) { case "RESOLVE": return { value: t.value, error: void 0 }; case "REJECT": return { value: !1, error: t.error }; case "RESET": return { value: void 0, error: void 0 }; default: return e } } function useResolver() { return reactExports.useReducer(reducer, { value: void 0, error: void 0 }) } const { PDFDataRangeTransport: PDFDataRangeTransport$1 } = pdfjs, eventProps = (() => { const e = {}; return allEvents.forEach(t => { e[t] = PropTypes.func }), e })(), isTypedArray = PropTypes.oneOfType([PropTypes.instanceOf(Int8Array), PropTypes.instanceOf(Uint8Array), PropTypes.instanceOf(Uint8ClampedArray), PropTypes.instanceOf(Int16Array), PropTypes.instanceOf(Uint16Array), PropTypes.instanceOf(Int32Array), PropTypes.instanceOf(Uint32Array), PropTypes.instanceOf(Float32Array), PropTypes.instanceOf(Float64Array)]), fileTypes = [PropTypes.string, PropTypes.instanceOf(ArrayBuffer), PropTypes.shape({ data: PropTypes.oneOfType([PropTypes.string, PropTypes.instanceOf(ArrayBuffer), PropTypes.arrayOf(PropTypes.number.isRequired), isTypedArray]).isRequired }), PropTypes.shape({ range: PropTypes.instanceOf(PDFDataRangeTransport$1).isRequired }), PropTypes.shape({ url: PropTypes.string.isRequired })]; typeof Blob < "u" && fileTypes.push(PropTypes.instanceOf(Blob)); const isClassName = PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string)]), isFile = PropTypes.oneOfType(fileTypes); PropTypes.instanceOf(LinkService); PropTypes.oneOf(["_self", "_blank", "_parent", "_top"]); PropTypes.shape({ commonObjs: PropTypes.shape({}).isRequired, getAnnotations: PropTypes.func.isRequired, getTextContent: PropTypes.func.isRequired, getViewport: PropTypes.func.isRequired, render: PropTypes.func.isRequired }); const isPageIndex = function e(t, xe, Ee) { const { [xe]: _e, pageNumber: Re, pdf: Ce } = t; if (!isDefined(Ce)) return null; if (isDefined(_e)) { if (typeof _e != "number") return new Error(`\`${xe}\` of type \`${typeof _e}\` supplied to \`${Ee}\`, expected \`number\`.`); if (_e < 0) return new Error(`Expected \`${xe}\` to be greater or equal to 0.`); const { numPages: Me } = Ce; if (_e + 1 > Me) return new Error(`Expected \`${xe}\` to be less or equal to ${Me - 1}.`) } else if (!isDefined(Re)) return new Error(`\`${xe}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${Ee}\`.`); return null }, isPageNumber = function e(t, xe, Ee) { const { [xe]: _e, pageIndex: Re, pdf: Ce } = t; if (!isDefined(Ce)) return null; if (isDefined(_e)) { if (typeof _e != "number") return new Error(`\`${xe}\` of type \`${typeof _e}\` supplied to \`${Ee}\`, expected \`number\`.`); if (_e < 1) return new Error(`Expected \`${xe}\` to be greater or equal to 1.`); const { numPages: Me } = Ce; if (_e > Me) return new Error(`Expected \`${xe}\` to be less or equal to ${Me}.`) } else if (!isDefined(Re)) return new Error(`\`${xe}\` not supplied. Either pageIndex or pageNumber must be supplied to \`${Ee}\`.`); return null }, isPdf = PropTypes.oneOfType([PropTypes.any, PropTypes.oneOf([!1])]), isRef = PropTypes.oneOfType([PropTypes.func, PropTypes.exact({ current: PropTypes.any })]), isRenderMode = PropTypes.oneOf(["canvas", "custom", "none", "svg"]), isRotate = PropTypes.oneOf([0, 90, 180, 270]); var __awaiter = function (e, t, xe, Ee) { function _e(Re) { return Re instanceof xe ? Re : new xe(function (Ce) { Ce(Re) }) } return new (xe || (xe = Promise))(function (Re, Ce) { function Me(Oe) { try { Pe(Ee.next(Oe)) } catch (je) { Ce(je) } } function De(Oe) { try { Pe(Ee.throw(Oe)) } catch (je) { Ce(je) } } function Pe(Oe) { Oe.done ? Re(Oe.value) : _e(Oe.value).then(Me, De) } Pe((Ee = Ee.apply(e, t || [])).next()) }) }, __rest$1 = function (e, t) { var xe = {}; for (var Ee in e) Object.prototype.hasOwnProperty.call(e, Ee) && t.indexOf(Ee) < 0 && (xe[Ee] = e[Ee]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var _e = 0, Ee = Object.getOwnPropertySymbols(e); _e < Ee.length; _e++)t.indexOf(Ee[_e]) < 0 && Object.prototype.propertyIsEnumerable.call(e, Ee[_e]) && (xe[Ee[_e]] = e[Ee[_e]]); return xe }; const { PDFDataRangeTransport } = pdfjs, defaultOnPassword = (e, t) => { switch (t) { case PasswordResponses.NEED_PASSWORD: { const xe = prompt("Enter the password to open this PDF file."); e(xe); break } case PasswordResponses.INCORRECT_PASSWORD: { const xe = prompt("Invalid password. Please try again."); e(xe); break } } }; function isParameterObject(e) { return typeof e == "object" && e !== null && ("data" in e || "range" in e || "url" in e) } const Document = reactExports.forwardRef(function e(t, xe) { var { children: Ee, className: _e, error: Re = "Failed to load PDF file.", externalLinkRel: Ce, externalLinkTarget: Me, file: De, inputRef: Pe, imageResourcesPath: Oe, loading: je = "Loading PDF…", noData: Be = "No PDF file specified.", onItemClick: Ie, onLoadError: Fe, onLoadProgress: ze, onLoadSuccess: qe, onPassword: He = defaultOnPassword, onSourceError: Ge, onSourceSuccess: Ze, options: sn, renderMode: Xe, rotate: St } = t, un = __rest$1(t, ["children", "className", "error", "externalLinkRel", "externalLinkTarget", "file", "inputRef", "imageResourcesPath", "loading", "noData", "onItemClick", "onLoadError", "onLoadProgress", "onLoadSuccess", "onPassword", "onSourceError", "onSourceSuccess", "options", "renderMode", "rotate"]); const [on, bn] = useResolver(), { value: Tn, error: fn } = on, [En, Pn] = useResolver(), { value: Rn, error: In } = En, xn = reactExports.useRef(new LinkService), vn = reactExports.useRef([]), tn = reactExports.useRef(), nn = reactExports.useRef(); reactExports.useEffect(() => { De && De !== tn.current && isParameterObject(De) && (warning(!dequal(De, tn.current), `File prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "file" prop.`), tn.current = De) }, [De]), reactExports.useEffect(() => { sn && sn !== nn.current && (warning(!dequal(sn, nn.current), `Options prop passed to <Document /> changed, but it's equal to previous one. This might result in unnecessary reloads. Consider memoizing the value passed to "options" prop.`), nn.current = sn) }, [sn]); const We = reactExports.useRef({ scrollPageIntoView: Cn => { const { dest: Vn, pageNumber: Yn, pageIndex: qn = Yn - 1 } = Cn; if (Ie) { Ie({ dest: Vn, pageIndex: qn, pageNumber: Yn }); return } const rr = vn.current[qn]; if (rr) { rr.scrollIntoView(); return } warning(!1, `An internal link leading to page ${Yn} was clicked, but neither <Document> was provided with onItemClick nor it was able to find the page within itself. Either provide onItemClick to <Document> and handle navigating by yourself or ensure that all pages are rendered within <Document>.`) } }); reactExports.useImperativeHandle(xe, () => ({ linkService: xn, pages: vn, viewer: We }), []); function dn() { Ze && Ze() } function Je() { fn && (warning(!1, fn.toString()), Ge && Ge(fn)) } function rn() { bn({ type: "RESET" }) } reactExports.useEffect(rn, [De, bn]); const hn = reactExports.useCallback(() => __awaiter(this, void 0, void 0, function* () { if (!De) return null; if (typeof De == "string") return isDataURI(De) ? { data: dataURItoByteString(De) } : (displayCORSWarning(), { url: De }); if (De instanceof PDFDataRangeTransport) return { range: De }; if (isArrayBuffer(De)) return { data: De }; if (isBrowser && isBlob(De)) return { data: yield loadFromFile(De) }; if (invariant(typeof De == "object"), invariant(isParameterObject(De)), "url" in De && typeof De.url == "string") { if (isDataURI(De.url)) { const { url: Cn } = De, Vn = __rest$1(De, ["url"]), Yn = dataURItoByteString(Cn); return Object.assign({ data: Yn }, Vn) } displayCORSWarning() } return De }), [De]); reactExports.useEffect(() => { const Cn = makeCancellablePromise(hn()); return Cn.promise.then(Vn => { bn({ type: "RESOLVE", value: Vn }) }).catch(Vn => { bn({ type: "REJECT", error: Vn }) }), () => { cancelRunningTask(Cn) } }, [hn, bn]), reactExports.useEffect(() => { if (!(typeof Tn > "u")) { if (Tn === !1) { Je(); return } dn() } }, [Tn]); function mn() { Rn && (qe && qe(Rn), vn.current = new Array(Rn.numPages), xn.current.setDocument(Rn)) } function Ye() { In && (warning(!1, In.toString()), Fe && Fe(In)) } function an() { Pn({ type: "RESET" }) } reactExports.useEffect(an, [Pn, Tn]); function pn() { if (!Tn) return; const Cn = Object.assign(Object.assign({}, sn), { isEvalSupported: !1 }), Vn = Object.assign(Object.assign({}, Tn), Cn), Yn = pdfjs.getDocument(Vn); ze && (Yn.onProgress = ze), He && (Yn.onPassword = He); const qn = Yn; return qn.promise.then(rr => { Pn({ type: "RESOLVE", value: rr }) }).catch(rr => { qn.destroyed || Pn({ type: "REJECT", error: rr }) }), () => { qn.destroy() } } reactExports.useEffect(pn, [sn, Pn, Tn]), reactExports.useEffect(() => { if (!(typeof Rn > "u")) { if (Rn === !1) { Ye(); return } mn() } }, [Rn]); function yn() { xn.current.setViewer(We.current), xn.current.setExternalLinkRel(Ce), xn.current.setExternalLinkTarget(Me) } reactExports.useEffect(yn, [Ce, Me]); function _n(Cn, Vn) { vn.current[Cn] = Vn } function On(Cn) { delete vn.current[Cn] } const kn = reactExports.useMemo(() => ({ imageResourcesPath: Oe, linkService: xn.current, onItemClick: Ie, pdf: Rn, registerPage: _n, renderMode: Xe, rotate: St, unregisterPage: On }), [Oe, Ie, Rn, Xe, St]), zn = reactExports.useMemo(() => makeEventProps(un, () => Rn), [un, Rn]); function sr() { return React.createElement(DocumentContext.Provider, { value: kn }, Ee) } function Fn() { return De ? Rn == null ? React.createElement(Message, { type: "loading" }, typeof je == "function" ? je() : je) : Rn === !1 ? React.createElement(Message, { type: "error" }, typeof Re == "function" ? Re() : Re) : sr() : React.createElement(Message, { type: "no-data" }, typeof Be == "function" ? Be() : Be) } return React.createElement("div", Object.assign({ className: clsx("react-pdf__Document", _e), ref: Pe, style: { "--scale-factor": "1" } }, zn), Fn()) }), isFunctionOrNode$1 = PropTypes.oneOfType([PropTypes.func, PropTypes.node]); Document.propTypes = Object.assign(Object.assign({}, eventProps), { children: PropTypes.node, className: isClassName, error: isFunctionOrNode$1, externalLinkRel: PropTypes.string, externalLinkTarget: PropTypes.oneOf(["_self", "_blank", "_parent", "_top"]), file: isFile, imageResourcesPath: PropTypes.string, inputRef: isRef, loading: isFunctionOrNode$1, noData: isFunctionOrNode$1, onItemClick: PropTypes.func, onLoadError: PropTypes.func, onLoadProgress: PropTypes.func, onLoadSuccess: PropTypes.func, onPassword: PropTypes.func, onSourceError: PropTypes.func, onSourceSuccess: PropTypes.func, options: PropTypes.shape({ canvasFactory: PropTypes.any, canvasMaxAreaInBytes: PropTypes.number, cMapPacked: PropTypes.bool, CMapReaderFactory: PropTypes.any, cMapUrl: PropTypes.string, disableAutoFetch: PropTypes.bool, disableFontFace: PropTypes.bool, disableRange: PropTypes.bool, disableStream: PropTypes.bool, docBaseUrl: PropTypes.string, enableXfa: PropTypes.bool, filterFactory: PropTypes.any, fontExtraProperties: PropTypes.bool, httpHeaders: PropTypes.object, isEvalSupported: PropTypes.bool, isOffscreenCanvasSupported: PropTypes.bool, length: PropTypes.number, maxImageSize: PropTypes.number, ownerDocument: PropTypes.any, password: PropTypes.string, pdfBug: PropTypes.bool, rangeChunkSize: PropTypes.number, StandardFontDataFactory: PropTypes.any, standardFontDataUrl: PropTypes.string, stopAtErrors: PropTypes.bool, useSystemFonts: PropTypes.bool, useWorkerFetch: PropTypes.bool, verbosity: PropTypes.number, withCredentials: PropTypes.bool, worker: PropTypes.any }), rotate: PropTypes.number }); function useDocumentContext() { return reactExports.useContext(DocumentContext) } function mergeRefs() { for (var e = [], t = 0; t < arguments.length; t++)e[t] = arguments[t]; var xe = e.filter(Boolean); if (xe.length <= 1) { var Ee = xe[0]; return Ee || null } return function (Re) { xe.forEach(function (Ce) { typeof Ce == "function" ? Ce(Re) : Ce && (Ce.current = Re) }) } } const PageContext = reactExports.createContext(null), PDF_ROLE_TO_HTML_ROLE = { Document: null, DocumentFragment: null, Part: "group", Sect: "group", Div: "group", Aside: "note", NonStruct: "none", P: null, H: "heading", Title: null, FENote: "note", Sub: "group", Lbl: null, Span: null, Em: null, Strong: null, Link: "link", Annot: "note", Form: "form", Ruby: null, RB: null, RT: null, RP: null, Warichu: null, WT: null, WP: null, L: "list", LI: "listitem", LBody: null, Table: "table", TR: "row", TH: "columnheader", TD: "cell", THead: "columnheader", TBody: null, TFoot: null, Caption: null, Figure: "figure", Formula: null, Artifact: null }, HEADING_PATTERN = /^H(\d+)$/; function isPdfRole(e) { return e in PDF_ROLE_TO_HTML_ROLE } function isStructTreeNode(e) { return "children" in e } function isStructTreeNodeWithOnlyContentChild(e) { return isStructTreeNode(e) ? e.children.length === 1 && 0 in e.children && "id" in e.children[0] : !1 } function getRoleAttributes(e) { const t = {}; if (isStructTreeNode(e)) { const { role: xe } = e, Ee = xe.match(HEADING_PATTERN); if (Ee) t.role = "heading", t["aria-level"] = Number(Ee[1]); else if (isPdfRole(xe)) { const _e = PDF_ROLE_TO_HTML_ROLE[xe]; _e && (t.role = _e) } } return t } function getBaseAttributes(e) { const t = {}; if (isStructTreeNode(e)) { if (e.alt !== void 0 && (t["aria-label"] = e.alt), e.lang !== void 0 && (t.lang = e.lang), isStructTreeNodeWithOnlyContentChild(e)) { const [xe] = e.children; if (xe) { const Ee = getBaseAttributes(xe); return Object.assign(Object.assign({}, t), Ee) } } } else "id" in e && (t["aria-owns"] = e.id); return t } function getAttributes(e) { return e ? Object.assign(Object.assign({}, getRoleAttributes(e)), getBaseAttributes(e)) : null } function StructTreeItem({ className: e, node: t }) { const xe = reactExports.useMemo(() => getAttributes(t), [t]), Ee = reactExports.useMemo(() => !isStructTreeNode(t) || isStructTreeNodeWithOnlyContentChild(t) ? null : t.children.map((_e, Re) => React.createElement(StructTreeItem, { key: Re, node: _e })), [t]); return React.createElement("span", Object.assign({ className: e }, xe), Ee) } function usePageContext() { return reactExports.useContext(PageContext) } function StructTree() { const e = usePageContext(); invariant(e); const { onGetStructTreeError: t, onGetStructTreeSuccess: xe } = e, [Ee, _e] = useResolver(), { value: Re, error: Ce } = Ee, { customTextRenderer: Me, page: De } = e; function Pe() { Re && xe && xe(Re) } function Oe() { Ce && (warning(!1, Ce.toString()), t && t(Ce)) } function je() { _e({ type: "RESET" }) } reactExports.useEffect(je, [_e, De]); function Be() { if (Me || !De) return; const Ie = makeCancellablePromise(De.getStructTree()), Fe = Ie; return Ie.promise.then(ze => { _e({ type: "RESOLVE", value: ze }) }).catch(ze => { _e({ type: "REJECT", error: ze }) }), () => cancelRunningTask(Fe) } return reactExports.useEffect(Be, [Me, De, _e]), reactExports.useEffect(() => { if (Re !== void 0) { if (Re === !1) { Oe(); return } Pe() } }, [Re]), Re ? React.createElement(StructTreeItem, { className: "react-pdf__Page__structTree structTree", node: Re }) : null } const ANNOTATION_MODE = pdfjs.AnnotationMode; function PageCanvas(e) { const t = usePageContext(); invariant(t); const xe = Object.assign(Object.assign({}, t), e), { _className: Ee, canvasBackground: _e, devicePixelRatio: Re = getDevicePixelRatio(), onRenderError: Ce, onRenderSuccess: Me, page: De, renderForms: Pe, renderTextLayer: Oe, rotate: je, scale: Be } = xe, { canvasRef: Ie } = e; invariant(De); const Fe = reactExports.useRef(null); function ze() { De && Me && Me(makePageCallback(De, Be)) } function qe(Xe) { isCancelException(Xe) || (warning(!1, Xe.toString()), Ce && Ce(Xe)) } const He = reactExports.useMemo(() => De.getViewport({ scale: Be * Re, rotation: je }), [Re, De, je, Be]), Ge = reactExports.useMemo(() => De.getViewport({ scale: Be, rotation: je }), [De, je, Be]); function Ze() { if (!De) return; De.cleanup(); const { current: Xe } = Fe; if (!Xe) return; Xe.width = He.width, Xe.height = He.height, Xe.style.width = `${Math.floor(Ge.width)}px`, Xe.style.height = `${Math.floor(Ge.height)}px`, Xe.style.visibility = "hidden"; const St = { annotationMode: Pe ? ANNOTATION_MODE.ENABLE_FORMS : ANNOTATION_MODE.ENABLE, canvasContext: Xe.getContext("2d", { alpha: !1 }), viewport: He }; _e && (St.background = _e); const un = De.render(St), on = un; return un.promise.then(() => { Xe.style.visibility = "", ze() }).catch(qe), () => cancelRunningTask(on) } reactExports.useEffect(Ze, [_e, Fe, Re, De, Pe, He, Ge]); const sn = reactExports.useCallback(() => { const { current: Xe } = Fe; Xe && (Xe.width = 0, Xe.height = 0) }, [Fe]); return reactExports.useEffect(() => sn, [sn]), React.createElement("canvas", { className: `${Ee}__canvas`, dir: "ltr", ref: mergeRefs(Ie, Fe), style: { display: "block", userSelect: "none" } }, Oe ? React.createElement(StructTree, null) : null) } function PageSVG() { const e = usePageContext(); invariant(e); const { _className: t, onRenderSuccess: xe, onRenderError: Ee, page: _e, rotate: Re, scale: Ce } = e; invariant(_e); const [Me, De] = useResolver(), { value: Pe, error: Oe } = Me; function je() { _e && xe && xe(makePageCallback(_e, Ce)) } function Be() { Oe && (isCancelException(Oe) || (warning(!1, Oe.toString()), Ee && Ee(Oe))) } const Ie = reactExports.useMemo(() => _e.getViewport({ scale: Ce, rotation: Re }), [_e, Re, Ce]); function Fe() { De({ type: "RESET" }) } reactExports.useEffect(Fe, [_e, De, Ie]); function ze() { if (!_e) return; const Ze = makeCancellablePromise(_e.getOperatorList()); return Ze.promise.then(sn => { new pdfjs.SVGGraphics(_e.commonObjs, _e.objs).getSVG(sn, Ie).then(St => { if (!(St instanceof SVGElement)) throw new Error("getSVG returned unexpected result."); De({ type: "RESOLVE", value: St }) }).catch(St => { De({ type: "REJECT", error: St }) }) }).catch(sn => { De({ type: "REJECT", error: sn }) }), () => cancelRunningTask(Ze) } reactExports.useEffect(ze, [_e, De, Ie]), reactExports.useEffect(() => { if (Pe !== void 0) { if (Pe === !1) { Be(); return } je() } }, [Pe]); function qe(Ze) { if (!Ze || !Pe) return; Ze.firstElementChild || Ze.appendChild(Pe); const { width: sn, height: Xe } = Ie; Pe.setAttribute("width", `${sn}`), Pe.setAttribute("height", `${Xe}`) } const { width: He, height: Ge } = Ie; return React.createElement("div", { className: `${t}__svg`, ref: Ze => qe(Ze), style: { display: "block", backgroundColor: "white", overflow: "hidden", width: He, height: Ge, userSelect: "none" } }) } function isTextItem(e) { return "str" in e } function TextLayer() { const e = usePageContext(); invariant(e); const { customTextRenderer: t, onGetTextError: xe, onGetTextSuccess: Ee, onRenderTextLayerError: _e, onRenderTextLayerSuccess: Re, page: Ce, pageIndex: Me, pageNumber: De, rotate: Pe, scale: Oe } = e; invariant(Ce); const [je, Be] = useResolver(), { value: Ie, error: Fe } = je, ze = reactExports.useRef(null), qe = reactExports.useRef(); warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-text-layer"), 10) === 1, "TextLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-text-layer"); function He() { Ie && Ee && Ee(Ie) } function Ge() { Fe && (warning(!1, Fe.toString()), xe && xe(Fe)) } function Ze() { Be({ type: "RESET" }) } reactExports.useEffect(Ze, [Ce, Be]); function sn() { if (!Ce) return; const fn = makeCancellablePromise(Ce.getTextContent()), En = fn; return fn.promise.then(Pn => { Be({ type: "RESOLVE", value: Pn }) }).catch(Pn => { Be({ type: "REJECT", error: Pn }) }), () => cancelRunningTask(En) } reactExports.useEffect(sn, [Ce, Be]), reactExports.useEffect(() => { if (Ie !== void 0) { if (Ie === !1) { Ge(); return } He() } }, [Ie]); const Xe = reactExports.useCallback(() => { Re && Re() }, [Re]), St = reactExports.useCallback(fn => { warning(!1, fn.toString()), _e && _e(fn) }, [_e]); function un() { const fn = qe.current; fn && fn.classList.add("active") } function on() { const fn = qe.current; fn && fn.classList.remove("active") } const bn = reactExports.useMemo(() => Ce.getViewport({ scale: Oe, rotation: Pe }), [Ce, Pe, Oe]); function Tn() { if (!Ce || !Ie) return; const { current: fn } = ze; if (!fn) return; fn.innerHTML = ""; const En = Ce.streamTextContent({ includeMarkedContent: !0 }), Pn = { container: fn, textContentSource: En, viewport: bn }, Rn = pdfjs.renderTextLayer(Pn), In = Rn; return Rn.promise.then(() => { const xn = document.createElement("div"); xn.className = "endOfContent", fn.append(xn), qe.current = xn; const vn = fn.querySelectorAll('[role="presentation"]'); if (t) { let tn = 0; Ie.items.forEach((nn, We) => { if (!isTextItem(nn)) return; const dn = vn[tn]; if (!dn) return; const Je = t(Object.assign({ pageIndex: Me, pageNumber: De, itemIndex: We }, nn)); dn.innerHTML = Je, tn += nn.str && nn.hasEOL ? 2 : 1 }) } Xe() }).catch(St), () => cancelRunningTask(In) } return reactExports.useLayoutEffect(Tn, [t, St, Xe, Ce, Me, De, Ie, bn]), React.createElement("div", { className: clsx("react-pdf__Page__textContent", "textLayer"), onMouseUp: on, onMouseDown: un, ref: ze }) } function AnnotationLayer() { const e = useDocumentContext(), t = usePageContext(); invariant(t); const xe = Object.assign(Object.assign({}, e), t), { imageResourcesPath: Ee, linkService: _e, onGetAnnotationsError: Re, onGetAnnotationsSuccess: Ce, onRenderAnnotationLayerError: Me, onRenderAnnotationLayerSuccess: De, page: Pe, pdf: Oe, renderForms: je, rotate: Be, scale: Ie = 1 } = xe; invariant(Oe), invariant(Pe), invariant(_e); const [Fe, ze] = useResolver(), { value: qe, error: He } = Fe, Ge = reactExports.useRef(null); warning(parseInt(window.getComputedStyle(document.body).getPropertyValue("--react-pdf-annotation-layer"), 10) === 1, "AnnotationLayer styles not found. Read more: https://github.com/wojtekmaj/react-pdf#support-for-annotations"); function Ze() { qe && Ce && Ce(qe) } function sn() { He && (warning(!1, He.toString()), Re && Re(He)) } function Xe() { ze({ type: "RESET" }) } reactExports.useEffect(Xe, [ze, Pe]); function St() { if (!Pe) return; const fn = makeCancellablePromise(Pe.getAnnotations()), En = fn; return fn.promise.then(Pn => { ze({ type: "RESOLVE", value: Pn }) }).catch(Pn => { ze({ type: "REJECT", error: Pn }) }), () => { cancelRunningTask(En) } } reactExports.useEffect(St, [ze, Pe, je]), reactExports.useEffect(() => { if (qe !== void 0) { if (qe === !1) { sn(); return } Ze() } }, [qe]); function un() { De && De() } function on(fn) { warning(!1, `${fn}`), Me && Me(fn) } const bn = reactExports.useMemo(() => Pe.getViewport({ scale: Ie, rotation: Be }), [Pe, Be, Ie]); function Tn() { if (!Oe || !Pe || !_e || !qe) return; const { current: fn } = Ge; if (!fn) return; const En = bn.clone({ dontFlip: !0 }), Pn = { accessibilityManager: null, annotationCanvasMap: null, div: fn, l10n: null, page: Pe, viewport: En }, Rn = { annotations: qe, annotationStorage: Oe.annotationStorage, div: fn, downloadManager: null, imageResourcesPath: Ee, linkService: _e, page: Pe, renderForms: je, viewport: En }; fn.innerHTML = ""; try { new pdfjs.AnnotationLayer(Pn).render(Rn), un() } catch (In) { on(In) } return () => { } } return reactExports.useEffect(Tn, [qe, Ee, _e, Pe, je, bn]), React.createElement("div", { className: clsx("react-pdf__Page__annotations", "annotationLayer"), ref: Ge }) } var __rest = function (e, t) { var xe = {}; for (var Ee in e) Object.prototype.hasOwnProperty.call(e, Ee) && t.indexOf(Ee) < 0 && (xe[Ee] = e[Ee]); if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var _e = 0, Ee = Object.getOwnPropertySymbols(e); _e < Ee.length; _e++)t.indexOf(Ee[_e]) < 0 && Object.prototype.propertyIsEnumerable.call(e, Ee[_e]) && (xe[Ee[_e]] = e[Ee[_e]]); return xe }; const defaultScale = 1, Page = function e(t) { const xe = useDocumentContext(), Ee = Object.assign(Object.assign({}, xe), t), { _className: _e = "react-pdf__Page", _enableRegisterUnregisterPage: Re = !0, canvasBackground: Ce, canvasRef: Me, children: De, className: Pe, customRenderer: Oe, customTextRenderer: je, devicePixelRatio: Be, error: Ie = "Failed to load the page.", height: Fe, inputRef: ze, loading: qe = "Loading page…", noData: He = "No page specified.", onGetAnnotationsError: Ge, onGetAnnotationsSuccess: Ze, onGetStructTreeError: sn, onGetStructTreeSuccess: Xe, onGetTextError: St, onGetTextSuccess: un, onLoadError: on, onLoadSuccess: bn, onRenderAnnotationLayerError: Tn, onRenderAnnotationLayerSuccess: fn, onRenderError: En, onRenderSuccess: Pn, onRenderTextLayerError: Rn, onRenderTextLayerSuccess: In, pageIndex: xn, pageNumber: vn, pdf: tn, registerPage: nn, renderAnnotationLayer: We = !0, renderForms: dn = !1, renderMode: Je = "canvas", renderTextLayer: rn = !0, rotate: hn, scale: mn = defaultScale, unregisterPage: Ye, width: an } = Ee, pn = __rest(Ee, ["_className", "_enableRegisterUnregisterPage", "canvasBackground", "canvasRef", "children", "className", "customRenderer", "customTextRenderer", "devicePixelRatio", "error", "height", "inputRef", "loading", "noData", "onGetAnnotationsError", "onGetAnnotationsSuccess", "onGetStructTreeError", "onGetStructTreeSuccess", "onGetTextError", "onGetTextSuccess", "onLoadError", "onLoadSuccess", "onRenderAnnotationLayerError", "onRenderAnnotationLayerSuccess", "onRenderError", "onRenderSuccess", "onRenderTextLayerError", "onRenderTextLayerSuccess", "pageIndex", "pageNumber", "pdf", "registerPage", "renderAnnotationLayer", "renderForms", "renderMode", "renderTextLayer", "rotate", "scale", "unregisterPage", "width"]), [yn, _n] = useResolver(), { value: On, error: kn } = yn, zn = reactExports.useRef(null); invariant(tn); const sr = isProvided(vn) ? vn - 1 : xn ?? null, Fn = vn ?? (isProvided(xn) ? xn + 1 : null), Cn = hn ?? (On ? On.rotate : null), Vn = reactExports.useMemo(() => { if (!On) return null; let wi = 1; const Jr = mn ?? defaultScale; if (an || Fe) { const mr = On.getViewport({ scale: 1, rotation: Cn }); an ? wi = an / mr.width : Fe && (wi = Fe / mr.height) } return Jr * wi }, [Fe, On, Cn, mn, an]); function Yn() { return () => { isProvided(sr) && Re && Ye && Ye(sr) } } reactExports.useEffect(Yn, [Re, tn, sr, Ye]); function qn() { if (bn) { if (!On || !Vn) return; bn(makePageCallback(On, Vn)) } if (Re && nn) { if (!isProvided(sr) || !zn.current) return; nn(sr, zn.current) } } function rr() { kn && (warning(!1, kn.toString()), on && on(kn)) } function hr() { _n({ type: "RESET" }) } reactExports.useEffect(hr, [_n, tn, sr]); function ur() { if (!tn || !Fn) return; const wi = makeCancellablePromise(tn.getPage(Fn)), Jr = wi; return wi.promise.then(mr => { _n({ type: "RESOLVE", value: mr }) }).catch(mr => { _n({ type: "REJECT", error: mr }) }), () => cancelRunningTask(Jr) } reactExports.useEffect(ur, [_n, tn, sr, Fn, nn]), reactExports.useEffect(() => { if (On !== void 0) { if (On === !1) { rr(); return } qn() } }, [On, Vn]); const Er = reactExports.useMemo(() => On && isProvided(sr) && Fn && isProvided(Cn) && isProvided(Vn) ? { _className: _e, canvasBackground: Ce, customTextRenderer: je, devicePixelRatio: Be, onGetAnnotationsError: Ge, onGetAnnotationsSuccess: Ze, onGetStructTreeError: sn, onGetStructTreeSuccess: Xe, onGetTextError: St, onGetTextSuccess: un, onRenderAnnotationLayerError: Tn, onRenderAnnotationLayerSuccess: fn, onRenderError: En, onRenderSuccess: Pn, onRenderTextLayerError: Rn, onRenderTextLayerSuccess: In, page: On, pageIndex: sr, pageNumber: Fn, renderForms: dn, renderTextLayer: rn, rotate: Cn, scale: Vn } : null, [_e, Ce, je, Be, Ge, Ze, sn, Xe, St, un, Tn, fn, En, Pn, Rn, In, On, sr, Fn, dn, rn, Cn, Vn]), _r = reactExports.useMemo(() => makeEventProps(pn, () => On && (Vn ? makePageCallback(On, Vn) : void 0)), [pn, On, Vn]), Or = `${sr}@${Vn}/${Cn}`, Ir = `${sr}/${Cn}`; function Dr() { switch (Je) { case "custom": return invariant(Oe), React.createElement(Oe, { key: `${Or}_custom` }); case "none": return null; case "svg": return React.createElement(PageSVG, { key: `${Ir}_svg` }); case "canvas": default: return React.createElement(PageCanvas, { key: `${Or}_canvas`, canvasRef: Me }) } } function Wr() { return rn ? React.createElement(TextLayer, { key: `${Or}_text` }) : null } function Cr() { return We ? React.createElement(AnnotationLayer, { key: `${Or}_annotations` }) : null } function zr() { return React.createElement(PageContext.Provider, { value: Er }, Dr(), Wr(), Cr(), De) } function Tr() { return Fn ? tn === null || On === void 0 || On === null ? React.createElement(Message, { type: "loading" }, typeof qe == "function" ? qe() : qe) : tn === !1 || On === !1 ? React.createElement(Message, { type: "error" }, typeof Ie == "function" ? Ie() : Ie) : zr() : React.createElement(Message, { type: "no-data" }, typeof He == "function" ? He() : He) } return React.createElement("div", Object.assign({ className: clsx(_e, Pe), "data-page-number": Fn, ref: mergeRefs(ze, zn), style: { "--scale-factor": `${Vn}`, backgroundColor: Ce || "white", position: "relative", minWidth: "min-content", minHeight: "min-content" } }, _r), Tr()) }, isFunctionOrNode = PropTypes.oneOfType([PropTypes.func, PropTypes.node]); Page.propTypes = Object.assign(Object.assign({}, eventProps), { canvasBackground: PropTypes.string, canvasRef: isRef, children: PropTypes.node, className: isClassName, customRenderer: PropTypes.func, customTextRenderer: PropTypes.func, devicePixelRatio: PropTypes.number, error: isFunctionOrNode, height: PropTypes.number, imageResourcesPath: PropTypes.string, inputRef: isRef, loading: isFunctionOrNode, noData: isFunctionOrNode, onGetTextError: PropTypes.func, onGetTextSuccess: PropTypes.func, onLoadError: PropTypes.func, onLoadSuccess: PropTypes.func, onRenderError: PropTypes.func, onRenderSuccess: PropTypes.func, onRenderTextLayerError: PropTypes.func, onRenderTextLayerSuccess: PropTypes.func, pageIndex: isPageIndex, pageNumber: isPageNumber, pdf: isPdf, renderAnnotationLayer: PropTypes.bool, renderForms: PropTypes.bool, renderMode: isRenderMode, renderTextLayer: PropTypes.bool, rotate: isRotate, scale: PropTypes.number, width: PropTypes.number }); displayWorkerWarning(); pdfjs.GlobalWorkerOptions.workerSrc = "pdf.worker.js"; const scriptRel = "modulepreload", assetsURL = function (e) { return "/" + e }, seen = {}, __vitePreload = function e(t, xe, Ee) { let _e = Promise.resolve(); if (xe && xe.length > 0) { let De = function (Pe) { return Promise.all(Pe.map(Oe => Promise.resolve(Oe).then(je => ({ status: "fulfilled", value: je }), je => ({ status: "rejected", reason: je })))) }; document.getElementsByTagName("link"); const Ce = document.querySelector("meta[property=csp-nonce]"), Me = Ce?.nonce || Ce?.getAttribute("nonce"); _e = De(xe.map(Pe => { if (Pe = assetsURL(Pe), Pe in seen) return; seen[Pe] = !0; const Oe = Pe.endsWith(".css"), je = Oe ? '[rel="stylesheet"]' : ""; if (document.querySelector(`link[href="${Pe}"]${je}`)) return; const Be = document.createElement("link"); if (Be.rel = Oe ? "stylesheet" : scriptRel, Oe || (Be.as = "script"), Be.crossOrigin = "", Be.href = Pe, Me && Be.setAttribute("nonce", Me), document.head.appendChild(Be), Oe) return new Promise((Ie, Fe) => { Be.addEventListener("load", Ie), Be.addEventListener("error", () => Fe(new Error(`Unable to preload CSS for ${Pe}`))) }) })) } function Re(Ce) { const Me = new Event("vite:preloadError", { cancelable: !0 }); if (Me.payload = Ce, window.dispatchEvent(Me), !Me.defaultPrevented) throw Ce } return _e.then(Ce => { for (const Me of Ce || []) Me.status === "rejected" && Re(Me.reason); return t().catch(Re) }) }; function _typeof(e) { "@babel/helpers - typeof"; return _typeof = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function (t) { return typeof t } : function (t) { return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, _typeof(e) } var u8 = Uint8Array, u16 = Uint16Array, i32 = Int32Array, fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]), fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]), clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), freb = function (e, t) { for (var xe = new u16(31), Ee = 0; Ee < 31; ++Ee)xe[Ee] = t += 1 << e[Ee - 1]; for (var _e = new i32(xe[30]), Ee = 1; Ee < 30; ++Ee)for (var Re = xe[Ee]; Re < xe[Ee + 1]; ++Re)_e[Re] = Re - xe[Ee] << 5 | Ee; return { b: xe, r: _e } }, _a = freb(fleb, 2), fl = _a.b, revfl = _a.r; fl[28] = 258, revfl[258] = 28; var _b = freb(fdeb, 0), fd = _b.b, revfd = _b.r, rev = new u16(32768); for (var i$1 = 0; i$1 < 32768; ++i$1) { var x$1 = (i$1 & 43690) >> 1 | (i$1 & 21845) << 1; x$1 = (x$1 & 52428) >> 2 | (x$1 & 13107) << 2, x$1 = (x$1 & 61680) >> 4 | (x$1 & 3855) << 4, rev[i$1] = ((x$1 & 65280) >> 8 | (x$1 & 255) << 8) >> 1 } var hMap = function (e, t, xe) { for (var Ee = e.length, _e = 0, Re = new u16(t); _e < Ee; ++_e)e[_e] && ++Re[e[_e] - 1]; var Ce = new u16(t); for (_e = 1; _e < t; ++_e)Ce[_e] = Ce[_e - 1] + Re[_e - 1] << 1; var Me; if (xe) { Me = new u16(1 << t); var De = 15 - t; for (_e = 0; _e < Ee; ++_e)if (e[_e]) for (var Pe = _e << 4 | e[_e], Oe = t - e[_e], je = Ce[e[_e] - 1]++ << Oe, Be = je | (1 << Oe) - 1; je <= Be; ++je)Me[rev[je] >> De] = Pe } else for (Me = new u16(Ee), _e = 0; _e < Ee; ++_e)e[_e] && (Me[_e] = rev[Ce[e[_e] - 1]++] >> 15 - e[_e]); return Me }, flt = new u8(288); for (var i$1 = 0; i$1 < 144; ++i$1)flt[i$1] = 8; for (var i$1 = 144; i$1 < 256; ++i$1)flt[i$1] = 9; for (var i$1 = 256; i$1 < 280; ++i$1)flt[i$1] = 7; for (var i$1 = 280; i$1 < 288; ++i$1)flt[i$1] = 8; var fdt = new u8(32); for (var i$1 = 0; i$1 < 32; ++i$1)fdt[i$1] = 5; var flm = hMap(flt, 9, 0), flrm = hMap(flt, 9, 1), fdm = hMap(fdt, 5, 0), fdrm = hMap(fdt, 5, 1), max = function (e) { for (var t = e[0], xe = 1; xe < e.length; ++xe)e[xe] > t && (t = e[xe]); return t }, bits = function (e, t, xe) { var Ee = t / 8 | 0; return (e[Ee] | e[Ee + 1] << 8) >> (t & 7) & xe }, bits16 = function (e, t) { var xe = t / 8 | 0; return (e[xe] | e[xe + 1] << 8 | e[xe + 2] << 16) >> (t & 7) }, shft = function (e) { return (e + 7) / 8 | 0 }, slc = function (e, t, xe) { return (xe == null || xe > e.length) && (xe = e.length), new u8(e.subarray(t, xe)) }, ec = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"], err = function (e, t, xe) { var Ee = new Error(t || ec[e]); if (Ee.code = e, Error.captureStackTrace && Error.captureStackTrace(Ee, err), !xe) throw Ee; return Ee }, inflt = function (e, t, xe, Ee) { var _e = e.length, Re = 0; if (!_e || t.f && !t.l) return xe || new u8(0); var Ce = !xe, Me = Ce || t.i != 2, De = t.i; Ce && (xe = new u8(_e * 3)); var Pe = function (On) { var kn = xe.length; if (On > kn) { var zn = new u8(Math.max(kn * 2, On)); zn.set(xe), xe = zn } }, Oe = t.f || 0, je = t.p || 0, Be = t.b || 0, Ie = t.l, Fe = t.d, ze = t.m, qe = t.n, He = _e * 8; do { if (!Ie) { Oe = bits(e, je, 1); var Ge = bits(e, je + 1, 3); if (je += 3, Ge) if (Ge == 1) Ie = flrm, Fe = fdrm, ze = 9, qe = 5; else if (Ge == 2) { var St = bits(e, je, 31) + 257, un = bits(e, je + 10, 15) + 4, on = St + bits(e, je + 5, 31) + 1; je += 14; for (var bn = new u8(on), Tn = new u8(19), fn = 0; fn < un; ++fn)Tn[clim[fn]] = bits(e, je + fn * 3, 7); je += un * 3; for (var En = max(Tn), Pn = (1 << En) - 1, Rn = hMap(Tn, En, 1), fn = 0; fn < on;) { var In = Rn[bits(e, je, Pn)]; je += In & 15; var Ze = In >> 4; if (Ze < 16) bn[fn++] = Ze; else { var xn = 0, vn = 0; for (Ze == 16 ? (vn = 3 + bits(e, je, 3), je += 2, xn = bn[fn - 1]) : Ze == 17 ? (vn = 3 + bits(e, je, 7), je += 3) : Ze == 18 && (vn = 11 + bits(e, je, 127), je += 7); vn--;)bn[fn++] = xn } } var tn = bn.subarray(0, St), nn = bn.subarray(St); ze = max(tn), qe = max(nn), Ie = hMap(tn, ze, 1), Fe = hMap(nn, qe, 1) } else err(1); else { var Ze = shft(je) + 4, sn = e[Ze - 4] | e[Ze - 3] << 8, Xe = Ze + sn; if (Xe > _e) { De && err(0); break } Me && Pe(Be + sn), xe.set(e.subarray(Ze, Xe), Be), t.b = Be += sn, t.p = je = Xe * 8, t.f = Oe; continue } if (je > He) { De && err(0); break } } Me && Pe(Be + 131072); for (var We = (1 << ze) - 1, dn = (1 << qe) - 1, Je = je; ; Je = je) { var xn = Ie[bits16(e, je) & We], rn = xn >> 4; if (je += xn & 15, je > He) { De && err(0); break } if (xn || err(2), rn < 256) xe[Be++] = rn; else if (rn == 256) { Je = je, Ie = null; break } else { var hn = rn - 254; if (rn > 264) { var fn = rn - 257, mn = fleb[fn]; hn = bits(e, je, (1 << mn) - 1) + fl[fn], je += mn } var Ye = Fe[bits16(e, je) & dn], an = Ye >> 4; Ye || err(3), je += Ye & 15; var nn = fd[an]; if (an > 3) { var mn = fdeb[an]; nn += bits16(e, je) & (1 << mn) - 1, je += mn } if (je > He) { De && err(0); break } Me && Pe(Be + 131072); var pn = Be + hn; if (Be < nn) { var yn = Re - nn, _n = Math.min(nn, pn); for (yn + Be < 0 && err(3); Be < _n; ++Be)xe[Be] = Ee[yn + Be] } for (; Be < pn; ++Be)xe[Be] = xe[Be - nn] } } t.l = Ie, t.p = Je, t.b = Be, t.f = Oe, Ie && (Oe = 1, t.m = ze, t.d = Fe, t.n = qe) } while (!Oe); return Be != xe.length && Ce ? slc(xe, 0, Be) : xe.subarray(0, Be) }, wbits = function (e, t, xe) { xe <<= t & 7; var Ee = t / 8 | 0; e[Ee] |= xe, e[Ee + 1] |= xe >> 8 }, wbits16 = function (e, t, xe) { xe <<= t & 7; var Ee = t / 8 | 0; e[Ee] |= xe, e[Ee + 1] |= xe >> 8, e[Ee + 2] |= xe >> 16 }, hTree = function (e, t) { for (var xe = [], Ee = 0; Ee < e.length; ++Ee)e[Ee] && xe.push({ s: Ee, f: e[Ee] }); var _e = xe.length, Re = xe.slice(); if (!_e) return { t: et$1, l: 0 }; if (_e == 1) { var Ce = new u8(xe[0].s + 1); return Ce[xe[0].s] = 1, { t: Ce, l: 1 } } xe.sort(function (Xe, St) { return Xe.f - St.f }), xe.push({ s: -1, f: 25001 }); var Me = xe[0], De = xe[1], Pe = 0, Oe = 1, je = 2; for (xe[0] = { s: -1, f: Me.f + De.f, l: Me, r: De }; Oe != _e - 1;)Me = xe[xe[Pe].f < xe[je].f ? Pe++ : je++], De = xe[Pe != Oe && xe[Pe].f < xe[je].f ? Pe++ : je++], xe[Oe++] = { s: -1, f: Me.f + De.f, l: Me, r: De }; for (var Be = Re[0].s, Ee = 1; Ee < _e; ++Ee)Re[Ee].s > Be && (Be = Re[Ee].s); var Ie = new u16(Be + 1), Fe = ln(xe[Oe - 1], Ie, 0); if (Fe > t) { var Ee = 0, ze = 0, qe = Fe - t, He = 1 << qe; for (Re.sort(function (St, un) { return Ie[un.s] - Ie[St.s] || St.f - un.f }); Ee < _e; ++Ee) { var Ge = Re[Ee].s; if (Ie[Ge] > t) ze += He - (1 << Fe - Ie[Ge]), Ie[Ge] = t; else break } for (ze >>= qe; ze > 0;) { var Ze = Re[Ee].s; Ie[Ze] < t ? ze -= 1 << t - Ie[Ze]++ - 1 : ++Ee } for (; Ee >= 0 && ze; --Ee) { var sn = Re[Ee].s; Ie[sn] == t && (--Ie[sn], ++ze) } Fe = t } return { t: new u8(Ie), l: Fe } }, ln = function (e, t, xe) { return e.s == -1 ? Math.max(ln(e.l, t, xe + 1), ln(e.r, t, xe + 1)) : t[e.s] = xe }, lc = function (e) { for (var t = e.length; t && !e[--t];); for (var xe = new u16(++t), Ee = 0, _e = e[0], Re = 1, Ce = function (De) { xe[Ee++] = De }, Me = 1; Me <= t; ++Me)if (e[Me] == _e && Me != t) ++Re; else { if (!_e && Re > 2) { for (; Re > 138; Re -= 138)Ce(32754); Re > 2 && (Ce(Re > 10 ? Re - 11 << 5 | 28690 : Re - 3 << 5 | 12305), Re = 0) } else if (Re > 3) { for (Ce(_e), --Re; Re > 6; Re -= 6)Ce(8304); Re > 2 && (Ce(Re - 3 << 5 | 8208), Re = 0) } for (; Re--;)Ce(_e); Re = 1, _e = e[Me] } return { c: xe.subarray(0, Ee), n: t } }, clen = function (e, t) { for (var xe = 0, Ee = 0; Ee < t.length; ++Ee)xe += e[Ee] * t[Ee]; return xe }, wfblk = function (e, t, xe) { var Ee = xe.length, _e = shft(t + 2); e[_e] = Ee & 255, e[_e + 1] = Ee >> 8, e[_e + 2] = e[_e] ^ 255, e[_e + 3] = e[_e + 1] ^ 255; for (var Re = 0; Re < Ee; ++Re)e[_e + Re + 4] = xe[Re]; return (_e + 4 + Ee) * 8 }, wblk = function (e, t, xe, Ee, _e, Re, Ce, Me, De, Pe, Oe) { wbits(t, Oe++, xe), ++_e[256]; for (var je = hTree(_e, 15), Be = je.t, Ie = je.l, Fe = hTree(Re, 15), ze = Fe.t, qe = Fe.l, He = lc(Be), Ge = He.c, Ze = He.n, sn = lc(ze), Xe = sn.c, St = sn.n, un = new u16(19), on = 0; on < Ge.length; ++on)++un[Ge[on] & 31]; for (var on = 0; on < Xe.length; ++on)++un[Xe[on] & 31]; for (var bn = hTree(un, 7), Tn = bn.t, fn = bn.l, En = 19; En > 4 && !Tn[clim[En - 1]]; --En); var Pn = Pe + 5 << 3, Rn = clen(_e, flt) + clen(Re, fdt) + Ce, In = clen(_e, Be) + clen(Re, ze) + Ce + 14 + 3 * En + clen(un, Tn) + 2 * un[16] + 3 * un[17] + 7 * un[18]; if (De >= 0 && Pn <= Rn && Pn <= In) return wfblk(t, Oe, e.subarray(De, De + Pe)); var xn, vn, tn, nn; if (wbits(t, Oe, 1 + (In < Rn)), Oe += 2, In < Rn) { xn = hMap(Be, Ie, 0), vn = Be, tn = hMap(ze, qe, 0), nn = ze; var We = hMap(Tn, fn, 0); wbits(t, Oe, Ze - 257), wbits(t, Oe + 5, St - 1), wbits(t, Oe + 10, En - 4), Oe += 14; for (var on = 0; on < En; ++on)wbits(t, Oe + 3 * on, Tn[clim[on]]); Oe += 3 * En; for (var dn = [Ge, Xe], Je = 0; Je < 2; ++Je)for (var rn = dn[Je], on = 0; on < rn.length; ++on) { var hn = rn[on] & 31; wbits(t, Oe, We[hn]), Oe += Tn[hn], hn > 15 && (wbits(t, Oe, rn[on] >> 5 & 127), Oe += rn[on] >> 12) } } else xn = flm, vn = flt, tn = fdm, nn = fdt; for (var on = 0; on < Me; ++on) { var mn = Ee[on]; if (mn > 255) { var hn = mn >> 18 & 31; wbits16(t, Oe, xn[hn + 257]), Oe += vn[hn + 257], hn > 7 && (wbits(t, Oe, mn >> 23 & 31), Oe += fleb[hn]); var Ye = mn & 31; wbits16(t, Oe, tn[Ye]), Oe += nn[Ye], Ye > 3 && (wbits16(t, Oe, mn >> 5 & 8191), Oe += fdeb[Ye]) } else wbits16(t, Oe, xn[mn]), Oe += vn[mn] } return wbits16(t, Oe, xn[256]), Oe + vn[256] }, deo = new i32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]), et$1 = new u8(0), dflt = function (e, t, xe, Ee, _e, Re) { var Ce = Re.z || e.length, Me = new u8(Ee + Ce + 5 * (1 + Math.ceil(Ce / 7e3)) + _e), De = Me.subarray(Ee, Me.length - _e), Pe = Re.l, Oe = (Re.r || 0) & 7; if (t) { Oe && (De[0] = Re.r >> 3); for (var je = deo[t - 1], Be = je >> 13, Ie = je & 8191, Fe = (1 << xe) - 1, ze = Re.p || new u16(32768), qe = Re.h || new u16(Fe + 1), He = Math.ceil(xe / 3), Ge = 2 * He, Ze = function (sr) { return (e[sr] ^ e[sr + 1] << He ^ e[sr + 2] << Ge) & Fe }, sn = new i32(25e3), Xe = new u16(288), St = new u16(32), un = 0, on = 0, bn = Re.i || 0, Tn = 0, fn = Re.w || 0, En = 0; bn + 2 < Ce; ++bn) { var Pn = Ze(bn), Rn = bn & 32767, In = qe[Pn]; if (ze[Rn] = In, qe[Pn] = Rn, fn <= bn) { var xn = Ce - bn; if ((un > 7e3 || Tn > 24576) && (xn > 423 || !Pe)) { Oe = wblk(e, De, 0, sn, Xe, St, on, Tn, En, bn - En, Oe), Tn = un = on = 0, En = bn; for (var vn = 0; vn < 286; ++vn)Xe[vn] = 0; for (var vn = 0; vn < 30; ++vn)St[vn] = 0 } var tn = 2, nn = 0, We = Ie, dn = Rn - In & 32767; if (xn > 2 && Pn == Ze(bn - dn)) for (var Je = Math.min(Be, xn) - 1, rn = Math.min(32767, bn), hn = Math.min(258, xn); dn <= rn && --We && Rn != In;) { if (e[bn + tn] == e[bn + tn - dn]) { for (var mn = 0; mn < hn && e[bn + mn] == e[bn + mn - dn]; ++mn); if (mn > tn) { if (tn = mn, nn = dn, mn > Je) break; for (var Ye = Math.min(dn, mn - 2), an = 0, vn = 0; vn < Ye; ++vn) { var pn = bn - dn + vn & 32767, yn = ze[pn], _n = pn - yn & 32767; _n > an && (an = _n, In = pn) } } } Rn = In, In = ze[Rn], dn += Rn - In & 32767 } if (nn) { sn[Tn++] = 268435456 | revfl[tn] << 18 | revfd[nn]; var On = revfl[tn] & 31, kn = revfd[nn] & 31; on += fleb[On] + fdeb[kn], ++Xe[257 + On], ++St[kn], fn = bn + tn, ++un } else sn[Tn++] = e[bn], ++Xe[e[bn]] } } for (bn = Math.max(bn, fn); bn < Ce; ++bn)sn[Tn++] = e[bn], ++Xe[e[bn]]; Oe = wblk(e, De, Pe, sn, Xe, St, on, Tn, En, bn - En, Oe), Pe || (Re.r = Oe & 7 | De[Oe / 8 | 0] << 3, Oe -= 7, Re.h = qe, Re.p = ze, Re.i = bn, Re.w = fn) } else { for (var bn = Re.w || 0; bn < Ce + Pe; bn += 65535) { var zn = bn + 65535; zn >= Ce && (De[Oe / 8 | 0] = Pe, zn = Ce), Oe = wfblk(De, Oe + 1, e.subarray(bn, zn)) } Re.i = Ce } return slc(Me, 0, Ee + shft(Oe) + _e) }, adler = function () { var e = 1, t = 0; return { p: function (xe) { for (var Ee = e, _e = t, Re = xe.length | 0, Ce = 0; Ce != Re;) { for (var Me = Math.min(Ce + 2655, Re); Ce < Me; ++Ce)_e += Ee += xe[Ce]; Ee = (Ee & 65535) + 15 * (Ee >> 16), _e = (_e & 65535) + 15 * (_e >> 16) } e = Ee, t = _e }, d: function () { return e %= 65521, t %= 65521, (e & 255) << 24 | (e & 65280) << 8 | (t & 255) << 8 | t >> 8 } } }, dopt = function (e, t, xe, Ee, _e) { if (!_e && (_e = { l: 1 }, t.dictionary)) { var Re = t.dictionary.subarray(-32768), Ce = new u8(Re.length + e.length); Ce.set(Re), Ce.set(e, Re.length), e = Ce, _e.w = Re.length } return dflt(e, t.level == null ? 6 : t.level, t.mem == null ? _e.l ? Math.ceil(Math.max(8, Math.min(13, Math.log(e.length))) * 1.5) : 20 : 12 + t.mem, xe, Ee, _e) }, wbytes = function (e, t, xe) { for (; xe; ++t)e[t] = xe, xe >>>= 8 }, zlh = function (e, t) { var xe = t.level, Ee = xe == 0 ? 0 : xe < 6 ? 1 : xe == 9 ? 3 : 2; if (e[0] = 120, e[1] = Ee << 6 | (t.dictionary && 32), e[1] |= 31 - (e[0] << 8 | e[1]) % 31, t.dictionary) { var _e = adler(); _e.p(t.dictionary), wbytes(e, 2, _e.d()) } }, zls = function (e, t) { return ((e[0] & 15) != 8 || e[0] >> 4 > 7 || (e[0] << 8 | e[1]) % 31) && err(6, "invalid zlib data"), (e[1] >> 5 & 1) == 1 && err(6, "invalid zlib data: " + (e[1] & 32 ? "need" : "unexpected") + " dictionary"), (e[1] >> 3 & 4) + 2 }; function zlibSync(e, t) { t || (t = {}); var xe = adler(); xe.p(e); var Ee = dopt(e, t, t.dictionary ? 6 : 2, 4); return zlh(Ee, t), wbytes(Ee, Ee.length - 4, xe.d()), Ee } function unzlibSync(e, t) { return inflt(e.subarray(zls(e), -4), { i: 2 }, t, t) } var td = typeof TextDecoder < "u" && new TextDecoder, tds = 0; try { td.decode(et$1, { stream: !0 }), tds = 1 } catch (e) { } var n = function () { return typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : this }(); function i() { n.console && typeof n.console.log == "function" && n.console.log.apply(n.console, arguments) } var a = { log: i, warn: function (e) { n.console && (typeof n.console.warn == "function" ? n.console.warn.apply(n.console, arguments) : i.call(null, arguments)) }, error: function (e) { n.console && (typeof n.console.error == "function" ? n.console.error.apply(n.console, arguments) : i(e)) } }; function o(e, t, xe) { var Ee = new XMLHttpRequest; Ee.open("GET", e), Ee.responseType = "blob", Ee.onload = function () { l(Ee.response, t, xe) }, Ee.onerror = function () { a.error("could not download file") }, Ee.send() } function s(e) { var t = new XMLHttpRequest; t.open("HEAD", e, !1); try { t.send() } catch { } return t.status >= 200 && t.status <= 299 } function c(e) { try { e.dispatchEvent(new MouseEvent("click")) } catch { var t = document.createEvent("MouseEvents"); t.initMouseEvent("click", !0, !0, window, 0, 0, 0, 80, 20, !1, !1, !1, !1, 0, null), e.dispatchEvent(t) } } var u, h, l = n.saveAs || ((typeof window > "u" ? "undefined" : _typeof(window)) !== "object" || window !== n ? function () { } : typeof HTMLAnchorElement < "u" && "download" in HTMLAnchorElement.prototype ? function (e, t, xe) { var Ee = n.URL || n.webkitURL, _e = document.createElement("a"); t = t || e.name || "download", _e.download = t, _e.rel = "noopener", typeof e == "string" ? (_e.href = e, _e.origin !== location.origin ? s(_e.href) ? o(e, t, xe) : c(_e, _e.target = "_blank") : c(_e)) : (_e.href = Ee.createObjectURL(e), setTimeout(function () { Ee.revokeObjectURL(_e.href) }, 4e4), setTimeout(function () { c(_e) }, 0)) } : "msSaveOrOpenBlob" in navigator ? function (e, t, xe) { if (t = t || e.name || "download", typeof e == "string") if (s(e)) o(e, t, xe); else { var Ee = document.createElement("a"); Ee.href = e, Ee.target = "_blank", setTimeout(function () { c(Ee) }) } else navigator.msSaveOrOpenBlob(function (_e, Re) { return Re === void 0 ? Re = { autoBom: !1 } : _typeof(Re) !== "object" && (a.warn("Deprecated: Expected third argument to be a object"), Re = { autoBom: !Re }), Re.autoBom && /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(_e.type) ? new Blob(["\uFEFF", _e], { type: _e.type }) : _e }(e, xe), t) } : function (e, t, xe, Ee) { if ((Ee = Ee || open("", "_blank")) && (Ee.document.title = Ee.document.body.innerText = "downloading..."), typeof e == "string") return o(e, t, xe); var _e = e.type === "application/octet-stream", Re = /constructor/i.test(n.HTMLElement) || n.safari, Ce = /CriOS\/[\d]+/.test(navigator.userAgent); if ((Ce || _e && Re) && (typeof FileReader > "u" ? "undefined" : _typeof(FileReader)) === "object") { var Me = new FileReader; Me.onloadend = function () { var Oe = Me.result; Oe = Ce ? Oe : Oe.replace(/^data:[^;]*;/, "data:attachment/file;"), Ee ? Ee.location.href = Oe : location = Oe, Ee = null }, Me.readAsDataURL(e) } else { var De = n.URL || n.webkitURL, Pe = De.createObjectURL(e); Ee ? Ee.location = Pe : location.href = Pe, Ee = null, setTimeout(function () { De.revokeObjectURL(Pe) }, 4e4) } });/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * {@link   http://www.phpied.com/rgb-color-parser-in-javascript/}
 * @license Use it if you like it
 */function f(e) { var t; e = e || "", this.ok = !1, e.charAt(0) == "#" && (e = e.substr(1, 6)), e = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "00ffff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000000", blanchedalmond: "ffebcd", blue: "0000ff", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "00ffff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dodgerblue: "1e90ff", feldspar: "d19275", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "ff00ff", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgrey: "d3d3d3", lightgreen: "90ee90", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslateblue: "8470ff", lightslategray: "778899", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "00ff00", limegreen: "32cd32", linen: "faf0e6", magenta: "ff00ff", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370d8", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "d87093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", red: "ff0000", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", violetred: "d02090", wheat: "f5deb3", white: "ffffff", whitesmoke: "f5f5f5", yellow: "ffff00", yellowgreen: "9acd32" }[e = (e = e.replace(/ /g, "")).toLowerCase()] || e; for (var xe = [{ re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ["rgb(123, 234, 45)", "rgb(255,234,245)"], process: function (Me) { return [parseInt(Me[1]), parseInt(Me[2]), parseInt(Me[3])] } }, { re: /^(\w{2})(\w{2})(\w{2})$/, example: ["#00ff00", "336699"], process: function (Me) { return [parseInt(Me[1], 16), parseInt(Me[2], 16), parseInt(Me[3], 16)] } }, { re: /^(\w{1})(\w{1})(\w{1})$/, example: ["#fb0", "f0f"], process: function (Me) { return [parseInt(Me[1] + Me[1], 16), parseInt(Me[2] + Me[2], 16), parseInt(Me[3] + Me[3], 16)] } }], Ee = 0; Ee < xe.length; Ee++) { var _e = xe[Ee].re, Re = xe[Ee].process, Ce = _e.exec(e); Ce && (t = Re(Ce), this.r = t[0], this.g = t[1], this.b = t[2], this.ok = !0) } this.r = this.r < 0 || isNaN(this.r) ? 0 : this.r > 255 ? 255 : this.r, this.g = this.g < 0 || isNaN(this.g) ? 0 : this.g > 255 ? 255 : this.g, this.b = this.b < 0 || isNaN(this.b) ? 0 : this.b > 255 ? 255 : this.b, this.toRGB = function () { return "rgb(" + this.r + ", " + this.g + ", " + this.b + ")" }, this.toHex = function () { var Me = this.r.toString(16), De = this.g.toString(16), Pe = this.b.toString(16); return Me.length == 1 && (Me = "0" + Me), De.length == 1 && (De = "0" + De), Pe.length == 1 && (Pe = "0" + Pe), "#" + Me + De + Pe } }/**
 * @license
 * Joseph Myers does not specify a particular license for his work.
 *
 * Author: Joseph Myers
 * Accessed from: http://www.myersdaily.org/joseph/javascript/md5.js
 *
 * Modified by: Owen Leong
 */function d(e, t) { var xe = e[0], Ee = e[1], _e = e[2], Re = e[3]; xe = g(xe, Ee, _e, Re, t[0], 7, -680876936), Re = g(Re, xe, Ee, _e, t[1], 12, -389564586), _e = g(_e, Re, xe, Ee, t[2], 17, 606105819), Ee = g(Ee, _e, Re, xe, t[3], 22, -1044525330), xe = g(xe, Ee, _e, Re, t[4], 7, -176418897), Re = g(Re, xe, Ee, _e, t[5], 12, 1200080426), _e = g(_e, Re, xe, Ee, t[6], 17, -1473231341), Ee = g(Ee, _e, Re, xe, t[7], 22, -45705983), xe = g(xe, Ee, _e, Re, t[8], 7, 1770035416), Re = g(Re, xe, Ee, _e, t[9], 12, -1958414417), _e = g(_e, Re, xe, Ee, t[10], 17, -42063), Ee = g(Ee, _e, Re, xe, t[11], 22, -1990404162), xe = g(xe, Ee, _e, Re, t[12], 7, 1804603682), Re = g(Re, xe, Ee, _e, t[13], 12, -40341101), _e = g(_e, Re, xe, Ee, t[14], 17, -1502002290), xe = m(xe, Ee = g(Ee, _e, Re, xe, t[15], 22, 1236535329), _e, Re, t[1], 5, -165796510), Re = m(Re, xe, Ee, _e, t[6], 9, -1069501632), _e = m(_e, Re, xe, Ee, t[11], 14, 643717713), Ee = m(Ee, _e, Re, xe, t[0], 20, -373897302), xe = m(xe, Ee, _e, Re, t[5], 5, -701558691), Re = m(Re, xe, Ee, _e, t[10], 9, 38016083), _e = m(_e, Re, xe, Ee, t[15], 14, -660478335), Ee = m(Ee, _e, Re, xe, t[4], 20, -405537848), xe = m(xe, Ee, _e, Re, t[9], 5, 568446438), Re = m(Re, xe, Ee, _e, t[14], 9, -1019803690), _e = m(_e, Re, xe, Ee, t[3], 14, -187363961), Ee = m(Ee, _e, Re, xe, t[8], 20, 1163531501), xe = m(xe, Ee, _e, Re, t[13], 5, -1444681467), Re = m(Re, xe, Ee, _e, t[2], 9, -51403784), _e = m(_e, Re, xe, Ee, t[7], 14, 1735328473), xe = v(xe, Ee = m(Ee, _e, Re, xe, t[12], 20, -1926607734), _e, Re, t[5], 4, -378558), Re = v(Re, xe, Ee, _e, t[8], 11, -2022574463), _e = v(_e, Re, xe, Ee, t[11], 16, 1839030562), Ee = v(Ee, _e, Re, xe, t[14], 23, -35309556), xe = v(xe, Ee, _e, Re, t[1], 4, -1530992060), Re = v(Re, xe, Ee, _e, t[4], 11, 1272893353), _e = v(_e, Re, xe, Ee, t[7], 16, -155497632), Ee = v(Ee, _e, Re, xe, t[10], 23, -1094730640), xe = v(xe, Ee, _e, Re, t[13], 4, 681279174), Re = v(Re, xe, Ee, _e, t[0], 11, -358537222), _e = v(_e, Re, xe, Ee, t[3], 16, -722521979), Ee = v(Ee, _e, Re, xe, t[6], 23, 76029189), xe = v(xe, Ee, _e, Re, t[9], 4, -640364487), Re = v(Re, xe, Ee, _e, t[12], 11, -421815835), _e = v(_e, Re, xe, Ee, t[15], 16, 530742520), xe = b(xe, Ee = v(Ee, _e, Re, xe, t[2], 23, -995338651), _e, Re, t[0], 6, -198630844), Re = b(Re, xe, Ee, _e, t[7], 10, 1126891415), _e = b(_e, Re, xe, Ee, t[14], 15, -1416354905), Ee = b(Ee, _e, Re, xe, t[5], 21, -57434055), xe = b(xe, Ee, _e, Re, t[12], 6, 1700485571), Re = b(Re, xe, Ee, _e, t[3], 10, -1894986606), _e = b(_e, Re, xe, Ee, t[10], 15, -1051523), Ee = b(Ee, _e, Re, xe, t[1], 21, -2054922799), xe = b(xe, Ee, _e, Re, t[8], 6, 1873313359), Re = b(Re, xe, Ee, _e, t[15], 10, -30611744), _e = b(_e, Re, xe, Ee, t[6], 15, -1560198380), Ee = b(Ee, _e, Re, xe, t[13], 21, 1309151649), xe = b(xe, Ee, _e, Re, t[4], 6, -145523070), Re = b(Re, xe, Ee, _e, t[11], 10, -1120210379), _e = b(_e, Re, xe, Ee, t[2], 15, 718787259), Ee = b(Ee, _e, Re, xe, t[9], 21, -343485551), e[0] = _(xe, e[0]), e[1] = _(Ee, e[1]), e[2] = _(_e, e[2]), e[3] = _(Re, e[3]) } function p(e, t, xe, Ee, _e, Re) { return t = _(_(t, e), _(Ee, Re)), _(t << _e | t >>> 32 - _e, xe) } function g(e, t, xe, Ee, _e, Re, Ce) { return p(t & xe | ~t & Ee, e, t, _e, Re, Ce) } function m(e, t, xe, Ee, _e, Re, Ce) { return p(t & Ee | xe & ~Ee, e, t, _e, Re, Ce) } function v(e, t, xe, Ee, _e, Re, Ce) { return p(t ^ xe ^ Ee, e, t, _e, Re, Ce) } function b(e, t, xe, Ee, _e, Re, Ce) { return p(xe ^ (t | ~Ee), e, t, _e, Re, Ce) } function y(e) { var t, xe = e.length, Ee = [1732584193, -271733879, -1732584194, 271733878]; for (t = 64; t <= e.length; t += 64)d(Ee, w(e.substring(t - 64, t))); e = e.substring(t - 64); var _e = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]; for (t = 0; t < e.length; t++)_e[t >> 2] |= e.charCodeAt(t) << (t % 4 << 3); if (_e[t >> 2] |= 128 << (t % 4 << 3), t > 55) for (d(Ee, _e), t = 0; t < 16; t++)_e[t] = 0; return _e[14] = 8 * xe, d(Ee, _e), Ee } function w(e) { var t, xe = []; for (t = 0; t < 64; t += 4)xe[t >> 2] = e.charCodeAt(t) + (e.charCodeAt(t + 1) << 8) + (e.charCodeAt(t + 2) << 16) + (e.charCodeAt(t + 3) << 24); return xe } u = n.atob.bind(n), h = n.btoa.bind(n); var N = "0123456789abcdef".split(""); function L(e) { for (var t = "", xe = 0; xe < 4; xe++)t += N[e >> 8 * xe + 4 & 15] + N[e >> 8 * xe & 15]; return t } function A(e) { return String.fromCharCode((255 & e) >> 0, (65280 & e) >> 8, (16711680 & e) >> 16, (4278190080 & e) >> 24) } function x(e) { return y(e).map(A).join("") } var S = function (e) { for (var t = 0; t < e.length; t++)e[t] = L(e[t]); return e.join("") }(y("hello")) != "5d41402abc4b2a76b9719d911017c592"; function _(e, t) { if (S) { var xe = (65535 & e) + (65535 & t); return (e >> 16) + (t >> 16) + (xe >> 16) << 16 | 65535 & xe } return e + t & 4294967295 }/**
 * @license
 * FPDF is released under a permissive license: there is no usage restriction.
 * You may embed it freely in your application (commercial or not), with or
 * without modifications.
 *
 * Reference: http://www.fpdf.org/en/script/script37.php
 */function P(e, t) { var xe, Ee, _e, Re; if (e !== xe) { for (var Ce = (_e = e, Re = 1 + (256 / e.length >> 0), new Array(Re + 1).join(_e)), Me = [], De = 0; De < 256; De++)Me[De] = De; var Pe = 0; for (De = 0; De < 256; De++) { var Oe = Me[De]; Pe = (Pe + Oe + Ce.charCodeAt(De)) % 256, Me[De] = Me[Pe], Me[Pe] = Oe } xe = e, Ee = Me } else Me = Ee; var je = t.length, Be = 0, Ie = 0, Fe = ""; for (De = 0; De < je; De++)Ie = (Ie + (Oe = Me[Be = (Be + 1) % 256])) % 256, Me[Be] = Me[Ie], Me[Ie] = Oe, Ce = Me[(Me[Be] + Me[Ie]) % 256], Fe += String.fromCharCode(t.charCodeAt(De) ^ Ce); return Fe }/**
 * @license
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 * Author: Owen Leong (@owenl131)
 * Date: 15 Oct 2020
 * References:
 * https://www.cs.cmu.edu/~dst/Adobe/Gallery/anon21jul01-pdf-encryption.txt
 * https://github.com/foliojs/pdfkit/blob/master/lib/security.js
 * http://www.fpdf.org/en/script/script37.php
 */var k = { print: 4, modify: 8, copy: 16, "annot-forms": 32 }; function I(e, t, xe, Ee) { this.v = 1, this.r = 2; var _e = 192; e.forEach(function (Me) { if (k.perm !== void 0) throw new Error("Invalid permission: " + Me); _e += k[Me] }), this.padding = "(¿N^NuAd\0NVÿú\b..\0¶Ðh>/\f©þdSiz"; var Re = (t + this.padding).substr(0, 32), Ce = (xe + this.padding).substr(0, 32); this.O = this.processOwnerPassword(Re, Ce), this.P = -(1 + (255 ^ _e)), this.encryptionKey = x(Re + this.O + this.lsbFirstWord(this.P) + this.hexToBytes(Ee)).substr(0, 5), this.U = P(this.encryptionKey, this.padding) } function F(e) { if (/[^\u0000-\u00ff]/.test(e)) throw new Error("Invalid PDF Name Object: " + e + ", Only accept ASCII characters."); for (var t = "", xe = e.length, Ee = 0; Ee < xe; Ee++) { var _e = e.charCodeAt(Ee); _e < 33 || _e === 35 || _e === 37 || _e === 40 || _e === 41 || _e === 47 || _e === 60 || _e === 62 || _e === 91 || _e === 93 || _e === 123 || _e === 125 || _e > 126 ? t += "#" + ("0" + _e.toString(16)).slice(-2) : t += e[Ee] } return t } function C(e) { if (_typeof(e) !== "object") throw new Error("Invalid Context passed to initialize PubSub (jsPDF-module)"); var t = {}; this.subscribe = function (xe, Ee, _e) { if (_e = _e || !1, typeof xe != "string" || typeof Ee != "function" || typeof _e != "boolean") throw new Error("Invalid arguments passed to PubSub.subscribe (jsPDF-module)"); t.hasOwnProperty(xe) || (t[xe] = {}); var Re = Math.random().toString(35); return t[xe][Re] = [Ee, !!_e], Re }, this.unsubscribe = function (xe) { for (var Ee in t) if (t[Ee][xe]) return delete t[Ee][xe], Object.keys(t[Ee]).length === 0 && delete t[Ee], !0; return !1 }, this.publish = function (xe) { if (t.hasOwnProperty(xe)) { var Ee = Array.prototype.slice.call(arguments, 1), _e = []; for (var Re in t[xe]) { var Ce = t[xe][Re]; try { Ce[0].apply(e, Ee) } catch (Me) { n.console && a.error("jsPDF PubSub Error", Me.message, Me) } Ce[1] && _e.push(Re) } _e.length && _e.forEach(this.unsubscribe) } }, this.getTopics = function () { return t } } function j(e) { if (!(this instanceof j)) return new j(e); var t = "opacity,stroke-opacity".split(","); for (var xe in e) e.hasOwnProperty(xe) && t.indexOf(xe) >= 0 && (this[xe] = e[xe]); this.id = "", this.objectNumber = -1 } function O(e, t) { this.gState = e, this.matrix = t, this.id = "", this.objectNumber = -1 } function B(e, t, xe, Ee, _e) { if (!(this instanceof B)) return new B(e, t, xe, Ee, _e); this.type = e === "axial" ? 2 : 3, this.coords = t, this.colors = xe, O.call(this, Ee, _e) } function M(e, t, xe, Ee, _e) { if (!(this instanceof M)) return new M(e, t, xe, Ee, _e); this.boundingBox = e, this.xStep = t, this.yStep = xe, this.stream = "", this.cloneIndex = 0, O.call(this, Ee, _e) } function E(e) {
  var t, xe = typeof arguments[0] == "string" ? arguments[0] : "p", Ee = arguments[1], _e = arguments[2], Re = arguments[3], Ce = [], Me = 1, De = 16, Pe = "S", Oe = null; _typeof(e = e || {}) === "object" && (xe = e.orientation, Ee = e.unit || Ee, _e = e.format || _e, Re = e.compress || e.compressPdf || Re, (Oe = e.encryption || null) !== null && (Oe.userPassword = Oe.userPassword || "", Oe.ownerPassword = Oe.ownerPassword || "", Oe.userPermissions = Oe.userPermissions || []), Me = typeof e.userUnit == "number" ? Math.abs(e.userUnit) : 1, e.precision !== void 0 && (t = e.precision), e.floatPrecision !== void 0 && (De = e.floatPrecision), Pe = e.defaultPathOperation || "S"), Ce = e.filters || (Re === !0 ? ["FlateEncode"] : Ce), Ee = Ee || "mm", xe = ("" + (xe || "P")).toLowerCase(); var je = e.putOnlyUsedFonts || !1, Be = {}, Ie = { internal: {}, __private__: {} }; Ie.__private__.PubSub = C; var Fe = "1.3", ze = Ie.__private__.getPdfVersion = function () { return Fe }; Ie.__private__.setPdfVersion = function (Qe) { Fe = Qe }; var qe = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] }; Ie.__private__.getPageFormats = function () { return qe }; var He = Ie.__private__.getPageFormat = function (Qe) { return qe[Qe] }; _e = _e || "a4"; var Ge = { COMPAT: "compat", ADVANCED: "advanced" }, Ze = Ge.COMPAT; function sn() { this.saveGraphicsState(), Cn(new Lr(Tr, 0, 0, -Tr, 0, Ao() * Tr).toString() + " cm"), this.setFontSize(this.getFontSize() / Tr), Pe = "n", Ze = Ge.ADVANCED } function Xe() { this.restoreGraphicsState(), Pe = "S", Ze = Ge.COMPAT } var St = Ie.__private__.combineFontStyleAndFontWeight = function (Qe, Sn) { if (Qe == "bold" && Sn == "normal" || Qe == "bold" && Sn == 400 || Qe == "normal" && Sn == "italic" || Qe == "bold" && Sn == "italic") throw new Error("Invalid Combination of fontweight and fontstyle"); return Sn && (Qe = Sn == 400 || Sn === "normal" ? Qe === "italic" ? "italic" : "normal" : Sn != 700 && Sn !== "bold" || Qe !== "normal" ? (Sn == 700 ? "bold" : Sn) + "" + Qe : "bold"), Qe }; Ie.advancedAPI = function (Qe) { var Sn = Ze === Ge.COMPAT; return Sn && sn.call(this), typeof Qe != "function" || (Qe(this), Sn && Xe.call(this)), this }, Ie.compatAPI = function (Qe) { var Sn = Ze === Ge.ADVANCED; return Sn && Xe.call(this), typeof Qe != "function" || (Qe(this), Sn && sn.call(this)), this }, Ie.isAdvancedAPI = function () { return Ze === Ge.ADVANCED }; var un, on = function (Qe) { if (Ze !== Ge.ADVANCED) throw new Error(Qe + " is only available in 'advanced' API mode. You need to call advancedAPI() first.") }, bn = Ie.roundToPrecision = Ie.__private__.roundToPrecision = function (Qe, Sn) { var Un = t || Sn; if (isNaN(Qe) || isNaN(Un)) throw new Error("Invalid argument passed to jsPDF.roundToPrecision"); return Qe.toFixed(Un).replace(/0+$/, "") }; un = Ie.hpf = Ie.__private__.hpf = typeof De == "number" ? function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.hpf"); return bn(Qe, De) } : De === "smart" ? function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.hpf"); return bn(Qe, Qe > -1 && Qe < 1 ? 16 : 5) } : function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.hpf"); return bn(Qe, 16) }; var Tn = Ie.f2 = Ie.__private__.f2 = function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.f2"); return bn(Qe, 2) }, fn = Ie.__private__.f3 = function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.f3"); return bn(Qe, 3) }, En = Ie.scale = Ie.__private__.scale = function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.scale"); return Ze === Ge.COMPAT ? Qe * Tr : Ze === Ge.ADVANCED ? Qe : void 0 }, Pn = function (Qe) { return Ze === Ge.COMPAT ? Ao() - Qe : Ze === Ge.ADVANCED ? Qe : void 0 }, Rn = function (Qe) { return En(Pn(Qe)) }; Ie.__private__.setPrecision = Ie.setPrecision = function (Qe) { typeof parseInt(Qe, 10) == "number" && (t = parseInt(Qe, 10)) }; var In, xn = "00000000000000000000000000000000", vn = Ie.__private__.getFileId = function () { return xn }, tn = Ie.__private__.setFileId = function (Qe) { return xn = Qe !== void 0 && /^[a-fA-F0-9]{32}$/.test(Qe) ? Qe.toUpperCase() : xn.split("").map(function () { return "ABCDEF0123456789".charAt(Math.floor(16 * Math.random())) }).join(""), Oe !== null && (gs = new I(Oe.userPermissions, Oe.userPassword, Oe.ownerPassword, xn)), xn }; Ie.setFileId = function (Qe) { return tn(Qe), this }, Ie.getFileId = function () { return vn() }; var nn = Ie.__private__.convertDateToPDFDate = function (Qe) { var Sn = Qe.getTimezoneOffset(), Un = Sn < 0 ? "+" : "-", $n = Math.floor(Math.abs(Sn / 60)), tr = Math.abs(Sn % 60), fr = [Un, hn($n), "'", hn(tr), "'"].join(""); return ["D:", Qe.getFullYear(), hn(Qe.getMonth() + 1), hn(Qe.getDate()), hn(Qe.getHours()), hn(Qe.getMinutes()), hn(Qe.getSeconds()), fr].join("") }, We = Ie.__private__.convertPDFDateToDate = function (Qe) { var Sn = parseInt(Qe.substr(2, 4), 10), Un = parseInt(Qe.substr(6, 2), 10) - 1, $n = parseInt(Qe.substr(8, 2), 10), tr = parseInt(Qe.substr(10, 2), 10), fr = parseInt(Qe.substr(12, 2), 10), Sr = parseInt(Qe.substr(14, 2), 10); return new Date(Sn, Un, $n, tr, fr, Sr, 0) }, dn = Ie.__private__.setCreationDate = function (Qe) { var Sn; if (Qe === void 0 && (Qe = new Date), Qe instanceof Date) Sn = nn(Qe); else { if (!/^D:(20[0-2][0-9]|203[0-7]|19[7-9][0-9])(0[0-9]|1[0-2])([0-2][0-9]|3[0-1])(0[0-9]|1[0-9]|2[0-3])(0[0-9]|[1-5][0-9])(0[0-9]|[1-5][0-9])(\+0[0-9]|\+1[0-4]|-0[0-9]|-1[0-1])'(0[0-9]|[1-5][0-9])'?$/.test(Qe)) throw new Error("Invalid argument passed to jsPDF.setCreationDate"); Sn = Qe } return In = Sn }, Je = Ie.__private__.getCreationDate = function (Qe) { var Sn = In; return Qe === "jsDate" && (Sn = We(In)), Sn }; Ie.setCreationDate = function (Qe) { return dn(Qe), this }, Ie.getCreationDate = function (Qe) { return Je(Qe) }; var rn, hn = Ie.__private__.padd2 = function (Qe) { return ("0" + parseInt(Qe)).slice(-2) }, mn = Ie.__private__.padd2Hex = function (Qe) { return ("00" + (Qe = Qe.toString())).substr(Qe.length) }, Ye = 0, an = [], pn = [], yn = 0, _n = [], On = [], kn = !1, zn = pn, sr = function () { Ye = 0, yn = 0, pn = [], an = [], _n = [], Ws = bi(), Xs = bi() }; Ie.__private__.setCustomOutputDestination = function (Qe) { kn = !0, zn = Qe }; var Fn = function (Qe) { kn || (zn = Qe) }; Ie.__private__.resetCustomOutputDestination = function () { kn = !1, zn = pn }; var Cn = Ie.__private__.out = function (Qe) { return Qe = Qe.toString(), yn += Qe.length + 1, zn.push(Qe), zn }, Vn = Ie.__private__.write = function (Qe) { return Cn(arguments.length === 1 ? Qe.toString() : Array.prototype.join.call(arguments, " ")) }, Yn = Ie.__private__.getArrayBuffer = function (Qe) { for (var Sn = Qe.length, Un = new ArrayBuffer(Sn), $n = new Uint8Array(Un); Sn--;)$n[Sn] = Qe.charCodeAt(Sn); return Un }, qn = [["Helvetica", "helvetica", "normal", "WinAnsiEncoding"], ["Helvetica-Bold", "helvetica", "bold", "WinAnsiEncoding"], ["Helvetica-Oblique", "helvetica", "italic", "WinAnsiEncoding"], ["Helvetica-BoldOblique", "helvetica", "bolditalic", "WinAnsiEncoding"], ["Courier", "courier", "normal", "WinAnsiEncoding"], ["Courier-Bold", "courier", "bold", "WinAnsiEncoding"], ["Courier-Oblique", "courier", "italic", "WinAnsiEncoding"], ["Courier-BoldOblique", "courier", "bolditalic", "WinAnsiEncoding"], ["Times-Roman", "times", "normal", "WinAnsiEncoding"], ["Times-Bold", "times", "bold", "WinAnsiEncoding"], ["Times-Italic", "times", "italic", "WinAnsiEncoding"], ["Times-BoldItalic", "times", "bolditalic", "WinAnsiEncoding"], ["ZapfDingbats", "zapfdingbats", "normal", null], ["Symbol", "symbol", "normal", null]]; Ie.__private__.getStandardFonts = function () { return qn }; var rr = e.fontSize || 16; Ie.__private__.setFontSize = Ie.setFontSize = function (Qe) { return rr = Ze === Ge.ADVANCED ? Qe / Tr : Qe, this }; var hr, ur = Ie.__private__.getFontSize = Ie.getFontSize = function () { return Ze === Ge.COMPAT ? rr : rr * Tr }, Er = e.R2L || !1; Ie.__private__.setR2L = Ie.setR2L = function (Qe) { return Er = Qe, this }, Ie.__private__.getR2L = Ie.getR2L = function () { return Er }; var _r, Or = Ie.__private__.setZoomMode = function (Qe) { var Sn = [void 0, null, "fullwidth", "fullheight", "fullpage", "original"]; if (/^(?:\d+\.\d*|\d*\.\d+|\d+)%$/.test(Qe)) hr = Qe; else if (isNaN(Qe)) { if (Sn.indexOf(Qe) === -1) throw new Error('zoom must be Integer (e.g. 2), a percentage Value (e.g. 300%) or fullwidth, fullheight, fullpage, original. "' + Qe + '" is not recognized.'); hr = Qe } else hr = parseInt(Qe, 10) }; Ie.__private__.getZoomMode = function () { return hr }; var Ir, Dr = Ie.__private__.setPageMode = function (Qe) { if ([void 0, null, "UseNone", "UseOutlines", "UseThumbs", "FullScreen"].indexOf(Qe) == -1) throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + Qe + '" is not recognized.'); _r = Qe }; Ie.__private__.getPageMode = function () { return _r }; var Wr = Ie.__private__.setLayoutMode = function (Qe) { if ([void 0, null, "continuous", "single", "twoleft", "tworight", "two"].indexOf(Qe) == -1) throw new Error('Layout mode must be one of continuous, single, twoleft, tworight. "' + Qe + '" is not recognized.'); Ir = Qe }; Ie.__private__.getLayoutMode = function () { return Ir }, Ie.__private__.setDisplayMode = Ie.setDisplayMode = function (Qe, Sn, Un) { return Or(Qe), Wr(Sn), Dr(Un), this }; var Cr = { title: "", subject: "", author: "", keywords: "", creator: "" }; Ie.__private__.getDocumentProperty = function (Qe) { if (Object.keys(Cr).indexOf(Qe) === -1) throw new Error("Invalid argument passed to jsPDF.getDocumentProperty"); return Cr[Qe] }, Ie.__private__.getDocumentProperties = function () { return Cr }, Ie.__private__.setDocumentProperties = Ie.setProperties = Ie.setDocumentProperties = function (Qe) { for (var Sn in Cr) Cr.hasOwnProperty(Sn) && Qe[Sn] && (Cr[Sn] = Qe[Sn]); return this }, Ie.__private__.setDocumentProperty = function (Qe, Sn) { if (Object.keys(Cr).indexOf(Qe) === -1) throw new Error("Invalid arguments passed to jsPDF.setDocumentProperty"); return Cr[Qe] = Sn }; var zr, Tr, wi, Jr, mr, Kn = {}, Qn = {}, Rr = [], kr = {}, di = {}, ei = {}, Wi = {}, $i = null, xi = 0, Ar = [], Ur = new C(Ie), hi = e.hotfixes || [], ii = {}, fi = {}, yi = [], Lr = function Qe(Sn, Un, $n, tr, fr, Sr) { if (!(this instanceof Qe)) return new Qe(Sn, Un, $n, tr, fr, Sr); isNaN(Sn) && (Sn = 1), isNaN(Un) && (Un = 0), isNaN($n) && ($n = 0), isNaN(tr) && (tr = 1), isNaN(fr) && (fr = 0), isNaN(Sr) && (Sr = 0), this._matrix = [Sn, Un, $n, tr, fr, Sr] }; Object.defineProperty(Lr.prototype, "sx", { get: function () { return this._matrix[0] }, set: function (Qe) { this._matrix[0] = Qe } }), Object.defineProperty(Lr.prototype, "shy", { get: function () { return this._matrix[1] }, set: function (Qe) { this._matrix[1] = Qe } }), Object.defineProperty(Lr.prototype, "shx", { get: function () { return this._matrix[2] }, set: function (Qe) { this._matrix[2] = Qe } }), Object.defineProperty(Lr.prototype, "sy", { get: function () { return this._matrix[3] }, set: function (Qe) { this._matrix[3] = Qe } }), Object.defineProperty(Lr.prototype, "tx", { get: function () { return this._matrix[4] }, set: function (Qe) { this._matrix[4] = Qe } }), Object.defineProperty(Lr.prototype, "ty", { get: function () { return this._matrix[5] }, set: function (Qe) { this._matrix[5] = Qe } }), Object.defineProperty(Lr.prototype, "a", { get: function () { return this._matrix[0] }, set: function (Qe) { this._matrix[0] = Qe } }), Object.defineProperty(Lr.prototype, "b", { get: function () { return this._matrix[1] }, set: function (Qe) { this._matrix[1] = Qe } }), Object.defineProperty(Lr.prototype, "c", { get: function () { return this._matrix[2] }, set: function (Qe) { this._matrix[2] = Qe } }), Object.defineProperty(Lr.prototype, "d", { get: function () { return this._matrix[3] }, set: function (Qe) { this._matrix[3] = Qe } }), Object.defineProperty(Lr.prototype, "e", { get: function () { return this._matrix[4] }, set: function (Qe) { this._matrix[4] = Qe } }), Object.defineProperty(Lr.prototype, "f", { get: function () { return this._matrix[5] }, set: function (Qe) { this._matrix[5] = Qe } }), Object.defineProperty(Lr.prototype, "rotation", { get: function () { return Math.atan2(this.shx, this.sx) } }), Object.defineProperty(Lr.prototype, "scaleX", { get: function () { return this.decompose().scale.sx } }), Object.defineProperty(Lr.prototype, "scaleY", { get: function () { return this.decompose().scale.sy } }), Object.defineProperty(Lr.prototype, "isIdentity", { get: function () { return this.sx === 1 && this.shy === 0 && this.shx === 0 && this.sy === 1 && this.tx === 0 && this.ty === 0 } }), Lr.prototype.join = function (Qe) { return [this.sx, this.shy, this.shx, this.sy, this.tx, this.ty].map(un).join(Qe) }, Lr.prototype.multiply = function (Qe) { var Sn = Qe.sx * this.sx + Qe.shy * this.shx, Un = Qe.sx * this.shy + Qe.shy * this.sy, $n = Qe.shx * this.sx + Qe.sy * this.shx, tr = Qe.shx * this.shy + Qe.sy * this.sy, fr = Qe.tx * this.sx + Qe.ty * this.shx + this.tx, Sr = Qe.tx * this.shy + Qe.ty * this.sy + this.ty; return new Lr(Sn, Un, $n, tr, fr, Sr) }, Lr.prototype.decompose = function () { var Qe = this.sx, Sn = this.shy, Un = this.shx, $n = this.sy, tr = this.tx, fr = this.ty, Sr = Math.sqrt(Qe * Qe + Sn * Sn), jr = (Qe /= Sr) * Un + (Sn /= Sr) * $n; Un -= Qe * jr, $n -= Sn * jr; var Br = Math.sqrt(Un * Un + $n * $n); return jr /= Br, Qe * ($n /= Br) < Sn * (Un /= Br) && (Qe = -Qe, Sn = -Sn, jr = -jr, Sr = -Sr), { scale: new Lr(Sr, 0, 0, Br, 0, 0), translate: new Lr(1, 0, 0, 1, tr, fr), rotate: new Lr(Qe, Sn, -Sn, Qe, 0, 0), skew: new Lr(1, 0, jr, 1, 0, 0) } }, Lr.prototype.toString = function (Qe) { return this.join(" ") }, Lr.prototype.inversed = function () { var Qe = this.sx, Sn = this.shy, Un = this.shx, $n = this.sy, tr = this.tx, fr = this.ty, Sr = 1 / (Qe * $n - Sn * Un), jr = $n * Sr, Br = -Sn * Sr, ti = -Un * Sr, Qr = Qe * Sr; return new Lr(jr, Br, ti, Qr, -jr * tr - ti * fr, -Br * tr - Qr * fr) }, Lr.prototype.applyToPoint = function (Qe) { var Sn = Qe.x * this.sx + Qe.y * this.shx + this.tx, Un = Qe.x * this.shy + Qe.y * this.sy + this.ty; return new Dl(Sn, Un) }, Lr.prototype.applyToRectangle = function (Qe) { var Sn = this.applyToPoint(Qe), Un = this.applyToPoint(new Dl(Qe.x + Qe.w, Qe.y + Qe.h)); return new Tc(Sn.x, Sn.y, Un.x - Sn.x, Un.y - Sn.y) }, Lr.prototype.clone = function () { var Qe = this.sx, Sn = this.shy, Un = this.shx, $n = this.sy, tr = this.tx, fr = this.ty; return new Lr(Qe, Sn, Un, $n, tr, fr) }, Ie.Matrix = Lr; var pi = Ie.matrixMult = function (Qe, Sn) { return Sn.multiply(Qe) }, ni = new Lr(1, 0, 0, 1, 0, 0); Ie.unitMatrix = Ie.identityMatrix = ni; var oi = function (Qe, Sn) { if (!di[Qe]) { var Un = (Sn instanceof B ? "Sh" : "P") + (Object.keys(kr).length + 1).toString(10); Sn.id = Un, di[Qe] = Un, kr[Un] = Sn, Ur.publish("addPattern", Sn) } }; Ie.ShadingPattern = B, Ie.TilingPattern = M, Ie.addShadingPattern = function (Qe, Sn) { return on("addShadingPattern()"), oi(Qe, Sn), this }, Ie.beginTilingPattern = function (Qe) { on("beginTilingPattern()"), kl(Qe.boundingBox[0], Qe.boundingBox[1], Qe.boundingBox[2] - Qe.boundingBox[0], Qe.boundingBox[3] - Qe.boundingBox[1], Qe.matrix) }, Ie.endTilingPattern = function (Qe, Sn) {
    on("endTilingPattern()"), Sn.stream = On[rn].join(`
`), oi(Qe, Sn), Ur.publish("endTilingPattern", Sn), yi.pop().restore()
  }; var si = Ie.__private__.newObject = function () { var Qe = bi(); return ms(Qe, !0), Qe }, bi = Ie.__private__.newObjectDeferred = function () { return Ye++, an[Ye] = function () { return yn }, Ye }, ms = function (Qe, Sn) { return Sn = typeof Sn == "boolean" && Sn, an[Qe] = yn, Sn && Cn(Qe + " 0 obj"), Qe }, Wo = Ie.__private__.newAdditionalObject = function () { var Qe = { objId: bi(), content: "" }; return _n.push(Qe), Qe }, Ws = bi(), Xs = bi(), _s = Ie.__private__.decodeColorString = function (Qe) { var Sn = Qe.split(" "); if (Sn.length !== 2 || Sn[1] !== "g" && Sn[1] !== "G") Sn.length === 5 && (Sn[4] === "k" || Sn[4] === "K") && (Sn = [(1 - Sn[0]) * (1 - Sn[3]), (1 - Sn[1]) * (1 - Sn[3]), (1 - Sn[2]) * (1 - Sn[3]), "r"]); else { var Un = parseFloat(Sn[0]); Sn = [Un, Un, Un, "r"] } for (var $n = "#", tr = 0; tr < 3; tr++)$n += ("0" + Math.floor(255 * parseFloat(Sn[tr])).toString(16)).slice(-2); return $n }, Rs = Ie.__private__.encodeColorString = function (Qe) { var Sn; typeof Qe == "string" && (Qe = { ch1: Qe }); var Un = Qe.ch1, $n = Qe.ch2, tr = Qe.ch3, fr = Qe.ch4, Sr = Qe.pdfColorType === "draw" ? ["G", "RG", "K"] : ["g", "rg", "k"]; if (typeof Un == "string" && Un.charAt(0) !== "#") { var jr = new f(Un); if (jr.ok) Un = jr.toHex(); else if (!/^\d*\.?\d*$/.test(Un)) throw new Error('Invalid color "' + Un + '" passed to jsPDF.encodeColorString.') } if (typeof Un == "string" && /^#[0-9A-Fa-f]{3}$/.test(Un) && (Un = "#" + Un[1] + Un[1] + Un[2] + Un[2] + Un[3] + Un[3]), typeof Un == "string" && /^#[0-9A-Fa-f]{6}$/.test(Un)) { var Br = parseInt(Un.substr(1), 16); Un = Br >> 16 & 255, $n = Br >> 8 & 255, tr = 255 & Br } if ($n === void 0 || fr === void 0 && Un === $n && $n === tr) if (typeof Un == "string") Sn = Un + " " + Sr[0]; else switch (Qe.precision) { case 2: Sn = Tn(Un / 255) + " " + Sr[0]; break; case 3: default: Sn = fn(Un / 255) + " " + Sr[0] } else if (fr === void 0 || _typeof(fr) === "object") { if (fr && !isNaN(fr.a) && fr.a === 0) return Sn = ["1.", "1.", "1.", Sr[1]].join(" "); if (typeof Un == "string") Sn = [Un, $n, tr, Sr[1]].join(" "); else switch (Qe.precision) { case 2: Sn = [Tn(Un / 255), Tn($n / 255), Tn(tr / 255), Sr[1]].join(" "); break; default: case 3: Sn = [fn(Un / 255), fn($n / 255), fn(tr / 255), Sr[1]].join(" ") } } else if (typeof Un == "string") Sn = [Un, $n, tr, fr, Sr[2]].join(" "); else switch (Qe.precision) { case 2: Sn = [Tn(Un), Tn($n), Tn(tr), Tn(fr), Sr[2]].join(" "); break; case 3: default: Sn = [fn(Un), fn($n), fn(tr), fn(fr), Sr[2]].join(" ") }return Sn }, Bs = Ie.__private__.getFilters = function () { return Ce }, ws = Ie.__private__.putStream = function (Qe) { var Sn = (Qe = Qe || {}).data || "", Un = Qe.filters || Bs(), $n = Qe.alreadyAppliedFilters || [], tr = Qe.addLength1 || !1, fr = Sn.length, Sr = Qe.objectId, jr = function (es) { return es }; if (Oe !== null && Sr === void 0) throw new Error("ObjectId must be passed to putStream for file encryption"); Oe !== null && (jr = gs.encryptor(Sr, 0)); var Br = {}; Un === !0 && (Un = ["FlateEncode"]); var ti = Qe.additionalKeyValues || [], Qr = (Br = E.API.processDataByFilters !== void 0 ? E.API.processDataByFilters(Sn, Un) : { data: Sn, reverseChain: [] }).reverseChain + (Array.isArray($n) ? $n.join(" ") : $n.toString()); if (Br.data.length !== 0 && (ti.push({ key: "Length", value: Br.data.length }), tr === !0 && ti.push({ key: "Length1", value: fr })), Qr.length != 0) if (Qr.split("/").length - 1 == 1) ti.push({ key: "Filter", value: Qr }); else { ti.push({ key: "Filter", value: "[" + Qr + "]" }); for (var mi = 0; mi < ti.length; mi += 1)if (ti[mi].key === "DecodeParms") { for (var zi = [], Vi = 0; Vi < Br.reverseChain.split("/").length - 1; Vi += 1)zi.push("null"); zi.push(ti[mi].value), ti[mi].value = "[" + zi.join(" ") + "]" } } Cn("<<"); for (var Ji = 0; Ji < ti.length; Ji++)Cn("/" + ti[Ji].key + " " + ti[Ji].value); Cn(">>"), Br.data.length !== 0 && (Cn("stream"), Cn(jr(Br.data)), Cn("endstream")) }, Li = Ie.__private__.putPage = function (Qe) {
    var Sn = Qe.number, Un = Qe.data, $n = Qe.objId, tr = Qe.contentsObjId; ms($n, !0), Cn("<</Type /Page"), Cn("/Parent " + Qe.rootDictionaryObjId + " 0 R"), Cn("/Resources " + Qe.resourceDictionaryObjId + " 0 R"), Cn("/MediaBox [" + parseFloat(un(Qe.mediaBox.bottomLeftX)) + " " + parseFloat(un(Qe.mediaBox.bottomLeftY)) + " " + un(Qe.mediaBox.topRightX) + " " + un(Qe.mediaBox.topRightY) + "]"), Qe.cropBox !== null && Cn("/CropBox [" + un(Qe.cropBox.bottomLeftX) + " " + un(Qe.cropBox.bottomLeftY) + " " + un(Qe.cropBox.topRightX) + " " + un(Qe.cropBox.topRightY) + "]"), Qe.bleedBox !== null && Cn("/BleedBox [" + un(Qe.bleedBox.bottomLeftX) + " " + un(Qe.bleedBox.bottomLeftY) + " " + un(Qe.bleedBox.topRightX) + " " + un(Qe.bleedBox.topRightY) + "]"), Qe.trimBox !== null && Cn("/TrimBox [" + un(Qe.trimBox.bottomLeftX) + " " + un(Qe.trimBox.bottomLeftY) + " " + un(Qe.trimBox.topRightX) + " " + un(Qe.trimBox.topRightY) + "]"), Qe.artBox !== null && Cn("/ArtBox [" + un(Qe.artBox.bottomLeftX) + " " + un(Qe.artBox.bottomLeftY) + " " + un(Qe.artBox.topRightX) + " " + un(Qe.artBox.topRightY) + "]"), typeof Qe.userUnit == "number" && Qe.userUnit !== 1 && Cn("/UserUnit " + Qe.userUnit), Ur.publish("putPage", { objId: $n, pageContext: Ar[Sn], pageNumber: Sn, page: Un }), Cn("/Contents " + tr + " 0 R"), Cn(">>"), Cn("endobj"); var fr = Un.join(`
`); return Ze === Ge.ADVANCED && (fr += `
Q`), ms(tr, !0), ws({ data: fr, filters: Bs(), objectId: tr }), Cn("endobj"), $n
  }, po = Ie.__private__.putPages = function () { var Qe, Sn, Un = []; for (Qe = 1; Qe <= xi; Qe++)Ar[Qe].objId = bi(), Ar[Qe].contentsObjId = bi(); for (Qe = 1; Qe <= xi; Qe++)Un.push(Li({ number: Qe, data: On[Qe], objId: Ar[Qe].objId, contentsObjId: Ar[Qe].contentsObjId, mediaBox: Ar[Qe].mediaBox, cropBox: Ar[Qe].cropBox, bleedBox: Ar[Qe].bleedBox, trimBox: Ar[Qe].trimBox, artBox: Ar[Qe].artBox, userUnit: Ar[Qe].userUnit, rootDictionaryObjId: Ws, resourceDictionaryObjId: Xs })); ms(Ws, !0), Cn("<</Type /Pages"); var $n = "/Kids ["; for (Sn = 0; Sn < xi; Sn++)$n += Un[Sn] + " 0 R "; Cn($n + "]"), Cn("/Count " + xi), Cn(">>"), Cn("endobj"), Ur.publish("postPutPages") }, Xo = function (Qe) { Ur.publish("putFont", { font: Qe, out: Cn, newObject: si, putStream: ws }), Qe.isAlreadyPutted !== !0 && (Qe.objectNumber = si(), Cn("<<"), Cn("/Type /Font"), Cn("/BaseFont /" + F(Qe.postScriptName)), Cn("/Subtype /Type1"), typeof Qe.encoding == "string" && Cn("/Encoding /" + Qe.encoding), Cn("/FirstChar 32"), Cn("/LastChar 255"), Cn(">>"), Cn("endobj")) }, ta = function () { for (var Qe in Kn) Kn.hasOwnProperty(Qe) && (je === !1 || je === !0 && Be.hasOwnProperty(Qe)) && Xo(Kn[Qe]) }, da = function (Qe) {
    Qe.objectNumber = si(); var Sn = []; Sn.push({ key: "Type", value: "/XObject" }), Sn.push({ key: "Subtype", value: "/Form" }), Sn.push({ key: "BBox", value: "[" + [un(Qe.x), un(Qe.y), un(Qe.x + Qe.width), un(Qe.y + Qe.height)].join(" ") + "]" }), Sn.push({ key: "Matrix", value: "[" + Qe.matrix.toString() + "]" }); var Un = Qe.pages[1].join(`
`); ws({ data: Un, additionalKeyValues: Sn, objectId: Qe.objectNumber }), Cn("endobj")
  }, _l = function () { for (var Qe in ii) ii.hasOwnProperty(Qe) && da(ii[Qe]) }, vc = function (Qe, Sn) { var Un, $n = [], tr = 1 / (Sn - 1); for (Un = 0; Un < 1; Un += tr)$n.push(Un); if ($n.push(1), Qe[0].offset != 0) { var fr = { offset: 0, color: Qe[0].color }; Qe.unshift(fr) } if (Qe[Qe.length - 1].offset != 1) { var Sr = { offset: 1, color: Qe[Qe.length - 1].color }; Qe.push(Sr) } for (var jr = "", Br = 0, ti = 0; ti < $n.length; ti++) { for (Un = $n[ti]; Un > Qe[Br + 1].offset;)Br++; var Qr = Qe[Br].offset, mi = (Un - Qr) / (Qe[Br + 1].offset - Qr), zi = Qe[Br].color, Vi = Qe[Br + 1].color; jr += mn(Math.round((1 - mi) * zi[0] + mi * Vi[0]).toString(16)) + mn(Math.round((1 - mi) * zi[1] + mi * Vi[1]).toString(16)) + mn(Math.round((1 - mi) * zi[2] + mi * Vi[2]).toString(16)) } return jr.trim() }, eu = function (Qe, Sn) { Sn || (Sn = 21); var Un = si(), $n = vc(Qe.colors, Sn), tr = []; tr.push({ key: "FunctionType", value: "0" }), tr.push({ key: "Domain", value: "[0.0 1.0]" }), tr.push({ key: "Size", value: "[" + Sn + "]" }), tr.push({ key: "BitsPerSample", value: "8" }), tr.push({ key: "Range", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), tr.push({ key: "Decode", value: "[0.0 1.0 0.0 1.0 0.0 1.0]" }), ws({ data: $n, additionalKeyValues: tr, alreadyAppliedFilters: ["/ASCIIHexDecode"], objectId: Un }), Cn("endobj"), Qe.objectNumber = si(), Cn("<< /ShadingType " + Qe.type), Cn("/ColorSpace /DeviceRGB"); var fr = "/Coords [" + un(parseFloat(Qe.coords[0])) + " " + un(parseFloat(Qe.coords[1])) + " "; Qe.type === 2 ? fr += un(parseFloat(Qe.coords[2])) + " " + un(parseFloat(Qe.coords[3])) : fr += un(parseFloat(Qe.coords[2])) + " " + un(parseFloat(Qe.coords[3])) + " " + un(parseFloat(Qe.coords[4])) + " " + un(parseFloat(Qe.coords[5])), Cn(fr += "]"), Qe.matrix && Cn("/Matrix [" + Qe.matrix.toString() + "]"), Cn("/Function " + Un + " 0 R"), Cn("/Extend [true true]"), Cn(">>"), Cn("endobj") }, Uu = function (Qe, Sn) { var Un = bi(), $n = si(); Sn.push({ resourcesOid: Un, objectOid: $n }), Qe.objectNumber = $n; var tr = []; tr.push({ key: "Type", value: "/Pattern" }), tr.push({ key: "PatternType", value: "1" }), tr.push({ key: "PaintType", value: "1" }), tr.push({ key: "TilingType", value: "1" }), tr.push({ key: "BBox", value: "[" + Qe.boundingBox.map(un).join(" ") + "]" }), tr.push({ key: "XStep", value: un(Qe.xStep) }), tr.push({ key: "YStep", value: un(Qe.yStep) }), tr.push({ key: "Resources", value: Un + " 0 R" }), Qe.matrix && tr.push({ key: "Matrix", value: "[" + Qe.matrix.toString() + "]" }), ws({ data: Qe.stream, additionalKeyValues: tr, objectId: Qe.objectNumber }), Cn("endobj") }, Ha = function (Qe) { var Sn; for (Sn in kr) kr.hasOwnProperty(Sn) && (kr[Sn] instanceof B ? eu(kr[Sn]) : kr[Sn] instanceof M && Uu(kr[Sn], Qe)) }, Yo = function (Qe) { for (var Sn in Qe.objectNumber = si(), Cn("<<"), Qe) switch (Sn) { case "opacity": Cn("/ca " + Tn(Qe[Sn])); break; case "stroke-opacity": Cn("/CA " + Tn(Qe[Sn])) }Cn(">>"), Cn("endobj") }, ha = function () { var Qe; for (Qe in ei) ei.hasOwnProperty(Qe) && Yo(ei[Qe]) }, Ko = function () { for (var Qe in Cn("/XObject <<"), ii) ii.hasOwnProperty(Qe) && ii[Qe].objectNumber >= 0 && Cn("/" + Qe + " " + ii[Qe].objectNumber + " 0 R"); Ur.publish("putXobjectDict"), Cn(">>") }, tu = function () { gs.oid = si(), Cn("<<"), Cn("/Filter /Standard"), Cn("/V " + gs.v), Cn("/R " + gs.r), Cn("/U <" + gs.toHexString(gs.U) + ">"), Cn("/O <" + gs.toHexString(gs.O) + ">"), Cn("/P " + gs.P), Cn(">>"), Cn("endobj") }, qa = function () { for (var Qe in Cn("/Font <<"), Kn) Kn.hasOwnProperty(Qe) && (je === !1 || je === !0 && Be.hasOwnProperty(Qe)) && Cn("/" + Qe + " " + Kn[Qe].objectNumber + " 0 R"); Cn(">>") }, bc = function () { if (Object.keys(kr).length > 0) { for (var Qe in Cn("/Shading <<"), kr) kr.hasOwnProperty(Qe) && kr[Qe] instanceof B && kr[Qe].objectNumber >= 0 && Cn("/" + Qe + " " + kr[Qe].objectNumber + " 0 R"); Ur.publish("putShadingPatternDict"), Cn(">>") } }, mo = function (Qe) { if (Object.keys(kr).length > 0) { for (var Sn in Cn("/Pattern <<"), kr) kr.hasOwnProperty(Sn) && kr[Sn] instanceof Ie.TilingPattern && kr[Sn].objectNumber >= 0 && kr[Sn].objectNumber < Qe && Cn("/" + Sn + " " + kr[Sn].objectNumber + " 0 R"); Ur.publish("putTilingPatternDict"), Cn(">>") } }, zu = function () { if (Object.keys(ei).length > 0) { var Qe; for (Qe in Cn("/ExtGState <<"), ei) ei.hasOwnProperty(Qe) && ei[Qe].objectNumber >= 0 && Cn("/" + Qe + " " + ei[Qe].objectNumber + " 0 R"); Ur.publish("putGStateDict"), Cn(">>") } }, Xi = function (Qe) { ms(Qe.resourcesOid, !0), Cn("<<"), Cn("/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]"), qa(), bc(), mo(Qe.objectOid), zu(), Ko(), Cn(">>"), Cn("endobj") }, Ls = function () { var Qe = []; ta(), ha(), _l(), Ha(Qe), Ur.publish("putResources"), Qe.forEach(Xi), Xi({ resourcesOid: Xs, objectOid: Number.MAX_SAFE_INTEGER }), Ur.publish("postPutResources") }, xc = function () { Ur.publish("putAdditionalObjects"); for (var Qe = 0; Qe < _n.length; Qe++) { var Sn = _n[Qe]; ms(Sn.objId, !0), Cn(Sn.content), Cn("endobj") } Ur.publish("postPutAdditionalObjects") }, nu = function (Qe) { Qn[Qe.fontName] = Qn[Qe.fontName] || {}, Qn[Qe.fontName][Qe.fontStyle] = Qe.id }, go = function (Qe, Sn, Un, $n, tr) { var fr = { id: "F" + (Object.keys(Kn).length + 1).toString(10), postScriptName: Qe, fontName: Sn, fontStyle: Un, encoding: $n, isStandardFont: tr || !1, metadata: {} }; return Ur.publish("addFont", { font: fr, instance: this }), Kn[fr.id] = fr, nu(fr), fr.id }, ru = function (Qe) { for (var Sn = 0, Un = qn.length; Sn < Un; Sn++) { var $n = go.call(this, Qe[Sn][0], Qe[Sn][1], Qe[Sn][2], qn[Sn][3], !0); je === !1 && (Be[$n] = !0); var tr = Qe[Sn][0].split("-"); nu({ id: $n, fontName: tr[0], fontStyle: tr[1] || "" }) } Ur.publish("addFonts", { fonts: Kn, dictionary: Qn }) }, Us = function (Qe) {
    return Qe.foo = function () {
      try { return Qe.apply(this, arguments) } catch ($n) {
        var Sn = $n.stack || ""; ~Sn.indexOf(" at ") && (Sn = Sn.split(" at ")[1]); var Un = "Error in function " + Sn.split(`
`)[0].split("<")[0] + ": " + $n.message; if (!n.console) throw new Error(Un); n.console.error(Un, $n), n.alert && alert(Un)
      }
    }, Qe.foo.bar = Qe, Qe.foo
  }, Rl = function (Qe, Sn) { var Un, $n, tr, fr, Sr, jr, Br, ti, Qr; if (tr = (Sn = Sn || {}).sourceEncoding || "Unicode", Sr = Sn.outputEncoding, (Sn.autoencode || Sr) && Kn[zr].metadata && Kn[zr].metadata[tr] && Kn[zr].metadata[tr].encoding && (fr = Kn[zr].metadata[tr].encoding, !Sr && Kn[zr].encoding && (Sr = Kn[zr].encoding), !Sr && fr.codePages && (Sr = fr.codePages[0]), typeof Sr == "string" && (Sr = fr[Sr]), Sr)) { for (Br = !1, jr = [], Un = 0, $n = Qe.length; Un < $n; Un++)(ti = Sr[Qe.charCodeAt(Un)]) ? jr.push(String.fromCharCode(ti)) : jr.push(Qe[Un]), jr[Un].charCodeAt(0) >> 8 && (Br = !0); Qe = jr.join("") } for (Un = Qe.length; Br === void 0 && Un !== 0;)Qe.charCodeAt(Un - 1) >> 8 && (Br = !0), Un--; if (!Br) return Qe; for (jr = Sn.noBOM ? [] : [254, 255], Un = 0, $n = Qe.length; Un < $n; Un++) { if ((Qr = (ti = Qe.charCodeAt(Un)) >> 8) >> 8) throw new Error("Character at position " + Un + " of string '" + Qe + "' exceeds 16bits. Cannot be encoded into UCS-2 BE"); jr.push(Qr), jr.push(ti - (Qr << 8)) } return String.fromCharCode.apply(void 0, jr) }, Bi = Ie.__private__.pdfEscape = Ie.pdfEscape = function (Qe, Sn) { return Rl(Qe, Sn).replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)") }, Qo = Ie.__private__.beginPage = function (Qe) { On[++xi] = [], Ar[xi] = { objId: 0, contentsObjId: 0, userUnit: Number(Me), artBox: null, bleedBox: null, cropBox: null, trimBox: null, mediaBox: { bottomLeftX: 0, bottomLeftY: 0, topRightX: Number(Qe[0]), topRightY: Number(Qe[1]) } }, $a(xi), Fn(On[rn]) }, yc = function (Qe, Sn) { var Un, $n, tr; switch (xe = Sn || xe, typeof Qe == "string" && (Un = He(Qe.toLowerCase()), Array.isArray(Un) && ($n = Un[0], tr = Un[1])), Array.isArray(Qe) && ($n = Qe[0] * Tr, tr = Qe[1] * Tr), isNaN($n) && ($n = _e[0], tr = _e[1]), ($n > 14400 || tr > 14400) && (a.warn("A page in a PDF can not be wider or taller than 14400 userUnit. jsPDF limits the width/height to 14400"), $n = Math.min(14400, $n), tr = Math.min(14400, tr)), _e = [$n, tr], xe.substr(0, 1)) { case "l": tr > $n && (_e = [tr, $n]); break; case "p": $n > tr && (_e = [tr, $n]) }Qo(_e), cu(yo), Cn(fa), Cc !== 0 && Cn(Cc + " J"), Ml !== 0 && Cn(Ml + " j"), Ur.publish("addPage", { pageNumber: xi }) }, Ec = function (Qe) { Qe > 0 && Qe <= xi && (On.splice(Qe, 1), Ar.splice(Qe, 1), xi--, rn > xi && (rn = xi), this.setPage(rn)) }, $a = function (Qe) { Qe > 0 && Qe <= xi && (rn = Qe) }, iu = Ie.__private__.getNumberOfPages = Ie.getNumberOfPages = function () { return On.length - 1 }, wc = function (Qe, Sn, Un) { var $n, tr = void 0; return Un = Un || {}, Qe = Qe !== void 0 ? Qe : Kn[zr].fontName, Sn = Sn !== void 0 ? Sn : Kn[zr].fontStyle, $n = Qe.toLowerCase(), Qn[$n] !== void 0 && Qn[$n][Sn] !== void 0 ? tr = Qn[$n][Sn] : Qn[Qe] !== void 0 && Qn[Qe][Sn] !== void 0 ? tr = Qn[Qe][Sn] : Un.disableWarning === !1 && a.warn("Unable to look up font label for font '" + Qe + "', '" + Sn + "'. Refer to getFontList() for available fonts."), tr || Un.noFallback || (tr = Qn.times[Sn]) == null && (tr = Qn.times.normal), tr }, vo = Ie.__private__.putInfo = function () { var Qe = si(), Sn = function ($n) { return $n }; for (var Un in Oe !== null && (Sn = gs.encryptor(Qe, 0)), Cn("<<"), Cn("/Producer (" + Bi(Sn("jsPDF " + E.version)) + ")"), Cr) Cr.hasOwnProperty(Un) && Cr[Un] && Cn("/" + Un.substr(0, 1).toUpperCase() + Un.substr(1) + " (" + Bi(Sn(Cr[Un])) + ")"); Cn("/CreationDate (" + Bi(Sn(In)) + ")"), Cn(">>"), Cn("endobj") }, Ac = Ie.__private__.putCatalog = function (Qe) { var Sn = (Qe = Qe || {}).rootDictionaryObjId || Ws; switch (si(), Cn("<<"), Cn("/Type /Catalog"), Cn("/Pages " + Sn + " 0 R"), hr || (hr = "fullwidth"), hr) { case "fullwidth": Cn("/OpenAction [3 0 R /FitH null]"); break; case "fullheight": Cn("/OpenAction [3 0 R /FitV null]"); break; case "fullpage": Cn("/OpenAction [3 0 R /Fit]"); break; case "original": Cn("/OpenAction [3 0 R /XYZ null null 1]"); break; default: var Un = "" + hr; Un.substr(Un.length - 1) === "%" && (hr = parseInt(hr) / 100), typeof hr == "number" && Cn("/OpenAction [3 0 R /XYZ null null " + Tn(hr) + "]") }switch (Ir || (Ir = "continuous"), Ir) { case "continuous": Cn("/PageLayout /OneColumn"); break; case "single": Cn("/PageLayout /SinglePage"); break; case "two": case "twoleft": Cn("/PageLayout /TwoColumnLeft"); break; case "tworight": Cn("/PageLayout /TwoColumnRight") }_r && Cn("/PageMode /" + _r), Ur.publish("putCatalog"), Cn(">>"), Cn("endobj") }, su = Ie.__private__.putTrailer = function () { Cn("trailer"), Cn("<<"), Cn("/Size " + (Ye + 1)), Cn("/Root " + Ye + " 0 R"), Cn("/Info " + (Ye - 1) + " 0 R"), Oe !== null && Cn("/Encrypt " + gs.oid + " 0 R"), Cn("/ID [ <" + xn + "> <" + xn + "> ]"), Cn(">>") }, au = Ie.__private__.putHeader = function () { Cn("%PDF-" + Fe), Cn("%ºß¬à") }, Sc = Ie.__private__.putXRef = function () { var Qe = "0000000000"; Cn("xref"), Cn("0 " + (Ye + 1)), Cn("0000000000 65535 f "); for (var Sn = 1; Sn <= Ye; Sn++)typeof an[Sn] == "function" ? Cn((Qe + an[Sn]()).slice(-10) + " 00000 n ") : an[Sn] !== void 0 ? Cn((Qe + an[Sn]).slice(-10) + " 00000 n ") : Cn("0000000000 00000 n ") }, Va = Ie.__private__.buildDocument = function () {
    sr(), Fn(pn), Ur.publish("buildDocument"), au(), po(), xc(), Ls(), Oe !== null && tu(), vo(), Ac(); var Qe = yn; return Sc(), su(), Cn("startxref"), Cn("" + Qe), Cn("%%EOF"), Fn(On[rn]), pn.join(`
`)
  }, Cl = Ie.__private__.getBlob = function (Qe) { return new Blob([Yn(Qe)], { type: "application/pdf" }) }, Ga = Ie.output = Ie.__private__.output = Us(function (Qe, Sn) { switch (typeof (Sn = Sn || {}) == "string" ? Sn = { filename: Sn } : Sn.filename = Sn.filename || "generated.pdf", Qe) { case void 0: return Va(); case "save": Ie.save(Sn.filename); break; case "arraybuffer": return Yn(Va()); case "blob": return Cl(Va()); case "bloburi": case "bloburl": if (n.URL !== void 0 && typeof n.URL.createObjectURL == "function") return n.URL && n.URL.createObjectURL(Cl(Va())) || void 0; a.warn("bloburl is not supported by your system, because URL.createObjectURL is not supported by your browser."); break; case "datauristring": case "dataurlstring": var Un = "", $n = Va(); try { Un = h($n) } catch { Un = h(unescape(encodeURIComponent($n))) } return "data:application/pdf;filename=" + Sn.filename + ";base64," + Un; case "pdfobjectnewwindow": if (Object.prototype.toString.call(n) === "[object Window]") { var tr = "https://cdnjs.cloudflare.com/ajax/libs/pdfobject/2.1.1/pdfobject.min.js", fr = ' integrity="sha512-4ze/a9/4jqu+tX9dfOqJYSvyYd5M6qum/3HpCLr+/Jqf0whc37VUbkpNGHR7/8pSnCFw47T1fmIpwBV7UySh3g==" crossorigin="anonymous"'; Sn.pdfObjectUrl && (tr = Sn.pdfObjectUrl, fr = ""); var Sr = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><script src="' + tr + '"' + fr + '><\/script><script >PDFObject.embed("' + this.output("dataurlstring") + '", ' + JSON.stringify(Sn) + ");<\/script></body></html>", jr = n.open(); return jr !== null && jr.document.write(Sr), jr } throw new Error("The option pdfobjectnewwindow just works in a browser-environment."); case "pdfjsnewwindow": if (Object.prototype.toString.call(n) === "[object Window]") { var Br = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe id="pdfViewer" src="' + (Sn.pdfJsUrl || "examples/PDF.js/web/viewer.html") + "?file=&downloadName=" + Sn.filename + '" width="500px" height="400px" /></body></html>', ti = n.open(); if (ti !== null) { ti.document.write(Br); var Qr = this; ti.document.documentElement.querySelector("#pdfViewer").onload = function () { ti.document.title = Sn.filename, ti.document.documentElement.querySelector("#pdfViewer").contentWindow.PDFViewerApplication.open(Qr.output("bloburl")) } } return ti } throw new Error("The option pdfjsnewwindow just works in a browser-environment."); case "dataurlnewwindow": if (Object.prototype.toString.call(n) !== "[object Window]") throw new Error("The option dataurlnewwindow just works in a browser-environment."); var mi = '<html><style>html, body { padding: 0; margin: 0; } iframe { width: 100%; height: 100%; border: 0;}  </style><body><iframe src="' + this.output("datauristring", Sn) + '"></iframe></body></html>', zi = n.open(); if (zi !== null && (zi.document.write(mi), zi.document.title = Sn.filename), zi || typeof safari > "u") return zi; break; case "datauri": case "dataurl": return n.document.location.href = this.output("datauristring", Sn); default: return null } }), Tl = function (Qe) { return Array.isArray(hi) === !0 && hi.indexOf(Qe) > -1 }; switch (Ee) { case "pt": Tr = 1; break; case "mm": Tr = 72 / 25.4; break; case "cm": Tr = 72 / 2.54; break; case "in": Tr = 72; break; case "px": Tr = Tl("px_scaling") == 1 ? .75 : 96 / 72; break; case "pc": case "em": Tr = 12; break; case "ex": Tr = 6; break; default: if (typeof Ee != "number") throw new Error("Invalid unit: " + Ee); Tr = Ee }var gs = null; dn(), tn(); var bo = function (Qe) { return Oe !== null ? gs.encryptor(Qe, 0) : function (Sn) { return Sn } }, Wa = Ie.__private__.getPageInfo = Ie.getPageInfo = function (Qe) { if (isNaN(Qe) || Qe % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfo"); return { objId: Ar[Qe].objId, pageNumber: Qe, pageContext: Ar[Qe] } }, Yr = Ie.__private__.getPageInfoByObjId = function (Qe) { if (isNaN(Qe) || Qe % 1 != 0) throw new Error("Invalid argument passed to jsPDF.getPageInfoByObjId"); for (var Sn in Ar) if (Ar[Sn].objId === Qe) break; return Wa(Sn) }, _c = Ie.__private__.getCurrentPageInfo = Ie.getCurrentPageInfo = function () { return { objId: Ar[rn].objId, pageNumber: rn, pageContext: Ar[rn] } }; Ie.addPage = function () { return yc.apply(this, arguments), this }, Ie.setPage = function () { return $a.apply(this, arguments), Fn.call(this, On[rn]), this }, Ie.insertPage = function (Qe) { return this.addPage(), this.movePage(rn, Qe), this }, Ie.movePage = function (Qe, Sn) { var Un, $n; if (Qe > Sn) { Un = On[Qe], $n = Ar[Qe]; for (var tr = Qe; tr > Sn; tr--)On[tr] = On[tr - 1], Ar[tr] = Ar[tr - 1]; On[Sn] = Un, Ar[Sn] = $n, this.setPage(Sn) } else if (Qe < Sn) { Un = On[Qe], $n = Ar[Qe]; for (var fr = Qe; fr < Sn; fr++)On[fr] = On[fr + 1], Ar[fr] = Ar[fr + 1]; On[Sn] = Un, Ar[Sn] = $n, this.setPage(Sn) } return this }, Ie.deletePage = function () { return Ec.apply(this, arguments), this }, Ie.__private__.text = Ie.text = function (Qe, Sn, Un, $n, tr) {
    var fr, Sr, jr, Br, ti, Qr, mi, zi, Vi, Ji = ($n = $n || {}).scope || this; if (typeof Qe == "number" && typeof Sn == "number" && (typeof Un == "string" || Array.isArray(Un))) { var es = Un; Un = Sn, Sn = Qe, Qe = es } if (arguments[3] instanceof Lr ? (on("The transform parameter of text() with a Matrix value"), Vi = tr) : (jr = arguments[4], Br = arguments[5], _typeof(mi = arguments[3]) === "object" && mi !== null || (typeof jr == "string" && (Br = jr, jr = null), typeof mi == "string" && (Br = mi, mi = null), typeof mi == "number" && (jr = mi, mi = null), $n = { flags: mi, angle: jr, align: Br })), isNaN(Sn) || isNaN(Un) || Qe == null) throw new Error("Invalid arguments passed to jsPDF.text"); if (Qe.length === 0) return Ji; var vs = "", pa = !1, Qs = typeof $n.lineHeightFactor == "number" ? $n.lineHeightFactor : Ys, ma = Ji.internal.scaleFactor; function Oc(li) { return li = li.split("	").join(Array($n.TabLen || 9).join(" ")), Bi(li, mi) } function Ya(li) { for (var ci, ki = li.concat(), ts = [], sa = ki.length; sa--;)typeof (ci = ki.shift()) == "string" ? ts.push(ci) : Array.isArray(li) && (ci.length === 1 || ci[1] === void 0 && ci[2] === void 0) ? ts.push(ci[0]) : ts.push([ci[0], ci[1], ci[2]]); return ts } function Ka(li, ci) { var ki; if (typeof li == "string") ki = ci(li)[0]; else if (Array.isArray(li)) { for (var ts, sa, jo = li.concat(), Mo = [], Ja = jo.length; Ja--;)typeof (ts = jo.shift()) == "string" ? Mo.push(ci(ts)[0]) : Array.isArray(ts) && typeof ts[0] == "string" && (sa = ci(ts[0], ts[1], ts[2]), Mo.push([sa[0], sa[1], sa[2]])); ki = Mo } return ki } var Bl = !1, So = !0; if (typeof Qe == "string") Bl = !0; else if (Array.isArray(Qe)) { var Ul = Qe.concat(); Sr = []; for (var tl, cs = Ul.length; cs--;)(typeof (tl = Ul.shift()) != "string" || Array.isArray(tl) && typeof tl[0] != "string") && (So = !1); Bl = So } if (Bl === !1) throw new Error('Type of text must be string or Array. "' + Qe + '" is not recognized.'); typeof Qe == "string" && (Qe = Qe.match(/[\r?\n]/) ? Qe.split(/\r\n|\r|\n/g) : [Qe]); var _o = rr / Ji.internal.scaleFactor, nl = _o * (Qs - 1); switch ($n.baseline) { case "bottom": Un -= nl; break; case "top": Un += _o - nl; break; case "hanging": Un += _o - 2 * nl; break; case "middle": Un += _o / 2 - nl }if ((Qr = $n.maxWidth || 0) > 0 && (typeof Qe == "string" ? Qe = Ji.splitTextToSize(Qe, Qr) : Object.prototype.toString.call(Qe) === "[object Array]" && (Qe = Qe.reduce(function (li, ci) { return li.concat(Ji.splitTextToSize(ci, Qr)) }, []))), fr = { text: Qe, x: Sn, y: Un, options: $n, mutex: { pdfEscape: Bi, activeFontKey: zr, fonts: Kn, activeFontSize: rr } }, Ur.publish("preProcessText", fr), Qe = fr.text, jr = ($n = fr.options).angle, !(Vi instanceof Lr) && jr && typeof jr == "number") { jr *= Math.PI / 180, $n.rotationDirection === 0 && (jr = -jr), Ze === Ge.ADVANCED && (jr = -jr); var rl = Math.cos(jr), zl = Math.sin(jr); Vi = new Lr(rl, zl, -zl, rl, 0, 0) } else jr && jr instanceof Lr && (Vi = jr); Ze !== Ge.ADVANCED || Vi || (Vi = ni), (ti = $n.charSpace || jl) !== void 0 && (vs += un(En(ti)) + ` Tc
`, this.setCharSpace(this.getCharSpace() || 0)), (zi = $n.horizontalScale) !== void 0 && (vs += un(100 * zi) + ` Tz
`), $n.lang; var Hs = -1, Gu = $n.renderingMode !== void 0 ? $n.renderingMode : $n.stroke, Lc = Ji.internal.getCurrentPageInfo().pageContext; switch (Gu) { case 0: case !1: case "fill": Hs = 0; break; case 1: case !0: case "stroke": Hs = 1; break; case 2: case "fillThenStroke": Hs = 2; break; case 3: case "invisible": Hs = 3; break; case 4: case "fillAndAddForClipping": Hs = 4; break; case 5: case "strokeAndAddPathForClipping": Hs = 5; break; case 6: case "fillThenStrokeAndAddToPathForClipping": Hs = 6; break; case 7: case "addToPathForClipping": Hs = 7 }var du = Lc.usedRenderingMode !== void 0 ? Lc.usedRenderingMode : -1; Hs !== -1 ? vs += Hs + ` Tr
`: du !== -1 && (vs += `0 Tr
`), Hs !== -1 && (Lc.usedRenderingMode = Hs), Br = $n.align || "left"; var ia, bs = rr * Qs, Ro = Ji.internal.pageSize.getWidth(), jc = Kn[zr]; ti = $n.charSpace || jl, Qr = $n.maxWidth || 0, mi = Object.assign({ autoencode: !0, noBOM: !0 }, $n.flags); var Qa = [], Co = function (li) { return Ji.getStringUnitWidth(li, { font: jc, charSpace: ti, fontSize: rr, doKerning: !1 }) * rr / ma }; if (Object.prototype.toString.call(Qe) === "[object Array]") { var js; Sr = Ya(Qe), Br !== "left" && (ia = Sr.map(Co)); var As, To = 0; if (Br === "right") { Sn -= ia[0], Qe = [], cs = Sr.length; for (var qs = 0; qs < cs; qs++)qs === 0 ? (As = Ks(Sn), js = Pa(Un)) : (As = En(To - ia[qs]), js = -bs), Qe.push([Sr[qs], As, js]), To = ia[qs] } else if (Br === "center") { Sn -= ia[0] / 2, Qe = [], cs = Sr.length; for (var ga = 0; ga < cs; ga++)ga === 0 ? (As = Ks(Sn), js = Pa(Un)) : (As = En((To - ia[ga]) / 2), js = -bs), Qe.push([Sr[ga], As, js]), To = ia[ga] } else if (Br === "left") { Qe = [], cs = Sr.length; for (var Oa = 0; Oa < cs; Oa++)Qe.push(Sr[Oa]) } else if (Br === "justify" && jc.encoding === "Identity-H") { Qe = [], cs = Sr.length, Qr = Qr !== 0 ? Qr : Ro; for (var va = 0, Yi = 0; Yi < cs; Yi++)if (js = Yi === 0 ? Pa(Un) : -bs, As = Yi === 0 ? Ks(Sn) : va, Yi < cs - 1) { var ba = En((Qr - ia[Yi]) / (Sr[Yi].split(" ").length - 1)), ss = Sr[Yi].split(" "); Qe.push([ss[0] + " ", As, js]), va = 0; for (var $s = 1; $s < ss.length; $s++) { var il = (Co(ss[$s - 1] + " " + ss[$s]) - Co(ss[$s])) * ma + ba; $s == ss.length - 1 ? Qe.push([ss[$s], il, 0]) : Qe.push([ss[$s] + " ", il, 0]), va -= il } } else Qe.push([Sr[Yi], As, js]); Qe.push(["", va, 0]) } else { if (Br !== "justify") throw new Error('Unrecognized alignment option, use "left", "center", "right" or "justify".'); for (Qe = [], cs = Sr.length, Qr = Qr !== 0 ? Qr : Ro, Yi = 0; Yi < cs; Yi++)js = Yi === 0 ? Pa(Un) : -bs, As = Yi === 0 ? Ks(Sn) : 0, Yi < cs - 1 ? Qa.push(un(En((Qr - ia[Yi]) / (Sr[Yi].split(" ").length - 1)))) : Qa.push(0), Qe.push([Sr[Yi], As, js]) } } var La = typeof $n.R2L == "boolean" ? $n.R2L : Er; La === !0 && (Qe = Ka(Qe, function (li, ci, ki) { return [li.split("").reverse().join(""), ci, ki] })), fr = { text: Qe, x: Sn, y: Un, options: $n, mutex: { pdfEscape: Bi, activeFontKey: zr, fonts: Kn, activeFontSize: rr } }, Ur.publish("postProcessText", fr), Qe = fr.text, pa = fr.mutex.isHex || !1; var Hl = Kn[zr].encoding; Hl !== "WinAnsiEncoding" && Hl !== "StandardEncoding" || (Qe = Ka(Qe, function (li, ci, ki) { return [Oc(li), ci, ki] })), Sr = Ya(Qe), Qe = []; for (var No, Po, Oo, sl = 0, ql = 1, Lo = Array.isArray(Sr[0]) ? ql : sl, Za = "", al = function (li, ci, ki) {
      var ts = ""; return ki instanceof Lr ? (ki = typeof $n.angle == "number" ? pi(ki, new Lr(1, 0, 0, 1, li, ci)) : pi(new Lr(1, 0, 0, 1, li, ci), ki), Ze === Ge.ADVANCED && (ki = pi(new Lr(1, 0, 0, -1, 0, 0), ki)), ts = ki.join(" ") + ` Tm
`) : ts = un(li) + " " + un(ci) + ` Td
`, ts
    }, Ki = 0; Ki < Sr.length; Ki++) {
      switch (Za = "", Lo) { case ql: Oo = (pa ? "<" : "(") + Sr[Ki][0] + (pa ? ">" : ")"), No = parseFloat(Sr[Ki][1]), Po = parseFloat(Sr[Ki][2]); break; case sl: Oo = (pa ? "<" : "(") + Sr[Ki] + (pa ? ">" : ")"), No = Ks(Sn), Po = Pa(Un) }Qa !== void 0 && Qa[Ki] !== void 0 && (Za = Qa[Ki] + ` Tw
`), Ki === 0 ? Qe.push(Za + al(No, Po, Vi) + Oo) : Lo === sl ? Qe.push(Za + Oo) : Lo === ql && Qe.push(Za + al(No, Po, Vi) + Oo)
    } Qe = Lo === sl ? Qe.join(` Tj
T* `) : Qe.join(` Tj
`), Qe += ` Tj
`; var Zs = `BT
/`; return Zs += zr + " " + rr + ` Tf
`, Zs += un(rr * Qs) + ` TL
`, Zs += Jo + `
`, Zs += vs, Zs += Qe, Cn(Zs += "ET"), Be[zr] = !0, Ji
  }; var ou = Ie.__private__.clip = Ie.clip = function (Qe) { return Cn(Qe === "evenodd" ? "W*" : "W"), this }; Ie.clipEvenOdd = function () { return ou("evenodd") }, Ie.__private__.discardPath = Ie.discardPath = function () { return Cn("n"), this }; var zs = Ie.__private__.isValidStyle = function (Qe) { var Sn = !1; return [void 0, null, "S", "D", "F", "DF", "FD", "f", "f*", "B", "B*", "n"].indexOf(Qe) !== -1 && (Sn = !0), Sn }; Ie.__private__.setDefaultPathOperation = Ie.setDefaultPathOperation = function (Qe) { return zs(Qe) && (Pe = Qe), this }; var na = Ie.__private__.getStyle = Ie.getStyle = function (Qe) { var Sn = Pe; switch (Qe) { case "D": case "S": Sn = "S"; break; case "F": Sn = "f"; break; case "FD": case "DF": Sn = "B"; break; case "f": case "f*": case "B": case "B*": Sn = Qe }return Sn }, Nl = Ie.close = function () { return Cn("h"), this }; Ie.stroke = function () { return Cn("S"), this }, Ie.fill = function (Qe) { return Ca("f", Qe), this }, Ie.fillEvenOdd = function (Qe) { return Ca("f*", Qe), this }, Ie.fillStroke = function (Qe) { return Ca("B", Qe), this }, Ie.fillStrokeEvenOdd = function (Qe) { return Ca("B*", Qe), this }; var Ca = function (Qe, Sn) { _typeof(Sn) === "object" ? Pl(Sn, Qe) : Cn(Qe) }, ra = function (Qe) { Qe === null || Ze === Ge.ADVANCED && Qe === void 0 || (Qe = na(Qe), Cn(Qe)) }; function Rc(Qe, Sn, Un, $n, tr) { var fr = new M(Sn || this.boundingBox, Un || this.xStep, $n || this.yStep, this.gState, tr || this.matrix); fr.stream = this.stream; var Sr = Qe + "$$" + this.cloneIndex++ + "$$"; return oi(Sr, fr), fr } var Pl = function (Qe, Sn) { var Un = di[Qe.key], $n = kr[Un]; if ($n instanceof B) Cn("q"), Cn(lu(Sn)), $n.gState && Ie.setGState($n.gState), Cn(Qe.matrix.toString() + " cm"), Cn("/" + Un + " sh"), Cn("Q"); else if ($n instanceof M) { var tr = new Lr(1, 0, 0, -1, 0, Ao()); Qe.matrix && (tr = tr.multiply(Qe.matrix || ni), Un = Rc.call($n, Qe.key, Qe.boundingBox, Qe.xStep, Qe.yStep, tr).id), Cn("q"), Cn("/Pattern cs"), Cn("/" + Un + " scn"), $n.gState && Ie.setGState($n.gState), Cn(Sn), Cn("Q") } }, lu = function (Qe) { switch (Qe) { case "f": case "F": return "W n"; case "f*": return "W* n"; case "B": return "W S"; case "B*": return "W* S"; case "S": return "W S"; case "n": return "W n" } }, xo = Ie.moveTo = function (Qe, Sn) { return Cn(un(En(Qe)) + " " + un(Rn(Sn)) + " m"), this }, Ta = Ie.lineTo = function (Qe, Sn) { return Cn(un(En(Qe)) + " " + un(Rn(Sn)) + " l"), this }, Xa = Ie.curveTo = function (Qe, Sn, Un, $n, tr, fr) { return Cn([un(En(Qe)), un(Rn(Sn)), un(En(Un)), un(Rn($n)), un(En(tr)), un(Rn(fr)), "c"].join(" ")), this }; Ie.__private__.line = Ie.line = function (Qe, Sn, Un, $n, tr) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || isNaN($n) || !zs(tr)) throw new Error("Invalid arguments passed to jsPDF.line"); return Ze === Ge.COMPAT ? this.lines([[Un - Qe, $n - Sn]], Qe, Sn, [1, 1], tr || "S") : this.lines([[Un - Qe, $n - Sn]], Qe, Sn, [1, 1]).stroke() }, Ie.__private__.lines = Ie.lines = function (Qe, Sn, Un, $n, tr, fr) { var Sr, jr, Br, ti, Qr, mi, zi, Vi, Ji, es, vs, pa; if (typeof Qe == "number" && (pa = Un, Un = Sn, Sn = Qe, Qe = pa), $n = $n || [1, 1], fr = fr || !1, isNaN(Sn) || isNaN(Un) || !Array.isArray(Qe) || !Array.isArray($n) || !zs(tr) || typeof fr != "boolean") throw new Error("Invalid arguments passed to jsPDF.lines"); for (xo(Sn, Un), Sr = $n[0], jr = $n[1], ti = Qe.length, es = Sn, vs = Un, Br = 0; Br < ti; Br++)(Qr = Qe[Br]).length === 2 ? (es = Qr[0] * Sr + es, vs = Qr[1] * jr + vs, Ta(es, vs)) : (mi = Qr[0] * Sr + es, zi = Qr[1] * jr + vs, Vi = Qr[2] * Sr + es, Ji = Qr[3] * jr + vs, es = Qr[4] * Sr + es, vs = Qr[5] * jr + vs, Xa(mi, zi, Vi, Ji, es, vs)); return fr && Nl(), ra(tr), this }, Ie.path = function (Qe) { for (var Sn = 0; Sn < Qe.length; Sn++) { var Un = Qe[Sn], $n = Un.c; switch (Un.op) { case "m": xo($n[0], $n[1]); break; case "l": Ta($n[0], $n[1]); break; case "c": Xa.apply(this, $n); break; case "h": Nl() } } return this }, Ie.__private__.rect = Ie.rect = function (Qe, Sn, Un, $n, tr) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || isNaN($n) || !zs(tr)) throw new Error("Invalid arguments passed to jsPDF.rect"); return Ze === Ge.COMPAT && ($n = -$n), Cn([un(En(Qe)), un(Rn(Sn)), un(En(Un)), un(En($n)), "re"].join(" ")), ra(tr), this }, Ie.__private__.triangle = Ie.triangle = function (Qe, Sn, Un, $n, tr, fr, Sr) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || isNaN($n) || isNaN(tr) || isNaN(fr) || !zs(Sr)) throw new Error("Invalid arguments passed to jsPDF.triangle"); return this.lines([[Un - Qe, $n - Sn], [tr - Un, fr - $n], [Qe - tr, Sn - fr]], Qe, Sn, [1, 1], Sr, !0), this }, Ie.__private__.roundedRect = Ie.roundedRect = function (Qe, Sn, Un, $n, tr, fr, Sr) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || isNaN($n) || isNaN(tr) || isNaN(fr) || !zs(Sr)) throw new Error("Invalid arguments passed to jsPDF.roundedRect"); var jr = 4 / 3 * (Math.SQRT2 - 1); return tr = Math.min(tr, .5 * Un), fr = Math.min(fr, .5 * $n), this.lines([[Un - 2 * tr, 0], [tr * jr, 0, tr, fr - fr * jr, tr, fr], [0, $n - 2 * fr], [0, fr * jr, -tr * jr, fr, -tr, fr], [2 * tr - Un, 0], [-tr * jr, 0, -tr, -fr * jr, -tr, -fr], [0, 2 * fr - $n], [0, -fr * jr, tr * jr, -fr, tr, -fr]], Qe + tr, Sn, [1, 1], Sr, !0), this }, Ie.__private__.ellipse = Ie.ellipse = function (Qe, Sn, Un, $n, tr) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || isNaN($n) || !zs(tr)) throw new Error("Invalid arguments passed to jsPDF.ellipse"); var fr = 4 / 3 * (Math.SQRT2 - 1) * Un, Sr = 4 / 3 * (Math.SQRT2 - 1) * $n; return xo(Qe + Un, Sn), Xa(Qe + Un, Sn - Sr, Qe + fr, Sn - $n, Qe, Sn - $n), Xa(Qe - fr, Sn - $n, Qe - Un, Sn - Sr, Qe - Un, Sn), Xa(Qe - Un, Sn + Sr, Qe - fr, Sn + $n, Qe, Sn + $n), Xa(Qe + fr, Sn + $n, Qe + Un, Sn + Sr, Qe + Un, Sn), ra(tr), this }, Ie.__private__.circle = Ie.circle = function (Qe, Sn, Un, $n) { if (isNaN(Qe) || isNaN(Sn) || isNaN(Un) || !zs($n)) throw new Error("Invalid arguments passed to jsPDF.circle"); return this.ellipse(Qe, Sn, Un, Un, $n) }, Ie.setFont = function (Qe, Sn, Un) { return Un && (Sn = St(Sn, Un)), zr = wc(Qe, Sn, { disableWarning: !1 }), this }; var Cs = Ie.__private__.getFont = Ie.getFont = function () { return Kn[wc.apply(Ie, arguments)] }; Ie.__private__.getFontList = Ie.getFontList = function () { var Qe, Sn, Un = {}; for (Qe in Qn) if (Qn.hasOwnProperty(Qe)) for (Sn in Un[Qe] = [], Qn[Qe]) Qn[Qe].hasOwnProperty(Sn) && Un[Qe].push(Sn); return Un }, Ie.addFont = function (Qe, Sn, Un, $n, tr) { var fr = ["StandardEncoding", "MacRomanEncoding", "Identity-H", "WinAnsiEncoding"]; return arguments[3] && fr.indexOf(arguments[3]) !== -1 ? tr = arguments[3] : arguments[3] && fr.indexOf(arguments[3]) == -1 && (Un = St(Un, $n)), tr = tr || "Identity-H", go.call(this, Qe, Sn, Un, tr) }; var Ys, yo = e.lineWidth || .200025, Na = Ie.__private__.getLineWidth = Ie.getLineWidth = function () { return yo }, cu = Ie.__private__.setLineWidth = Ie.setLineWidth = function (Qe) { return yo = Qe, Cn(un(En(Qe)) + " w"), this }; Ie.__private__.setLineDash = E.API.setLineDash = E.API.setLineDashPattern = function (Qe, Sn) { if (Qe = Qe || [], Sn = Sn || 0, isNaN(Sn) || !Array.isArray(Qe)) throw new Error("Invalid arguments passed to jsPDF.setLineDash"); return Qe = Qe.map(function (Un) { return un(En(Un)) }).join(" "), Sn = un(En(Sn)), Cn("[" + Qe + "] " + Sn + " d"), this }; var Ol = Ie.__private__.getLineHeight = Ie.getLineHeight = function () { return rr * Ys }; Ie.__private__.getLineHeight = Ie.getLineHeight = function () { return rr * Ys }; var Ll = Ie.__private__.setLineHeightFactor = Ie.setLineHeightFactor = function (Qe) { return typeof (Qe = Qe || 1.15) == "number" && (Ys = Qe), this }, Eo = Ie.__private__.getLineHeightFactor = Ie.getLineHeightFactor = function () { return Ys }; Ll(e.lineHeight); var Ks = Ie.__private__.getHorizontalCoordinate = function (Qe) { return En(Qe) }, Pa = Ie.__private__.getVerticalCoordinate = function (Qe) { return Ze === Ge.ADVANCED ? Qe : Ar[rn].mediaBox.topRightY - Ar[rn].mediaBox.bottomLeftY - En(Qe) }, Hu = Ie.__private__.getHorizontalCoordinateString = Ie.getHorizontalCoordinateString = function (Qe) { return un(Ks(Qe)) }, wo = Ie.__private__.getVerticalCoordinateString = Ie.getVerticalCoordinateString = function (Qe) { return un(Pa(Qe)) }, fa = e.strokeColor || "0 G"; Ie.__private__.getStrokeColor = Ie.getDrawColor = function () { return _s(fa) }, Ie.__private__.setStrokeColor = Ie.setDrawColor = function (Qe, Sn, Un, $n) { return fa = Rs({ ch1: Qe, ch2: Sn, ch3: Un, ch4: $n, pdfColorType: "draw", precision: 2 }), Cn(fa), this }; var Zo = e.fillColor || "0 g"; Ie.__private__.getFillColor = Ie.getFillColor = function () { return _s(Zo) }, Ie.__private__.setFillColor = Ie.setFillColor = function (Qe, Sn, Un, $n) { return Zo = Rs({ ch1: Qe, ch2: Sn, ch3: Un, ch4: $n, pdfColorType: "fill", precision: 2 }), Cn(Zo), this }; var Jo = e.textColor || "0 g", qu = Ie.__private__.getTextColor = Ie.getTextColor = function () { return _s(Jo) }; Ie.__private__.setTextColor = Ie.setTextColor = function (Qe, Sn, Un, $n) { return Jo = Rs({ ch1: Qe, ch2: Sn, ch3: Un, ch4: $n, pdfColorType: "text", precision: 3 }), this }; var jl = e.charSpace, $u = Ie.__private__.getCharSpace = Ie.getCharSpace = function () { return parseFloat(jl || 0) }; Ie.__private__.setCharSpace = Ie.setCharSpace = function (Qe) { if (isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.setCharSpace"); return jl = Qe, this }; var Cc = 0; Ie.CapJoinStyles = { 0: 0, butt: 0, but: 0, miter: 0, 1: 1, round: 1, rounded: 1, circle: 1, 2: 2, projecting: 2, project: 2, square: 2, bevel: 2 }, Ie.__private__.setLineCap = Ie.setLineCap = function (Qe) { var Sn = Ie.CapJoinStyles[Qe]; if (Sn === void 0) throw new Error("Line cap style of '" + Qe + "' is not recognized. See or extend .CapJoinStyles property for valid styles"); return Cc = Sn, Cn(Sn + " J"), this }; var Ml = 0; Ie.__private__.setLineJoin = Ie.setLineJoin = function (Qe) { var Sn = Ie.CapJoinStyles[Qe]; if (Sn === void 0) throw new Error("Line join style of '" + Qe + "' is not recognized. See or extend .CapJoinStyles property for valid styles"); return Ml = Sn, Cn(Sn + " j"), this }, Ie.__private__.setLineMiterLimit = Ie.__private__.setMiterLimit = Ie.setLineMiterLimit = Ie.setMiterLimit = function (Qe) { if (Qe = Qe || 0, isNaN(Qe)) throw new Error("Invalid argument passed to jsPDF.setLineMiterLimit"); return Cn(un(En(Qe)) + " M"), this }, Ie.GState = j, Ie.setGState = function (Qe) { (Qe = typeof Qe == "string" ? ei[Wi[Qe]] : uu(null, Qe)).equals($i) || (Cn("/" + Qe.id + " gs"), $i = Qe) }; var uu = function (Qe, Sn) { if (!Qe || !Wi[Qe]) { var Un = !1; for (var $n in ei) if (ei.hasOwnProperty($n) && ei[$n].equals(Sn)) { Un = !0; break } if (Un) Sn = ei[$n]; else { var tr = "GS" + (Object.keys(ei).length + 1).toString(10); ei[tr] = Sn, Sn.id = tr } return Qe && (Wi[Qe] = Sn.id), Ur.publish("addGState", Sn), Sn } }; Ie.addGState = function (Qe, Sn) { return uu(Qe, Sn), this }, Ie.saveGraphicsState = function () { return Cn("q"), Rr.push({ key: zr, size: rr, color: Jo }), this }, Ie.restoreGraphicsState = function () { Cn("Q"); var Qe = Rr.pop(); return zr = Qe.key, rr = Qe.size, Jo = Qe.color, $i = null, this }, Ie.setCurrentTransformationMatrix = function (Qe) { return Cn(Qe.toString() + " cm"), this }, Ie.comment = function (Qe) { return Cn("#" + Qe), this }; var Dl = function (Qe, Sn) { var Un = Qe || 0; Object.defineProperty(this, "x", { enumerable: !0, get: function () { return Un }, set: function (fr) { isNaN(fr) || (Un = parseFloat(fr)) } }); var $n = Sn || 0; Object.defineProperty(this, "y", { enumerable: !0, get: function () { return $n }, set: function (fr) { isNaN(fr) || ($n = parseFloat(fr)) } }); var tr = "pt"; return Object.defineProperty(this, "type", { enumerable: !0, get: function () { return tr }, set: function (fr) { tr = fr.toString() } }), this }, Tc = function (Qe, Sn, Un, $n) { Dl.call(this, Qe, Sn), this.type = "rect"; var tr = Un || 0; Object.defineProperty(this, "w", { enumerable: !0, get: function () { return tr }, set: function (Sr) { isNaN(Sr) || (tr = parseFloat(Sr)) } }); var fr = $n || 0; return Object.defineProperty(this, "h", { enumerable: !0, get: function () { return fr }, set: function (Sr) { isNaN(Sr) || (fr = parseFloat(Sr)) } }), this }, Nc = function () { this.page = xi, this.currentPage = rn, this.pages = On.slice(0), this.pagesContext = Ar.slice(0), this.x = wi, this.y = Jr, this.matrix = mr, this.width = el(rn), this.height = Ao(rn), this.outputDestination = zn, this.id = "", this.objectNumber = -1 }; Nc.prototype.restore = function () { xi = this.page, rn = this.currentPage, Ar = this.pagesContext, On = this.pages, wi = this.x, Jr = this.y, mr = this.matrix, Fl(rn, this.width), Pc(rn, this.height), zn = this.outputDestination }; var kl = function (Qe, Sn, Un, $n, tr) { yi.push(new Nc), xi = rn = 0, On = [], wi = Qe, Jr = Sn, mr = tr, Qo([Un, $n]) }, Vu = function (Qe) { if (fi[Qe]) yi.pop().restore(); else { var Sn = new Nc, Un = "Xo" + (Object.keys(ii).length + 1).toString(10); Sn.id = Un, fi[Qe] = Un, ii[Un] = Sn, Ur.publish("addFormObject", Sn), yi.pop().restore() } }; for (var Il in Ie.beginFormObject = function (Qe, Sn, Un, $n, tr) { return kl(Qe, Sn, Un, $n, tr), this }, Ie.endFormObject = function (Qe) { return Vu(Qe), this }, Ie.doFormObject = function (Qe, Sn) { var Un = ii[fi[Qe]]; return Cn("q"), Cn(Sn.toString() + " cm"), Cn("/" + Un.id + " Do"), Cn("Q"), this }, Ie.getFormObject = function (Qe) { var Sn = ii[fi[Qe]]; return { x: Sn.x, y: Sn.y, width: Sn.width, height: Sn.height, matrix: Sn.matrix } }, Ie.save = function (Qe, Sn) { return Qe = Qe || "generated.pdf", (Sn = Sn || {}).returnPromise = Sn.returnPromise || !1, Sn.returnPromise === !1 ? (l(Cl(Va()), Qe), typeof l.unload == "function" && n.setTimeout && setTimeout(l.unload, 911), this) : new Promise(function (Un, $n) { try { var tr = l(Cl(Va()), Qe); typeof l.unload == "function" && n.setTimeout && setTimeout(l.unload, 911), Un(tr) } catch (fr) { $n(fr.message) } }) }, E.API) E.API.hasOwnProperty(Il) && (Il === "events" && E.API.events.length ? function (Qe, Sn) { var Un, $n, tr; for (tr = Sn.length - 1; tr !== -1; tr--)Un = Sn[tr][0], $n = Sn[tr][1], Qe.subscribe.apply(Qe, [Un].concat(typeof $n == "function" ? [$n] : $n)) }(Ur, E.API.events) : Ie[Il] = E.API[Il]); var el = Ie.getPageWidth = function (Qe) { return (Ar[Qe = Qe || rn].mediaBox.topRightX - Ar[Qe].mediaBox.bottomLeftX) / Tr }, Fl = Ie.setPageWidth = function (Qe, Sn) { Ar[Qe].mediaBox.topRightX = Sn * Tr + Ar[Qe].mediaBox.bottomLeftX }, Ao = Ie.getPageHeight = function (Qe) { return (Ar[Qe = Qe || rn].mediaBox.topRightY - Ar[Qe].mediaBox.bottomLeftY) / Tr }, Pc = Ie.setPageHeight = function (Qe, Sn) { Ar[Qe].mediaBox.topRightY = Sn * Tr + Ar[Qe].mediaBox.bottomLeftY }; return Ie.internal = { pdfEscape: Bi, getStyle: na, getFont: Cs, getFontSize: ur, getCharSpace: $u, getTextColor: qu, getLineHeight: Ol, getLineHeightFactor: Eo, getLineWidth: Na, write: Vn, getHorizontalCoordinate: Ks, getVerticalCoordinate: Pa, getCoordinateString: Hu, getVerticalCoordinateString: wo, collections: {}, newObject: si, newAdditionalObject: Wo, newObjectDeferred: bi, newObjectDeferredBegin: ms, getFilters: Bs, putStream: ws, events: Ur, scaleFactor: Tr, pageSize: { getWidth: function () { return el(rn) }, setWidth: function (Qe) { Fl(rn, Qe) }, getHeight: function () { return Ao(rn) }, setHeight: function (Qe) { Pc(rn, Qe) } }, encryptionOptions: Oe, encryption: gs, getEncryptor: bo, output: Ga, getNumberOfPages: iu, pages: On, out: Cn, f2: Tn, f3: fn, getPageInfo: Wa, getPageInfoByObjId: Yr, getCurrentPageInfo: _c, getPDFVersion: ze, Point: Dl, Rectangle: Tc, Matrix: Lr, hasHotfix: Tl }, Object.defineProperty(Ie.internal.pageSize, "width", { get: function () { return el(rn) }, set: function (Qe) { Fl(rn, Qe) }, enumerable: !0, configurable: !0 }), Object.defineProperty(Ie.internal.pageSize, "height", { get: function () { return Ao(rn) }, set: function (Qe) { Pc(rn, Qe) }, enumerable: !0, configurable: !0 }), ru.call(Ie, qn), zr = "F1", yc(_e, xe), Ur.publish("initialized"), Ie
} I.prototype.lsbFirstWord = function (e) { return String.fromCharCode(e >> 0 & 255, e >> 8 & 255, e >> 16 & 255, e >> 24 & 255) }, I.prototype.toHexString = function (e) { return e.split("").map(function (t) { return ("0" + (255 & t.charCodeAt(0)).toString(16)).slice(-2) }).join("") }, I.prototype.hexToBytes = function (e) { for (var t = [], xe = 0; xe < e.length; xe += 2)t.push(String.fromCharCode(parseInt(e.substr(xe, 2), 16))); return t.join("") }, I.prototype.processOwnerPassword = function (e, t) { return P(x(t).substr(0, 5), e) }, I.prototype.encryptor = function (e, t) { var xe = x(this.encryptionKey + String.fromCharCode(255 & e, e >> 8 & 255, e >> 16 & 255, 255 & t, t >> 8 & 255)).substr(0, 10); return function (Ee) { return P(xe, Ee) } }, j.prototype.equals = function (e) { var t, xe = "id,objectNumber,equals"; if (!e || _typeof(e) !== _typeof(this)) return !1; var Ee = 0; for (t in this) if (!(xe.indexOf(t) >= 0)) { if (this.hasOwnProperty(t) && !e.hasOwnProperty(t) || this[t] !== e[t]) return !1; Ee++ } for (t in e) e.hasOwnProperty(t) && xe.indexOf(t) < 0 && Ee--; return Ee === 0 }, E.API = { events: [] }, E.version = "3.0.1"; var q = E.API, D = 1, R = function (e) { return e.replace(/\\/g, "\\\\").replace(/\(/g, "\\(").replace(/\)/g, "\\)") }, T = function (e) { return e.replace(/\\\\/g, "\\").replace(/\\\(/g, "(").replace(/\\\)/g, ")") }, U = function (e) { return e.toFixed(2) }, z = function (e) { return e.toFixed(5) }; q.__acroform__ = {}; var H = function (e, t) { e.prototype = Object.create(t.prototype), e.prototype.constructor = e }, W = function (e) { return e * D }, V = function (e) { var t = new ut, xe = At.internal.getHeight(e) || 0, Ee = At.internal.getWidth(e) || 0; return t.BBox = [0, 0, Number(U(Ee)), Number(U(xe))], t }, G = q.__acroform__.setBit = function (e, t) { if (e = e || 0, t = t || 0, isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBit"); return e |= 1 << t }, Y = q.__acroform__.clearBit = function (e, t) { if (e = e || 0, t = t || 0, isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBit"); return e &= ~(1 << t) }, J = q.__acroform__.getBit = function (e, t) { if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBit"); return (e & 1 << t) == 0 ? 0 : 1 }, X = q.__acroform__.getBitForPdf = function (e, t) { if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.getBitForPdf"); return J(e, t - 1) }, K = q.__acroform__.setBitForPdf = function (e, t) { if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.setBitForPdf"); return G(e, t - 1) }, Z = q.__acroform__.clearBitForPdf = function (e, t) { if (isNaN(e) || isNaN(t)) throw new Error("Invalid arguments passed to jsPDF.API.__acroform__.clearBitForPdf"); return Y(e, t - 1) }, $ = q.__acroform__.calculateCoordinates = function (e, t) { var xe = t.internal.getHorizontalCoordinate, Ee = t.internal.getVerticalCoordinate, _e = e[0], Re = e[1], Ce = e[2], Me = e[3], De = {}; return De.lowerLeft_X = xe(_e) || 0, De.lowerLeft_Y = Ee(Re + Me) || 0, De.upperRight_X = xe(_e + Ce) || 0, De.upperRight_Y = Ee(Re) || 0, [Number(U(De.lowerLeft_X)), Number(U(De.lowerLeft_Y)), Number(U(De.upperRight_X)), Number(U(De.upperRight_Y))] }, Q = function (e) {
  if (e.appearanceStreamContent) return e.appearanceStreamContent; if (e.V || e.DV) {
    var t = [], xe = e._V || e.DV, Ee = tt(e, xe), _e = e.scope.internal.getFont(e.fontName, e.fontStyle).id; t.push("/Tx BMC"), t.push("q"), t.push("BT"), t.push(e.scope.__private__.encodeColorString(e.color)), t.push("/" + _e + " " + U(Ee.fontSize) + " Tf"), t.push("1 0 0 1 0 0 Tm"), t.push(Ee.text), t.push("ET"), t.push("Q"), t.push("EMC"); var Re = V(e); return Re.scope = e.scope, Re.stream = t.join(`
`), Re
  }
}, tt = function (e, t) {
  var xe = e.fontSize === 0 ? e.maxFontSize : e.fontSize, Ee = { text: "", fontSize: "" }, _e = (t = (t = t.substr(0, 1) == "(" ? t.substr(1) : t).substr(t.length - 1) == ")" ? t.substr(0, t.length - 1) : t).split(" "); _e = e.multiline ? _e.map(function (fn) {
    return fn.split(`
`)
  }) : _e.map(function (fn) { return [fn] }); var Re = xe, Ce = At.internal.getHeight(e) || 0; Ce = Ce < 0 ? -Ce : Ce; var Me = At.internal.getWidth(e) || 0; Me = Me < 0 ? -Me : Me; var De = function (fn, En, Pn) { if (fn + 1 < _e.length) { var Rn = En + " " + _e[fn + 1][0]; return et(Rn, e, Pn).width <= Me - 4 } return !1 }; Re++; e: for (; Re > 0;) {
    t = "", Re--; var Pe, Oe, je = et("3", e, Re).height, Be = e.multiline ? Ce - Re : (Ce - je) / 2, Ie = Be += 2, Fe = 0, ze = 0, qe = 0; if (Re <= 0) {
      t = `(...) Tj
`, t += "% Width of Text: " + et(t, e, Re = 12).width + ", FieldWidth:" + Me + `
`; break
    } for (var He = "", Ge = 0, Ze = 0; Ze < _e.length; Ze++)if (_e.hasOwnProperty(Ze)) {
      var sn = !1; if (_e[Ze].length !== 1 && qe !== _e[Ze].length - 1) { if ((je + 2) * (Ge + 2) + 2 > Ce) continue e; He += _e[Ze][qe], sn = !0, ze = Ze, Ze-- } else { He = (He += _e[Ze][qe] + " ").substr(He.length - 1) == " " ? He.substr(0, He.length - 1) : He; var Xe = parseInt(Ze), St = De(Xe, He, Re), un = Ze >= _e.length - 1; if (St && !un) { He += " ", qe = 0; continue } if (St || un) { if (un) ze = Xe; else if (e.multiline && (je + 2) * (Ge + 2) + 2 > Ce) continue e } else { if (!e.multiline || (je + 2) * (Ge + 2) + 2 > Ce) continue e; ze = Xe } } for (var on = "", bn = Fe; bn <= ze; bn++) { var Tn = _e[bn]; if (e.multiline) { if (bn === ze) { on += Tn[qe] + " ", qe = (qe + 1) % Tn.length; continue } if (bn === Fe) { on += Tn[Tn.length - 1] + " "; continue } } on += Tn[0] + " " } switch (on = on.substr(on.length - 1) == " " ? on.substr(0, on.length - 1) : on, Oe = et(on, e, Re).width, e.textAlign) { case "right": Pe = Me - Oe - 2; break; case "center": Pe = (Me - Oe) / 2; break; case "left": default: Pe = 2 }t += U(Pe) + " " + U(Ie) + ` Td
`, t += "(" + R(on) + `) Tj
`, t += -U(Pe) + ` 0 Td
`, Ie = -(Re + 2), Oe = 0, Fe = sn ? ze : ze + 1, Ge++, He = ""
    } break
  } return Ee.text = t, Ee.fontSize = Re, Ee
}, et = function (e, t, xe) { var Ee = t.scope.internal.getFont(t.fontName, t.fontStyle), _e = t.scope.getStringUnitWidth(e, { font: Ee, fontSize: parseFloat(xe), charSpace: 0 }) * parseFloat(xe); return { height: t.scope.getStringUnitWidth("3", { font: Ee, fontSize: parseFloat(xe), charSpace: 0 }) * parseFloat(xe) * 1.5, width: _e } }, rt = { fields: [], xForms: [], acroFormDictionaryRoot: null, printedOut: !1, internal: null, isInitialized: !1 }, nt = function (e, t) { var xe = { type: "reference", object: e }; t.internal.getPageInfo(e.page).pageContext.annotations.find(function (Ee) { return Ee.type === xe.type && Ee.object === xe.object }) === void 0 && t.internal.getPageInfo(e.page).pageContext.annotations.push(xe) }, it = function (e, t) { for (var xe in e) if (e.hasOwnProperty(xe)) { var Ee = xe, _e = e[xe]; t.internal.newObjectDeferredBegin(_e.objId, !0), _typeof(_e) === "object" && typeof _e.putStream == "function" && _e.putStream(), delete e[Ee] } }, at = function (e, t) {
  if (t.scope = e, e.internal !== void 0 && (e.internal.acroformPlugin === void 0 || e.internal.acroformPlugin.isInitialized === !1)) {
    if (lt.FieldNum = 0, e.internal.acroformPlugin = JSON.parse(JSON.stringify(rt)), e.internal.acroformPlugin.acroFormDictionaryRoot) throw new Error("Exception while creating AcroformDictionary"); D = e.internal.scaleFactor, e.internal.acroformPlugin.acroFormDictionaryRoot = new ht, e.internal.acroformPlugin.acroFormDictionaryRoot.scope = e, e.internal.acroformPlugin.acroFormDictionaryRoot._eventID = e.internal.events.subscribe("postPutResources", function () { (function (xe) { xe.internal.events.unsubscribe(xe.internal.acroformPlugin.acroFormDictionaryRoot._eventID), delete xe.internal.acroformPlugin.acroFormDictionaryRoot._eventID, xe.internal.acroformPlugin.printedOut = !0 })(e) }), e.internal.events.subscribe("buildDocument", function () { (function (xe) { xe.internal.acroformPlugin.acroFormDictionaryRoot.objId = void 0; var Ee = xe.internal.acroformPlugin.acroFormDictionaryRoot.Fields; for (var _e in Ee) if (Ee.hasOwnProperty(_e)) { var Re = Ee[_e]; Re.objId = void 0, Re.hasAnnotation && nt(Re, xe) } })(e) }), e.internal.events.subscribe("putCatalog", function () { (function (xe) { if (xe.internal.acroformPlugin.acroFormDictionaryRoot === void 0) throw new Error("putCatalogCallback: Root missing."); xe.internal.write("/AcroForm " + xe.internal.acroformPlugin.acroFormDictionaryRoot.objId + " 0 R") })(e) }), e.internal.events.subscribe("postPutPages", function (xe) {
      (function (Ee, _e) {
        var Re = !Ee; for (var Ce in Ee || (_e.internal.newObjectDeferredBegin(_e.internal.acroformPlugin.acroFormDictionaryRoot.objId, !0), _e.internal.acroformPlugin.acroFormDictionaryRoot.putStream()), Ee = Ee || _e.internal.acroformPlugin.acroFormDictionaryRoot.Kids) if (Ee.hasOwnProperty(Ce)) {
          var Me = Ee[Ce], De = [], Pe = Me.Rect; if (Me.Rect && (Me.Rect = $(Me.Rect, _e)), _e.internal.newObjectDeferredBegin(Me.objId, !0), Me.DA = At.createDefaultAppearanceStream(Me), _typeof(Me) === "object" && typeof Me.getKeyValueListForStream == "function" && (De = Me.getKeyValueListForStream()), Me.Rect = Pe, Me.hasAppearanceStream && !Me.appearanceStreamContent) { var Oe = Q(Me); De.push({ key: "AP", value: "<</N " + Oe + ">>" }), _e.internal.acroformPlugin.xForms.push(Oe) } if (Me.appearanceStreamContent) {
            var je = ""; for (var Be in Me.appearanceStreamContent) if (Me.appearanceStreamContent.hasOwnProperty(Be)) { var Ie = Me.appearanceStreamContent[Be]; if (je += "/" + Be + " ", je += "<<", Object.keys(Ie).length >= 1 || Array.isArray(Ie)) { for (var Ce in Ie) if (Ie.hasOwnProperty(Ce)) { var Fe = Ie[Ce]; typeof Fe == "function" && (Fe = Fe.call(_e, Me)), je += "/" + Ce + " " + Fe + " ", _e.internal.acroformPlugin.xForms.indexOf(Fe) >= 0 || _e.internal.acroformPlugin.xForms.push(Fe) } } else typeof (Fe = Ie) == "function" && (Fe = Fe.call(_e, Me)), je += "/" + Ce + " " + Fe, _e.internal.acroformPlugin.xForms.indexOf(Fe) >= 0 || _e.internal.acroformPlugin.xForms.push(Fe); je += ">>" } De.push({
              key: "AP", value: `<<
`+ je + ">>"
            })
          } _e.internal.putStream({ additionalKeyValues: De, objectId: Me.objId }), _e.internal.out("endobj")
        } Re && it(_e.internal.acroformPlugin.xForms, _e)
      })(xe, e)
    }), e.internal.acroformPlugin.isInitialized = !0
  }
}, ot = q.__acroform__.arrayToPdfArray = function (e, t, xe) { var Ee = function (Ce) { return Ce }; if (Array.isArray(e)) { for (var _e = "[", Re = 0; Re < e.length; Re++)switch (Re !== 0 && (_e += " "), _typeof(e[Re])) { case "boolean": case "number": case "object": _e += e[Re].toString(); break; case "string": e[Re].substr(0, 1) !== "/" ? (t !== void 0 && xe && (Ee = xe.internal.getEncryptor(t)), _e += "(" + R(Ee(e[Re].toString())) + ")") : _e += e[Re].toString() }return _e += "]" } throw new Error("Invalid argument passed to jsPDF.__acroform__.arrayToPdfArray") }, st = function (e, t, xe) { var Ee = function (_e) { return _e }; return t !== void 0 && xe && (Ee = xe.internal.getEncryptor(t)), (e = e || "").toString(), e = "(" + R(Ee(e)) + ")" }, ct = function () { this._objId = void 0, this._scope = void 0, Object.defineProperty(this, "objId", { get: function () { if (this._objId === void 0) { if (this.scope === void 0) return; this._objId = this.scope.internal.newObjectDeferred() } return this._objId }, set: function (e) { this._objId = e } }), Object.defineProperty(this, "scope", { value: this._scope, writable: !0 }) }; ct.prototype.toString = function () { return this.objId + " 0 R" }, ct.prototype.putStream = function () { var e = this.getKeyValueListForStream(); this.scope.internal.putStream({ data: this.stream, additionalKeyValues: e, objectId: this.objId }), this.scope.internal.out("endobj") }, ct.prototype.getKeyValueListForStream = function () { var e = [], t = Object.getOwnPropertyNames(this).filter(function (Re) { return Re != "content" && Re != "appearanceStreamContent" && Re != "scope" && Re != "objId" && Re.substring(0, 1) != "_" }); for (var xe in t) if (Object.getOwnPropertyDescriptor(this, t[xe]).configurable === !1) { var Ee = t[xe], _e = this[Ee]; _e && (Array.isArray(_e) ? e.push({ key: Ee, value: ot(_e, this.objId, this.scope) }) : _e instanceof ct ? (_e.scope = this.scope, e.push({ key: Ee, value: _e.objId + " 0 R" })) : typeof _e != "function" && e.push({ key: Ee, value: _e })) } return e }; var ut = function () { ct.call(this), Object.defineProperty(this, "Type", { value: "/XObject", configurable: !1, writable: !0 }), Object.defineProperty(this, "Subtype", { value: "/Form", configurable: !1, writable: !0 }), Object.defineProperty(this, "FormType", { value: 1, configurable: !1, writable: !0 }); var e, t = []; Object.defineProperty(this, "BBox", { configurable: !1, get: function () { return t }, set: function (xe) { t = xe } }), Object.defineProperty(this, "Resources", { value: "2 0 R", configurable: !1, writable: !0 }), Object.defineProperty(this, "stream", { enumerable: !1, configurable: !0, set: function (xe) { e = xe.trim() }, get: function () { return e || null } }) }; H(ut, ct); var ht = function () { ct.call(this); var e, t = []; Object.defineProperty(this, "Kids", { enumerable: !1, configurable: !0, get: function () { return t.length > 0 ? t : void 0 } }), Object.defineProperty(this, "Fields", { enumerable: !1, configurable: !1, get: function () { return t } }), Object.defineProperty(this, "DA", { enumerable: !1, configurable: !1, get: function () { if (e) { var xe = function (Ee) { return Ee }; return this.scope && (xe = this.scope.internal.getEncryptor(this.objId)), "(" + R(xe(e)) + ")" } }, set: function (xe) { e = xe } }) }; H(ht, ct); var lt = function e() { ct.call(this); var t = 4; Object.defineProperty(this, "F", { enumerable: !1, configurable: !1, get: function () { return t }, set: function (He) { if (isNaN(He)) throw new Error('Invalid value "' + He + '" for attribute F supplied.'); t = He } }), Object.defineProperty(this, "showWhenPrinted", { enumerable: !0, configurable: !0, get: function () { return !!X(t, 3) }, set: function (He) { He ? this.F = K(t, 3) : this.F = Z(t, 3) } }); var xe = 0; Object.defineProperty(this, "Ff", { enumerable: !1, configurable: !1, get: function () { return xe }, set: function (He) { if (isNaN(He)) throw new Error('Invalid value "' + He + '" for attribute Ff supplied.'); xe = He } }); var Ee = []; Object.defineProperty(this, "Rect", { enumerable: !1, configurable: !1, get: function () { if (Ee.length !== 0) return Ee }, set: function (He) { Ee = He !== void 0 ? He : [] } }), Object.defineProperty(this, "x", { enumerable: !0, configurable: !0, get: function () { return !Ee || isNaN(Ee[0]) ? 0 : Ee[0] }, set: function (He) { Ee[0] = He } }), Object.defineProperty(this, "y", { enumerable: !0, configurable: !0, get: function () { return !Ee || isNaN(Ee[1]) ? 0 : Ee[1] }, set: function (He) { Ee[1] = He } }), Object.defineProperty(this, "width", { enumerable: !0, configurable: !0, get: function () { return !Ee || isNaN(Ee[2]) ? 0 : Ee[2] }, set: function (He) { Ee[2] = He } }), Object.defineProperty(this, "height", { enumerable: !0, configurable: !0, get: function () { return !Ee || isNaN(Ee[3]) ? 0 : Ee[3] }, set: function (He) { Ee[3] = He } }); var _e = ""; Object.defineProperty(this, "FT", { enumerable: !0, configurable: !1, get: function () { return _e }, set: function (He) { switch (He) { case "/Btn": case "/Tx": case "/Ch": case "/Sig": _e = He; break; default: throw new Error('Invalid value "' + He + '" for attribute FT supplied.') } } }); var Re = null; Object.defineProperty(this, "T", { enumerable: !0, configurable: !1, get: function () { if (!Re || Re.length < 1) { if (this instanceof yt) return; Re = "FieldObject" + e.FieldNum++ } var He = function (Ge) { return Ge }; return this.scope && (He = this.scope.internal.getEncryptor(this.objId)), "(" + R(He(Re)) + ")" }, set: function (He) { Re = He.toString() } }), Object.defineProperty(this, "fieldName", { configurable: !0, enumerable: !0, get: function () { return Re }, set: function (He) { Re = He } }); var Ce = "helvetica"; Object.defineProperty(this, "fontName", { enumerable: !0, configurable: !0, get: function () { return Ce }, set: function (He) { Ce = He } }); var Me = "normal"; Object.defineProperty(this, "fontStyle", { enumerable: !0, configurable: !0, get: function () { return Me }, set: function (He) { Me = He } }); var De = 0; Object.defineProperty(this, "fontSize", { enumerable: !0, configurable: !0, get: function () { return De }, set: function (He) { De = He } }); var Pe = void 0; Object.defineProperty(this, "maxFontSize", { enumerable: !0, configurable: !0, get: function () { return Pe === void 0 ? 50 / D : Pe }, set: function (He) { Pe = He } }); var Oe = "black"; Object.defineProperty(this, "color", { enumerable: !0, configurable: !0, get: function () { return Oe }, set: function (He) { Oe = He } }); var je = "/F1 0 Tf 0 g"; Object.defineProperty(this, "DA", { enumerable: !0, configurable: !1, get: function () { if (!(!je || this instanceof yt || this instanceof Nt)) return st(je, this.objId, this.scope) }, set: function (He) { He = He.toString(), je = He } }); var Be = null; Object.defineProperty(this, "DV", { enumerable: !1, configurable: !1, get: function () { if (Be) return this instanceof mt ? Be : st(Be, this.objId, this.scope) }, set: function (He) { He = He.toString(), Be = this instanceof mt ? He : He.substr(0, 1) === "(" ? T(He.substr(1, He.length - 2)) : T(He) } }), Object.defineProperty(this, "defaultValue", { enumerable: !0, configurable: !0, get: function () { return this instanceof mt ? T(Be.substr(1, Be.length - 1)) : Be }, set: function (He) { He = He.toString(), Be = this instanceof mt ? "/" + He : He } }); var Ie = null; Object.defineProperty(this, "_V", { enumerable: !1, configurable: !1, get: function () { if (Ie) return Ie }, set: function (He) { this.V = He } }), Object.defineProperty(this, "V", { enumerable: !1, configurable: !1, get: function () { if (Ie) return this instanceof mt ? Ie : st(Ie, this.objId, this.scope) }, set: function (He) { He = He.toString(), Ie = this instanceof mt ? He : He.substr(0, 1) === "(" ? T(He.substr(1, He.length - 2)) : T(He) } }), Object.defineProperty(this, "value", { enumerable: !0, configurable: !0, get: function () { return this instanceof mt ? T(Ie.substr(1, Ie.length - 1)) : Ie }, set: function (He) { He = He.toString(), Ie = this instanceof mt ? "/" + He : He } }), Object.defineProperty(this, "hasAnnotation", { enumerable: !0, configurable: !0, get: function () { return this.Rect } }), Object.defineProperty(this, "Type", { enumerable: !0, configurable: !1, get: function () { return this.hasAnnotation ? "/Annot" : null } }), Object.defineProperty(this, "Subtype", { enumerable: !0, configurable: !1, get: function () { return this.hasAnnotation ? "/Widget" : null } }); var Fe, ze = !1; Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function () { return ze }, set: function (He) { He = !!He, ze = He } }), Object.defineProperty(this, "page", { enumerable: !0, configurable: !0, get: function () { if (Fe) return Fe }, set: function (He) { Fe = He } }), Object.defineProperty(this, "readOnly", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 1) }, set: function (He) { He ? this.Ff = K(this.Ff, 1) : this.Ff = Z(this.Ff, 1) } }), Object.defineProperty(this, "required", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 2) }, set: function (He) { He ? this.Ff = K(this.Ff, 2) : this.Ff = Z(this.Ff, 2) } }), Object.defineProperty(this, "noExport", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 3) }, set: function (He) { He ? this.Ff = K(this.Ff, 3) : this.Ff = Z(this.Ff, 3) } }); var qe = null; Object.defineProperty(this, "Q", { enumerable: !0, configurable: !1, get: function () { if (qe !== null) return qe }, set: function (He) { if ([0, 1, 2].indexOf(He) === -1) throw new Error('Invalid value "' + He + '" for attribute Q supplied.'); qe = He } }), Object.defineProperty(this, "textAlign", { get: function () { var He; switch (qe) { case 0: default: He = "left"; break; case 1: He = "center"; break; case 2: He = "right" }return He }, configurable: !0, enumerable: !0, set: function (He) { switch (He) { case "right": case 2: qe = 2; break; case "center": case 1: qe = 1; break; case "left": case 0: default: qe = 0 } } }) }; H(lt, ct); var ft = function () { lt.call(this), this.FT = "/Ch", this.V = "()", this.fontName = "zapfdingbats"; var e = 0; Object.defineProperty(this, "TI", { enumerable: !0, configurable: !1, get: function () { return e }, set: function (xe) { e = xe } }), Object.defineProperty(this, "topIndex", { enumerable: !0, configurable: !0, get: function () { return e }, set: function (xe) { e = xe } }); var t = []; Object.defineProperty(this, "Opt", { enumerable: !0, configurable: !1, get: function () { return ot(t, this.objId, this.scope) }, set: function (xe) { var Ee, _e; _e = [], typeof (Ee = xe) == "string" && (_e = function (Re, Ce, Me) { Me || (Me = 1); for (var De, Pe = []; De = Ce.exec(Re);)Pe.push(De[Me]); return Pe }(Ee, /\((.*?)\)/g)), t = _e } }), this.getOptions = function () { return t }, this.setOptions = function (xe) { t = xe, this.sort && t.sort() }, this.addOption = function (xe) { xe = (xe = xe || "").toString(), t.push(xe), this.sort && t.sort() }, this.removeOption = function (xe, Ee) { for (Ee = Ee || !1, xe = (xe = xe || "").toString(); t.indexOf(xe) !== -1 && (t.splice(t.indexOf(xe), 1), Ee !== !1);); }, Object.defineProperty(this, "combo", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 18) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 18) : this.Ff = Z(this.Ff, 18) } }), Object.defineProperty(this, "edit", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 19) }, set: function (xe) { this.combo === !0 && (xe ? this.Ff = K(this.Ff, 19) : this.Ff = Z(this.Ff, 19)) } }), Object.defineProperty(this, "sort", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 20) }, set: function (xe) { xe ? (this.Ff = K(this.Ff, 20), t.sort()) : this.Ff = Z(this.Ff, 20) } }), Object.defineProperty(this, "multiSelect", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 22) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 22) : this.Ff = Z(this.Ff, 22) } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 23) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23) } }), Object.defineProperty(this, "commitOnSelChange", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 27) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 27) : this.Ff = Z(this.Ff, 27) } }), this.hasAppearanceStream = !1 }; H(ft, lt); var dt = function () { ft.call(this), this.fontName = "helvetica", this.combo = !1 }; H(dt, ft); var pt = function () { dt.call(this), this.combo = !0 }; H(pt, dt); var gt = function () { pt.call(this), this.edit = !0 }; H(gt, pt); var mt = function () {
  lt.call(this), this.FT = "/Btn", Object.defineProperty(this, "noToggleToOff", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 15) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 15) : this.Ff = Z(this.Ff, 15) } }), Object.defineProperty(this, "radio", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 16) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 16) : this.Ff = Z(this.Ff, 16) } }), Object.defineProperty(this, "pushButton", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 17) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 17) : this.Ff = Z(this.Ff, 17) } }), Object.defineProperty(this, "radioIsUnison", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 26) }, set: function (xe) { xe ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26) } }); var e, t = {}; Object.defineProperty(this, "MK", {
    enumerable: !1, configurable: !1, get: function () {
      var xe = function (Re) { return Re }; if (this.scope && (xe = this.scope.internal.getEncryptor(this.objId)), Object.keys(t).length !== 0) {
        var Ee, _e = []; for (Ee in _e.push("<<"), t) _e.push("/" + Ee + " (" + R(xe(t[Ee])) + ")"); return _e.push(">>"), _e.join(`
`)
      }
    }, set: function (xe) { _typeof(xe) === "object" && (t = xe) }
  }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function () { return t.CA || "" }, set: function (xe) { typeof xe == "string" && (t.CA = xe) } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function () { return e }, set: function (xe) { e = xe } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function () { return e.substr(1, e.length - 1) }, set: function (xe) { e = "/" + xe } })
}; H(mt, lt); var vt = function () { mt.call(this), this.pushButton = !0 }; H(vt, mt); var bt = function () { mt.call(this), this.radio = !0, this.pushButton = !1; var e = []; Object.defineProperty(this, "Kids", { enumerable: !0, configurable: !1, get: function () { return e }, set: function (t) { e = t !== void 0 ? t : [] } }) }; H(bt, mt); var yt = function () {
  var e, t; lt.call(this), Object.defineProperty(this, "Parent", { enumerable: !1, configurable: !1, get: function () { return e }, set: function (_e) { e = _e } }), Object.defineProperty(this, "optionName", { enumerable: !1, configurable: !0, get: function () { return t }, set: function (_e) { t = _e } }); var xe, Ee = {}; Object.defineProperty(this, "MK", {
    enumerable: !1, configurable: !1, get: function () {
      var _e = function (Me) { return Me }; this.scope && (_e = this.scope.internal.getEncryptor(this.objId)); var Re, Ce = []; for (Re in Ce.push("<<"), Ee) Ce.push("/" + Re + " (" + R(_e(Ee[Re])) + ")"); return Ce.push(">>"), Ce.join(`
`)
    }, set: function (_e) { _typeof(_e) === "object" && (Ee = _e) }
  }), Object.defineProperty(this, "caption", { enumerable: !0, configurable: !0, get: function () { return Ee.CA || "" }, set: function (_e) { typeof _e == "string" && (Ee.CA = _e) } }), Object.defineProperty(this, "AS", { enumerable: !1, configurable: !1, get: function () { return xe }, set: function (_e) { xe = _e } }), Object.defineProperty(this, "appearanceState", { enumerable: !0, configurable: !0, get: function () { return xe.substr(1, xe.length - 1) }, set: function (_e) { xe = "/" + _e } }), this.caption = "l", this.appearanceState = "Off", this._AppearanceType = At.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(this.optionName)
}; H(yt, lt), bt.prototype.setAppearance = function (e) { if (!("createAppearanceStream" in e) || !("getCA" in e)) throw new Error("Couldn't assign Appearance to RadioButton. Appearance was Invalid!"); for (var t in this.Kids) if (this.Kids.hasOwnProperty(t)) { var xe = this.Kids[t]; xe.appearanceStreamContent = e.createAppearanceStream(xe.optionName), xe.caption = e.getCA() } }, bt.prototype.createOption = function (e) { var t = new yt; return t.Parent = this, t.optionName = e, this.Kids.push(t), xt.call(this.scope, t), t }; var wt = function () { mt.call(this), this.fontName = "zapfdingbats", this.caption = "3", this.appearanceState = "On", this.value = "On", this.textAlign = "center", this.appearanceStreamContent = At.CheckBox.createAppearanceStream() }; H(wt, mt); var Nt = function () { lt.call(this), this.FT = "/Tx", Object.defineProperty(this, "multiline", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 13) }, set: function (t) { t ? this.Ff = K(this.Ff, 13) : this.Ff = Z(this.Ff, 13) } }), Object.defineProperty(this, "fileSelect", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 21) }, set: function (t) { t ? this.Ff = K(this.Ff, 21) : this.Ff = Z(this.Ff, 21) } }), Object.defineProperty(this, "doNotSpellCheck", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 23) }, set: function (t) { t ? this.Ff = K(this.Ff, 23) : this.Ff = Z(this.Ff, 23) } }), Object.defineProperty(this, "doNotScroll", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 24) }, set: function (t) { t ? this.Ff = K(this.Ff, 24) : this.Ff = Z(this.Ff, 24) } }), Object.defineProperty(this, "comb", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 25) }, set: function (t) { t ? this.Ff = K(this.Ff, 25) : this.Ff = Z(this.Ff, 25) } }), Object.defineProperty(this, "richText", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 26) }, set: function (t) { t ? this.Ff = K(this.Ff, 26) : this.Ff = Z(this.Ff, 26) } }); var e = null; Object.defineProperty(this, "MaxLen", { enumerable: !0, configurable: !1, get: function () { return e }, set: function (t) { e = t } }), Object.defineProperty(this, "maxLength", { enumerable: !0, configurable: !0, get: function () { return e }, set: function (t) { Number.isInteger(t) && (e = t) } }), Object.defineProperty(this, "hasAppearanceStream", { enumerable: !0, configurable: !0, get: function () { return this.V || this.DV } }) }; H(Nt, lt); var Lt = function () { Nt.call(this), Object.defineProperty(this, "password", { enumerable: !0, configurable: !0, get: function () { return !!X(this.Ff, 14) }, set: function (e) { e ? this.Ff = K(this.Ff, 14) : this.Ff = Z(this.Ff, 14) } }), this.password = !0 }; H(Lt, Nt); var At = {
  CheckBox: {
    createAppearanceStream: function () { return { N: { On: At.CheckBox.YesNormal }, D: { On: At.CheckBox.YesPushDown, Off: At.CheckBox.OffPushDown } } }, YesPushDown: function (e) {
      var t = V(e); t.scope = e.scope; var xe = [], Ee = e.scope.internal.getFont(e.fontName, e.fontStyle).id, _e = e.scope.__private__.encodeColorString(e.color), Re = tt(e, e.caption); return xe.push("0.749023 g"), xe.push("0 0 " + U(At.internal.getWidth(e)) + " " + U(At.internal.getHeight(e)) + " re"), xe.push("f"), xe.push("BMC"), xe.push("q"), xe.push("0 0 1 rg"), xe.push("/" + Ee + " " + U(Re.fontSize) + " Tf " + _e), xe.push("BT"), xe.push(Re.text), xe.push("ET"), xe.push("Q"), xe.push("EMC"), t.stream = xe.join(`
`), t
    }, YesNormal: function (e) {
      var t = V(e); t.scope = e.scope; var xe = e.scope.internal.getFont(e.fontName, e.fontStyle).id, Ee = e.scope.__private__.encodeColorString(e.color), _e = [], Re = At.internal.getHeight(e), Ce = At.internal.getWidth(e), Me = tt(e, e.caption); return _e.push("1 g"), _e.push("0 0 " + U(Ce) + " " + U(Re) + " re"), _e.push("f"), _e.push("q"), _e.push("0 0 1 rg"), _e.push("0 0 " + U(Ce - 1) + " " + U(Re - 1) + " re"), _e.push("W"), _e.push("n"), _e.push("0 g"), _e.push("BT"), _e.push("/" + xe + " " + U(Me.fontSize) + " Tf " + Ee), _e.push(Me.text), _e.push("ET"), _e.push("Q"), t.stream = _e.join(`
`), t
    }, OffPushDown: function (e) {
      var t = V(e); t.scope = e.scope; var xe = []; return xe.push("0.749023 g"), xe.push("0 0 " + U(At.internal.getWidth(e)) + " " + U(At.internal.getHeight(e)) + " re"), xe.push("f"), t.stream = xe.join(`
`), t
    }
  }, RadioButton: {
    Circle: {
      createAppearanceStream: function (e) { var t = { D: { Off: At.RadioButton.Circle.OffPushDown }, N: {} }; return t.N[e] = At.RadioButton.Circle.YesNormal, t.D[e] = At.RadioButton.Circle.YesPushDown, t }, getCA: function () { return "l" }, YesNormal: function (e) {
        var t = V(e); t.scope = e.scope; var xe = [], Ee = At.internal.getWidth(e) <= At.internal.getHeight(e) ? At.internal.getWidth(e) / 4 : At.internal.getHeight(e) / 4; Ee = Number((.9 * Ee).toFixed(5)); var _e = At.internal.Bezier_C, Re = Number((Ee * _e).toFixed(5)); return xe.push("q"), xe.push("1 0 0 1 " + z(At.internal.getWidth(e) / 2) + " " + z(At.internal.getHeight(e) / 2) + " cm"), xe.push(Ee + " 0 m"), xe.push(Ee + " " + Re + " " + Re + " " + Ee + " 0 " + Ee + " c"), xe.push("-" + Re + " " + Ee + " -" + Ee + " " + Re + " -" + Ee + " 0 c"), xe.push("-" + Ee + " -" + Re + " -" + Re + " -" + Ee + " 0 -" + Ee + " c"), xe.push(Re + " -" + Ee + " " + Ee + " -" + Re + " " + Ee + " 0 c"), xe.push("f"), xe.push("Q"), t.stream = xe.join(`
`), t
      }, YesPushDown: function (e) {
        var t = V(e); t.scope = e.scope; var xe = [], Ee = At.internal.getWidth(e) <= At.internal.getHeight(e) ? At.internal.getWidth(e) / 4 : At.internal.getHeight(e) / 4; Ee = Number((.9 * Ee).toFixed(5)); var _e = Number((2 * Ee).toFixed(5)), Re = Number((_e * At.internal.Bezier_C).toFixed(5)), Ce = Number((Ee * At.internal.Bezier_C).toFixed(5)); return xe.push("0.749023 g"), xe.push("q"), xe.push("1 0 0 1 " + z(At.internal.getWidth(e) / 2) + " " + z(At.internal.getHeight(e) / 2) + " cm"), xe.push(_e + " 0 m"), xe.push(_e + " " + Re + " " + Re + " " + _e + " 0 " + _e + " c"), xe.push("-" + Re + " " + _e + " -" + _e + " " + Re + " -" + _e + " 0 c"), xe.push("-" + _e + " -" + Re + " -" + Re + " -" + _e + " 0 -" + _e + " c"), xe.push(Re + " -" + _e + " " + _e + " -" + Re + " " + _e + " 0 c"), xe.push("f"), xe.push("Q"), xe.push("0 g"), xe.push("q"), xe.push("1 0 0 1 " + z(At.internal.getWidth(e) / 2) + " " + z(At.internal.getHeight(e) / 2) + " cm"), xe.push(Ee + " 0 m"), xe.push(Ee + " " + Ce + " " + Ce + " " + Ee + " 0 " + Ee + " c"), xe.push("-" + Ce + " " + Ee + " -" + Ee + " " + Ce + " -" + Ee + " 0 c"), xe.push("-" + Ee + " -" + Ce + " -" + Ce + " -" + Ee + " 0 -" + Ee + " c"), xe.push(Ce + " -" + Ee + " " + Ee + " -" + Ce + " " + Ee + " 0 c"), xe.push("f"), xe.push("Q"), t.stream = xe.join(`
`), t
      }, OffPushDown: function (e) {
        var t = V(e); t.scope = e.scope; var xe = [], Ee = At.internal.getWidth(e) <= At.internal.getHeight(e) ? At.internal.getWidth(e) / 4 : At.internal.getHeight(e) / 4; Ee = Number((.9 * Ee).toFixed(5)); var _e = Number((2 * Ee).toFixed(5)), Re = Number((_e * At.internal.Bezier_C).toFixed(5)); return xe.push("0.749023 g"), xe.push("q"), xe.push("1 0 0 1 " + z(At.internal.getWidth(e) / 2) + " " + z(At.internal.getHeight(e) / 2) + " cm"), xe.push(_e + " 0 m"), xe.push(_e + " " + Re + " " + Re + " " + _e + " 0 " + _e + " c"), xe.push("-" + Re + " " + _e + " -" + _e + " " + Re + " -" + _e + " 0 c"), xe.push("-" + _e + " -" + Re + " -" + Re + " -" + _e + " 0 -" + _e + " c"), xe.push(Re + " -" + _e + " " + _e + " -" + Re + " " + _e + " 0 c"), xe.push("f"), xe.push("Q"), t.stream = xe.join(`
`), t
      }
    }, Cross: {
      createAppearanceStream: function (e) { var t = { D: { Off: At.RadioButton.Cross.OffPushDown }, N: {} }; return t.N[e] = At.RadioButton.Cross.YesNormal, t.D[e] = At.RadioButton.Cross.YesPushDown, t }, getCA: function () { return "8" }, YesNormal: function (e) {
        var t = V(e); t.scope = e.scope; var xe = [], Ee = At.internal.calculateCross(e); return xe.push("q"), xe.push("1 1 " + U(At.internal.getWidth(e) - 2) + " " + U(At.internal.getHeight(e) - 2) + " re"), xe.push("W"), xe.push("n"), xe.push(U(Ee.x1.x) + " " + U(Ee.x1.y) + " m"), xe.push(U(Ee.x2.x) + " " + U(Ee.x2.y) + " l"), xe.push(U(Ee.x4.x) + " " + U(Ee.x4.y) + " m"), xe.push(U(Ee.x3.x) + " " + U(Ee.x3.y) + " l"), xe.push("s"), xe.push("Q"), t.stream = xe.join(`
`), t
      }, YesPushDown: function (e) {
        var t = V(e); t.scope = e.scope; var xe = At.internal.calculateCross(e), Ee = []; return Ee.push("0.749023 g"), Ee.push("0 0 " + U(At.internal.getWidth(e)) + " " + U(At.internal.getHeight(e)) + " re"), Ee.push("f"), Ee.push("q"), Ee.push("1 1 " + U(At.internal.getWidth(e) - 2) + " " + U(At.internal.getHeight(e) - 2) + " re"), Ee.push("W"), Ee.push("n"), Ee.push(U(xe.x1.x) + " " + U(xe.x1.y) + " m"), Ee.push(U(xe.x2.x) + " " + U(xe.x2.y) + " l"), Ee.push(U(xe.x4.x) + " " + U(xe.x4.y) + " m"), Ee.push(U(xe.x3.x) + " " + U(xe.x3.y) + " l"), Ee.push("s"), Ee.push("Q"), t.stream = Ee.join(`
`), t
      }, OffPushDown: function (e) {
        var t = V(e); t.scope = e.scope; var xe = []; return xe.push("0.749023 g"), xe.push("0 0 " + U(At.internal.getWidth(e)) + " " + U(At.internal.getHeight(e)) + " re"), xe.push("f"), t.stream = xe.join(`
`), t
      }
    }
  }, createDefaultAppearanceStream: function (e) { var t = e.scope.internal.getFont(e.fontName, e.fontStyle).id, xe = e.scope.__private__.encodeColorString(e.color); return "/" + t + " " + e.fontSize + " Tf " + xe }
}; At.internal = { Bezier_C: .551915024494, calculateCross: function (e) { var t = At.internal.getWidth(e), xe = At.internal.getHeight(e), Ee = Math.min(t, xe); return { x1: { x: (t - Ee) / 2, y: (xe - Ee) / 2 + Ee }, x2: { x: (t - Ee) / 2 + Ee, y: (xe - Ee) / 2 }, x3: { x: (t - Ee) / 2, y: (xe - Ee) / 2 }, x4: { x: (t - Ee) / 2 + Ee, y: (xe - Ee) / 2 + Ee } } } }, At.internal.getWidth = function (e) { var t = 0; return _typeof(e) === "object" && (t = W(e.Rect[2])), t }, At.internal.getHeight = function (e) { var t = 0; return _typeof(e) === "object" && (t = W(e.Rect[3])), t }; var xt = q.addField = function (e) { if (at(this, e), !(e instanceof lt)) throw new Error("Invalid argument passed to jsPDF.addField."); var t; return (t = e).scope.internal.acroformPlugin.printedOut && (t.scope.internal.acroformPlugin.printedOut = !1, t.scope.internal.acroformPlugin.acroFormDictionaryRoot = null), t.scope.internal.acroformPlugin.acroFormDictionaryRoot.Fields.push(t), e.page = e.scope.internal.getCurrentPageInfo().pageNumber, this }; q.AcroFormChoiceField = ft, q.AcroFormListBox = dt, q.AcroFormComboBox = pt, q.AcroFormEditBox = gt, q.AcroFormButton = mt, q.AcroFormPushButton = vt, q.AcroFormRadioButton = bt, q.AcroFormCheckBox = wt, q.AcroFormTextField = Nt, q.AcroFormPasswordField = Lt, q.AcroFormAppearance = At, q.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }, E.AcroForm = { ChoiceField: ft, ListBox: dt, ComboBox: pt, EditBox: gt, Button: mt, PushButton: vt, RadioButton: bt, CheckBox: wt, TextField: Nt, PasswordField: Lt, Appearance: At }; E.AcroForm; function _t(e) { return e.reduce(function (t, xe, Ee) { return t[xe] = Ee, t }, {}) } (function (e) { e.__addimage__ = {}; var t = "UNKNOWN", xe = { PNG: [[137, 80, 78, 71]], TIFF: [[77, 77, 0, 42], [73, 73, 42, 0]], JPEG: [[255, 216, 255, 224, void 0, void 0, 74, 70, 73, 70, 0], [255, 216, 255, 225, void 0, void 0, 69, 120, 105, 102, 0, 0], [255, 216, 255, 219], [255, 216, 255, 238]], JPEG2000: [[0, 0, 0, 12, 106, 80, 32, 32]], GIF87a: [[71, 73, 70, 56, 55, 97]], GIF89a: [[71, 73, 70, 56, 57, 97]], WEBP: [[82, 73, 70, 70, void 0, void 0, void 0, void 0, 87, 69, 66, 80]], BMP: [[66, 77], [66, 65], [67, 73], [67, 80], [73, 67], [80, 84]] }, Ee = e.__addimage__.getImageFileTypeByImageData = function (fn, En) { var Pn, Rn, In, xn, vn, tn = t; if ((En = En || t) === "RGBA" || fn.data !== void 0 && fn.data instanceof Uint8ClampedArray && "height" in fn && "width" in fn) return "RGBA"; if (St(fn)) for (vn in xe) for (In = xe[vn], Pn = 0; Pn < In.length; Pn += 1) { for (xn = !0, Rn = 0; Rn < In[Pn].length; Rn += 1)if (In[Pn][Rn] !== void 0 && In[Pn][Rn] !== fn[Rn]) { xn = !1; break } if (xn === !0) { tn = vn; break } } else for (vn in xe) for (In = xe[vn], Pn = 0; Pn < In.length; Pn += 1) { for (xn = !0, Rn = 0; Rn < In[Pn].length; Rn += 1)if (In[Pn][Rn] !== void 0 && In[Pn][Rn] !== fn.charCodeAt(Rn)) { xn = !1; break } if (xn === !0) { tn = vn; break } } return tn === t && En !== t && (tn = En), tn }, _e = function fn(En) { for (var Pn = this.internal.write, Rn = this.internal.putStream, In = (0, this.internal.getFilters)(); In.indexOf("FlateEncode") !== -1;)In.splice(In.indexOf("FlateEncode"), 1); En.objectId = this.internal.newObject(); var xn = []; if (xn.push({ key: "Type", value: "/XObject" }), xn.push({ key: "Subtype", value: "/Image" }), xn.push({ key: "Width", value: En.width }), xn.push({ key: "Height", value: En.height }), En.colorSpace === qe.INDEXED ? xn.push({ key: "ColorSpace", value: "[/Indexed /DeviceRGB " + (En.palette.length / 3 - 1) + " " + ("sMask" in En && En.sMask !== void 0 ? En.objectId + 2 : En.objectId + 1) + " 0 R]" }) : (xn.push({ key: "ColorSpace", value: "/" + En.colorSpace }), En.colorSpace === qe.DEVICE_CMYK && xn.push({ key: "Decode", value: "[1 0 1 0 1 0 1 0]" })), xn.push({ key: "BitsPerComponent", value: En.bitsPerComponent }), "decodeParameters" in En && En.decodeParameters !== void 0 && xn.push({ key: "DecodeParms", value: "<<" + En.decodeParameters + ">>" }), "transparency" in En && Array.isArray(En.transparency)) { for (var vn = "", tn = 0, nn = En.transparency.length; tn < nn; tn++)vn += En.transparency[tn] + " " + En.transparency[tn] + " "; xn.push({ key: "Mask", value: "[" + vn + "]" }) } En.sMask !== void 0 && xn.push({ key: "SMask", value: En.objectId + 1 + " 0 R" }); var We = En.filter !== void 0 ? ["/" + En.filter] : void 0; if (Rn({ data: En.data, additionalKeyValues: xn, alreadyAppliedFilters: We, objectId: En.objectId }), Pn("endobj"), "sMask" in En && En.sMask !== void 0) { var dn = "/Predictor " + En.predictor + " /Colors 1 /BitsPerComponent " + En.bitsPerComponent + " /Columns " + En.width, Je = { width: En.width, height: En.height, colorSpace: "DeviceGray", bitsPerComponent: En.bitsPerComponent, decodeParameters: dn, data: En.sMask }; "filter" in En && (Je.filter = En.filter), fn.call(this, Je) } if (En.colorSpace === qe.INDEXED) { var rn = this.internal.newObject(); Rn({ data: on(new Uint8Array(En.palette)), objectId: rn }), Pn("endobj") } }, Re = function () { var fn = this.internal.collections.addImage_images; for (var En in fn) _e.call(this, fn[En]) }, Ce = function () { var fn, En = this.internal.collections.addImage_images, Pn = this.internal.write; for (var Rn in En) Pn("/I" + (fn = En[Rn]).index, fn.objectId, "0", "R") }, Me = function () { this.internal.collections.addImage_images || (this.internal.collections.addImage_images = {}, this.internal.events.subscribe("putResources", Re), this.internal.events.subscribe("putXobjectDict", Ce)) }, De = function () { var fn = this.internal.collections.addImage_images; return Me.call(this), fn }, Pe = function () { return Object.keys(this.internal.collections.addImage_images).length }, Oe = function (fn) { return typeof e["process" + fn.toUpperCase()] == "function" }, je = function (fn) { return _typeof(fn) === "object" && fn.nodeType === 1 }, Be = function (fn, En) { if (fn.nodeName === "IMG" && fn.hasAttribute("src")) { var Pn = "" + fn.getAttribute("src"); if (Pn.indexOf("data:image/") === 0) return u(unescape(Pn).split("base64,").pop()); var Rn = e.loadFile(Pn, !0); if (Rn !== void 0) return Rn } if (fn.nodeName === "CANVAS") { if (fn.width === 0 || fn.height === 0) throw new Error("Given canvas must have data. Canvas width: " + fn.width + ", height: " + fn.height); var In; switch (En) { case "PNG": In = "image/png"; break; case "WEBP": In = "image/webp"; break; case "JPEG": case "JPG": default: In = "image/jpeg" }return u(fn.toDataURL(In, 1).split("base64,").pop()) } }, Ie = function (fn) { var En = this.internal.collections.addImage_images; if (En) { for (var Pn in En) if (fn === En[Pn].alias) return En[Pn] } }, Fe = function (fn, En, Pn) { return fn || En || (fn = -96, En = -96), fn < 0 && (fn = -1 * Pn.width * 72 / fn / this.internal.scaleFactor), En < 0 && (En = -1 * Pn.height * 72 / En / this.internal.scaleFactor), fn === 0 && (fn = En * Pn.width / Pn.height), En === 0 && (En = fn * Pn.height / Pn.width), [fn, En] }, ze = function (fn, En, Pn, Rn, In, xn) { var vn = Fe.call(this, Pn, Rn, In), tn = this.internal.getCoordinateString, nn = this.internal.getVerticalCoordinateString, We = De.call(this); if (Pn = vn[0], Rn = vn[1], We[In.index] = In, xn) { xn *= Math.PI / 180; var dn = Math.cos(xn), Je = Math.sin(xn), rn = function (mn) { return mn.toFixed(4) }, hn = [rn(dn), rn(Je), rn(-1 * Je), rn(dn), 0, 0, "cm"] } this.internal.write("q"), xn ? (this.internal.write([1, "0", "0", 1, tn(fn), nn(En + Rn), "cm"].join(" ")), this.internal.write(hn.join(" ")), this.internal.write([tn(Pn), "0", "0", tn(Rn), "0", "0", "cm"].join(" "))) : this.internal.write([tn(Pn), "0", "0", tn(Rn), tn(fn), nn(En + Rn), "cm"].join(" ")), this.isAdvancedAPI() && this.internal.write([1, 0, 0, -1, 0, 0, "cm"].join(" ")), this.internal.write("/I" + In.index + " Do"), this.internal.write("Q") }, qe = e.color_spaces = { DEVICE_RGB: "DeviceRGB", DEVICE_GRAY: "DeviceGray", DEVICE_CMYK: "DeviceCMYK", CAL_GREY: "CalGray", CAL_RGB: "CalRGB", LAB: "Lab", ICC_BASED: "ICCBased", INDEXED: "Indexed", PATTERN: "Pattern", SEPARATION: "Separation", DEVICE_N: "DeviceN" }; e.decode = { DCT_DECODE: "DCTDecode", FLATE_DECODE: "FlateDecode", LZW_DECODE: "LZWDecode", JPX_DECODE: "JPXDecode", JBIG2_DECODE: "JBIG2Decode", ASCII85_DECODE: "ASCII85Decode", ASCII_HEX_DECODE: "ASCIIHexDecode", RUN_LENGTH_DECODE: "RunLengthDecode", CCITT_FAX_DECODE: "CCITTFaxDecode" }; var He = e.image_compression = { NONE: "NONE", FAST: "FAST", MEDIUM: "MEDIUM", SLOW: "SLOW" }, Ge = e.__addimage__.sHashCode = function (fn) { var En, Pn, Rn = 0; if (typeof fn == "string") for (Pn = fn.length, En = 0; En < Pn; En++)Rn = (Rn << 5) - Rn + fn.charCodeAt(En), Rn |= 0; else if (St(fn)) for (Pn = fn.byteLength / 2, En = 0; En < Pn; En++)Rn = (Rn << 5) - Rn + fn[En], Rn |= 0; return Rn }, Ze = e.__addimage__.validateStringAsBase64 = function (fn) { (fn = fn || "").toString().trim(); var En = !0; return fn.length === 0 && (En = !1), fn.length % 4 != 0 && (En = !1), /^[A-Za-z0-9+/]+$/.test(fn.substr(0, fn.length - 2)) === !1 && (En = !1), /^[A-Za-z0-9/][A-Za-z0-9+/]|[A-Za-z0-9+/]=|==$/.test(fn.substr(-2)) === !1 && (En = !1), En }, sn = e.__addimage__.extractImageFromDataUrl = function (fn) { if (fn == null || !(fn = fn.trim()).startsWith("data:")) return null; var En = fn.indexOf(","); return En < 0 ? null : fn.substring(0, En).trim().endsWith("base64") ? fn.substring(En + 1) : null }, Xe = e.__addimage__.supportsArrayBuffer = function () { return typeof ArrayBuffer < "u" && typeof Uint8Array < "u" }; e.__addimage__.isArrayBuffer = function (fn) { return Xe() && fn instanceof ArrayBuffer }; var St = e.__addimage__.isArrayBufferView = function (fn) { return Xe() && typeof Uint32Array < "u" && (fn instanceof Int8Array || fn instanceof Uint8Array || typeof Uint8ClampedArray < "u" && fn instanceof Uint8ClampedArray || fn instanceof Int16Array || fn instanceof Uint16Array || fn instanceof Int32Array || fn instanceof Uint32Array || fn instanceof Float32Array || fn instanceof Float64Array) }, un = e.__addimage__.binaryStringToUint8Array = function (fn) { for (var En = fn.length, Pn = new Uint8Array(En), Rn = 0; Rn < En; Rn++)Pn[Rn] = fn.charCodeAt(Rn); return Pn }, on = e.__addimage__.arrayBufferToBinaryString = function (fn) { for (var En = "", Pn = St(fn) ? fn : new Uint8Array(fn), Rn = 0; Rn < Pn.length; Rn += 8192)En += String.fromCharCode.apply(null, Pn.subarray(Rn, Rn + 8192)); return En }; e.addImage = function () { var fn, En, Pn, Rn, In, xn, vn, tn, nn; if (typeof arguments[1] == "number" ? (En = t, Pn = arguments[1], Rn = arguments[2], In = arguments[3], xn = arguments[4], vn = arguments[5], tn = arguments[6], nn = arguments[7]) : (En = arguments[1], Pn = arguments[2], Rn = arguments[3], In = arguments[4], xn = arguments[5], vn = arguments[6], tn = arguments[7], nn = arguments[8]), _typeof(fn = arguments[0]) === "object" && !je(fn) && "imageData" in fn) { var We = fn; fn = We.imageData, En = We.format || En || t, Pn = We.x || Pn || 0, Rn = We.y || Rn || 0, In = We.w || We.width || In, xn = We.h || We.height || xn, vn = We.alias || vn, tn = We.compression || tn, nn = We.rotation || We.angle || nn } var dn = this.internal.getFilters(); if (tn === void 0 && dn.indexOf("FlateEncode") !== -1 && (tn = "SLOW"), isNaN(Pn) || isNaN(Rn)) throw new Error("Invalid coordinates passed to jsPDF.addImage"); Me.call(this); var Je = bn.call(this, fn, En, vn, tn); return ze.call(this, Pn, Rn, In, xn, Je, nn), this }; var bn = function (fn, En, Pn, Rn) { var In, xn, vn; if (typeof fn == "string" && Ee(fn) === t) { fn = unescape(fn); var tn = Tn(fn, !1); (tn !== "" || (tn = e.loadFile(fn, !0)) !== void 0) && (fn = tn) } if (je(fn) && (fn = Be(fn, En)), En = Ee(fn, En), !Oe(En)) throw new Error("addImage does not support files of type '" + En + "', please ensure that a plugin for '" + En + "' support is added."); if (((vn = Pn) == null || vn.length === 0) && (Pn = function (nn) { return typeof nn == "string" || St(nn) ? Ge(nn) : St(nn.data) ? Ge(nn.data) : null }(fn)), (In = Ie.call(this, Pn)) || (Xe() && (fn instanceof Uint8Array || En === "RGBA" || (xn = fn, fn = un(fn))), In = this["process" + En.toUpperCase()](fn, Pe.call(this), Pn, function (nn) { return nn && typeof nn == "string" && (nn = nn.toUpperCase()), nn in e.image_compression ? nn : He.NONE }(Rn), xn)), !In) throw new Error("An unknown error occurred whilst processing the image."); return In }, Tn = e.__addimage__.convertBase64ToBinaryString = function (fn, En) { En = typeof En != "boolean" || En; var Pn, Rn = ""; if (typeof fn == "string") { var In; Pn = (In = sn(fn)) !== null && In !== void 0 ? In : fn; try { Rn = u(Pn) } catch (xn) { if (En) throw Ze(Pn) ? new Error("atob-Error in jsPDF.convertBase64ToBinaryString " + xn.message) : new Error("Supplied Data is not a valid base64-String jsPDF.convertBase64ToBinaryString ") } } return Rn }; e.getImageProperties = function (fn) { var En, Pn, Rn = ""; if (je(fn) && (fn = Be(fn)), typeof fn == "string" && Ee(fn) === t && ((Rn = Tn(fn, !1)) === "" && (Rn = e.loadFile(fn) || ""), fn = Rn), Pn = Ee(fn), !Oe(Pn)) throw new Error("addImage does not support files of type '" + Pn + "', please ensure that a plugin for '" + Pn + "' support is added."); if (!Xe() || fn instanceof Uint8Array || (fn = un(fn)), !(En = this["process" + Pn.toUpperCase()](fn))) throw new Error("An unknown error occurred whilst processing the image"); return En.fileType = Pn, En } })(E.API), function (e) { var t = function (xe) { if (xe !== void 0 && xe != "") return !0 }; E.API.events.push(["addPage", function (xe) { this.internal.getPageInfo(xe.pageNumber).pageContext.annotations = [] }]), e.events.push(["putPage", function (xe) { for (var Ee, _e, Re, Ce = this.internal.getCoordinateString, Me = this.internal.getVerticalCoordinateString, De = this.internal.getPageInfoByObjId(xe.objId), Pe = xe.pageContext.annotations, Oe = !1, je = 0; je < Pe.length && !Oe; je++)switch ((Ee = Pe[je]).type) { case "link": (t(Ee.options.url) || t(Ee.options.pageNumber)) && (Oe = !0); break; case "reference": case "text": case "freetext": Oe = !0 }if (Oe != 0) { this.internal.write("/Annots ["); for (var Be = 0; Be < Pe.length; Be++) { Ee = Pe[Be]; var Ie = this.internal.pdfEscape, Fe = this.internal.getEncryptor(xe.objId); switch (Ee.type) { case "reference": this.internal.write(" " + Ee.object.objId + " 0 R "); break; case "text": var ze = this.internal.newAdditionalObject(), qe = this.internal.newAdditionalObject(), He = this.internal.getEncryptor(ze.objId), Ge = Ee.title || "Note"; Re = "<</Type /Annot /Subtype /Text " + (_e = "/Rect [" + Ce(Ee.bounds.x) + " " + Me(Ee.bounds.y + Ee.bounds.h) + " " + Ce(Ee.bounds.x + Ee.bounds.w) + " " + Me(Ee.bounds.y) + "] ") + "/Contents (" + Ie(He(Ee.contents)) + ")", Re += " /Popup " + qe.objId + " 0 R", Re += " /P " + De.objId + " 0 R", Re += " /T (" + Ie(He(Ge)) + ") >>", ze.content = Re; var Ze = ze.objId + " 0 R"; Re = "<</Type /Annot /Subtype /Popup " + (_e = "/Rect [" + Ce(Ee.bounds.x + 30) + " " + Me(Ee.bounds.y + Ee.bounds.h) + " " + Ce(Ee.bounds.x + Ee.bounds.w + 30) + " " + Me(Ee.bounds.y) + "] ") + " /Parent " + Ze, Ee.open && (Re += " /Open true"), Re += " >>", qe.content = Re, this.internal.write(ze.objId, "0 R", qe.objId, "0 R"); break; case "freetext": _e = "/Rect [" + Ce(Ee.bounds.x) + " " + Me(Ee.bounds.y) + " " + Ce(Ee.bounds.x + Ee.bounds.w) + " " + Me(Ee.bounds.y + Ee.bounds.h) + "] "; var sn = Ee.color || "#000000"; Re = "<</Type /Annot /Subtype /FreeText " + _e + "/Contents (" + Ie(Fe(Ee.contents)) + ")", Re += " /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#" + sn + ")", Re += " /Border [0 0 0]", Re += " >>", this.internal.write(Re); break; case "link": if (Ee.options.name) { var Xe = this.annotations._nameMap[Ee.options.name]; Ee.options.pageNumber = Xe.page, Ee.options.top = Xe.y } else Ee.options.top || (Ee.options.top = 0); if (_e = "/Rect [" + Ee.finalBounds.x + " " + Ee.finalBounds.y + " " + Ee.finalBounds.w + " " + Ee.finalBounds.h + "] ", Re = "", Ee.options.url) Re = "<</Type /Annot /Subtype /Link " + _e + "/Border [0 0 0] /A <</S /URI /URI (" + Ie(Fe(Ee.options.url)) + ") >>"; else if (Ee.options.pageNumber) switch (Re = "<</Type /Annot /Subtype /Link " + _e + "/Border [0 0 0] /Dest [" + this.internal.getPageInfo(Ee.options.pageNumber).objId + " 0 R", Ee.options.magFactor = Ee.options.magFactor || "XYZ", Ee.options.magFactor) { case "Fit": Re += " /Fit]"; break; case "FitH": Re += " /FitH " + Ee.options.top + "]"; break; case "FitV": Ee.options.left = Ee.options.left || 0, Re += " /FitV " + Ee.options.left + "]"; break; case "XYZ": default: var St = Me(Ee.options.top); Ee.options.left = Ee.options.left || 0, Ee.options.zoom === void 0 && (Ee.options.zoom = 0), Re += " /XYZ " + Ee.options.left + " " + St + " " + Ee.options.zoom + "]" }Re != "" && (Re += " >>", this.internal.write(Re)) } } this.internal.write("]") } }]), e.createAnnotation = function (xe) { var Ee = this.internal.getCurrentPageInfo(); switch (xe.type) { case "link": this.link(xe.bounds.x, xe.bounds.y, xe.bounds.w, xe.bounds.h, xe); break; case "text": case "freetext": Ee.pageContext.annotations.push(xe) } }, e.link = function (xe, Ee, _e, Re, Ce) { var Me = this.internal.getCurrentPageInfo(), De = this.internal.getCoordinateString, Pe = this.internal.getVerticalCoordinateString; Me.pageContext.annotations.push({ finalBounds: { x: De(xe), y: Pe(Ee), w: De(xe + _e), h: Pe(Ee + Re) }, options: Ce, type: "link" }) }, e.textWithLink = function (xe, Ee, _e, Re) { var Ce, Me, De = this.getTextWidth(xe), Pe = this.internal.getLineHeight() / this.internal.scaleFactor; if (Re.maxWidth !== void 0) { Me = Re.maxWidth; var Oe = this.splitTextToSize(xe, Me).length; Ce = Math.ceil(Pe * Oe) } else Me = De, Ce = Pe; return this.text(xe, Ee, _e, Re), _e += .2 * Pe, Re.align === "center" && (Ee -= De / 2), Re.align === "right" && (Ee -= De), this.link(Ee, _e - Pe, Me, Ce, Re), De }, e.getTextWidth = function (xe) { var Ee = this.internal.getFontSize(); return this.getStringUnitWidth(xe) * Ee / this.internal.scaleFactor } }(E.API), function (e) { var t = { 1569: [65152], 1570: [65153, 65154], 1571: [65155, 65156], 1572: [65157, 65158], 1573: [65159, 65160], 1574: [65161, 65162, 65163, 65164], 1575: [65165, 65166], 1576: [65167, 65168, 65169, 65170], 1577: [65171, 65172], 1578: [65173, 65174, 65175, 65176], 1579: [65177, 65178, 65179, 65180], 1580: [65181, 65182, 65183, 65184], 1581: [65185, 65186, 65187, 65188], 1582: [65189, 65190, 65191, 65192], 1583: [65193, 65194], 1584: [65195, 65196], 1585: [65197, 65198], 1586: [65199, 65200], 1587: [65201, 65202, 65203, 65204], 1588: [65205, 65206, 65207, 65208], 1589: [65209, 65210, 65211, 65212], 1590: [65213, 65214, 65215, 65216], 1591: [65217, 65218, 65219, 65220], 1592: [65221, 65222, 65223, 65224], 1593: [65225, 65226, 65227, 65228], 1594: [65229, 65230, 65231, 65232], 1601: [65233, 65234, 65235, 65236], 1602: [65237, 65238, 65239, 65240], 1603: [65241, 65242, 65243, 65244], 1604: [65245, 65246, 65247, 65248], 1605: [65249, 65250, 65251, 65252], 1606: [65253, 65254, 65255, 65256], 1607: [65257, 65258, 65259, 65260], 1608: [65261, 65262], 1609: [65263, 65264, 64488, 64489], 1610: [65265, 65266, 65267, 65268], 1649: [64336, 64337], 1655: [64477], 1657: [64358, 64359, 64360, 64361], 1658: [64350, 64351, 64352, 64353], 1659: [64338, 64339, 64340, 64341], 1662: [64342, 64343, 64344, 64345], 1663: [64354, 64355, 64356, 64357], 1664: [64346, 64347, 64348, 64349], 1667: [64374, 64375, 64376, 64377], 1668: [64370, 64371, 64372, 64373], 1670: [64378, 64379, 64380, 64381], 1671: [64382, 64383, 64384, 64385], 1672: [64392, 64393], 1676: [64388, 64389], 1677: [64386, 64387], 1678: [64390, 64391], 1681: [64396, 64397], 1688: [64394, 64395], 1700: [64362, 64363, 64364, 64365], 1702: [64366, 64367, 64368, 64369], 1705: [64398, 64399, 64400, 64401], 1709: [64467, 64468, 64469, 64470], 1711: [64402, 64403, 64404, 64405], 1713: [64410, 64411, 64412, 64413], 1715: [64406, 64407, 64408, 64409], 1722: [64414, 64415], 1723: [64416, 64417, 64418, 64419], 1726: [64426, 64427, 64428, 64429], 1728: [64420, 64421], 1729: [64422, 64423, 64424, 64425], 1733: [64480, 64481], 1734: [64473, 64474], 1735: [64471, 64472], 1736: [64475, 64476], 1737: [64482, 64483], 1739: [64478, 64479], 1740: [64508, 64509, 64510, 64511], 1744: [64484, 64485, 64486, 64487], 1746: [64430, 64431], 1747: [64432, 64433] }, xe = { 65247: { 65154: 65269, 65156: 65271, 65160: 65273, 65166: 65275 }, 65248: { 65154: 65270, 65156: 65272, 65160: 65274, 65166: 65276 }, 65165: { 65247: { 65248: { 65258: 65010 } } }, 1617: { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 } }, Ee = { 1612: 64606, 1613: 64607, 1614: 64608, 1615: 64609, 1616: 64610 }, _e = [1570, 1571, 1573, 1575]; e.__arabicParser__ = {}; var Re = e.__arabicParser__.isInArabicSubstitutionA = function (ze) { return t[ze.charCodeAt(0)] !== void 0 }, Ce = e.__arabicParser__.isArabicLetter = function (ze) { return typeof ze == "string" && /^[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]+$/.test(ze) }, Me = e.__arabicParser__.isArabicEndLetter = function (ze) { return Ce(ze) && Re(ze) && t[ze.charCodeAt(0)].length <= 2 }, De = e.__arabicParser__.isArabicAlfLetter = function (ze) { return Ce(ze) && _e.indexOf(ze.charCodeAt(0)) >= 0 }; e.__arabicParser__.arabicLetterHasIsolatedForm = function (ze) { return Ce(ze) && Re(ze) && t[ze.charCodeAt(0)].length >= 1 }; var Pe = e.__arabicParser__.arabicLetterHasFinalForm = function (ze) { return Ce(ze) && Re(ze) && t[ze.charCodeAt(0)].length >= 2 }; e.__arabicParser__.arabicLetterHasInitialForm = function (ze) { return Ce(ze) && Re(ze) && t[ze.charCodeAt(0)].length >= 3 }; var Oe = e.__arabicParser__.arabicLetterHasMedialForm = function (ze) { return Ce(ze) && Re(ze) && t[ze.charCodeAt(0)].length == 4 }, je = e.__arabicParser__.resolveLigatures = function (ze) { var qe = 0, He = xe, Ge = "", Ze = 0; for (qe = 0; qe < ze.length; qe += 1)He[ze.charCodeAt(qe)] !== void 0 ? (Ze++, typeof (He = He[ze.charCodeAt(qe)]) == "number" && (Ge += String.fromCharCode(He), He = xe, Ze = 0), qe === ze.length - 1 && (He = xe, Ge += ze.charAt(qe - (Ze - 1)), qe -= Ze - 1, Ze = 0)) : (He = xe, Ge += ze.charAt(qe - Ze), qe -= Ze, Ze = 0); return Ge }; e.__arabicParser__.isArabicDiacritic = function (ze) { return ze !== void 0 && Ee[ze.charCodeAt(0)] !== void 0 }; var Be = e.__arabicParser__.getCorrectForm = function (ze, qe, He) { return Ce(ze) ? Re(ze) === !1 ? -1 : !Pe(ze) || !Ce(qe) && !Ce(He) || !Ce(He) && Me(qe) || Me(ze) && !Ce(qe) || Me(ze) && De(qe) || Me(ze) && Me(qe) ? 0 : Oe(ze) && Ce(qe) && !Me(qe) && Ce(He) && Pe(He) ? 3 : Me(ze) || !Ce(He) ? 1 : 2 : -1 }, Ie = function (ze) { var qe = 0, He = 0, Ge = 0, Ze = "", sn = "", Xe = "", St = (ze = ze || "").split("\\s+"), un = []; for (qe = 0; qe < St.length; qe += 1) { for (un.push(""), He = 0; He < St[qe].length; He += 1)Ze = St[qe][He], sn = St[qe][He - 1], Xe = St[qe][He + 1], Ce(Ze) ? (Ge = Be(Ze, sn, Xe), un[qe] += Ge !== -1 ? String.fromCharCode(t[Ze.charCodeAt(0)][Ge]) : Ze) : un[qe] += Ze; un[qe] = je(un[qe]) } return un.join(" ") }, Fe = e.__arabicParser__.processArabic = e.processArabic = function () { var ze, qe = typeof arguments[0] == "string" ? arguments[0] : arguments[0].text, He = []; if (Array.isArray(qe)) { var Ge = 0; for (He = [], Ge = 0; Ge < qe.length; Ge += 1)Array.isArray(qe[Ge]) ? He.push([Ie(qe[Ge][0]), qe[Ge][1], qe[Ge][2]]) : He.push([Ie(qe[Ge])]); ze = He } else ze = Ie(qe); return typeof arguments[0] == "string" ? ze : (arguments[0].text = ze, arguments[0]) }; e.events.push(["preProcessText", Fe]) }(E.API), E.API.autoPrint = function (e) { var t; switch ((e = e || {}).variant = e.variant || "non-conform", e.variant) { case "javascript": this.addJS("print({});"); break; case "non-conform": default: this.internal.events.subscribe("postPutResources", function () { t = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /Named"), this.internal.out("/Type /Action"), this.internal.out("/N /Print"), this.internal.out(">>"), this.internal.out("endobj") }), this.internal.events.subscribe("putCatalog", function () { this.internal.out("/OpenAction " + t + " 0 R") }) }return this }, function (e) { var t = function () { var xe = void 0; Object.defineProperty(this, "pdf", { get: function () { return xe }, set: function (Me) { xe = Me } }); var Ee = 150; Object.defineProperty(this, "width", { get: function () { return Ee }, set: function (Me) { Ee = isNaN(Me) || Number.isInteger(Me) === !1 || Me < 0 ? 150 : Me, this.getContext("2d").pageWrapXEnabled && (this.getContext("2d").pageWrapX = Ee + 1) } }); var _e = 300; Object.defineProperty(this, "height", { get: function () { return _e }, set: function (Me) { _e = isNaN(Me) || Number.isInteger(Me) === !1 || Me < 0 ? 300 : Me, this.getContext("2d").pageWrapYEnabled && (this.getContext("2d").pageWrapY = _e + 1) } }); var Re = []; Object.defineProperty(this, "childNodes", { get: function () { return Re }, set: function (Me) { Re = Me } }); var Ce = {}; Object.defineProperty(this, "style", { get: function () { return Ce }, set: function (Me) { Ce = Me } }), Object.defineProperty(this, "parentNode", {}) }; t.prototype.getContext = function (xe, Ee) { var _e; if ((xe = xe || "2d") !== "2d") return null; for (_e in Ee) this.pdf.context2d.hasOwnProperty(_e) && (this.pdf.context2d[_e] = Ee[_e]); return this.pdf.context2d._canvas = this, this.pdf.context2d }, t.prototype.toDataURL = function () { throw new Error("toDataURL is not implemented.") }, e.events.push(["initialized", function () { this.canvas = new t, this.canvas.pdf = this }]) }(E.API), function (e) { var t = { left: 0, top: 0, bottom: 0, right: 0 }, xe = !1, Ee = function () { this.internal.__cell__ === void 0 && (this.internal.__cell__ = {}, this.internal.__cell__.padding = 3, this.internal.__cell__.headerFunction = void 0, this.internal.__cell__.margins = Object.assign({}, t), this.internal.__cell__.margins.width = this.getPageWidth(), _e.call(this)) }, _e = function () { this.internal.__cell__.lastCell = new Re, this.internal.__cell__.pages = 1 }, Re = function () { var De = arguments[0]; Object.defineProperty(this, "x", { enumerable: !0, get: function () { return De }, set: function (ze) { De = ze } }); var Pe = arguments[1]; Object.defineProperty(this, "y", { enumerable: !0, get: function () { return Pe }, set: function (ze) { Pe = ze } }); var Oe = arguments[2]; Object.defineProperty(this, "width", { enumerable: !0, get: function () { return Oe }, set: function (ze) { Oe = ze } }); var je = arguments[3]; Object.defineProperty(this, "height", { enumerable: !0, get: function () { return je }, set: function (ze) { je = ze } }); var Be = arguments[4]; Object.defineProperty(this, "text", { enumerable: !0, get: function () { return Be }, set: function (ze) { Be = ze } }); var Ie = arguments[5]; Object.defineProperty(this, "lineNumber", { enumerable: !0, get: function () { return Ie }, set: function (ze) { Ie = ze } }); var Fe = arguments[6]; return Object.defineProperty(this, "align", { enumerable: !0, get: function () { return Fe }, set: function (ze) { Fe = ze } }), this }; Re.prototype.clone = function () { return new Re(this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align) }, Re.prototype.toArray = function () { return [this.x, this.y, this.width, this.height, this.text, this.lineNumber, this.align] }, e.setHeaderFunction = function (De) { return Ee.call(this), this.internal.__cell__.headerFunction = typeof De == "function" ? De : void 0, this }, e.getTextDimensions = function (De, Pe) { Ee.call(this); var Oe = (Pe = Pe || {}).fontSize || this.getFontSize(), je = Pe.font || this.getFont(), Be = Pe.scaleFactor || this.internal.scaleFactor, Ie = 0, Fe = 0, ze = 0, qe = this; if (!Array.isArray(De) && typeof De != "string") { if (typeof De != "number") throw new Error("getTextDimensions expects text-parameter to be of type String or type Number or an Array of Strings."); De = String(De) } var He = Pe.maxWidth; He > 0 ? typeof De == "string" ? De = this.splitTextToSize(De, He) : Object.prototype.toString.call(De) === "[object Array]" && (De = De.reduce(function (Ze, sn) { return Ze.concat(qe.splitTextToSize(sn, He)) }, [])) : De = Array.isArray(De) ? De : [De]; for (var Ge = 0; Ge < De.length; Ge++)Ie < (ze = this.getStringUnitWidth(De[Ge], { font: je }) * Oe) && (Ie = ze); return Ie !== 0 && (Fe = De.length), { w: Ie /= Be, h: Math.max((Fe * Oe * this.getLineHeightFactor() - Oe * (this.getLineHeightFactor() - 1)) / Be, 0) } }, e.cellAddPage = function () { Ee.call(this), this.addPage(); var De = this.internal.__cell__.margins || t; return this.internal.__cell__.lastCell = new Re(De.left, De.top, void 0, void 0), this.internal.__cell__.pages += 1, this }; var Ce = e.cell = function () { var De; De = arguments[0] instanceof Re ? arguments[0] : new Re(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]), Ee.call(this); var Pe = this.internal.__cell__.lastCell, Oe = this.internal.__cell__.padding, je = this.internal.__cell__.margins || t, Be = this.internal.__cell__.tableHeaderRow, Ie = this.internal.__cell__.printHeaders; return Pe.lineNumber !== void 0 && (Pe.lineNumber === De.lineNumber ? (De.x = (Pe.x || 0) + (Pe.width || 0), De.y = Pe.y || 0) : Pe.y + Pe.height + De.height + je.bottom > this.getPageHeight() ? (this.cellAddPage(), De.y = je.top, Ie && Be && (this.printHeaderRow(De.lineNumber, !0), De.y += Be[0].height)) : De.y = Pe.y + Pe.height || De.y), De.text[0] !== void 0 && (this.rect(De.x, De.y, De.width, De.height, xe === !0 ? "FD" : void 0), De.align === "right" ? this.text(De.text, De.x + De.width - Oe, De.y + Oe, { align: "right", baseline: "top" }) : De.align === "center" ? this.text(De.text, De.x + De.width / 2, De.y + Oe, { align: "center", baseline: "top", maxWidth: De.width - Oe - Oe }) : this.text(De.text, De.x + Oe, De.y + Oe, { align: "left", baseline: "top", maxWidth: De.width - Oe - Oe })), this.internal.__cell__.lastCell = De, this }; e.table = function (De, Pe, Oe, je, Be) { if (Ee.call(this), !Oe) throw new Error("No data for PDF table."); var Ie, Fe, ze, qe, He = [], Ge = [], Ze = [], sn = {}, Xe = {}, St = [], un = [], on = (Be = Be || {}).autoSize || !1, bn = Be.printHeaders !== !1, Tn = Be.css && Be.css["font-size"] !== void 0 ? 16 * Be.css["font-size"] : Be.fontSize || 12, fn = Be.margins || Object.assign({ width: this.getPageWidth() }, t), En = typeof Be.padding == "number" ? Be.padding : 3, Pn = Be.headerBackgroundColor || "#c8c8c8", Rn = Be.headerTextColor || "#000"; if (_e.call(this), this.internal.__cell__.printHeaders = bn, this.internal.__cell__.margins = fn, this.internal.__cell__.table_font_size = Tn, this.internal.__cell__.padding = En, this.internal.__cell__.headerBackgroundColor = Pn, this.internal.__cell__.headerTextColor = Rn, this.setFontSize(Tn), je == null) Ge = He = Object.keys(Oe[0]), Ze = He.map(function () { return "left" }); else if (Array.isArray(je) && _typeof(je[0]) === "object") for (He = je.map(function (We) { return We.name }), Ge = je.map(function (We) { return We.prompt || We.name || "" }), Ze = je.map(function (We) { return We.align || "left" }), Ie = 0; Ie < je.length; Ie += 1)Xe[je[Ie].name] = je[Ie].width * (19.049976 / 25.4); else Array.isArray(je) && typeof je[0] == "string" && (Ge = He = je, Ze = He.map(function () { return "left" })); if (on || Array.isArray(je) && typeof je[0] == "string") for (Ie = 0; Ie < He.length; Ie += 1) { for (sn[qe = He[Ie]] = Oe.map(function (We) { return We[qe] }), this.setFont(void 0, "bold"), St.push(this.getTextDimensions(Ge[Ie], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w), Fe = sn[qe], this.setFont(void 0, "normal"), ze = 0; ze < Fe.length; ze += 1)St.push(this.getTextDimensions(Fe[ze], { fontSize: this.internal.__cell__.table_font_size, scaleFactor: this.internal.scaleFactor }).w); Xe[qe] = Math.max.apply(null, St) + En + En, St = [] } if (bn) { var In = {}; for (Ie = 0; Ie < He.length; Ie += 1)In[He[Ie]] = {}, In[He[Ie]].text = Ge[Ie], In[He[Ie]].align = Ze[Ie]; var xn = Me.call(this, In, Xe); un = He.map(function (We) { return new Re(De, Pe, Xe[We], xn, In[We].text, void 0, In[We].align) }), this.setTableHeaderRow(un), this.printHeaderRow(1, !1) } var vn = je.reduce(function (We, dn) { return We[dn.name] = dn.align, We }, {}); for (Ie = 0; Ie < Oe.length; Ie += 1) { "rowStart" in Be && Be.rowStart instanceof Function && Be.rowStart({ row: Ie, data: Oe[Ie] }, this); var tn = Me.call(this, Oe[Ie], Xe); for (ze = 0; ze < He.length; ze += 1) { var nn = Oe[Ie][He[ze]]; "cellStart" in Be && Be.cellStart instanceof Function && Be.cellStart({ row: Ie, col: ze, data: nn }, this), Ce.call(this, new Re(De, Pe, Xe[He[ze]], tn, nn, Ie + 2, vn[He[ze]])) } } return this.internal.__cell__.table_x = De, this.internal.__cell__.table_y = Pe, this }; var Me = function (De, Pe) { var Oe = this.internal.__cell__.padding, je = this.internal.__cell__.table_font_size, Be = this.internal.scaleFactor; return Object.keys(De).map(function (Ie) { var Fe = De[Ie]; return this.splitTextToSize(Fe.hasOwnProperty("text") ? Fe.text : Fe, Pe[Ie] - Oe - Oe) }, this).map(function (Ie) { return this.getLineHeightFactor() * Ie.length * je / Be + Oe + Oe }, this).reduce(function (Ie, Fe) { return Math.max(Ie, Fe) }, 0) }; e.setTableHeaderRow = function (De) { Ee.call(this), this.internal.__cell__.tableHeaderRow = De }, e.printHeaderRow = function (De, Pe) { if (Ee.call(this), !this.internal.__cell__.tableHeaderRow) throw new Error("Property tableHeaderRow does not exist."); var Oe; if (xe = !0, typeof this.internal.__cell__.headerFunction == "function") { var je = this.internal.__cell__.headerFunction(this, this.internal.__cell__.pages); this.internal.__cell__.lastCell = new Re(je[0], je[1], je[2], je[3], void 0, -1) } this.setFont(void 0, "bold"); for (var Be = [], Ie = 0; Ie < this.internal.__cell__.tableHeaderRow.length; Ie += 1) { Oe = this.internal.__cell__.tableHeaderRow[Ie].clone(), Pe && (Oe.y = this.internal.__cell__.margins.top || 0, Be.push(Oe)), Oe.lineNumber = De; var Fe = this.getTextColor(); this.setTextColor(this.internal.__cell__.headerTextColor), this.setFillColor(this.internal.__cell__.headerBackgroundColor), Ce.call(this, Oe), this.setTextColor(Fe) } Be.length > 0 && this.setTableHeaderRow(Be), this.setFont(void 0, "normal"), xe = !1 } }(E.API); var Pt = { italic: ["italic", "oblique", "normal"], oblique: ["oblique", "italic", "normal"], normal: ["normal", "oblique", "italic"] }, kt = ["ultra-condensed", "extra-condensed", "condensed", "semi-condensed", "normal", "semi-expanded", "expanded", "extra-expanded", "ultra-expanded"], It = _t(kt), Ft = [100, 200, 300, 400, 500, 600, 700, 800, 900], Ct = _t(Ft); function jt(e) { var t = e.family.replace(/"|'/g, "").toLowerCase(), xe = function (Re) { return Pt[Re = Re || "normal"] ? Re : "normal" }(e.style), Ee = function (Re) { if (!Re) return 400; if (typeof Re == "number") return Re >= 100 && Re <= 900 && Re % 100 == 0 ? Re : 400; if (/^\d00$/.test(Re)) return parseInt(Re); switch (Re) { case "bold": return 700; case "normal": default: return 400 } }(e.weight), _e = function (Re) { return typeof It[Re = Re || "normal"] == "number" ? Re : "normal" }(e.stretch); return { family: t, style: xe, weight: Ee, stretch: _e, src: e.src || [], ref: e.ref || { name: t, style: [_e, xe, Ee].join(" ") } } } function Ot(e, t, xe, Ee) { var _e; for (_e = xe; _e >= 0 && _e < t.length; _e += Ee)if (e[t[_e]]) return e[t[_e]]; for (_e = xe; _e >= 0 && _e < t.length; _e -= Ee)if (e[t[_e]]) return e[t[_e]] } var Bt = { "sans-serif": "helvetica", fixed: "courier", monospace: "courier", terminal: "courier", cursive: "times", fantasy: "times", serif: "times" }, Mt = { caption: "times", icon: "times", menu: "times", "message-box": "times", "small-caption": "times", "status-bar": "times" }; function Et(e) { return [e.stretch, e.style, e.weight, e.family].join(" ") } function qt(e, t, xe) { for (var Ee = (xe = xe || {}).defaultFontFamily || "times", _e = Object.assign({}, Bt, xe.genericFontFamilies || {}), Re = null, Ce = null, Me = 0; Me < t.length; ++Me)if (_e[(Re = jt(t[Me])).family] && (Re.family = _e[Re.family]), e.hasOwnProperty(Re.family)) { Ce = e[Re.family]; break } if (!(Ce = Ce || e[Ee])) throw new Error("Could not find a font-family for the rule '" + Et(Re) + "' and default family '" + Ee + "'."); if (Ce = function (De, Pe) { if (Pe[De]) return Pe[De]; var Oe = It[De], je = Oe <= It.normal ? -1 : 1, Be = Ot(Pe, kt, Oe, je); if (!Be) throw new Error("Could not find a matching font-stretch value for " + De); return Be }(Re.stretch, Ce), Ce = function (De, Pe) { if (Pe[De]) return Pe[De]; for (var Oe = Pt[De], je = 0; je < Oe.length; ++je)if (Pe[Oe[je]]) return Pe[Oe[je]]; throw new Error("Could not find a matching font-style for " + De) }(Re.style, Ce), !(Ce = function (De, Pe) { if (Pe[De]) return Pe[De]; if (De === 400 && Pe[500]) return Pe[500]; if (De === 500 && Pe[400]) return Pe[400]; var Oe = Ct[De], je = Ot(Pe, Ft, Oe, De < 400 ? -1 : 1); if (!je) throw new Error("Could not find a matching font-weight for value " + De); return je }(Re.weight, Ce))) throw new Error("Failed to resolve a font for the rule '" + Et(Re) + "'."); return Ce } function Dt(e) { return e.trimLeft() } function Rt(e, t) { for (var xe = 0; xe < e.length;) { if (e.charAt(xe) === t) return [e.substring(0, xe), e.substring(xe + 1)]; xe += 1 } return null } function Tt(e) { var t = e.match(/^(-[a-z_]|[a-z_])[a-z0-9_-]*/i); return t === null ? null : [t[0], e.substring(t[0].length)] } var Ut, zt, Ht, Wt = ["times"]; (function (e) { var t, xe, Ee, _e, Re, Ce, Me, De, Pe, Oe = function (Je) { return Je = Je || {}, this.isStrokeTransparent = Je.isStrokeTransparent || !1, this.strokeOpacity = Je.strokeOpacity || 1, this.strokeStyle = Je.strokeStyle || "#000000", this.fillStyle = Je.fillStyle || "#000000", this.isFillTransparent = Je.isFillTransparent || !1, this.fillOpacity = Je.fillOpacity || 1, this.font = Je.font || "10px sans-serif", this.textBaseline = Je.textBaseline || "alphabetic", this.textAlign = Je.textAlign || "left", this.lineWidth = Je.lineWidth || 1, this.lineJoin = Je.lineJoin || "miter", this.lineCap = Je.lineCap || "butt", this.path = Je.path || [], this.transform = Je.transform !== void 0 ? Je.transform.clone() : new De, this.globalCompositeOperation = Je.globalCompositeOperation || "normal", this.globalAlpha = Je.globalAlpha || 1, this.clip_path = Je.clip_path || [], this.currentPoint = Je.currentPoint || new Ce, this.miterLimit = Je.miterLimit || 10, this.lastPoint = Je.lastPoint || new Ce, this.lineDashOffset = Je.lineDashOffset || 0, this.lineDash = Je.lineDash || [], this.margin = Je.margin || [0, 0, 0, 0], this.prevPageLastElemOffset = Je.prevPageLastElemOffset || 0, this.ignoreClearRect = typeof Je.ignoreClearRect != "boolean" || Je.ignoreClearRect, this }; e.events.push(["initialized", function () { this.context2d = new je(this), t = this.internal.f2, xe = this.internal.getCoordinateString, Ee = this.internal.getVerticalCoordinateString, _e = this.internal.getHorizontalCoordinate, Re = this.internal.getVerticalCoordinate, Ce = this.internal.Point, Me = this.internal.Rectangle, De = this.internal.Matrix, Pe = new Oe }]); var je = function (Je) { Object.defineProperty(this, "canvas", { get: function () { return { parentNode: !1, style: !1 } } }); var rn = Je; Object.defineProperty(this, "pdf", { get: function () { return rn } }); var hn = !1; Object.defineProperty(this, "pageWrapXEnabled", { get: function () { return hn }, set: function (Fn) { hn = !!Fn } }); var mn = !1; Object.defineProperty(this, "pageWrapYEnabled", { get: function () { return mn }, set: function (Fn) { mn = !!Fn } }); var Ye = 0; Object.defineProperty(this, "posX", { get: function () { return Ye }, set: function (Fn) { isNaN(Fn) || (Ye = Fn) } }); var an = 0; Object.defineProperty(this, "posY", { get: function () { return an }, set: function (Fn) { isNaN(Fn) || (an = Fn) } }), Object.defineProperty(this, "margin", { get: function () { return Pe.margin }, set: function (Fn) { var Cn; typeof Fn == "number" ? Cn = [Fn, Fn, Fn, Fn] : ((Cn = new Array(4))[0] = Fn[0], Cn[1] = Fn.length >= 2 ? Fn[1] : Cn[0], Cn[2] = Fn.length >= 3 ? Fn[2] : Cn[0], Cn[3] = Fn.length >= 4 ? Fn[3] : Cn[1]), Pe.margin = Cn } }); var pn = !1; Object.defineProperty(this, "autoPaging", { get: function () { return pn }, set: function (Fn) { pn = Fn } }); var yn = 0; Object.defineProperty(this, "lastBreak", { get: function () { return yn }, set: function (Fn) { yn = Fn } }); var _n = []; Object.defineProperty(this, "pageBreaks", { get: function () { return _n }, set: function (Fn) { _n = Fn } }), Object.defineProperty(this, "ctx", { get: function () { return Pe }, set: function (Fn) { Fn instanceof Oe && (Pe = Fn) } }), Object.defineProperty(this, "path", { get: function () { return Pe.path }, set: function (Fn) { Pe.path = Fn } }); var On = []; Object.defineProperty(this, "ctxStack", { get: function () { return On }, set: function (Fn) { On = Fn } }), Object.defineProperty(this, "fillStyle", { get: function () { return this.ctx.fillStyle }, set: function (Fn) { var Cn; Cn = Be(Fn), this.ctx.fillStyle = Cn.style, this.ctx.isFillTransparent = Cn.a === 0, this.ctx.fillOpacity = Cn.a, this.pdf.setFillColor(Cn.r, Cn.g, Cn.b, { a: Cn.a }), this.pdf.setTextColor(Cn.r, Cn.g, Cn.b, { a: Cn.a }) } }), Object.defineProperty(this, "strokeStyle", { get: function () { return this.ctx.strokeStyle }, set: function (Fn) { var Cn = Be(Fn); this.ctx.strokeStyle = Cn.style, this.ctx.isStrokeTransparent = Cn.a === 0, this.ctx.strokeOpacity = Cn.a, Cn.a === 0 ? this.pdf.setDrawColor(255, 255, 255) : (Cn.a, this.pdf.setDrawColor(Cn.r, Cn.g, Cn.b)) } }), Object.defineProperty(this, "lineCap", { get: function () { return this.ctx.lineCap }, set: function (Fn) { ["butt", "round", "square"].indexOf(Fn) !== -1 && (this.ctx.lineCap = Fn, this.pdf.setLineCap(Fn)) } }), Object.defineProperty(this, "lineWidth", { get: function () { return this.ctx.lineWidth }, set: function (Fn) { isNaN(Fn) || (this.ctx.lineWidth = Fn, this.pdf.setLineWidth(Fn)) } }), Object.defineProperty(this, "lineJoin", { get: function () { return this.ctx.lineJoin }, set: function (Fn) { ["bevel", "round", "miter"].indexOf(Fn) !== -1 && (this.ctx.lineJoin = Fn, this.pdf.setLineJoin(Fn)) } }), Object.defineProperty(this, "miterLimit", { get: function () { return this.ctx.miterLimit }, set: function (Fn) { isNaN(Fn) || (this.ctx.miterLimit = Fn, this.pdf.setMiterLimit(Fn)) } }), Object.defineProperty(this, "textBaseline", { get: function () { return this.ctx.textBaseline }, set: function (Fn) { this.ctx.textBaseline = Fn } }), Object.defineProperty(this, "textAlign", { get: function () { return this.ctx.textAlign }, set: function (Fn) { ["right", "end", "center", "left", "start"].indexOf(Fn) !== -1 && (this.ctx.textAlign = Fn) } }); var kn = null; function zn(Fn, Cn) { if (kn === null) { var Vn = function (Yn) { var qn = []; return Object.keys(Yn).forEach(function (rr) { Yn[rr].forEach(function (hr) { var ur = null; switch (hr) { case "bold": ur = { family: rr, weight: "bold" }; break; case "italic": ur = { family: rr, style: "italic" }; break; case "bolditalic": ur = { family: rr, weight: "bold", style: "italic" }; break; case "": case "normal": ur = { family: rr } }ur !== null && (ur.ref = { name: rr, style: hr }, qn.push(ur)) }) }), qn }(Fn.getFontList()); kn = function (Yn) { for (var qn = {}, rr = 0; rr < Yn.length; ++rr) { var hr = jt(Yn[rr]), ur = hr.family, Er = hr.stretch, _r = hr.style, Or = hr.weight; qn[ur] = qn[ur] || {}, qn[ur][Er] = qn[ur][Er] || {}, qn[ur][Er][_r] = qn[ur][Er][_r] || {}, qn[ur][Er][_r][Or] = hr } return qn }(Vn.concat(Cn)) } return kn } var sr = null; Object.defineProperty(this, "fontFaces", { get: function () { return sr }, set: function (Fn) { kn = null, sr = Fn } }), Object.defineProperty(this, "font", { get: function () { return this.ctx.font }, set: function (Fn) { var Cn; if (this.ctx.font = Fn, (Cn = /^\s*(?=(?:(?:[-a-z]+\s*){0,2}(italic|oblique))?)(?=(?:(?:[-a-z]+\s*){0,2}(small-caps))?)(?=(?:(?:[-a-z]+\s*){0,2}(bold(?:er)?|lighter|[1-9]00))?)(?:(?:normal|\1|\2|\3)\s*){0,3}((?:xx?-)?(?:small|large)|medium|smaller|larger|[.\d]+(?:\%|in|[cem]m|ex|p[ctx]))(?:\s*\/\s*(normal|[.\d]+(?:\%|in|[cem]m|ex|p[ctx])))?\s*([-_,\"\'\sa-z]+?)\s*$/i.exec(Fn)) !== null) { var Vn = Cn[1]; Cn[2]; var Yn = Cn[3], qn = Cn[4]; Cn[5]; var rr = Cn[6], hr = /^([.\d]+)((?:%|in|[cem]m|ex|p[ctx]))$/i.exec(qn)[2]; qn = Math.floor(hr === "px" ? parseFloat(qn) * this.pdf.internal.scaleFactor : hr === "em" ? parseFloat(qn) * this.pdf.getFontSize() : parseFloat(qn) * this.pdf.internal.scaleFactor), this.pdf.setFontSize(qn); var ur = function (Cr) { var zr, Tr, wi = [], Jr = Cr.trim(); if (Jr === "") return Wt; if (Jr in Mt) return [Mt[Jr]]; for (; Jr !== "";) { switch (Tr = null, zr = (Jr = Dt(Jr)).charAt(0)) { case '"': case "'": Tr = Rt(Jr.substring(1), zr); break; default: Tr = Tt(Jr) }if (Tr === null || (wi.push(Tr[0]), (Jr = Dt(Tr[1])) !== "" && Jr.charAt(0) !== ",")) return Wt; Jr = Jr.replace(/^,/, "") } return wi }(rr); if (this.fontFaces) { var Er = qt(zn(this.pdf, this.fontFaces), ur.map(function (Cr) { return { family: Cr, stretch: "normal", weight: Yn, style: Vn } })); this.pdf.setFont(Er.ref.name, Er.ref.style) } else { var _r = ""; (Yn === "bold" || parseInt(Yn, 10) >= 700 || Vn === "bold") && (_r = "bold"), Vn === "italic" && (_r += "italic"), _r.length === 0 && (_r = "normal"); for (var Or = "", Ir = { arial: "Helvetica", Arial: "Helvetica", verdana: "Helvetica", Verdana: "Helvetica", helvetica: "Helvetica", Helvetica: "Helvetica", "sans-serif": "Helvetica", fixed: "Courier", monospace: "Courier", terminal: "Courier", cursive: "Times", fantasy: "Times", serif: "Times" }, Dr = 0; Dr < ur.length; Dr++) { if (this.pdf.internal.getFont(ur[Dr], _r, { noFallback: !0, disableWarning: !0 }) !== void 0) { Or = ur[Dr]; break } if (_r === "bolditalic" && this.pdf.internal.getFont(ur[Dr], "bold", { noFallback: !0, disableWarning: !0 }) !== void 0) Or = ur[Dr], _r = "bold"; else if (this.pdf.internal.getFont(ur[Dr], "normal", { noFallback: !0, disableWarning: !0 }) !== void 0) { Or = ur[Dr], _r = "normal"; break } } if (Or === "") { for (var Wr = 0; Wr < ur.length; Wr++)if (Ir[ur[Wr]]) { Or = Ir[ur[Wr]]; break } } Or = Or === "" ? "Times" : Or, this.pdf.setFont(Or, _r) } } } }), Object.defineProperty(this, "globalCompositeOperation", { get: function () { return this.ctx.globalCompositeOperation }, set: function (Fn) { this.ctx.globalCompositeOperation = Fn } }), Object.defineProperty(this, "globalAlpha", { get: function () { return this.ctx.globalAlpha }, set: function (Fn) { this.ctx.globalAlpha = Fn } }), Object.defineProperty(this, "lineDashOffset", { get: function () { return this.ctx.lineDashOffset }, set: function (Fn) { this.ctx.lineDashOffset = Fn, dn.call(this) } }), Object.defineProperty(this, "lineDash", { get: function () { return this.ctx.lineDash }, set: function (Fn) { this.ctx.lineDash = Fn, dn.call(this) } }), Object.defineProperty(this, "ignoreClearRect", { get: function () { return this.ctx.ignoreClearRect }, set: function (Fn) { this.ctx.ignoreClearRect = !!Fn } }) }; je.prototype.setLineDash = function (Je) { this.lineDash = Je }, je.prototype.getLineDash = function () { return this.lineDash.length % 2 ? this.lineDash.concat(this.lineDash) : this.lineDash.slice() }, je.prototype.fill = function () { sn.call(this, "fill", !1) }, je.prototype.stroke = function () { sn.call(this, "stroke", !1) }, je.prototype.beginPath = function () { this.path = [{ type: "begin" }] }, je.prototype.moveTo = function (Je, rn) { if (isNaN(Je) || isNaN(rn)) throw a.error("jsPDF.context2d.moveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.moveTo"); var hn = this.ctx.transform.applyToPoint(new Ce(Je, rn)); this.path.push({ type: "mt", x: hn.x, y: hn.y }), this.ctx.lastPoint = new Ce(Je, rn) }, je.prototype.closePath = function () { var Je = new Ce(0, 0), rn = 0; for (rn = this.path.length - 1; rn !== -1; rn--)if (this.path[rn].type === "begin" && _typeof(this.path[rn + 1]) === "object" && typeof this.path[rn + 1].x == "number") { Je = new Ce(this.path[rn + 1].x, this.path[rn + 1].y); break } this.path.push({ type: "close" }), this.ctx.lastPoint = new Ce(Je.x, Je.y) }, je.prototype.lineTo = function (Je, rn) { if (isNaN(Je) || isNaN(rn)) throw a.error("jsPDF.context2d.lineTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.lineTo"); var hn = this.ctx.transform.applyToPoint(new Ce(Je, rn)); this.path.push({ type: "lt", x: hn.x, y: hn.y }), this.ctx.lastPoint = new Ce(hn.x, hn.y) }, je.prototype.clip = function () { this.ctx.clip_path = JSON.parse(JSON.stringify(this.path)), sn.call(this, null, !0) }, je.prototype.quadraticCurveTo = function (Je, rn, hn, mn) { if (isNaN(hn) || isNaN(mn) || isNaN(Je) || isNaN(rn)) throw a.error("jsPDF.context2d.quadraticCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.quadraticCurveTo"); var Ye = this.ctx.transform.applyToPoint(new Ce(hn, mn)), an = this.ctx.transform.applyToPoint(new Ce(Je, rn)); this.path.push({ type: "qct", x1: an.x, y1: an.y, x: Ye.x, y: Ye.y }), this.ctx.lastPoint = new Ce(Ye.x, Ye.y) }, je.prototype.bezierCurveTo = function (Je, rn, hn, mn, Ye, an) { if (isNaN(Ye) || isNaN(an) || isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn)) throw a.error("jsPDF.context2d.bezierCurveTo: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.bezierCurveTo"); var pn = this.ctx.transform.applyToPoint(new Ce(Ye, an)), yn = this.ctx.transform.applyToPoint(new Ce(Je, rn)), _n = this.ctx.transform.applyToPoint(new Ce(hn, mn)); this.path.push({ type: "bct", x1: yn.x, y1: yn.y, x2: _n.x, y2: _n.y, x: pn.x, y: pn.y }), this.ctx.lastPoint = new Ce(pn.x, pn.y) }, je.prototype.arc = function (Je, rn, hn, mn, Ye, an) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn) || isNaN(Ye)) throw a.error("jsPDF.context2d.arc: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.arc"); if (an = !!an, !this.ctx.transform.isIdentity) { var pn = this.ctx.transform.applyToPoint(new Ce(Je, rn)); Je = pn.x, rn = pn.y; var yn = this.ctx.transform.applyToPoint(new Ce(0, hn)), _n = this.ctx.transform.applyToPoint(new Ce(0, 0)); hn = Math.sqrt(Math.pow(yn.x - _n.x, 2) + Math.pow(yn.y - _n.y, 2)) } Math.abs(Ye - mn) >= 2 * Math.PI && (mn = 0, Ye = 2 * Math.PI), this.path.push({ type: "arc", x: Je, y: rn, radius: hn, startAngle: mn, endAngle: Ye, counterclockwise: an }) }, je.prototype.arcTo = function (Je, rn, hn, mn, Ye) { throw new Error("arcTo not implemented.") }, je.prototype.rect = function (Je, rn, hn, mn) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn)) throw a.error("jsPDF.context2d.rect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rect"); this.moveTo(Je, rn), this.lineTo(Je + hn, rn), this.lineTo(Je + hn, rn + mn), this.lineTo(Je, rn + mn), this.lineTo(Je, rn), this.lineTo(Je + hn, rn), this.lineTo(Je, rn) }, je.prototype.fillRect = function (Je, rn, hn, mn) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn)) throw a.error("jsPDF.context2d.fillRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillRect"); if (!Ie.call(this)) { var Ye = {}; this.lineCap !== "butt" && (Ye.lineCap = this.lineCap, this.lineCap = "butt"), this.lineJoin !== "miter" && (Ye.lineJoin = this.lineJoin, this.lineJoin = "miter"), this.beginPath(), this.rect(Je, rn, hn, mn), this.fill(), Ye.hasOwnProperty("lineCap") && (this.lineCap = Ye.lineCap), Ye.hasOwnProperty("lineJoin") && (this.lineJoin = Ye.lineJoin) } }, je.prototype.strokeRect = function (Je, rn, hn, mn) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn)) throw a.error("jsPDF.context2d.strokeRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeRect"); Fe.call(this) || (this.beginPath(), this.rect(Je, rn, hn, mn), this.stroke()) }, je.prototype.clearRect = function (Je, rn, hn, mn) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn)) throw a.error("jsPDF.context2d.clearRect: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.clearRect"); this.ignoreClearRect || (this.fillStyle = "#ffffff", this.fillRect(Je, rn, hn, mn)) }, je.prototype.save = function (Je) { Je = typeof Je != "boolean" || Je; for (var rn = this.pdf.internal.getCurrentPageInfo().pageNumber, hn = 0; hn < this.pdf.internal.getNumberOfPages(); hn++)this.pdf.setPage(hn + 1), this.pdf.internal.out("q"); if (this.pdf.setPage(rn), Je) { this.ctx.fontSize = this.pdf.internal.getFontSize(); var mn = new Oe(this.ctx); this.ctxStack.push(this.ctx), this.ctx = mn } }, je.prototype.restore = function (Je) { Je = typeof Je != "boolean" || Je; for (var rn = this.pdf.internal.getCurrentPageInfo().pageNumber, hn = 0; hn < this.pdf.internal.getNumberOfPages(); hn++)this.pdf.setPage(hn + 1), this.pdf.internal.out("Q"); this.pdf.setPage(rn), Je && this.ctxStack.length !== 0 && (this.ctx = this.ctxStack.pop(), this.fillStyle = this.ctx.fillStyle, this.strokeStyle = this.ctx.strokeStyle, this.font = this.ctx.font, this.lineCap = this.ctx.lineCap, this.lineWidth = this.ctx.lineWidth, this.lineJoin = this.ctx.lineJoin, this.lineDash = this.ctx.lineDash, this.lineDashOffset = this.ctx.lineDashOffset) }, je.prototype.toDataURL = function () { throw new Error("toDataUrl not implemented.") }; var Be = function (Je) { var rn, hn, mn, Ye; if (Je.isCanvasGradient === !0 && (Je = Je.getColor()), !Je) return { r: 0, g: 0, b: 0, a: 0, style: Je }; if (/transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/.test(Je)) rn = 0, hn = 0, mn = 0, Ye = 0; else { var an = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/.exec(Je); if (an !== null) rn = parseInt(an[1]), hn = parseInt(an[2]), mn = parseInt(an[3]), Ye = 1; else if ((an = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d.]+)\s*\)/.exec(Je)) !== null) rn = parseInt(an[1]), hn = parseInt(an[2]), mn = parseInt(an[3]), Ye = parseFloat(an[4]); else { if (Ye = 1, typeof Je == "string" && Je.charAt(0) !== "#") { var pn = new f(Je); Je = pn.ok ? pn.toHex() : "#000000" } Je.length === 4 ? (rn = Je.substring(1, 2), rn += rn, hn = Je.substring(2, 3), hn += hn, mn = Je.substring(3, 4), mn += mn) : (rn = Je.substring(1, 3), hn = Je.substring(3, 5), mn = Je.substring(5, 7)), rn = parseInt(rn, 16), hn = parseInt(hn, 16), mn = parseInt(mn, 16) } } return { r: rn, g: hn, b: mn, a: Ye, style: Je } }, Ie = function () { return this.ctx.isFillTransparent || this.globalAlpha == 0 }, Fe = function () { return !!(this.ctx.isStrokeTransparent || this.globalAlpha == 0) }; je.prototype.fillText = function (Je, rn, hn, mn) { if (isNaN(rn) || isNaN(hn) || typeof Je != "string") throw a.error("jsPDF.context2d.fillText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.fillText"); if (mn = isNaN(mn) ? void 0 : mn, !Ie.call(this)) { var Ye = tn(this.ctx.transform.rotation), an = this.ctx.transform.scaleX; En.call(this, { text: Je, x: rn, y: hn, scale: an, angle: Ye, align: this.textAlign, maxWidth: mn }) } }, je.prototype.strokeText = function (Je, rn, hn, mn) { if (isNaN(rn) || isNaN(hn) || typeof Je != "string") throw a.error("jsPDF.context2d.strokeText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.strokeText"); if (!Fe.call(this)) { mn = isNaN(mn) ? void 0 : mn; var Ye = tn(this.ctx.transform.rotation), an = this.ctx.transform.scaleX; En.call(this, { text: Je, x: rn, y: hn, scale: an, renderingMode: "stroke", angle: Ye, align: this.textAlign, maxWidth: mn }) } }, je.prototype.measureText = function (Je) { if (typeof Je != "string") throw a.error("jsPDF.context2d.measureText: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.measureText"); var rn = this.pdf, hn = this.pdf.internal.scaleFactor, mn = rn.internal.getFontSize(), Ye = rn.getStringUnitWidth(Je) * mn / rn.internal.scaleFactor, an = function (pn) { var yn = (pn = pn || {}).width || 0; return Object.defineProperty(this, "width", { get: function () { return yn } }), this }; return new an({ width: Ye *= Math.round(96 * hn / 72 * 1e4) / 1e4 }) }, je.prototype.scale = function (Je, rn) { if (isNaN(Je) || isNaN(rn)) throw a.error("jsPDF.context2d.scale: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.scale"); var hn = new De(Je, 0, 0, rn, 0, 0); this.ctx.transform = this.ctx.transform.multiply(hn) }, je.prototype.rotate = function (Je) { if (isNaN(Je)) throw a.error("jsPDF.context2d.rotate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.rotate"); var rn = new De(Math.cos(Je), Math.sin(Je), -Math.sin(Je), Math.cos(Je), 0, 0); this.ctx.transform = this.ctx.transform.multiply(rn) }, je.prototype.translate = function (Je, rn) { if (isNaN(Je) || isNaN(rn)) throw a.error("jsPDF.context2d.translate: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.translate"); var hn = new De(1, 0, 0, 1, Je, rn); this.ctx.transform = this.ctx.transform.multiply(hn) }, je.prototype.transform = function (Je, rn, hn, mn, Ye, an) { if (isNaN(Je) || isNaN(rn) || isNaN(hn) || isNaN(mn) || isNaN(Ye) || isNaN(an)) throw a.error("jsPDF.context2d.transform: Invalid arguments", arguments), new Error("Invalid arguments passed to jsPDF.context2d.transform"); var pn = new De(Je, rn, hn, mn, Ye, an); this.ctx.transform = this.ctx.transform.multiply(pn) }, je.prototype.setTransform = function (Je, rn, hn, mn, Ye, an) { Je = isNaN(Je) ? 1 : Je, rn = isNaN(rn) ? 0 : rn, hn = isNaN(hn) ? 0 : hn, mn = isNaN(mn) ? 1 : mn, Ye = isNaN(Ye) ? 0 : Ye, an = isNaN(an) ? 0 : an, this.ctx.transform = new De(Je, rn, hn, mn, Ye, an) }; var ze = function () { return this.margin[0] > 0 || this.margin[1] > 0 || this.margin[2] > 0 || this.margin[3] > 0 }; je.prototype.drawImage = function (Je, rn, hn, mn, Ye, an, pn, yn, _n) { var On = this.pdf.getImageProperties(Je), kn = 1, zn = 1, sr = 1, Fn = 1; mn !== void 0 && yn !== void 0 && (sr = yn / mn, Fn = _n / Ye, kn = On.width / mn * yn / mn, zn = On.height / Ye * _n / Ye), an === void 0 && (an = rn, pn = hn, rn = 0, hn = 0), mn !== void 0 && yn === void 0 && (yn = mn, _n = Ye), mn === void 0 && yn === void 0 && (yn = On.width, _n = On.height); for (var Cn, Vn = this.ctx.transform.decompose(), Yn = tn(Vn.rotate.shx), qn = new De, rr = (qn = (qn = (qn = qn.multiply(Vn.translate)).multiply(Vn.skew)).multiply(Vn.scale)).applyToRectangle(new Me(an - rn * sr, pn - hn * Fn, mn * kn, Ye * zn)), hr = qe.call(this, rr), ur = [], Er = 0; Er < hr.length; Er += 1)ur.indexOf(hr[Er]) === -1 && ur.push(hr[Er]); if (Ze(ur), this.autoPaging) for (var _r = ur[0], Or = ur[ur.length - 1], Ir = _r; Ir < Or + 1; Ir++) { this.pdf.setPage(Ir); var Dr = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Wr = Ir === 1 ? this.posY + this.margin[0] : this.margin[0], Cr = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], zr = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Tr = Ir === 1 ? 0 : Cr + (Ir - 2) * zr; if (this.ctx.clip_path.length !== 0) { var wi = this.path; Cn = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Ge(Cn, this.posX + this.margin[3], -Tr + Wr + this.ctx.prevPageLastElemOffset), Xe.call(this, "fill", !0), this.path = wi } var Jr = JSON.parse(JSON.stringify(rr)); Jr = Ge([Jr], this.posX + this.margin[3], -Tr + Wr + this.ctx.prevPageLastElemOffset)[0]; var mr = (Ir > _r || Ir < Or) && ze.call(this); mr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Dr, zr, null).clip().discardPath()), this.pdf.addImage(Je, "JPEG", Jr.x, Jr.y, Jr.w, Jr.h, null, null, Yn), mr && this.pdf.restoreGraphicsState() } else this.pdf.addImage(Je, "JPEG", rr.x, rr.y, rr.w, rr.h, null, null, Yn) }; var qe = function (Je, rn, hn) { var mn = []; rn = rn || this.pdf.internal.pageSize.width, hn = hn || this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2]; var Ye = this.posY + this.ctx.prevPageLastElemOffset; switch (Je.type) { default: case "mt": case "lt": mn.push(Math.floor((Je.y + Ye) / hn) + 1); break; case "arc": mn.push(Math.floor((Je.y + Ye - Je.radius) / hn) + 1), mn.push(Math.floor((Je.y + Ye + Je.radius) / hn) + 1); break; case "qct": var an = nn(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Je.x1, Je.y1, Je.x, Je.y); mn.push(Math.floor((an.y + Ye) / hn) + 1), mn.push(Math.floor((an.y + an.h + Ye) / hn) + 1); break; case "bct": var pn = We(this.ctx.lastPoint.x, this.ctx.lastPoint.y, Je.x1, Je.y1, Je.x2, Je.y2, Je.x, Je.y); mn.push(Math.floor((pn.y + Ye) / hn) + 1), mn.push(Math.floor((pn.y + pn.h + Ye) / hn) + 1); break; case "rect": mn.push(Math.floor((Je.y + Ye) / hn) + 1), mn.push(Math.floor((Je.y + Je.h + Ye) / hn) + 1) }for (var yn = 0; yn < mn.length; yn += 1)for (; this.pdf.internal.getNumberOfPages() < mn[yn];)He.call(this); return mn }, He = function () { var Je = this.fillStyle, rn = this.strokeStyle, hn = this.font, mn = this.lineCap, Ye = this.lineWidth, an = this.lineJoin; this.pdf.addPage(), this.fillStyle = Je, this.strokeStyle = rn, this.font = hn, this.lineCap = mn, this.lineWidth = Ye, this.lineJoin = an }, Ge = function (Je, rn, hn) { for (var mn = 0; mn < Je.length; mn++)switch (Je[mn].type) { case "bct": Je[mn].x2 += rn, Je[mn].y2 += hn; case "qct": Je[mn].x1 += rn, Je[mn].y1 += hn; case "mt": case "lt": case "arc": default: Je[mn].x += rn, Je[mn].y += hn }return Je }, Ze = function (Je) { return Je.sort(function (rn, hn) { return rn - hn }) }, sn = function (Je, rn) { for (var hn, mn, Ye = this.fillStyle, an = this.strokeStyle, pn = this.lineCap, yn = this.lineWidth, _n = Math.abs(yn * this.ctx.transform.scaleX), On = this.lineJoin, kn = JSON.parse(JSON.stringify(this.path)), zn = JSON.parse(JSON.stringify(this.path)), sr = [], Fn = 0; Fn < zn.length; Fn++)if (zn[Fn].x !== void 0) for (var Cn = qe.call(this, zn[Fn]), Vn = 0; Vn < Cn.length; Vn += 1)sr.indexOf(Cn[Vn]) === -1 && sr.push(Cn[Vn]); for (var Yn = 0; Yn < sr.length; Yn++)for (; this.pdf.internal.getNumberOfPages() < sr[Yn];)He.call(this); if (Ze(sr), this.autoPaging) for (var qn = sr[0], rr = sr[sr.length - 1], hr = qn; hr < rr + 1; hr++) { this.pdf.setPage(hr), this.fillStyle = Ye, this.strokeStyle = an, this.lineCap = pn, this.lineWidth = _n, this.lineJoin = On; var ur = this.pdf.internal.pageSize.width - this.margin[3] - this.margin[1], Er = hr === 1 ? this.posY + this.margin[0] : this.margin[0], _r = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Or = this.pdf.internal.pageSize.height - this.margin[0] - this.margin[2], Ir = hr === 1 ? 0 : _r + (hr - 2) * Or; if (this.ctx.clip_path.length !== 0) { var Dr = this.path; hn = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Ge(hn, this.posX + this.margin[3], -Ir + Er + this.ctx.prevPageLastElemOffset), Xe.call(this, Je, !0), this.path = Dr } if (mn = JSON.parse(JSON.stringify(kn)), this.path = Ge(mn, this.posX + this.margin[3], -Ir + Er + this.ctx.prevPageLastElemOffset), rn === !1 || hr === 0) { var Wr = (hr > qn || hr < rr) && ze.call(this); Wr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], ur, Or, null).clip().discardPath()), Xe.call(this, Je, rn), Wr && this.pdf.restoreGraphicsState() } this.lineWidth = yn } else this.lineWidth = _n, Xe.call(this, Je, rn), this.lineWidth = yn; this.path = kn }, Xe = function (Je, rn) { if ((Je !== "stroke" || rn || !Fe.call(this)) && (Je === "stroke" || rn || !Ie.call(this))) { for (var hn, mn, Ye = [], an = this.path, pn = 0; pn < an.length; pn++) { var yn = an[pn]; switch (yn.type) { case "begin": Ye.push({ begin: !0 }); break; case "close": Ye.push({ close: !0 }); break; case "mt": Ye.push({ start: yn, deltas: [], abs: [] }); break; case "lt": var _n = Ye.length; if (an[pn - 1] && !isNaN(an[pn - 1].x) && (hn = [yn.x - an[pn - 1].x, yn.y - an[pn - 1].y], _n > 0)) { for (; _n >= 0; _n--)if (Ye[_n - 1].close !== !0 && Ye[_n - 1].begin !== !0) { Ye[_n - 1].deltas.push(hn), Ye[_n - 1].abs.push(yn); break } } break; case "bct": hn = [yn.x1 - an[pn - 1].x, yn.y1 - an[pn - 1].y, yn.x2 - an[pn - 1].x, yn.y2 - an[pn - 1].y, yn.x - an[pn - 1].x, yn.y - an[pn - 1].y], Ye[Ye.length - 1].deltas.push(hn); break; case "qct": var On = an[pn - 1].x + 2 / 3 * (yn.x1 - an[pn - 1].x), kn = an[pn - 1].y + 2 / 3 * (yn.y1 - an[pn - 1].y), zn = yn.x + 2 / 3 * (yn.x1 - yn.x), sr = yn.y + 2 / 3 * (yn.y1 - yn.y), Fn = yn.x, Cn = yn.y; hn = [On - an[pn - 1].x, kn - an[pn - 1].y, zn - an[pn - 1].x, sr - an[pn - 1].y, Fn - an[pn - 1].x, Cn - an[pn - 1].y], Ye[Ye.length - 1].deltas.push(hn); break; case "arc": Ye.push({ deltas: [], abs: [], arc: !0 }), Array.isArray(Ye[Ye.length - 1].abs) && Ye[Ye.length - 1].abs.push(yn) } } mn = rn ? null : Je === "stroke" ? "stroke" : "fill"; for (var Vn = !1, Yn = 0; Yn < Ye.length; Yn++)if (Ye[Yn].arc) for (var qn = Ye[Yn].abs, rr = 0; rr < qn.length; rr++) { var hr = qn[rr]; hr.type === "arc" ? on.call(this, hr.x, hr.y, hr.radius, hr.startAngle, hr.endAngle, hr.counterclockwise, void 0, rn, !Vn) : Pn.call(this, hr.x, hr.y), Vn = !0 } else if (Ye[Yn].close === !0) this.pdf.internal.out("h"), Vn = !1; else if (Ye[Yn].begin !== !0) { var ur = Ye[Yn].start.x, Er = Ye[Yn].start.y; Rn.call(this, Ye[Yn].deltas, ur, Er), Vn = !0 } mn && bn.call(this, mn), rn && Tn.call(this) } }, St = function (Je) { var rn = this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor, hn = rn * (this.pdf.internal.getLineHeightFactor() - 1); switch (this.ctx.textBaseline) { case "bottom": return Je - hn; case "top": return Je + rn - hn; case "hanging": return Je + rn - 2 * hn; case "middle": return Je + rn / 2 - hn; case "ideographic": return Je; case "alphabetic": default: return Je } }, un = function (Je) { return Je + this.pdf.internal.getFontSize() / this.pdf.internal.scaleFactor * (this.pdf.internal.getLineHeightFactor() - 1) }; je.prototype.createLinearGradient = function () { var Je = function () { }; return Je.colorStops = [], Je.addColorStop = function (rn, hn) { this.colorStops.push([rn, hn]) }, Je.getColor = function () { return this.colorStops.length === 0 ? "#000000" : this.colorStops[0][1] }, Je.isCanvasGradient = !0, Je }, je.prototype.createPattern = function () { return this.createLinearGradient() }, je.prototype.createRadialGradient = function () { return this.createLinearGradient() }; var on = function (Je, rn, hn, mn, Ye, an, pn, yn, _n) { for (var On = xn.call(this, hn, mn, Ye, an), kn = 0; kn < On.length; kn++) { var zn = On[kn]; kn === 0 && (_n ? fn.call(this, zn.x1 + Je, zn.y1 + rn) : Pn.call(this, zn.x1 + Je, zn.y1 + rn)), In.call(this, Je, rn, zn.x2, zn.y2, zn.x3, zn.y3, zn.x4, zn.y4) } yn ? Tn.call(this) : bn.call(this, pn) }, bn = function (Je) { switch (Je) { case "stroke": this.pdf.internal.out("S"); break; case "fill": this.pdf.internal.out("f") } }, Tn = function () { this.pdf.clip(), this.pdf.discardPath() }, fn = function (Je, rn) { this.pdf.internal.out(xe(Je) + " " + Ee(rn) + " m") }, En = function (Je) { var rn; switch (Je.align) { case "right": case "end": rn = "right"; break; case "center": rn = "center"; break; case "left": case "start": default: rn = "left" }var hn = this.pdf.getTextDimensions(Je.text), mn = St.call(this, Je.y), Ye = un.call(this, mn) - hn.h, an = this.ctx.transform.applyToPoint(new Ce(Je.x, mn)), pn = this.ctx.transform.decompose(), yn = new De; yn = (yn = (yn = yn.multiply(pn.translate)).multiply(pn.skew)).multiply(pn.scale); for (var _n, On, kn, zn = this.ctx.transform.applyToRectangle(new Me(Je.x, mn, hn.w, hn.h)), sr = yn.applyToRectangle(new Me(Je.x, Ye, hn.w, hn.h)), Fn = qe.call(this, sr), Cn = [], Vn = 0; Vn < Fn.length; Vn += 1)Cn.indexOf(Fn[Vn]) === -1 && Cn.push(Fn[Vn]); if (Ze(Cn), this.autoPaging) for (var Yn = Cn[0], qn = Cn[Cn.length - 1], rr = Yn; rr < qn + 1; rr++) { this.pdf.setPage(rr); var hr = rr === 1 ? this.posY + this.margin[0] : this.margin[0], ur = this.pdf.internal.pageSize.height - this.posY - this.margin[0] - this.margin[2], Er = this.pdf.internal.pageSize.height - this.margin[2], _r = Er - this.margin[0], Or = this.pdf.internal.pageSize.width - this.margin[1], Ir = Or - this.margin[3], Dr = rr === 1 ? 0 : ur + (rr - 2) * _r; if (this.ctx.clip_path.length !== 0) { var Wr = this.path; _n = JSON.parse(JSON.stringify(this.ctx.clip_path)), this.path = Ge(_n, this.posX + this.margin[3], -1 * Dr + hr), Xe.call(this, "fill", !0), this.path = Wr } var Cr = Ge([JSON.parse(JSON.stringify(sr))], this.posX + this.margin[3], -Dr + hr + this.ctx.prevPageLastElemOffset)[0]; Je.scale >= .01 && (On = this.pdf.internal.getFontSize(), this.pdf.setFontSize(On * Je.scale), kn = this.lineWidth, this.lineWidth = kn * Je.scale); var zr = this.autoPaging !== "text"; if (zr || Cr.y + Cr.h <= Er) { if (zr || Cr.y >= hr && Cr.x <= Or) { var Tr = zr ? Je.text : this.pdf.splitTextToSize(Je.text, Je.maxWidth || Or - Cr.x)[0], wi = Ge([JSON.parse(JSON.stringify(zn))], this.posX + this.margin[3], -Dr + hr + this.ctx.prevPageLastElemOffset)[0], Jr = zr && (rr > Yn || rr < qn) && ze.call(this); Jr && (this.pdf.saveGraphicsState(), this.pdf.rect(this.margin[3], this.margin[0], Ir, _r, null).clip().discardPath()), this.pdf.text(Tr, wi.x, wi.y, { angle: Je.angle, align: rn, renderingMode: Je.renderingMode }), Jr && this.pdf.restoreGraphicsState() } } else Cr.y < Er && (this.ctx.prevPageLastElemOffset += Er - Cr.y); Je.scale >= .01 && (this.pdf.setFontSize(On), this.lineWidth = kn) } else Je.scale >= .01 && (On = this.pdf.internal.getFontSize(), this.pdf.setFontSize(On * Je.scale), kn = this.lineWidth, this.lineWidth = kn * Je.scale), this.pdf.text(Je.text, an.x + this.posX, an.y + this.posY, { angle: Je.angle, align: rn, renderingMode: Je.renderingMode, maxWidth: Je.maxWidth }), Je.scale >= .01 && (this.pdf.setFontSize(On), this.lineWidth = kn) }, Pn = function (Je, rn, hn, mn) { hn = hn || 0, mn = mn || 0, this.pdf.internal.out(xe(Je + hn) + " " + Ee(rn + mn) + " l") }, Rn = function (Je, rn, hn) { return this.pdf.lines(Je, rn, hn, null, null) }, In = function (Je, rn, hn, mn, Ye, an, pn, yn) { this.pdf.internal.out([t(_e(hn + Je)), t(Re(mn + rn)), t(_e(Ye + Je)), t(Re(an + rn)), t(_e(pn + Je)), t(Re(yn + rn)), "c"].join(" ")) }, xn = function (Je, rn, hn, mn) { for (var Ye = 2 * Math.PI, an = Math.PI / 2; rn > hn;)rn -= Ye; var pn = Math.abs(hn - rn); pn < Ye && mn && (pn = Ye - pn); for (var yn = [], _n = mn ? -1 : 1, On = rn; pn > 1e-5;) { var kn = On + _n * Math.min(pn, an); yn.push(vn.call(this, Je, On, kn)), pn -= Math.abs(kn - On), On = kn } return yn }, vn = function (Je, rn, hn) { var mn = (hn - rn) / 2, Ye = Je * Math.cos(mn), an = Je * Math.sin(mn), pn = Ye, yn = -an, _n = pn * pn + yn * yn, On = _n + pn * Ye + yn * an, kn = 4 / 3 * (Math.sqrt(2 * _n * On) - On) / (pn * an - yn * Ye), zn = pn - kn * yn, sr = yn + kn * pn, Fn = zn, Cn = -sr, Vn = mn + rn, Yn = Math.cos(Vn), qn = Math.sin(Vn); return { x1: Je * Math.cos(rn), y1: Je * Math.sin(rn), x2: zn * Yn - sr * qn, y2: zn * qn + sr * Yn, x3: Fn * Yn - Cn * qn, y3: Fn * qn + Cn * Yn, x4: Je * Math.cos(hn), y4: Je * Math.sin(hn) } }, tn = function (Je) { return 180 * Je / Math.PI }, nn = function (Je, rn, hn, mn, Ye, an) { var pn = Je + .5 * (hn - Je), yn = rn + .5 * (mn - rn), _n = Ye + .5 * (hn - Ye), On = an + .5 * (mn - an), kn = Math.min(Je, Ye, pn, _n), zn = Math.max(Je, Ye, pn, _n), sr = Math.min(rn, an, yn, On), Fn = Math.max(rn, an, yn, On); return new Me(kn, sr, zn - kn, Fn - sr) }, We = function (Je, rn, hn, mn, Ye, an, pn, yn) { var _n, On, kn, zn, sr, Fn, Cn, Vn, Yn, qn, rr, hr, ur, Er, _r = hn - Je, Or = mn - rn, Ir = Ye - hn, Dr = an - mn, Wr = pn - Ye, Cr = yn - an; for (On = 0; On < 41; On++)Yn = (Cn = (kn = Je + (_n = On / 40) * _r) + _n * ((sr = hn + _n * Ir) - kn)) + _n * (sr + _n * (Ye + _n * Wr - sr) - Cn), qn = (Vn = (zn = rn + _n * Or) + _n * ((Fn = mn + _n * Dr) - zn)) + _n * (Fn + _n * (an + _n * Cr - Fn) - Vn), On == 0 ? (rr = Yn, hr = qn, ur = Yn, Er = qn) : (rr = Math.min(rr, Yn), hr = Math.min(hr, qn), ur = Math.max(ur, Yn), Er = Math.max(Er, qn)); return new Me(Math.round(rr), Math.round(hr), Math.round(ur - rr), Math.round(Er - hr)) }, dn = function () { if (this.prevLineDash || this.ctx.lineDash.length || this.ctx.lineDashOffset) { var Je, rn, hn = (Je = this.ctx.lineDash, rn = this.ctx.lineDashOffset, JSON.stringify({ lineDash: Je, lineDashOffset: rn })); this.prevLineDash !== hn && (this.pdf.setLineDash(this.ctx.lineDash, this.ctx.lineDashOffset), this.prevLineDash = hn) } } })(E.API), function (e) { var t = function (Re) { var Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze; for (Me = [], De = 0, Pe = (Re += Ce = "\0\0\0\0".slice(Re.length % 4 || 4)).length; Pe > De; De += 4)(Oe = (Re.charCodeAt(De) << 24) + (Re.charCodeAt(De + 1) << 16) + (Re.charCodeAt(De + 2) << 8) + Re.charCodeAt(De + 3)) !== 0 ? (je = (Oe = ((Oe = ((Oe = ((Oe = (Oe - (ze = Oe % 85)) / 85) - (Fe = Oe % 85)) / 85) - (Ie = Oe % 85)) / 85) - (Be = Oe % 85)) / 85) % 85, Me.push(je + 33, Be + 33, Ie + 33, Fe + 33, ze + 33)) : Me.push(122); return function (qe, He) { for (var Ge = He; Ge > 0; Ge--)qe.pop() }(Me, Ce.length), String.fromCharCode.apply(String, Me) + "~>" }, xe = function (Re) { var Ce, Me, De, Pe, Oe, je = String, Be = "length", Ie = 255, Fe = "charCodeAt", ze = "slice", qe = "replace"; for (Re[ze](-2), Re = Re[ze](0, -2)[qe](/\s/g, "")[qe]("z", "!!!!!"), De = [], Pe = 0, Oe = (Re += Ce = "uuuuu"[ze](Re[Be] % 5 || 5))[Be]; Oe > Pe; Pe += 5)Me = 52200625 * (Re[Fe](Pe) - 33) + 614125 * (Re[Fe](Pe + 1) - 33) + 7225 * (Re[Fe](Pe + 2) - 33) + 85 * (Re[Fe](Pe + 3) - 33) + (Re[Fe](Pe + 4) - 33), De.push(Ie & Me >> 24, Ie & Me >> 16, Ie & Me >> 8, Ie & Me); return function (He, Ge) { for (var Ze = Ge; Ze > 0; Ze--)He.pop() }(De, Ce[Be]), je.fromCharCode.apply(je, De) }, Ee = function (Re) { var Ce = new RegExp(/^([0-9A-Fa-f]{2})+$/); if ((Re = Re.replace(/\s/g, "")).indexOf(">") !== -1 && (Re = Re.substr(0, Re.indexOf(">"))), Re.length % 2 && (Re += "0"), Ce.test(Re) === !1) return ""; for (var Me = "", De = 0; De < Re.length; De += 2)Me += String.fromCharCode("0x" + (Re[De] + Re[De + 1])); return Me }, _e = function (Re) { for (var Ce = new Uint8Array(Re.length), Me = Re.length; Me--;)Ce[Me] = Re.charCodeAt(Me); return Re = (Ce = zlibSync(Ce)).reduce(function (De, Pe) { return De + String.fromCharCode(Pe) }, "") }; e.processDataByFilters = function (Re, Ce) { var Me = 0, De = Re || "", Pe = []; for (typeof (Ce = Ce || []) == "string" && (Ce = [Ce]), Me = 0; Me < Ce.length; Me += 1)switch (Ce[Me]) { case "ASCII85Decode": case "/ASCII85Decode": De = xe(De), Pe.push("/ASCII85Encode"); break; case "ASCII85Encode": case "/ASCII85Encode": De = t(De), Pe.push("/ASCII85Decode"); break; case "ASCIIHexDecode": case "/ASCIIHexDecode": De = Ee(De), Pe.push("/ASCIIHexEncode"); break; case "ASCIIHexEncode": case "/ASCIIHexEncode": De = De.split("").map(function (Oe) { return ("0" + Oe.charCodeAt().toString(16)).slice(-2) }).join("") + ">", Pe.push("/ASCIIHexDecode"); break; case "FlateEncode": case "/FlateEncode": De = _e(De), Pe.push("/FlateDecode"); break; default: throw new Error('The filter: "' + Ce[Me] + '" is not implemented') }return { data: De, reverseChain: Pe.reverse().join(" ") } } }(E.API), function (e) { e.loadFile = function (t, xe, Ee) { return function (_e, Re, Ce) { Re = Re !== !1, Ce = typeof Ce == "function" ? Ce : function () { }; var Me = void 0; try { Me = function (De, Pe, Oe) { var je = new XMLHttpRequest, Be = 0, Ie = function (Fe) { var ze = Fe.length, qe = [], He = String.fromCharCode; for (Be = 0; Be < ze; Be += 1)qe.push(He(255 & Fe.charCodeAt(Be))); return qe.join("") }; if (je.open("GET", De, !Pe), je.overrideMimeType("text/plain; charset=x-user-defined"), Pe === !1 && (je.onload = function () { je.status === 200 ? Oe(Ie(this.responseText)) : Oe(void 0) }), je.send(null), Pe && je.status === 200) return Ie(je.responseText) }(_e, Re, Ce) } catch { } return Me }(t, xe, Ee) }, e.loadImageFile = e.loadFile }(E.API), function (e) { function t() { return (n.html2canvas ? Promise.resolve(n.html2canvas) : __vitePreload(() => import("./html2canvas.esm-BfxBtG_O.js"), [])).catch(function (Ce) { return Promise.reject(new Error("Could not load html2canvas: " + Ce)) }).then(function (Ce) { return Ce.default ? Ce.default : Ce }) } function xe() { return (n.DOMPurify ? Promise.resolve(n.DOMPurify) : __vitePreload(() => import("./purify.es-CQJ0hv7W.js"), [])).catch(function (Ce) { return Promise.reject(new Error("Could not load dompurify: " + Ce)) }).then(function (Ce) { return Ce.default ? Ce.default : Ce }) } var Ee = function (Ce) { var Me = _typeof(Ce); return Me === "undefined" ? "undefined" : Me === "string" || Ce instanceof String ? "string" : Me === "number" || Ce instanceof Number ? "number" : Me === "function" || Ce instanceof Function ? "function" : Ce && Ce.constructor === Array ? "array" : Ce && Ce.nodeType === 1 ? "element" : Me === "object" ? "object" : "unknown" }, _e = function (Ce, Me) { var De = document.createElement(Ce); for (var Pe in Me.className && (De.className = Me.className), Me.innerHTML && Me.dompurify && (De.innerHTML = Me.dompurify.sanitize(Me.innerHTML)), Me.style) De.style[Pe] = Me.style[Pe]; return De }, Re = function Ce(Me) { var De = Object.assign(Ce.convert(Promise.resolve()), JSON.parse(JSON.stringify(Ce.template))), Pe = Ce.convert(Promise.resolve(), De); return Pe = (Pe = Pe.setProgress(1, Ce, 1, [Ce])).set(Me) }; (Re.prototype = Object.create(Promise.prototype)).constructor = Re, Re.convert = function (Ce, Me) { return Ce.__proto__ = Me || Re.prototype, Ce }, Re.template = { prop: { src: null, container: null, overlay: null, canvas: null, img: null, pdf: null, pageSize: null, callback: function () { } }, progress: { val: 0, state: null, n: 0, stack: [] }, opt: { filename: "file.pdf", margin: [0, 0, 0, 0], enableLinks: !0, x: 0, y: 0, html2canvas: {}, jsPDF: {}, backgroundColor: "transparent" } }, Re.prototype.from = function (Ce, Me) { return this.then(function () { switch (Me = Me || function (De) { switch (Ee(De)) { case "string": return "string"; case "element": return De.nodeName.toLowerCase() === "canvas" ? "canvas" : "element"; default: return "unknown" } }(Ce)) { case "string": return this.then(xe).then(function (De) { return this.set({ src: _e("div", { innerHTML: Ce, dompurify: De }) }) }); case "element": return this.set({ src: Ce }); case "canvas": return this.set({ canvas: Ce }); case "img": return this.set({ img: Ce }); default: return this.error("Unknown source type.") } }) }, Re.prototype.to = function (Ce) { switch (Ce) { case "container": return this.toContainer(); case "canvas": return this.toCanvas(); case "img": return this.toImg(); case "pdf": return this.toPdf(); default: return this.error("Invalid target.") } }, Re.prototype.toContainer = function () { return this.thenList([function () { return this.prop.src || this.error("Cannot duplicate - no source HTML.") }, function () { return this.prop.pageSize || this.setPageSize() }]).then(function () { var Ce = { position: "relative", display: "inline-block", width: (typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? Math.max(this.prop.src.clientWidth, this.prop.src.scrollWidth, this.prop.src.offsetWidth) : this.opt.windowWidth) + "px", left: 0, right: 0, top: 0, margin: "auto", backgroundColor: this.opt.backgroundColor }, Me = function De(Pe, Oe) { for (var je = Pe.nodeType === 3 ? document.createTextNode(Pe.nodeValue) : Pe.cloneNode(!1), Be = Pe.firstChild; Be; Be = Be.nextSibling)Oe !== !0 && Be.nodeType === 1 && Be.nodeName === "SCRIPT" || je.appendChild(De(Be, Oe)); return Pe.nodeType === 1 && (Pe.nodeName === "CANVAS" ? (je.width = Pe.width, je.height = Pe.height, je.getContext("2d").drawImage(Pe, 0, 0)) : Pe.nodeName !== "TEXTAREA" && Pe.nodeName !== "SELECT" || (je.value = Pe.value), je.addEventListener("load", function () { je.scrollTop = Pe.scrollTop, je.scrollLeft = Pe.scrollLeft }, !0)), je }(this.prop.src, this.opt.html2canvas.javascriptEnabled); Me.tagName === "BODY" && (Ce.height = Math.max(document.body.scrollHeight, document.body.offsetHeight, document.documentElement.clientHeight, document.documentElement.scrollHeight, document.documentElement.offsetHeight) + "px"), this.prop.overlay = _e("div", { className: "html2pdf__overlay", style: { position: "fixed", overflow: "hidden", zIndex: 1e3, left: "-100000px", right: 0, bottom: 0, top: 0 } }), this.prop.container = _e("div", { className: "html2pdf__container", style: Ce }), this.prop.container.appendChild(Me), this.prop.container.firstChild.appendChild(_e("div", { style: { clear: "both", border: "0 none transparent", margin: 0, padding: 0, height: 0 } })), this.prop.container.style.float = "none", this.prop.overlay.appendChild(this.prop.container), document.body.appendChild(this.prop.overlay), this.prop.container.firstChild.style.position = "relative", this.prop.container.height = Math.max(this.prop.container.firstChild.clientHeight, this.prop.container.firstChild.scrollHeight, this.prop.container.firstChild.offsetHeight) + "px" }) }, Re.prototype.toCanvas = function () { var Ce = [function () { return document.body.contains(this.prop.container) || this.toContainer() }]; return this.thenList(Ce).then(t).then(function (Me) { var De = Object.assign({}, this.opt.html2canvas); return delete De.onrendered, Me(this.prop.container, De) }).then(function (Me) { (this.opt.html2canvas.onrendered || function () { })(Me), this.prop.canvas = Me, document.body.removeChild(this.prop.overlay) }) }, Re.prototype.toContext2d = function () { var Ce = [function () { return document.body.contains(this.prop.container) || this.toContainer() }]; return this.thenList(Ce).then(t).then(function (Me) { var De = this.opt.jsPDF, Pe = this.opt.fontFaces, Oe = typeof this.opt.width != "number" || isNaN(this.opt.width) || typeof this.opt.windowWidth != "number" || isNaN(this.opt.windowWidth) ? 1 : this.opt.width / this.opt.windowWidth, je = Object.assign({ async: !0, allowTaint: !0, scale: Oe, scrollX: this.opt.scrollX || 0, scrollY: this.opt.scrollY || 0, backgroundColor: "#ffffff", imageTimeout: 15e3, logging: !0, proxy: null, removeContainer: !0, foreignObjectRendering: !1, useCORS: !1 }, this.opt.html2canvas); if (delete je.onrendered, De.context2d.autoPaging = this.opt.autoPaging === void 0 || this.opt.autoPaging, De.context2d.posX = this.opt.x, De.context2d.posY = this.opt.y, De.context2d.margin = this.opt.margin, De.context2d.fontFaces = Pe, Pe) for (var Be = 0; Be < Pe.length; ++Be) { var Ie = Pe[Be], Fe = Ie.src.find(function (ze) { return ze.format === "truetype" }); Fe && De.addFont(Fe.url, Ie.ref.name, Ie.ref.style) } return je.windowHeight = je.windowHeight || 0, je.windowHeight = je.windowHeight == 0 ? Math.max(this.prop.container.clientHeight, this.prop.container.scrollHeight, this.prop.container.offsetHeight) : je.windowHeight, De.context2d.save(!0), Me(this.prop.container, je) }).then(function (Me) { this.opt.jsPDF.context2d.restore(!0), (this.opt.html2canvas.onrendered || function () { })(Me), this.prop.canvas = Me, document.body.removeChild(this.prop.overlay) }) }, Re.prototype.toImg = function () { return this.thenList([function () { return this.prop.canvas || this.toCanvas() }]).then(function () { var Ce = this.prop.canvas.toDataURL("image/" + this.opt.image.type, this.opt.image.quality); this.prop.img = document.createElement("img"), this.prop.img.src = Ce }) }, Re.prototype.toPdf = function () { return this.thenList([function () { return this.toContext2d() }]).then(function () { this.prop.pdf = this.prop.pdf || this.opt.jsPDF }) }, Re.prototype.output = function (Ce, Me, De) { return (De = De || "pdf").toLowerCase() === "img" || De.toLowerCase() === "image" ? this.outputImg(Ce, Me) : this.outputPdf(Ce, Me) }, Re.prototype.outputPdf = function (Ce, Me) { return this.thenList([function () { return this.prop.pdf || this.toPdf() }]).then(function () { return this.prop.pdf.output(Ce, Me) }) }, Re.prototype.outputImg = function (Ce) { return this.thenList([function () { return this.prop.img || this.toImg() }]).then(function () { switch (Ce) { case void 0: case "img": return this.prop.img; case "datauristring": case "dataurlstring": return this.prop.img.src; case "datauri": case "dataurl": return document.location.href = this.prop.img.src; default: throw 'Image output type "' + Ce + '" is not supported.' } }) }, Re.prototype.save = function (Ce) { return this.thenList([function () { return this.prop.pdf || this.toPdf() }]).set(Ce ? { filename: Ce } : null).then(function () { this.prop.pdf.save(this.opt.filename) }) }, Re.prototype.doCallback = function () { return this.thenList([function () { return this.prop.pdf || this.toPdf() }]).then(function () { this.prop.callback(this.prop.pdf) }) }, Re.prototype.set = function (Ce) { if (Ee(Ce) !== "object") return this; var Me = Object.keys(Ce || {}).map(function (De) { if (De in Re.template.prop) return function () { this.prop[De] = Ce[De] }; switch (De) { case "margin": return this.setMargin.bind(this, Ce.margin); case "jsPDF": return function () { return this.opt.jsPDF = Ce.jsPDF, this.setPageSize() }; case "pageSize": return this.setPageSize.bind(this, Ce.pageSize); default: return function () { this.opt[De] = Ce[De] } } }, this); return this.then(function () { return this.thenList(Me) }) }, Re.prototype.get = function (Ce, Me) { return this.then(function () { var De = Ce in Re.template.prop ? this.prop[Ce] : this.opt[Ce]; return Me ? Me(De) : De }) }, Re.prototype.setMargin = function (Ce) { return this.then(function () { switch (Ee(Ce)) { case "number": Ce = [Ce, Ce, Ce, Ce]; case "array": if (Ce.length === 2 && (Ce = [Ce[0], Ce[1], Ce[0], Ce[1]]), Ce.length === 4) break; default: return this.error("Invalid margin array.") }this.opt.margin = Ce }).then(this.setPageSize) }, Re.prototype.setPageSize = function (Ce) { function Me(De, Pe) { return Math.floor(De * Pe / 72 * 96) } return this.then(function () { (Ce = Ce || E.getPageSize(this.opt.jsPDF)).hasOwnProperty("inner") || (Ce.inner = { width: Ce.width - this.opt.margin[1] - this.opt.margin[3], height: Ce.height - this.opt.margin[0] - this.opt.margin[2] }, Ce.inner.px = { width: Me(Ce.inner.width, Ce.k), height: Me(Ce.inner.height, Ce.k) }, Ce.inner.ratio = Ce.inner.height / Ce.inner.width), this.prop.pageSize = Ce }) }, Re.prototype.setProgress = function (Ce, Me, De, Pe) { return Ce != null && (this.progress.val = Ce), Me != null && (this.progress.state = Me), De != null && (this.progress.n = De), Pe != null && (this.progress.stack = Pe), this.progress.ratio = this.progress.val / this.progress.state, this }, Re.prototype.updateProgress = function (Ce, Me, De, Pe) { return this.setProgress(Ce ? this.progress.val + Ce : null, Me || null, De ? this.progress.n + De : null, Pe ? this.progress.stack.concat(Pe) : null) }, Re.prototype.then = function (Ce, Me) { var De = this; return this.thenCore(Ce, Me, function (Pe, Oe) { return De.updateProgress(null, null, 1, [Pe]), Promise.prototype.then.call(this, function (je) { return De.updateProgress(null, Pe), je }).then(Pe, Oe).then(function (je) { return De.updateProgress(1), je }) }) }, Re.prototype.thenCore = function (Ce, Me, De) { De = De || Promise.prototype.then, Ce && (Ce = Ce.bind(this)), Me && (Me = Me.bind(this)); var Pe = Promise.toString().indexOf("[native code]") !== -1 && Promise.name === "Promise" ? this : Re.convert(Object.assign({}, this), Promise.prototype), Oe = De.call(Pe, Ce, Me); return Re.convert(Oe, this.__proto__) }, Re.prototype.thenExternal = function (Ce, Me) { return Promise.prototype.then.call(this, Ce, Me) }, Re.prototype.thenList = function (Ce) { var Me = this; return Ce.forEach(function (De) { Me = Me.thenCore(De) }), Me }, Re.prototype.catch = function (Ce) { Ce && (Ce = Ce.bind(this)); var Me = Promise.prototype.catch.call(this, Ce); return Re.convert(Me, this) }, Re.prototype.catchExternal = function (Ce) { return Promise.prototype.catch.call(this, Ce) }, Re.prototype.error = function (Ce) { return this.then(function () { throw new Error(Ce) }) }, Re.prototype.using = Re.prototype.set, Re.prototype.saveAs = Re.prototype.save, Re.prototype.export = Re.prototype.output, Re.prototype.run = Re.prototype.then, E.getPageSize = function (Ce, Me, De) { if (_typeof(Ce) === "object") { var Pe = Ce; Ce = Pe.orientation, Me = Pe.unit || Me, De = Pe.format || De } Me = Me || "mm", De = De || "a4", Ce = ("" + (Ce || "P")).toLowerCase(); var Oe, je = ("" + De).toLowerCase(), Be = { a0: [2383.94, 3370.39], a1: [1683.78, 2383.94], a2: [1190.55, 1683.78], a3: [841.89, 1190.55], a4: [595.28, 841.89], a5: [419.53, 595.28], a6: [297.64, 419.53], a7: [209.76, 297.64], a8: [147.4, 209.76], a9: [104.88, 147.4], a10: [73.7, 104.88], b0: [2834.65, 4008.19], b1: [2004.09, 2834.65], b2: [1417.32, 2004.09], b3: [1000.63, 1417.32], b4: [708.66, 1000.63], b5: [498.9, 708.66], b6: [354.33, 498.9], b7: [249.45, 354.33], b8: [175.75, 249.45], b9: [124.72, 175.75], b10: [87.87, 124.72], c0: [2599.37, 3676.54], c1: [1836.85, 2599.37], c2: [1298.27, 1836.85], c3: [918.43, 1298.27], c4: [649.13, 918.43], c5: [459.21, 649.13], c6: [323.15, 459.21], c7: [229.61, 323.15], c8: [161.57, 229.61], c9: [113.39, 161.57], c10: [79.37, 113.39], dl: [311.81, 623.62], letter: [612, 792], "government-letter": [576, 756], legal: [612, 1008], "junior-legal": [576, 360], ledger: [1224, 792], tabloid: [792, 1224], "credit-card": [153, 243] }; switch (Me) { case "pt": Oe = 1; break; case "mm": Oe = 72 / 25.4; break; case "cm": Oe = 72 / 2.54; break; case "in": Oe = 72; break; case "px": Oe = .75; break; case "pc": case "em": Oe = 12; break; case "ex": Oe = 6; break; default: throw "Invalid unit: " + Me }var Ie, Fe = 0, ze = 0; if (Be.hasOwnProperty(je)) Fe = Be[je][1] / Oe, ze = Be[je][0] / Oe; else try { Fe = De[1], ze = De[0] } catch { throw new Error("Invalid format: " + De) } if (Ce === "p" || Ce === "portrait") Ce = "p", ze > Fe && (Ie = ze, ze = Fe, Fe = Ie); else { if (Ce !== "l" && Ce !== "landscape") throw "Invalid orientation: " + Ce; Ce = "l", Fe > ze && (Ie = ze, ze = Fe, Fe = Ie) } return { width: ze, height: Fe, unit: Me, k: Oe, orientation: Ce } }, e.html = function (Ce, Me) { (Me = Me || {}).callback = Me.callback || function () { }, Me.html2canvas = Me.html2canvas || {}, Me.html2canvas.canvas = Me.html2canvas.canvas || this.canvas, Me.jsPDF = Me.jsPDF || this, Me.fontFaces = Me.fontFaces ? Me.fontFaces.map(jt) : null; var De = new Re(Me); return Me.worker ? De : De.from(Ce).doCallback() } }(E.API), E.API.addJS = function (e) { return Ht = e, this.internal.events.subscribe("postPutResources", function () { Ut = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/Names [(EmbeddedJS) " + (Ut + 1) + " 0 R]"), this.internal.out(">>"), this.internal.out("endobj"), zt = this.internal.newObject(), this.internal.out("<<"), this.internal.out("/S /JavaScript"), this.internal.out("/JS (" + Ht + ")"), this.internal.out(">>"), this.internal.out("endobj") }), this.internal.events.subscribe("putCatalog", function () { Ut !== void 0 && zt !== void 0 && this.internal.out("/Names <</JavaScript " + Ut + " 0 R>>") }), this }, function (e) {
  var t; e.events.push(["postPutResources", function () { var xe = this, Ee = /^(\d+) 0 obj$/; if (this.outline.root.children.length > 0) for (var _e = xe.outline.render().split(/\r\n/), Re = 0; Re < _e.length; Re++) { var Ce = _e[Re], Me = Ee.exec(Ce); if (Me != null) { var De = Me[1]; xe.internal.newObjectDeferredBegin(De, !1) } xe.internal.write(Ce) } if (this.outline.createNamedDestinations) { var Pe = this.internal.pages.length, Oe = []; for (Re = 0; Re < Pe; Re++) { var je = xe.internal.newObject(); Oe.push(je); var Be = xe.internal.getPageInfo(Re + 1); xe.internal.write("<< /D[" + Be.objId + " 0 R /XYZ null null null]>> endobj") } var Ie = xe.internal.newObject(); for (xe.internal.write("<< /Names [ "), Re = 0; Re < Oe.length; Re++)xe.internal.write("(page_" + (Re + 1) + ")" + Oe[Re] + " 0 R"); xe.internal.write(" ] >>", "endobj"), t = xe.internal.newObject(), xe.internal.write("<< /Dests " + Ie + " 0 R"), xe.internal.write(">>", "endobj") } }]), e.events.push(["putCatalog", function () { this.outline.root.children.length > 0 && (this.internal.write("/Outlines", this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && this.internal.write("/Names " + t + " 0 R")) }]), e.events.push(["initialized", function () {
    var xe = this; xe.outline = { createNamedDestinations: !1, root: { children: [] } }, xe.outline.add = function (Ee, _e, Re) { var Ce = { title: _e, options: Re, children: [] }; return Ee == null && (Ee = this.root), Ee.children.push(Ce), Ce }, xe.outline.render = function () { return this.ctx = {}, this.ctx.val = "", this.ctx.pdf = xe, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val }, xe.outline.genIds_r = function (Ee) { Ee.id = xe.internal.newObjectDeferred(); for (var _e = 0; _e < Ee.children.length; _e++)this.genIds_r(Ee.children[_e]) }, xe.outline.renderRoot = function (Ee) { this.objStart(Ee), this.line("/Type /Outlines"), Ee.children.length > 0 && (this.line("/First " + this.makeRef(Ee.children[0])), this.line("/Last " + this.makeRef(Ee.children[Ee.children.length - 1]))), this.line("/Count " + this.count_r({ count: 0 }, Ee)), this.objEnd() }, xe.outline.renderItems = function (Ee) { for (var _e = this.ctx.pdf.internal.getVerticalCoordinateString, Re = 0; Re < Ee.children.length; Re++) { var Ce = Ee.children[Re]; this.objStart(Ce), this.line("/Title " + this.makeString(Ce.title)), this.line("/Parent " + this.makeRef(Ee)), Re > 0 && this.line("/Prev " + this.makeRef(Ee.children[Re - 1])), Re < Ee.children.length - 1 && this.line("/Next " + this.makeRef(Ee.children[Re + 1])), Ce.children.length > 0 && (this.line("/First " + this.makeRef(Ce.children[0])), this.line("/Last " + this.makeRef(Ce.children[Ce.children.length - 1]))); var Me = this.count = this.count_r({ count: 0 }, Ce); if (Me > 0 && this.line("/Count " + Me), Ce.options && Ce.options.pageNumber) { var De = xe.internal.getPageInfo(Ce.options.pageNumber); this.line("/Dest [" + De.objId + " 0 R /XYZ 0 " + _e(0) + " 0]") } this.objEnd() } for (var Pe = 0; Pe < Ee.children.length; Pe++)this.renderItems(Ee.children[Pe]) }, xe.outline.line = function (Ee) {
      this.ctx.val += Ee + `\r
`}, xe.outline.makeRef = function (Ee) { return Ee.id + " 0 R" }, xe.outline.makeString = function (Ee) { return "(" + xe.internal.pdfEscape(Ee) + ")" }, xe.outline.objStart = function (Ee) {
        this.ctx.val += `\r
`+ Ee.id + ` 0 obj\r
<<\r
`}, xe.outline.objEnd = function () {
        this.ctx.val += `>> \r
endobj\r
`}, xe.outline.count_r = function (Ee, _e) { for (var Re = 0; Re < _e.children.length; Re++)Ee.count++, this.count_r(Ee, _e.children[Re]); return Ee.count }
  }])
}(E.API), function (e) { var t = [192, 193, 194, 195, 196, 197, 198, 199]; e.processJPEG = function (xe, Ee, _e, Re, Ce, Me) { var De, Pe = this.decode.DCT_DECODE, Oe = null; if (typeof xe == "string" || this.__addimage__.isArrayBuffer(xe) || this.__addimage__.isArrayBufferView(xe)) { switch (xe = Ce || xe, xe = this.__addimage__.isArrayBuffer(xe) ? new Uint8Array(xe) : xe, (De = function (je) { for (var Be, Ie = 256 * je.charCodeAt(4) + je.charCodeAt(5), Fe = je.length, ze = { width: 0, height: 0, numcomponents: 1 }, qe = 4; qe < Fe; qe += 2) { if (qe += Ie, t.indexOf(je.charCodeAt(qe + 1)) !== -1) { Be = 256 * je.charCodeAt(qe + 5) + je.charCodeAt(qe + 6), ze = { width: 256 * je.charCodeAt(qe + 7) + je.charCodeAt(qe + 8), height: Be, numcomponents: je.charCodeAt(qe + 9) }; break } Ie = 256 * je.charCodeAt(qe + 2) + je.charCodeAt(qe + 3) } return ze }(xe = this.__addimage__.isArrayBufferView(xe) ? this.__addimage__.arrayBufferToBinaryString(xe) : xe)).numcomponents) { case 1: Me = this.color_spaces.DEVICE_GRAY; break; case 4: Me = this.color_spaces.DEVICE_CMYK; break; case 3: Me = this.color_spaces.DEVICE_RGB }Oe = { data: xe, width: De.width, height: De.height, colorSpace: Me, bitsPerComponent: 8, filter: Pe, index: Ee, alias: _e } } return Oe } }(E.API); var Vt, Gt, Yt, Jt, Xt, Kt = function () { var e, t, xe; function Ee(Re) { var Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze, qe, He, Ge, Ze; for (this.data = Re, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, je = null; ;) { switch (Ce = this.readUInt32(), Fe = (function () { var sn, Xe; for (Xe = [], sn = 0; sn < 4; ++sn)Xe.push(String.fromCharCode(this.data[this.pos++])); return Xe }).call(this).join("")) { case "IHDR": this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++]; break; case "acTL": this.animation = { numFrames: this.readUInt32(), numPlays: this.readUInt32() || 1 / 0, frames: [] }; break; case "PLTE": this.palette = this.read(Ce); break; case "fcTL": je && this.animation.frames.push(je), this.pos += 4, je = { width: this.readUInt32(), height: this.readUInt32(), xOffset: this.readUInt32(), yOffset: this.readUInt32() }, Oe = this.readUInt16(), Pe = this.readUInt16() || 100, je.delay = 1e3 * Oe / Pe, je.disposeOp = this.data[this.pos++], je.blendOp = this.data[this.pos++], je.data = []; break; case "IDAT": case "fdAT": for (Fe === "fdAT" && (this.pos += 4, Ce -= 4), Re = je?.data || this.imgData, He = 0; 0 <= Ce ? He < Ce : He > Ce; 0 <= Ce ? ++He : --He)Re.push(this.data[this.pos++]); break; case "tRNS": switch (this.transparency = {}, this.colorType) { case 3: if (De = this.palette.length / 3, this.transparency.indexed = this.read(Ce), this.transparency.indexed.length > De) throw new Error("More transparent colors than palette size"); if ((ze = De - this.transparency.indexed.length) > 0) for (Ge = 0; 0 <= ze ? Ge < ze : Ge > ze; 0 <= ze ? ++Ge : --Ge)this.transparency.indexed.push(255); break; case 0: this.transparency.grayscale = this.read(Ce)[0]; break; case 2: this.transparency.rgb = this.read(Ce) }break; case "tEXt": Be = (qe = this.read(Ce)).indexOf(0), Ie = String.fromCharCode.apply(String, qe.slice(0, Be)), this.text[Ie] = String.fromCharCode.apply(String, qe.slice(Be + 1)); break; case "IEND": return je && this.animation.frames.push(je), this.colors = (function () { switch (this.colorType) { case 0: case 3: case 4: return 1; case 2: case 6: return 3 } }).call(this), this.hasAlphaChannel = (Ze = this.colorType) === 4 || Ze === 6, Me = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * Me, this.colorSpace = (function () { switch (this.colors) { case 1: return "DeviceGray"; case 3: return "DeviceRGB" } }).call(this), void (this.imgData = new Uint8Array(this.imgData)); default: this.pos += Ce }if (this.pos += 4, this.pos > this.data.length) throw new Error("Incomplete or corrupt PNG file") } } Ee.prototype.read = function (Re) { var Ce, Me; for (Me = [], Ce = 0; 0 <= Re ? Ce < Re : Ce > Re; 0 <= Re ? ++Ce : --Ce)Me.push(this.data[this.pos++]); return Me }, Ee.prototype.readUInt32 = function () { return this.data[this.pos++] << 24 | this.data[this.pos++] << 16 | this.data[this.pos++] << 8 | this.data[this.pos++] }, Ee.prototype.readUInt16 = function () { return this.data[this.pos++] << 8 | this.data[this.pos++] }, Ee.prototype.decodePixels = function (Re) { var Ce = this.pixelBitlength / 8, Me = new Uint8Array(this.width * this.height * Ce), De = 0, Pe = this; if (Re == null && (Re = this.imgData), Re.length === 0) return new Uint8Array(0); function Oe(je, Be, Ie, Fe) { var ze, qe, He, Ge, Ze, sn, Xe, St, un, on, bn, Tn, fn, En, Pn, Rn, In, xn, vn, tn, nn, We = Math.ceil((Pe.width - je) / Ie), dn = Math.ceil((Pe.height - Be) / Fe), Je = Pe.width == We && Pe.height == dn; for (En = Ce * We, Tn = Je ? Me : new Uint8Array(En * dn), sn = Re.length, fn = 0, qe = 0; fn < dn && De < sn;) { switch (Re[De++]) { case 0: for (Ge = In = 0; In < En; Ge = In += 1)Tn[qe++] = Re[De++]; break; case 1: for (Ge = xn = 0; xn < En; Ge = xn += 1)ze = Re[De++], Ze = Ge < Ce ? 0 : Tn[qe - Ce], Tn[qe++] = (ze + Ze) % 256; break; case 2: for (Ge = vn = 0; vn < En; Ge = vn += 1)ze = Re[De++], He = (Ge - Ge % Ce) / Ce, Pn = fn && Tn[(fn - 1) * En + He * Ce + Ge % Ce], Tn[qe++] = (Pn + ze) % 256; break; case 3: for (Ge = tn = 0; tn < En; Ge = tn += 1)ze = Re[De++], He = (Ge - Ge % Ce) / Ce, Ze = Ge < Ce ? 0 : Tn[qe - Ce], Pn = fn && Tn[(fn - 1) * En + He * Ce + Ge % Ce], Tn[qe++] = (ze + Math.floor((Ze + Pn) / 2)) % 256; break; case 4: for (Ge = nn = 0; nn < En; Ge = nn += 1)ze = Re[De++], He = (Ge - Ge % Ce) / Ce, Ze = Ge < Ce ? 0 : Tn[qe - Ce], fn === 0 ? Pn = Rn = 0 : (Pn = Tn[(fn - 1) * En + He * Ce + Ge % Ce], Rn = He && Tn[(fn - 1) * En + (He - 1) * Ce + Ge % Ce]), Xe = Ze + Pn - Rn, St = Math.abs(Xe - Ze), on = Math.abs(Xe - Pn), bn = Math.abs(Xe - Rn), un = St <= on && St <= bn ? Ze : on <= bn ? Pn : Rn, Tn[qe++] = (ze + un) % 256; break; default: throw new Error("Invalid filter algorithm: " + Re[De - 1]) }if (!Je) { var rn = ((Be + fn * Fe) * Pe.width + je) * Ce, hn = fn * En; for (Ge = 0; Ge < We; Ge += 1) { for (var mn = 0; mn < Ce; mn += 1)Me[rn++] = Tn[hn++]; rn += (Ie - 1) * Ce } } fn++ } } return Re = unzlibSync(Re), Pe.interlaceMethod == 1 ? (Oe(0, 0, 8, 8), Oe(4, 0, 8, 8), Oe(0, 4, 4, 8), Oe(2, 0, 4, 4), Oe(0, 2, 2, 4), Oe(1, 0, 2, 2), Oe(0, 1, 1, 2)) : Oe(0, 0, 1, 1), Me }, Ee.prototype.decodePalette = function () { var Re, Ce, Me, De, Pe, Oe, je, Be, Ie; for (Me = this.palette, Oe = this.transparency.indexed || [], Pe = new Uint8Array((Oe.length || 0) + Me.length), De = 0, Re = 0, Ce = je = 0, Be = Me.length; je < Be; Ce = je += 3)Pe[De++] = Me[Ce], Pe[De++] = Me[Ce + 1], Pe[De++] = Me[Ce + 2], Pe[De++] = (Ie = Oe[Re++]) != null ? Ie : 255; return Pe }, Ee.prototype.copyToImageData = function (Re, Ce) { var Me, De, Pe, Oe, je, Be, Ie, Fe, ze, qe, He; if (De = this.colors, ze = null, Me = this.hasAlphaChannel, this.palette.length && (ze = (He = this._decodedPalette) != null ? He : this._decodedPalette = this.decodePalette(), De = 4, Me = !0), Fe = (Pe = Re.data || Re).length, je = ze || Ce, Oe = Be = 0, De === 1) for (; Oe < Fe;)Ie = ze ? 4 * Ce[Oe / 4] : Be, qe = je[Ie++], Pe[Oe++] = qe, Pe[Oe++] = qe, Pe[Oe++] = qe, Pe[Oe++] = Me ? je[Ie++] : 255, Be = Ie; else for (; Oe < Fe;)Ie = ze ? 4 * Ce[Oe / 4] : Be, Pe[Oe++] = je[Ie++], Pe[Oe++] = je[Ie++], Pe[Oe++] = je[Ie++], Pe[Oe++] = Me ? je[Ie++] : 255, Be = Ie }, Ee.prototype.decode = function () { var Re; return Re = new Uint8Array(this.width * this.height * 4), this.copyToImageData(Re, this.decodePixels()), Re }; var _e = function () { if (Object.prototype.toString.call(n) === "[object Window]") { try { t = n.document.createElement("canvas"), xe = t.getContext("2d") } catch { return !1 } return !0 } return !1 }; return _e(), e = function (Re) { var Ce; if (_e() === !0) return xe.width = Re.width, xe.height = Re.height, xe.clearRect(0, 0, Re.width, Re.height), xe.putImageData(Re, 0, 0), (Ce = new Image).src = t.toDataURL(), Ce; throw new Error("This method requires a Browser with Canvas-capability.") }, Ee.prototype.decodeFrames = function (Re) { var Ce, Me, De, Pe, Oe, je, Be, Ie; if (this.animation) { for (Ie = [], Me = Oe = 0, je = (Be = this.animation.frames).length; Oe < je; Me = ++Oe)Ce = Be[Me], De = Re.createImageData(Ce.width, Ce.height), Pe = this.decodePixels(new Uint8Array(Ce.data)), this.copyToImageData(De, Pe), Ce.imageData = De, Ie.push(Ce.image = e(De)); return Ie } }, Ee.prototype.renderFrame = function (Re, Ce) { var Me, De, Pe; return Me = (De = this.animation.frames)[Ce], Pe = De[Ce - 1], Ce === 0 && Re.clearRect(0, 0, this.width, this.height), Pe?.disposeOp === 1 ? Re.clearRect(Pe.xOffset, Pe.yOffset, Pe.width, Pe.height) : Pe?.disposeOp === 2 && Re.putImageData(Pe.imageData, Pe.xOffset, Pe.yOffset), Me.blendOp === 0 && Re.clearRect(Me.xOffset, Me.yOffset, Me.width, Me.height), Re.drawImage(Me.image, Me.xOffset, Me.yOffset) }, Ee.prototype.animate = function (Re) { var Ce, Me, De, Pe, Oe, je, Be = this; return Me = 0, je = this.animation, Pe = je.numFrames, De = je.frames, Oe = je.numPlays, (Ce = function () { var Ie, Fe; if (Ie = Me++ % Pe, Fe = De[Ie], Be.renderFrame(Re, Ie), Pe > 1 && Me / Pe < Oe) return Be.animation._timeout = setTimeout(Ce, Fe.delay) })() }, Ee.prototype.stopAnimation = function () { var Re; return clearTimeout((Re = this.animation) != null ? Re._timeout : void 0) }, Ee.prototype.render = function (Re) { var Ce, Me; return Re._png && Re._png.stopAnimation(), Re._png = this, Re.width = this.width, Re.height = this.height, Ce = Re.getContext("2d"), this.animation ? (this.decodeFrames(Ce), this.animate(Ce)) : (Me = Ce.createImageData(this.width, this.height), this.copyToImageData(Me, this.decodePixels()), Ce.putImageData(Me, 0, 0)) }, Ee }();/**
 * @license
 *
 * Copyright (c) 2014 James Robb, https://github.com/jamesbrobb
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * "Software"), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 * ====================================================================
 *//**
 * @license
 * (c) Dean McNamee <dean@gmail.com>, 2013.
 *
 * https://github.com/deanm/omggif
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 * omggif is a JavaScript implementation of a GIF 89a encoder and decoder,
 * including animation and compression.  It does not rely on any specific
 * underlying system, so should run in the browser, Node, or Plask.
 */function Zt(e) { var t = 0; if (e[t++] !== 71 || e[t++] !== 73 || e[t++] !== 70 || e[t++] !== 56 || (e[t++] + 1 & 253) != 56 || e[t++] !== 97) throw new Error("Invalid GIF 87a/89a header."); var xe = e[t++] | e[t++] << 8, Ee = e[t++] | e[t++] << 8, _e = e[t++], Re = _e >> 7, Ce = 1 << (7 & _e) + 1; e[t++], e[t++]; var Me = null, De = null; Re && (Me = t, De = Ce, t += 3 * Ce); var Pe = !0, Oe = [], je = 0, Be = null, Ie = 0, Fe = null; for (this.width = xe, this.height = Ee; Pe && t < e.length;)switch (e[t++]) { case 33: switch (e[t++]) { case 255: if (e[t] !== 11 || e[t + 1] == 78 && e[t + 2] == 69 && e[t + 3] == 84 && e[t + 4] == 83 && e[t + 5] == 67 && e[t + 6] == 65 && e[t + 7] == 80 && e[t + 8] == 69 && e[t + 9] == 50 && e[t + 10] == 46 && e[t + 11] == 48 && e[t + 12] == 3 && e[t + 13] == 1 && e[t + 16] == 0) t += 14, Fe = e[t++] | e[t++] << 8, t++; else for (t += 12; ;) { if (!((fn = e[t++]) >= 0)) throw Error("Invalid block size"); if (fn === 0) break; t += fn } break; case 249: if (e[t++] !== 4 || e[t + 4] !== 0) throw new Error("Invalid graphics extension block."); var ze = e[t++]; je = e[t++] | e[t++] << 8, Be = e[t++], (1 & ze) == 0 && (Be = null), Ie = ze >> 2 & 7, t++; break; case 254: for (; ;) { if (!((fn = e[t++]) >= 0)) throw Error("Invalid block size"); if (fn === 0) break; t += fn } break; default: throw new Error("Unknown graphic control label: 0x" + e[t - 1].toString(16)) }break; case 44: var qe = e[t++] | e[t++] << 8, He = e[t++] | e[t++] << 8, Ge = e[t++] | e[t++] << 8, Ze = e[t++] | e[t++] << 8, sn = e[t++], Xe = sn >> 6 & 1, St = 1 << (7 & sn) + 1, un = Me, on = De, bn = !1; sn >> 7 && (bn = !0, un = t, on = St, t += 3 * St); var Tn = t; for (t++; ;) { var fn; if (!((fn = e[t++]) >= 0)) throw Error("Invalid block size"); if (fn === 0) break; t += fn } Oe.push({ x: qe, y: He, width: Ge, height: Ze, has_local_palette: bn, palette_offset: un, palette_size: on, data_offset: Tn, data_length: t - Tn, transparent_index: Be, interlaced: !!Xe, delay: je, disposal: Ie }); break; case 59: Pe = !1; break; default: throw new Error("Unknown gif block: 0x" + e[t - 1].toString(16)) }this.numFrames = function () { return Oe.length }, this.loopCount = function () { return Fe }, this.frameInfo = function (En) { if (En < 0 || En >= Oe.length) throw new Error("Frame index out of range."); return Oe[En] }, this.decodeAndBlitFrameBGRA = function (En, Pn) { var Rn = this.frameInfo(En), In = Rn.width * Rn.height, xn = new Uint8Array(In); $t(e, Rn.data_offset, xn, In); var vn = Rn.palette_offset, tn = Rn.transparent_index; tn === null && (tn = 256); var nn = Rn.width, We = xe - nn, dn = nn, Je = 4 * (Rn.y * xe + Rn.x), rn = 4 * ((Rn.y + Rn.height) * xe + Rn.x), hn = Je, mn = 4 * We; Rn.interlaced === !0 && (mn += 4 * xe * 7); for (var Ye = 8, an = 0, pn = xn.length; an < pn; ++an) { var yn = xn[an]; if (dn === 0 && (dn = nn, (hn += mn) >= rn && (mn = 4 * We + 4 * xe * (Ye - 1), hn = Je + (nn + We) * (Ye << 1), Ye >>= 1)), yn === tn) hn += 4; else { var _n = e[vn + 3 * yn], On = e[vn + 3 * yn + 1], kn = e[vn + 3 * yn + 2]; Pn[hn++] = kn, Pn[hn++] = On, Pn[hn++] = _n, Pn[hn++] = 255 } --dn } }, this.decodeAndBlitFrameRGBA = function (En, Pn) { var Rn = this.frameInfo(En), In = Rn.width * Rn.height, xn = new Uint8Array(In); $t(e, Rn.data_offset, xn, In); var vn = Rn.palette_offset, tn = Rn.transparent_index; tn === null && (tn = 256); var nn = Rn.width, We = xe - nn, dn = nn, Je = 4 * (Rn.y * xe + Rn.x), rn = 4 * ((Rn.y + Rn.height) * xe + Rn.x), hn = Je, mn = 4 * We; Rn.interlaced === !0 && (mn += 4 * xe * 7); for (var Ye = 8, an = 0, pn = xn.length; an < pn; ++an) { var yn = xn[an]; if (dn === 0 && (dn = nn, (hn += mn) >= rn && (mn = 4 * We + 4 * xe * (Ye - 1), hn = Je + (nn + We) * (Ye << 1), Ye >>= 1)), yn === tn) hn += 4; else { var _n = e[vn + 3 * yn], On = e[vn + 3 * yn + 1], kn = e[vn + 3 * yn + 2]; Pn[hn++] = _n, Pn[hn++] = On, Pn[hn++] = kn, Pn[hn++] = 255 } --dn } } } function $t(e, t, xe, Ee) { for (var _e = e[t++], Re = 1 << _e, Ce = Re + 1, Me = Ce + 1, De = _e + 1, Pe = (1 << De) - 1, Oe = 0, je = 0, Be = 0, Ie = e[t++], Fe = new Int32Array(4096), ze = null; ;) { for (; Oe < 16 && Ie !== 0;)je |= e[t++] << Oe, Oe += 8, Ie === 1 ? Ie = e[t++] : --Ie; if (Oe < De) break; var qe = je & Pe; if (je >>= De, Oe -= De, qe !== Re) { if (qe === Ce) break; for (var He = qe < Me ? qe : ze, Ge = 0, Ze = He; Ze > Re;)Ze = Fe[Ze] >> 8, ++Ge; var sn = Ze; if (Be + Ge + (He !== qe ? 1 : 0) > Ee) return void a.log("Warning, gif stream longer than expected."); xe[Be++] = sn; var Xe = Be += Ge; for (He !== qe && (xe[Be++] = sn), Ze = He; Ge--;)Ze = Fe[Ze], xe[--Xe] = 255 & Ze, Ze >>= 8; ze !== null && Me < 4096 && (Fe[Me++] = ze << 8 | sn, Me >= Pe + 1 && De < 12 && (++De, Pe = Pe << 1 | 1)), ze = qe } else Me = Ce + 1, Pe = (1 << (De = _e + 1)) - 1, ze = null } return Be !== Ee && a.log("Warning, gif stream shorter than expected."), xe }/**
 * @license
  Copyright (c) 2008, Adobe Systems Incorporated
  All rights reserved.

  Redistribution and use in source and binary forms, with or without 
  modification, are permitted provided that the following conditions are
  met:

  * Redistributions of source code must retain the above copyright notice, 
    this list of conditions and the following disclaimer.
  
  * Redistributions in binary form must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the 
    documentation and/or other materials provided with the distribution.
  
  * Neither the name of Adobe Systems Incorporated nor the names of its 
    contributors may be used to endorse or promote products derived from 
    this software without specific prior written permission.

  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
  IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR 
  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*/function Qt(e) { var t, xe, Ee, _e, Re, Ce = Math.floor, Me = new Array(64), De = new Array(64), Pe = new Array(64), Oe = new Array(64), je = new Array(65535), Be = new Array(65535), Ie = new Array(64), Fe = new Array(64), ze = [], qe = 0, He = 7, Ge = new Array(64), Ze = new Array(64), sn = new Array(64), Xe = new Array(256), St = new Array(2048), un = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], on = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], bn = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Tn = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], fn = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], En = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], Pn = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], Rn = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], In = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250]; function xn(Je, rn) { for (var hn = 0, mn = 0, Ye = new Array, an = 1; an <= 16; an++) { for (var pn = 1; pn <= Je[an]; pn++)Ye[rn[mn]] = [], Ye[rn[mn]][0] = hn, Ye[rn[mn]][1] = an, mn++, hn++; hn *= 2 } return Ye } function vn(Je) { for (var rn = Je[0], hn = Je[1] - 1; hn >= 0;)rn & 1 << hn && (qe |= 1 << He), hn--, --He < 0 && (qe == 255 ? (tn(255), tn(0)) : tn(qe), He = 7, qe = 0) } function tn(Je) { ze.push(Je) } function nn(Je) { tn(Je >> 8 & 255), tn(255 & Je) } function We(Je, rn, hn, mn, Ye) { for (var an, pn = Ye[0], yn = Ye[240], _n = function (qn, rr) { var hr, ur, Er, _r, Or, Ir, Dr, Wr, Cr, zr, Tr = 0; for (Cr = 0; Cr < 8; ++Cr) { hr = qn[Tr], ur = qn[Tr + 1], Er = qn[Tr + 2], _r = qn[Tr + 3], Or = qn[Tr + 4], Ir = qn[Tr + 5], Dr = qn[Tr + 6]; var wi = hr + (Wr = qn[Tr + 7]), Jr = hr - Wr, mr = ur + Dr, Kn = ur - Dr, Qn = Er + Ir, Rr = Er - Ir, kr = _r + Or, di = _r - Or, ei = wi + kr, Wi = wi - kr, $i = mr + Qn, xi = mr - Qn; qn[Tr] = ei + $i, qn[Tr + 4] = ei - $i; var Ar = .707106781 * (xi + Wi); qn[Tr + 2] = Wi + Ar, qn[Tr + 6] = Wi - Ar; var Ur = .382683433 * ((ei = di + Rr) - (xi = Kn + Jr)), hi = .5411961 * ei + Ur, ii = 1.306562965 * xi + Ur, fi = .707106781 * ($i = Rr + Kn), yi = Jr + fi, Lr = Jr - fi; qn[Tr + 5] = Lr + hi, qn[Tr + 3] = Lr - hi, qn[Tr + 1] = yi + ii, qn[Tr + 7] = yi - ii, Tr += 8 } for (Tr = 0, Cr = 0; Cr < 8; ++Cr) { hr = qn[Tr], ur = qn[Tr + 8], Er = qn[Tr + 16], _r = qn[Tr + 24], Or = qn[Tr + 32], Ir = qn[Tr + 40], Dr = qn[Tr + 48]; var pi = hr + (Wr = qn[Tr + 56]), ni = hr - Wr, oi = ur + Dr, si = ur - Dr, bi = Er + Ir, ms = Er - Ir, Wo = _r + Or, Ws = _r - Or, Xs = pi + Wo, _s = pi - Wo, Rs = oi + bi, Bs = oi - bi; qn[Tr] = Xs + Rs, qn[Tr + 32] = Xs - Rs; var ws = .707106781 * (Bs + _s); qn[Tr + 16] = _s + ws, qn[Tr + 48] = _s - ws; var Li = .382683433 * ((Xs = Ws + ms) - (Bs = si + ni)), po = .5411961 * Xs + Li, Xo = 1.306562965 * Bs + Li, ta = .707106781 * (Rs = ms + si), da = ni + ta, _l = ni - ta; qn[Tr + 40] = _l + po, qn[Tr + 24] = _l - po, qn[Tr + 8] = da + Xo, qn[Tr + 56] = da - Xo, Tr++ } for (Cr = 0; Cr < 64; ++Cr)zr = qn[Cr] * rr[Cr], Ie[Cr] = zr > 0 ? zr + .5 | 0 : zr - .5 | 0; return Ie }(Je, rn), On = 0; On < 64; ++On)Fe[un[On]] = _n[On]; var kn = Fe[0] - hn; hn = Fe[0], kn == 0 ? vn(mn[0]) : (vn(mn[Be[an = 32767 + kn]]), vn(je[an])); for (var zn = 63; zn > 0 && Fe[zn] == 0;)zn--; if (zn == 0) return vn(pn), hn; for (var sr, Fn = 1; Fn <= zn;) { for (var Cn = Fn; Fe[Fn] == 0 && Fn <= zn;)++Fn; var Vn = Fn - Cn; if (Vn >= 16) { sr = Vn >> 4; for (var Yn = 1; Yn <= sr; ++Yn)vn(yn); Vn &= 15 } an = 32767 + Fe[Fn], vn(Ye[(Vn << 4) + Be[an]]), vn(je[an]), Fn++ } return zn != 63 && vn(pn), hn } function dn(Je) { Je = Math.min(Math.max(Je, 1), 100), Re != Je && (function (rn) { for (var hn = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], mn = 0; mn < 64; mn++) { var Ye = Ce((hn[mn] * rn + 50) / 100); Ye = Math.min(Math.max(Ye, 1), 255), Me[un[mn]] = Ye } for (var an = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], pn = 0; pn < 64; pn++) { var yn = Ce((an[pn] * rn + 50) / 100); yn = Math.min(Math.max(yn, 1), 255), De[un[pn]] = yn } for (var _n = [1, 1.387039845, 1.306562965, 1.175875602, 1, .785694958, .5411961, .275899379], On = 0, kn = 0; kn < 8; kn++)for (var zn = 0; zn < 8; zn++)Pe[On] = 1 / (Me[un[On]] * _n[kn] * _n[zn] * 8), Oe[On] = 1 / (De[un[On]] * _n[kn] * _n[zn] * 8), On++ }(Je < 50 ? Math.floor(5e3 / Je) : Math.floor(200 - 2 * Je)), Re = Je) } this.encode = function (Je, rn) { rn && dn(rn), ze = new Array, qe = 0, He = 7, nn(65496), nn(65504), nn(16), tn(74), tn(70), tn(73), tn(70), tn(0), tn(1), tn(1), tn(0), nn(1), nn(1), tn(0), tn(0), function () { nn(65499), nn(132), tn(0); for (var ur = 0; ur < 64; ur++)tn(Me[ur]); tn(1); for (var Er = 0; Er < 64; Er++)tn(De[Er]) }(), function (ur, Er) { nn(65472), nn(17), tn(8), nn(Er), nn(ur), tn(3), tn(1), tn(17), tn(0), tn(2), tn(17), tn(1), tn(3), tn(17), tn(1) }(Je.width, Je.height), function () { nn(65476), nn(418), tn(0); for (var ur = 0; ur < 16; ur++)tn(on[ur + 1]); for (var Er = 0; Er <= 11; Er++)tn(bn[Er]); tn(16); for (var _r = 0; _r < 16; _r++)tn(Tn[_r + 1]); for (var Or = 0; Or <= 161; Or++)tn(fn[Or]); tn(1); for (var Ir = 0; Ir < 16; Ir++)tn(En[Ir + 1]); for (var Dr = 0; Dr <= 11; Dr++)tn(Pn[Dr]); tn(17); for (var Wr = 0; Wr < 16; Wr++)tn(Rn[Wr + 1]); for (var Cr = 0; Cr <= 161; Cr++)tn(In[Cr]) }(), nn(65498), nn(12), tn(3), tn(1), tn(0), tn(2), tn(17), tn(3), tn(17), tn(0), tn(63), tn(0); var hn = 0, mn = 0, Ye = 0; qe = 0, He = 7, this.encode.displayName = "_encode_"; for (var an, pn, yn, _n, On, kn, zn, sr, Fn, Cn = Je.data, Vn = Je.width, Yn = Je.height, qn = 4 * Vn, rr = 0; rr < Yn;) { for (an = 0; an < qn;) { for (On = qn * rr + an, zn = -1, sr = 0, Fn = 0; Fn < 64; Fn++)kn = On + (sr = Fn >> 3) * qn + (zn = 4 * (7 & Fn)), rr + sr >= Yn && (kn -= qn * (rr + 1 + sr - Yn)), an + zn >= qn && (kn -= an + zn - qn + 4), pn = Cn[kn++], yn = Cn[kn++], _n = Cn[kn++], Ge[Fn] = (St[pn] + St[yn + 256 >> 0] + St[_n + 512 >> 0] >> 16) - 128, Ze[Fn] = (St[pn + 768 >> 0] + St[yn + 1024 >> 0] + St[_n + 1280 >> 0] >> 16) - 128, sn[Fn] = (St[pn + 1280 >> 0] + St[yn + 1536 >> 0] + St[_n + 1792 >> 0] >> 16) - 128; hn = We(Ge, Pe, hn, t, Ee), mn = We(Ze, Oe, mn, xe, _e), Ye = We(sn, Oe, Ye, xe, _e), an += 32 } rr += 8 } if (He >= 0) { var hr = []; hr[1] = He + 1, hr[0] = (1 << He + 1) - 1, vn(hr) } return nn(65497), new Uint8Array(ze) }, e = e || 50, function () { for (var Je = String.fromCharCode, rn = 0; rn < 256; rn++)Xe[rn] = Je(rn) }(), t = xn(on, bn), xe = xn(En, Pn), Ee = xn(Tn, fn), _e = xn(Rn, In), function () { for (var Je = 1, rn = 2, hn = 1; hn <= 15; hn++) { for (var mn = Je; mn < rn; mn++)Be[32767 + mn] = hn, je[32767 + mn] = [], je[32767 + mn][1] = hn, je[32767 + mn][0] = mn; for (var Ye = -(rn - 1); Ye <= -Je; Ye++)Be[32767 + Ye] = hn, je[32767 + Ye] = [], je[32767 + Ye][1] = hn, je[32767 + Ye][0] = rn - 1 + Ye; Je <<= 1, rn <<= 1 } }(), function () { for (var Je = 0; Je < 256; Je++)St[Je] = 19595 * Je, St[Je + 256 >> 0] = 38470 * Je, St[Je + 512 >> 0] = 7471 * Je + 32768, St[Je + 768 >> 0] = -11059 * Je, St[Je + 1024 >> 0] = -21709 * Je, St[Je + 1280 >> 0] = 32768 * Je + 8421375, St[Je + 1536 >> 0] = -27439 * Je, St[Je + 1792 >> 0] = -5329 * Je }(), dn(e) }/**
 * @license
 * Copyright (c) 2017 Aras Abbasi
 *
 * Licensed under the MIT License.
 * http://opensource.org/licenses/mit-license
 */function te(e, t) { if (this.pos = 0, this.buffer = e, this.datav = new DataView(e.buffer), this.is_with_alpha = !!t, this.bottom_up = !0, this.flag = String.fromCharCode(this.buffer[0]) + String.fromCharCode(this.buffer[1]), this.pos += 2, ["BM", "BA", "CI", "CP", "IC", "PT"].indexOf(this.flag) === -1) throw new Error("Invalid BMP File"); this.parseHeader(), this.parseBGR() } function ee(e) { function t(on) { if (!on) throw Error("assert :P") } function xe(on, bn, Tn) { for (var fn = 0; 4 > fn; fn++)if (on[bn + fn] != Tn.charCodeAt(fn)) return !0; return !1 } function Ee(on, bn, Tn, fn, En) { for (var Pn = 0; Pn < En; Pn++)on[bn + Pn] = Tn[fn + Pn] } function _e(on, bn, Tn, fn) { for (var En = 0; En < fn; En++)on[bn + En] = Tn } function Re(on) { return new Int32Array(on) } function Ce(on, bn) { for (var Tn = [], fn = 0; fn < on; fn++)Tn.push(new bn); return Tn } function Me(on, bn) { var Tn = []; return function fn(En, Pn, Rn) { for (var In = Rn[Pn], xn = 0; xn < In && (En.push(Rn.length > Pn + 1 ? [] : new bn), !(Rn.length < Pn + 1)); xn++)fn(En[xn], Pn + 1, Rn) }(Tn, 0, on), Tn } var De = function () { var on = this; function bn(Ue, Ve) { for (var en = 1 << Ve - 1 >>> 0; Ue & en;)en >>>= 1; return en ? (Ue & en - 1) + en : Ue } function Tn(Ue, Ve, en, gn, An) { t(!(gn % en)); do Ue[Ve + (gn -= en)] = An; while (0 < gn) } function fn(Ue, Ve, en, gn, An) { if (t(2328 >= An), 512 >= An) var Nn = Re(512); else if ((Nn = Re(An)) == null) return 0; return function (Ln, jn, Dn, Bn, Gn, ar) { var nr, Jn, xr = jn, dr = 1 << Dn, Wn = Re(16), Zn = Re(16); for (t(Gn != 0), t(Bn != null), t(Ln != null), t(0 < Dn), Jn = 0; Jn < Gn; ++Jn) { if (15 < Bn[Jn]) return 0; ++Wn[Bn[Jn]] } if (Wn[0] == Gn) return 0; for (Zn[1] = 0, nr = 1; 15 > nr; ++nr) { if (Wn[nr] > 1 << nr) return 0; Zn[nr + 1] = Zn[nr] + Wn[nr] } for (Jn = 0; Jn < Gn; ++Jn)nr = Bn[Jn], 0 < Bn[Jn] && (ar[Zn[nr]++] = Jn); if (Zn[15] == 1) return (Bn = new En).g = 0, Bn.value = ar[0], Tn(Ln, xr, 1, dr, Bn), dr; var pr, yr = -1, vr = dr - 1, Mr = 0, Nr = 1, Hr = 1, Pr = 1 << Dn; for (Jn = 0, nr = 1, Gn = 2; nr <= Dn; ++nr, Gn <<= 1) { if (Nr += Hr <<= 1, 0 > (Hr -= Wn[nr])) return 0; for (; 0 < Wn[nr]; --Wn[nr])(Bn = new En).g = nr, Bn.value = ar[Jn++], Tn(Ln, xr + Mr, Gn, Pr, Bn), Mr = bn(Mr, nr) } for (nr = Dn + 1, Gn = 2; 15 >= nr; ++nr, Gn <<= 1) { if (Nr += Hr <<= 1, 0 > (Hr -= Wn[nr])) return 0; for (; 0 < Wn[nr]; --Wn[nr]) { if (Bn = new En, (Mr & vr) != yr) { for (xr += Pr, pr = 1 << (yr = nr) - Dn; 15 > yr && !(0 >= (pr -= Wn[yr]));)++yr, pr <<= 1; dr += Pr = 1 << (pr = yr - Dn), Ln[jn + (yr = Mr & vr)].g = pr + Dn, Ln[jn + yr].value = xr - jn - yr } Bn.g = nr - Dn, Bn.value = ar[Jn++], Tn(Ln, xr + (Mr >> Dn), Gn, Pr, Bn), Mr = bn(Mr, nr) } } return Nr != 2 * Zn[15] - 1 ? 0 : dr }(Ue, Ve, en, gn, An, Nn) } function En() { this.value = this.g = 0 } function Pn() { this.value = this.g = 0 } function Rn() { this.G = Ce(5, En), this.H = Re(5), this.jc = this.Qb = this.qb = this.nd = 0, this.pd = Ce(cs, Pn) } function In(Ue, Ve, en, gn) { t(Ue != null), t(Ve != null), t(2147483648 > gn), Ue.Ca = 254, Ue.I = 0, Ue.b = -8, Ue.Ka = 0, Ue.oa = Ve, Ue.pa = en, Ue.Jd = Ve, Ue.Yc = en + gn, Ue.Zc = 4 <= gn ? en + gn - 4 + 1 : en, an(Ue) } function xn(Ue, Ve) { for (var en = 0; 0 < Ve--;)en |= yn(Ue, 128) << Ve; return en } function vn(Ue, Ve) { var en = xn(Ue, Ve); return pn(Ue) ? -en : en } function tn(Ue, Ve, en, gn) { var An, Nn = 0; for (t(Ue != null), t(Ve != null), t(4294967288 > gn), Ue.Sb = gn, Ue.Ra = 0, Ue.u = 0, Ue.h = 0, 4 < gn && (gn = 4), An = 0; An < gn; ++An)Nn += Ve[en + An] << 8 * An; Ue.Ra = Nn, Ue.bb = gn, Ue.oa = Ve, Ue.pa = en } function nn(Ue) { for (; 8 <= Ue.u && Ue.bb < Ue.Sb;)Ue.Ra >>>= 8, Ue.Ra += Ue.oa[Ue.pa + Ue.bb] << rl - 8 >>> 0, ++Ue.bb, Ue.u -= 8; hn(Ue) && (Ue.h = 1, Ue.u = 0) } function We(Ue, Ve) { if (t(0 <= Ve), !Ue.h && Ve <= nl) { var en = rn(Ue) & _o[Ve]; return Ue.u += Ve, nn(Ue), en } return Ue.h = 1, Ue.u = 0 } function dn() { this.b = this.Ca = this.I = 0, this.oa = [], this.pa = 0, this.Jd = [], this.Yc = 0, this.Zc = [], this.Ka = 0 } function Je() { this.Ra = 0, this.oa = [], this.h = this.u = this.bb = this.Sb = this.pa = 0 } function rn(Ue) { return Ue.Ra >>> (Ue.u & rl - 1) >>> 0 } function hn(Ue) { return t(Ue.bb <= Ue.Sb), Ue.h || Ue.bb == Ue.Sb && Ue.u > rl } function mn(Ue, Ve) { Ue.u = Ve, Ue.h = hn(Ue) } function Ye(Ue) { Ue.u >= zl && (t(Ue.u >= zl), nn(Ue)) } function an(Ue) { t(Ue != null && Ue.oa != null), Ue.pa < Ue.Zc ? (Ue.I = (Ue.oa[Ue.pa++] | Ue.I << 8) >>> 0, Ue.b += 8) : (t(Ue != null && Ue.oa != null), Ue.pa < Ue.Yc ? (Ue.b += 8, Ue.I = Ue.oa[Ue.pa++] | Ue.I << 8) : Ue.Ka ? Ue.b = 0 : (Ue.I <<= 8, Ue.b += 8, Ue.Ka = 1)) } function pn(Ue) { return xn(Ue, 1) } function yn(Ue, Ve) { var en = Ue.Ca; 0 > Ue.b && an(Ue); var gn = Ue.b, An = en * Ve >>> 8, Nn = (Ue.I >>> gn > An) + 0; for (Nn ? (en -= An, Ue.I -= An + 1 << gn >>> 0) : en = An + 1, gn = en, An = 0; 256 <= gn;)An += 8, gn >>= 8; return gn = 7 ^ An + Hs[gn], Ue.b -= gn, Ue.Ca = (en << gn) - 1, Nn } function _n(Ue, Ve, en) { Ue[Ve + 0] = en >> 24 & 255, Ue[Ve + 1] = en >> 16 & 255, Ue[Ve + 2] = en >> 8 & 255, Ue[Ve + 3] = en >> 0 & 255 } function On(Ue, Ve) { return Ue[Ve + 0] << 0 | Ue[Ve + 1] << 8 } function kn(Ue, Ve) { return On(Ue, Ve) | Ue[Ve + 2] << 16 } function zn(Ue, Ve) { return On(Ue, Ve) | On(Ue, Ve + 2) << 16 } function sr(Ue, Ve) { var en = 1 << Ve; return t(Ue != null), t(0 < Ve), Ue.X = Re(en), Ue.X == null ? 0 : (Ue.Mb = 32 - Ve, Ue.Xa = Ve, 1) } function Fn(Ue, Ve) { t(Ue != null), t(Ve != null), t(Ue.Xa == Ve.Xa), Ee(Ve.X, 0, Ue.X, 0, 1 << Ve.Xa) } function Cn() { this.X = [], this.Xa = this.Mb = 0 } function Vn(Ue, Ve, en, gn) { t(en != null), t(gn != null); var An = en[0], Nn = gn[0]; return An == 0 && (An = (Ue * Nn + Ve / 2) / Ve), Nn == 0 && (Nn = (Ve * An + Ue / 2) / Ue), 0 >= An || 0 >= Nn ? 0 : (en[0] = An, gn[0] = Nn, 1) } function Yn(Ue, Ve) { return Ue + (1 << Ve) - 1 >>> Ve } function qn(Ue, Ve) { return ((4278255360 & Ue) + (4278255360 & Ve) >>> 0 & 4278255360) + ((16711935 & Ue) + (16711935 & Ve) >>> 0 & 16711935) >>> 0 } function rr(Ue, Ve) { on[Ve] = function (en, gn, An, Nn, Ln, jn, Dn) { var Bn; for (Bn = 0; Bn < Ln; ++Bn) { var Gn = on[Ue](jn[Dn + Bn - 1], An, Nn + Bn); jn[Dn + Bn] = qn(en[gn + Bn], Gn) } } } function hr() { this.ud = this.hd = this.jd = 0 } function ur(Ue, Ve) { return ((4278124286 & (Ue ^ Ve)) >>> 1) + (Ue & Ve) >>> 0 } function Er(Ue) { return 0 <= Ue && 256 > Ue ? Ue : 0 > Ue ? 0 : 255 < Ue ? 255 : void 0 } function _r(Ue, Ve) { return Er(Ue + (Ue - Ve + .5 >> 1)) } function Or(Ue, Ve, en) { return Math.abs(Ve - en) - Math.abs(Ue - en) } function Ir(Ue, Ve, en, gn, An, Nn, Ln) { for (gn = Nn[Ln - 1], en = 0; en < An; ++en)Nn[Ln + en] = gn = qn(Ue[Ve + en], gn) } function Dr(Ue, Ve, en, gn, An) { var Nn; for (Nn = 0; Nn < en; ++Nn) { var Ln = Ue[Ve + Nn], jn = Ln >> 8 & 255, Dn = 16711935 & (Dn = (Dn = 16711935 & Ln) + ((jn << 16) + jn)); gn[An + Nn] = (4278255360 & Ln) + Dn >>> 0 } } function Wr(Ue, Ve) { Ve.jd = Ue >> 0 & 255, Ve.hd = Ue >> 8 & 255, Ve.ud = Ue >> 16 & 255 } function Cr(Ue, Ve, en, gn, An, Nn) { var Ln; for (Ln = 0; Ln < gn; ++Ln) { var jn = Ve[en + Ln], Dn = jn >>> 8, Bn = jn, Gn = 255 & (Gn = (Gn = jn >>> 16) + ((Ue.jd << 24 >> 24) * (Dn << 24 >> 24) >>> 5)); Bn = 255 & (Bn = (Bn = Bn + ((Ue.hd << 24 >> 24) * (Dn << 24 >> 24) >>> 5)) + ((Ue.ud << 24 >> 24) * (Gn << 24 >> 24) >>> 5)), An[Nn + Ln] = (4278255360 & jn) + (Gn << 16) + Bn } } function zr(Ue, Ve, en, gn, An) { on[Ve] = function (Nn, Ln, jn, Dn, Bn, Gn, ar, nr, Jn) { for (Dn = ar; Dn < nr; ++Dn)for (ar = 0; ar < Jn; ++ar)Bn[Gn++] = An(jn[gn(Nn[Ln++])]) }, on[Ue] = function (Nn, Ln, jn, Dn, Bn, Gn, ar) { var nr = 8 >> Nn.b, Jn = Nn.Ea, xr = Nn.K[0], dr = Nn.w; if (8 > nr) for (Nn = (1 << Nn.b) - 1, dr = (1 << nr) - 1; Ln < jn; ++Ln) { var Wn, Zn = 0; for (Wn = 0; Wn < Jn; ++Wn)Wn & Nn || (Zn = gn(Dn[Bn++])), Gn[ar++] = An(xr[Zn & dr]), Zn >>= nr } else on["VP8LMapColor" + en](Dn, Bn, xr, dr, Gn, ar, Ln, jn, Jn) } } function Tr(Ue, Ve, en, gn, An) { for (en = Ve + en; Ve < en;) { var Nn = Ue[Ve++]; gn[An++] = Nn >> 16 & 255, gn[An++] = Nn >> 8 & 255, gn[An++] = Nn >> 0 & 255 } } function wi(Ue, Ve, en, gn, An) { for (en = Ve + en; Ve < en;) { var Nn = Ue[Ve++]; gn[An++] = Nn >> 16 & 255, gn[An++] = Nn >> 8 & 255, gn[An++] = Nn >> 0 & 255, gn[An++] = Nn >> 24 & 255 } } function Jr(Ue, Ve, en, gn, An) { for (en = Ve + en; Ve < en;) { var Nn = (Ln = Ue[Ve++]) >> 16 & 240 | Ln >> 12 & 15, Ln = Ln >> 0 & 240 | Ln >> 28 & 15; gn[An++] = Nn, gn[An++] = Ln } } function mr(Ue, Ve, en, gn, An) { for (en = Ve + en; Ve < en;) { var Nn = (Ln = Ue[Ve++]) >> 16 & 248 | Ln >> 13 & 7, Ln = Ln >> 5 & 224 | Ln >> 3 & 31; gn[An++] = Nn, gn[An++] = Ln } } function Kn(Ue, Ve, en, gn, An) { for (en = Ve + en; Ve < en;) { var Nn = Ue[Ve++]; gn[An++] = Nn >> 0 & 255, gn[An++] = Nn >> 8 & 255, gn[An++] = Nn >> 16 & 255 } } function Qn(Ue, Ve, en, gn, An, Nn) { if (Nn == 0) for (en = Ve + en; Ve < en;)_n(gn, ((Nn = Ue[Ve++])[0] >> 24 | Nn[1] >> 8 & 65280 | Nn[2] << 8 & 16711680 | Nn[3] << 24) >>> 0), An += 32; else Ee(gn, An, Ue, Ve, en) } function Rr(Ue, Ve) { on[Ve][0] = on[Ue + "0"], on[Ve][1] = on[Ue + "1"], on[Ve][2] = on[Ue + "2"], on[Ve][3] = on[Ue + "3"], on[Ve][4] = on[Ue + "4"], on[Ve][5] = on[Ue + "5"], on[Ve][6] = on[Ue + "6"], on[Ve][7] = on[Ue + "7"], on[Ve][8] = on[Ue + "8"], on[Ve][9] = on[Ue + "9"], on[Ve][10] = on[Ue + "10"], on[Ve][11] = on[Ue + "11"], on[Ve][12] = on[Ue + "12"], on[Ve][13] = on[Ue + "13"], on[Ve][14] = on[Ue + "0"], on[Ve][15] = on[Ue + "0"] } function kr(Ue) { return Ue == Dc || Ue == Do || Ue == to || Ue == Vl } function di() { this.eb = [], this.size = this.A = this.fb = 0 } function ei() { this.y = [], this.f = [], this.ea = [], this.F = [], this.Tc = this.Ed = this.Cd = this.Fd = this.lb = this.Db = this.Ab = this.fa = this.J = this.W = this.N = this.O = 0 } function Wi() { this.Rd = this.height = this.width = this.S = 0, this.f = {}, this.f.RGBA = new di, this.f.kb = new ei, this.sd = null } function $i() { this.width = [0], this.height = [0], this.Pd = [0], this.Qd = [0], this.format = [0] } function xi() { this.Id = this.fd = this.Md = this.hb = this.ib = this.da = this.bd = this.cd = this.j = this.v = this.Da = this.Sd = this.ob = 0 } function Ar(Ue) { return alert("todo:WebPSamplerProcessPlane"), Ue.T } function Ur(Ue, Ve) { var en = Ue.T, gn = Ve.ba.f.RGBA, An = gn.eb, Nn = gn.fb + Ue.ka * gn.A, Ln = ys[Ve.ba.S], jn = Ue.y, Dn = Ue.O, Bn = Ue.f, Gn = Ue.N, ar = Ue.ea, nr = Ue.W, Jn = Ve.cc, xr = Ve.dc, dr = Ve.Mc, Wn = Ve.Nc, Zn = Ue.ka, pr = Ue.ka + Ue.T, yr = Ue.U, vr = yr + 1 >> 1; for (Zn == 0 ? Ln(jn, Dn, null, null, Bn, Gn, ar, nr, Bn, Gn, ar, nr, An, Nn, null, null, yr) : (Ln(Ve.ec, Ve.fc, jn, Dn, Jn, xr, dr, Wn, Bn, Gn, ar, nr, An, Nn - gn.A, An, Nn, yr), ++en); Zn + 2 < pr; Zn += 2)Jn = Bn, xr = Gn, dr = ar, Wn = nr, Gn += Ue.Rc, nr += Ue.Rc, Nn += 2 * gn.A, Ln(jn, (Dn += 2 * Ue.fa) - Ue.fa, jn, Dn, Jn, xr, dr, Wn, Bn, Gn, ar, nr, An, Nn - gn.A, An, Nn, yr); return Dn += Ue.fa, Ue.j + pr < Ue.o ? (Ee(Ve.ec, Ve.fc, jn, Dn, yr), Ee(Ve.cc, Ve.dc, Bn, Gn, vr), Ee(Ve.Mc, Ve.Nc, ar, nr, vr), en--) : 1 & pr || Ln(jn, Dn, null, null, Bn, Gn, ar, nr, Bn, Gn, ar, nr, An, Nn + gn.A, null, null, yr), en } function hi(Ue, Ve, en) { var gn = Ue.F, An = [Ue.J]; if (gn != null) { var Nn = Ue.U, Ln = Ve.ba.S, jn = Ln == ll || Ln == to; Ve = Ve.ba.f.RGBA; var Dn = [0], Bn = Ue.ka; Dn[0] = Ue.T, Ue.Kb && (Bn == 0 ? --Dn[0] : (--Bn, An[0] -= Ue.width), Ue.j + Ue.ka + Ue.T == Ue.o && (Dn[0] = Ue.o - Ue.j - Bn)); var Gn = Ve.eb; Bn = Ve.fb + Bn * Ve.A, Ue = ci(gn, An[0], Ue.width, Nn, Dn, Gn, Bn + (jn ? 0 : 3), Ve.A), t(en == Dn), Ue && kr(Ln) && Zs(Gn, Bn, jn, Nn, Dn, Ve.A) } return 0 } function ii(Ue) { var Ve = Ue.ma, en = Ve.ba.S, gn = 11 > en, An = en == $l || en == Mc || en == ll || en == eo || en == 12 || kr(en); if (Ve.memory = null, Ve.Ib = null, Ve.Jb = null, Ve.Nd = null, !So(Ve.Oa, Ue, An ? 11 : 12)) return 0; if (An && kr(en) && Sr(), Ue.da) alert("todo:use_scaling"); else { if (gn) { if (Ve.Ib = Ar, Ue.Kb) { if (en = Ue.U + 1 >> 1, Ve.memory = Re(Ue.U + 2 * en), Ve.memory == null) return 0; Ve.ec = Ve.memory, Ve.fc = 0, Ve.cc = Ve.ec, Ve.dc = Ve.fc + Ue.U, Ve.Mc = Ve.cc, Ve.Nc = Ve.dc + en, Ve.Ib = Ur, Sr() } } else alert("todo:EmitYUV"); An && (Ve.Jb = hi, gn && tr()) } if (gn && !Dd) { for (Ue = 0; 256 > Ue; ++Ue)Ph[Ue] = 89858 * (Ue - 128) + ds >> Ia, Fc[Ue] = -22014 * (Ue - 128) + ds, Xu[Ue] = -45773 * (Ue - 128), hs[Ue] = 113618 * (Ue - 128) + ds >> Ia; for (Ue = Fo; Ue < bu; ++Ue)Ve = 76283 * (Ue - 16) + ds >> Ia, Bc[Ue - Fo] = Qs(Ve, 255), Yu[Ue - Fo] = Qs(Ve + 8 >> 4, 15); Dd = 1 } return 1 } function fi(Ue) { var Ve = Ue.ma, en = Ue.U, gn = Ue.T; return t(!(1 & Ue.ka)), 0 >= en || 0 >= gn ? 0 : (en = Ve.Ib(Ue, Ve), Ve.Jb != null && Ve.Jb(Ue, Ve, en), Ve.Dc += en, 1) } function yi(Ue) { Ue.ma.memory = null } function Lr(Ue, Ve, en, gn) { return We(Ue, 8) != 47 ? 0 : (Ve[0] = We(Ue, 14) + 1, en[0] = We(Ue, 14) + 1, gn[0] = We(Ue, 1), We(Ue, 3) != 0 ? 0 : !Ue.h) } function pi(Ue, Ve) { if (4 > Ue) return Ue + 1; var en = Ue - 2 >> 1; return (2 + (1 & Ue) << en) + We(Ve, en) + 1 } function ni(Ue, Ve) { return 120 < Ve ? Ve - 120 : 1 <= (en = ((en = ro[Ve - 1]) >> 4) * Ue + (8 - (15 & en))) ? en : 1; var en } function oi(Ue, Ve, en) { var gn = rn(en), An = Ue[Ve += 255 & gn].g - 8; return 0 < An && (mn(en, en.u + 8), gn = rn(en), Ve += Ue[Ve].value, Ve += gn & (1 << An) - 1), mn(en, en.u + Ue[Ve].g), Ue[Ve].value } function si(Ue, Ve, en) { return en.g += Ue.g, en.value += Ue.value << Ve >>> 0, t(8 >= en.g), Ue.g } function bi(Ue, Ve, en) { var gn = Ue.xc; return t((Ve = gn == 0 ? 0 : Ue.vc[Ue.md * (en >> gn) + (Ve >> gn)]) < Ue.Wb), Ue.Ya[Ve] } function ms(Ue, Ve, en, gn) { var An = Ue.ab, Nn = Ue.c * Ve, Ln = Ue.C; Ve = Ln + Ve; var jn = en, Dn = gn; for (gn = Ue.Ta, en = Ue.Ua; 0 < An--;) { var Bn = Ue.gc[An], Gn = Ln, ar = Ve, nr = jn, Jn = Dn, xr = (Dn = gn, jn = en, Bn.Ea); switch (t(Gn < ar), t(ar <= Bn.nc), Bn.hc) { case 2: du(nr, Jn, (ar - Gn) * xr, Dn, jn); break; case 0: var dr = Gn, Wn = ar, Zn = Dn, pr = jn, yr = (Pr = Bn).Ea; dr == 0 && (Gu(nr, Jn, null, null, 1, Zn, pr), Ir(nr, Jn + 1, 0, 0, yr - 1, Zn, pr + 1), Jn += yr, pr += yr, ++dr); for (var vr = 1 << Pr.b, Mr = vr - 1, Nr = Yn(yr, Pr.b), Hr = Pr.K, Pr = Pr.w + (dr >> Pr.b) * Nr; dr < Wn;) { var Ai = Hr, Ci = Pr, ai = 1; for (Lc(nr, Jn, Zn, pr - yr, 1, Zn, pr); ai < yr;) { var ri = (ai & ~Mr) + vr; ri > yr && (ri = yr), (0, Qa[Ai[Ci++] >> 8 & 15])(nr, Jn + +ai, Zn, pr + ai - yr, ri - ai, Zn, pr + ai), ai = ri } Jn += yr, pr += yr, ++dr & Mr || (Pr += Nr) } ar != Bn.nc && Ee(Dn, jn - xr, Dn, jn + (ar - Gn - 1) * xr, xr); break; case 1: for (xr = nr, Wn = Jn, yr = (nr = Bn.Ea) - (pr = nr & ~(Zn = (Jn = 1 << Bn.b) - 1)), dr = Yn(nr, Bn.b), vr = Bn.K, Bn = Bn.w + (Gn >> Bn.b) * dr; Gn < ar;) { for (Mr = vr, Nr = Bn, Hr = new hr, Pr = Wn + pr, Ai = Wn + nr; Wn < Pr;)Wr(Mr[Nr++], Hr), Co(Hr, xr, Wn, Jn, Dn, jn), Wn += Jn, jn += Jn; Wn < Ai && (Wr(Mr[Nr++], Hr), Co(Hr, xr, Wn, yr, Dn, jn), Wn += yr, jn += yr), ++Gn & Zn || (Bn += dr) } break; case 3: if (nr == Dn && Jn == jn && 0 < Bn.b) { for (Wn = Dn, nr = xr = jn + (ar - Gn) * xr - (pr = (ar - Gn) * Yn(Bn.Ea, Bn.b)), Jn = Dn, Zn = jn, dr = [], pr = (yr = pr) - 1; 0 <= pr; --pr)dr[pr] = Jn[Zn + pr]; for (pr = yr - 1; 0 <= pr; --pr)Wn[nr + pr] = dr[pr]; ia(Bn, Gn, ar, Dn, xr, Dn, jn) } else ia(Bn, Gn, ar, nr, Jn, Dn, jn) }jn = gn, Dn = en } Dn != en && Ee(gn, en, jn, Dn, Nn) } function Wo(Ue, Ve) { var en = Ue.V, gn = Ue.Ba + Ue.c * Ue.C, An = Ve - Ue.C; if (t(Ve <= Ue.l.o), t(16 >= An), 0 < An) { var Nn = Ue.l, Ln = Ue.Ta, jn = Ue.Ua, Dn = Nn.width; if (ms(Ue, An, en, gn), An = jn = [jn], t((en = Ue.C) < (gn = Ve)), t(Nn.v < Nn.va), gn > Nn.o && (gn = Nn.o), en < Nn.j) { var Bn = Nn.j - en; en = Nn.j, An[0] += Bn * Dn } if (en >= gn ? en = 0 : (An[0] += 4 * Nn.v, Nn.ka = en - Nn.j, Nn.U = Nn.va - Nn.v, Nn.T = gn - en, en = 1), en) { if (jn = jn[0], 11 > (en = Ue.ca).S) { var Gn = en.f.RGBA, ar = (gn = en.S, An = Nn.U, Nn = Nn.T, Bn = Gn.eb, Gn.A), nr = Nn; for (Gn = Gn.fb + Ue.Ma * Gn.A; 0 < nr--;) { var Jn = Ln, xr = jn, dr = An, Wn = Bn, Zn = Gn; switch (gn) { case Ts: js(Jn, xr, dr, Wn, Zn); break; case $l: As(Jn, xr, dr, Wn, Zn); break; case Dc: As(Jn, xr, dr, Wn, Zn), Zs(Wn, Zn, 0, dr, 1, 0); break; case ja: ga(Jn, xr, dr, Wn, Zn); break; case Mc: Qn(Jn, xr, dr, Wn, Zn, 1); break; case Do: Qn(Jn, xr, dr, Wn, Zn, 1), Zs(Wn, Zn, 0, dr, 1, 0); break; case ll: Qn(Jn, xr, dr, Wn, Zn, 0); break; case to: Qn(Jn, xr, dr, Wn, Zn, 0), Zs(Wn, Zn, 1, dr, 1, 0); break; case eo: To(Jn, xr, dr, Wn, Zn); break; case Vl: To(Jn, xr, dr, Wn, Zn), li(Wn, Zn, dr, 1, 0); break; case fu: qs(Jn, xr, dr, Wn, Zn); break; default: t(0) }jn += Dn, Gn += ar } Ue.Ma += Nn } else alert("todo:EmitRescaledRowsYUVA"); t(Ue.Ma <= en.height) } } Ue.C = Ve, t(Ue.C <= Ue.i) } function Ws(Ue) { var Ve; if (0 < Ue.ua) return 0; for (Ve = 0; Ve < Ue.Wb; ++Ve) { var en = Ue.Ya[Ve].G, gn = Ue.Ya[Ve].H; if (0 < en[1][gn[1] + 0].g || 0 < en[2][gn[2] + 0].g || 0 < en[3][gn[3] + 0].g) return 0 } return 1 } function Xs(Ue, Ve, en, gn, An, Nn) { if (Ue.Z != 0) { var Ln = Ue.qd, jn = Ue.rd; for (t(Da[Ue.Z] != null); Ve < en; ++Ve)Da[Ue.Z](Ln, jn, gn, An, gn, An, Nn), Ln = gn, jn = An, An += Nn; Ue.qd = Ln, Ue.rd = jn } } function _s(Ue, Ve) { var en = Ue.l.ma, gn = en.Z == 0 || en.Z == 1 ? Ue.l.j : Ue.C; if (gn = Ue.C < gn ? gn : Ue.C, t(Ve <= Ue.l.o), Ve > gn) { var An = Ue.l.width, Nn = en.ca, Ln = en.tb + An * gn, jn = Ue.V, Dn = Ue.Ba + Ue.c * gn, Bn = Ue.gc; t(Ue.ab == 1), t(Bn[0].hc == 3), Ro(Bn[0], gn, Ve, jn, Dn, Nn, Ln), Xs(en, gn, Ve, Nn, Ln, An) } Ue.C = Ue.Ma = Ve } function Rs(Ue, Ve, en, gn, An, Nn, Ln) { var jn = Ue.$ / gn, Dn = Ue.$ % gn, Bn = Ue.m, Gn = Ue.s, ar = en + Ue.$, nr = ar; An = en + gn * An; var Jn = en + gn * Nn, xr = 280 + Gn.ua, dr = Ue.Pb ? jn : 16777216, Wn = 0 < Gn.ua ? Gn.Wa : null, Zn = Gn.wc, pr = ar < Jn ? bi(Gn, Dn, jn) : null; t(Ue.C < Nn), t(Jn <= An); var yr = !1; e: for (; ;) { for (; yr || ar < Jn;) { var vr = 0; if (jn >= dr) { var Mr = ar - en; t((dr = Ue).Pb), dr.wd = dr.m, dr.xd = Mr, 0 < dr.s.ua && Fn(dr.s.Wa, dr.s.vb), dr = jn + Ld } if (Dn & Zn || (pr = bi(Gn, Dn, jn)), t(pr != null), pr.Qb && (Ve[ar] = pr.qb, yr = !0), !yr) if (Ye(Bn), pr.jc) { vr = Bn, Mr = Ve; var Nr = ar, Hr = pr.pd[rn(vr) & cs - 1]; t(pr.jc), 256 > Hr.g ? (mn(vr, vr.u + Hr.g), Mr[Nr] = Hr.value, vr = 0) : (mn(vr, vr.u + Hr.g - 256), t(256 <= Hr.value), vr = Hr.value), vr == 0 && (yr = !0) } else vr = oi(pr.G[0], pr.H[0], Bn); if (Bn.h) break; if (yr || 256 > vr) { if (!yr) if (pr.nd) Ve[ar] = (pr.qb | vr << 8) >>> 0; else { if (Ye(Bn), yr = oi(pr.G[1], pr.H[1], Bn), Ye(Bn), Mr = oi(pr.G[2], pr.H[2], Bn), Nr = oi(pr.G[3], pr.H[3], Bn), Bn.h) break; Ve[ar] = (Nr << 24 | yr << 16 | vr << 8 | Mr) >>> 0 } if (yr = !1, ++ar, ++Dn >= gn && (Dn = 0, ++jn, Ln != null && jn <= Nn && !(jn % 16) && Ln(Ue, jn), Wn != null)) for (; nr < ar;)vr = Ve[nr++], Wn.X[(506832829 * vr & 4294967295) >>> Wn.Mb] = vr } else if (280 > vr) { if (vr = pi(vr - 256, Bn), Mr = oi(pr.G[4], pr.H[4], Bn), Ye(Bn), Mr = ni(gn, Mr = pi(Mr, Bn)), Bn.h) break; if (ar - en < Mr || An - ar < vr) break e; for (Nr = 0; Nr < vr; ++Nr)Ve[ar + Nr] = Ve[ar + Nr - Mr]; for (ar += vr, Dn += vr; Dn >= gn;)Dn -= gn, ++jn, Ln != null && jn <= Nn && !(jn % 16) && Ln(Ue, jn); if (t(ar <= An), Dn & Zn && (pr = bi(Gn, Dn, jn)), Wn != null) for (; nr < ar;)vr = Ve[nr++], Wn.X[(506832829 * vr & 4294967295) >>> Wn.Mb] = vr } else { if (!(vr < xr)) break e; for (yr = vr - 280, t(Wn != null); nr < ar;)vr = Ve[nr++], Wn.X[(506832829 * vr & 4294967295) >>> Wn.Mb] = vr; vr = ar, t(!(yr >>> (Mr = Wn).Xa)), Ve[vr] = Mr.X[yr], yr = !0 } yr || t(Bn.h == hn(Bn)) } if (Ue.Pb && Bn.h && ar < An) t(Ue.m.h), Ue.a = 5, Ue.m = Ue.wd, Ue.$ = Ue.xd, 0 < Ue.s.ua && Fn(Ue.s.vb, Ue.s.Wa); else { if (Bn.h) break e; Ln?.(Ue, jn > Nn ? Nn : jn), Ue.a = 0, Ue.$ = ar - en } return 1 } return Ue.a = 3, 0 } function Bs(Ue) { t(Ue != null), Ue.vc = null, Ue.yc = null, Ue.Ya = null; var Ve = Ue.Wa; Ve != null && (Ve.X = null), Ue.vb = null, t(Ue != null) } function ws() { var Ue = new Vu; return Ue == null ? null : (Ue.a = 0, Ue.xb = Gl, Rr("Predictor", "VP8LPredictors"), Rr("Predictor", "VP8LPredictors_C"), Rr("PredictorAdd", "VP8LPredictorsAdd"), Rr("PredictorAdd", "VP8LPredictorsAdd_C"), du = Dr, Co = Cr, js = Tr, As = wi, To = Jr, qs = mr, ga = Kn, on.VP8LMapColor32b = bs, on.VP8LMapColor8b = jc, Ue) } function Li(Ue, Ve, en, gn, An) { var Nn = 1, Ln = [Ue], jn = [Ve], Dn = gn.m, Bn = gn.s, Gn = null, ar = 0; e: for (; ;) { if (en) for (; Nn && We(Dn, 1);) { var nr = Ln, Jn = jn, xr = gn, dr = 1, Wn = xr.m, Zn = xr.gc[xr.ab], pr = We(Wn, 2); if (xr.Oc & 1 << pr) Nn = 0; else { switch (xr.Oc |= 1 << pr, Zn.hc = pr, Zn.Ea = nr[0], Zn.nc = Jn[0], Zn.K = [null], ++xr.ab, t(4 >= xr.ab), pr) { case 0: case 1: Zn.b = We(Wn, 3) + 2, dr = Li(Yn(Zn.Ea, Zn.b), Yn(Zn.nc, Zn.b), 0, xr, Zn.K), Zn.K = Zn.K[0]; break; case 3: var yr, vr = We(Wn, 8) + 1, Mr = 16 < vr ? 0 : 4 < vr ? 1 : 2 < vr ? 2 : 3; if (nr[0] = Yn(Zn.Ea, Mr), Zn.b = Mr, yr = dr = Li(vr, 1, 0, xr, Zn.K)) { var Nr, Hr = vr, Pr = Zn, Ai = 1 << (8 >> Pr.b), Ci = Re(Ai); if (Ci == null) yr = 0; else { var ai = Pr.K[0], ri = Pr.w; for (Ci[0] = Pr.K[0][0], Nr = 1; Nr < 1 * Hr; ++Nr)Ci[Nr] = qn(ai[ri + Nr], Ci[Nr - 1]); for (; Nr < 4 * Ai; ++Nr)Ci[Nr] = 0; Pr.K[0] = null, Pr.K[0] = Ci, yr = 1 } } dr = yr; break; case 2: break; default: t(0) }Nn = dr } } if (Ln = Ln[0], jn = jn[0], Nn && We(Dn, 1) && !(Nn = 1 <= (ar = We(Dn, 4)) && 11 >= ar)) { gn.a = 3; break e } var Oi; if (Oi = Nn) t: { var Ti, Zr, ji, $r = gn, Xr = Ln, Ei = jn, Si = ar, Es = en, fs = $r.m, ns = $r.s, rs = [null], as = 1, la = 0, Ni = ul[Si]; n: for (; ;) { if (Es && We(fs, 1)) { var os = We(fs, 3) + 2, xa = Yn(Xr, os), Bo = Yn(Ei, os), pl = xa * Bo; if (!Li(xa, Bo, 0, $r, rs)) break n; for (rs = rs[0], ns.xc = os, Ti = 0; Ti < pl; ++Ti) { var Uo = rs[Ti] >> 8 & 65535; rs[Ti] = Uo, Uo >= as && (as = Uo + 1) } } if (fs.h) break n; for (Zr = 0; 5 > Zr; ++Zr) { var Hi = Js[Zr]; !Zr && 0 < Si && (Hi += 1 << Si), la < Hi && (la = Hi) } var Uc = Ce(as * Ni, En), xu = as, Ds = Ce(xu, Rn); if (Ds == null) var Gi = null; else t(65536 >= xu), Gi = Ds; var ml = Re(la); if (Gi == null || ml == null || Uc == null) { $r.a = 1; break n } var zo = Uc; for (Ti = ji = 0; Ti < as; ++Ti) { var Vs = Gi[Ti], Ho = Vs.G, Gs = Vs.H, zc = 0, Xl = 1, yu = 0; for (Zr = 0; 5 > Zr; ++Zr) { Hi = Js[Zr], Ho[Zr] = zo, Gs[Zr] = ji, !Zr && 0 < Si && (Hi += 1 << Si); i: { var Hc, Eu = Hi, qc = $r, Yl = ml, Fd = zo, Bd = ji, $c = 0, oo = qc.m, Lh = We(oo, 1); if (_e(Yl, 0, 0, Eu), Lh) { var Ud = We(oo, 1) + 1, zd = We(oo, 1), Ku = We(oo, zd == 0 ? 1 : 8); Yl[Ku] = 1, Ud == 2 && (Yl[Ku = We(oo, 8)] = 1); var Kl = 1 } else { var Qu = Re(19), Zu = We(oo, 4) + 4; if (19 < Zu) { qc.a = 3; var Vc = 0; break i } for (Hc = 0; Hc < Zu; ++Hc)Qu[no[Hc]] = We(oo, 3); var wu = void 0, Ql = void 0, Hd = qc, qd = Qu, lo = Eu, Gc = Yl, Au = 0, ya = Hd.m, Zl = 8, Ju = Ce(128, En); r: for (; fn(Ju, 0, 7, qd, 19);) { if (We(ya, 1)) { var $d = 2 + 2 * We(ya, 3); if ((wu = 2 + We(ya, $d)) > lo) break r } else wu = lo; for (Ql = 0; Ql < lo && wu--;) { Ye(ya); var ed = Ju[0 + (127 & rn(ya))]; mn(ya, ya.u + ed.g); var gl = ed.value; if (16 > gl) Gc[Ql++] = gl, gl != 0 && (Zl = gl); else { var Vd = gl == 16, nd = gl - 16, rd = oa[nd], id = We(ya, pu[nd]) + rd; if (Ql + id > lo) break r; for (var Gd = Vd ? Zl : 0; 0 < id--;)Gc[Ql++] = Gd } } Au = 1; break r } Au || (Hd.a = 3), Kl = Au } (Kl = Kl && !oo.h) && ($c = fn(Fd, Bd, 8, Yl, Eu)), Kl && $c != 0 ? Vc = $c : (qc.a = 3, Vc = 0) } if (Vc == 0) break n; if (Xl && cl[Zr] == 1 && (Xl = zo[ji].g == 0), zc += zo[ji].g, ji += Vc, 3 >= Zr) { var vl, Su = ml[0]; for (vl = 1; vl < Hi; ++vl)ml[vl] > Su && (Su = ml[vl]); yu += Su } } if (Vs.nd = Xl, Vs.Qb = 0, Xl && (Vs.qb = (Ho[3][Gs[3] + 0].value << 24 | Ho[1][Gs[1] + 0].value << 16 | Ho[2][Gs[2] + 0].value) >>> 0, zc == 0 && 256 > Ho[0][Gs[0] + 0].value && (Vs.Qb = 1, Vs.qb += Ho[0][Gs[0] + 0].value << 8)), Vs.jc = !Vs.Qb && 6 > yu, Vs.jc) { var Wc, co = Vs; for (Wc = 0; Wc < cs; ++Wc) { var Fa = Wc, uo = co.pd[Fa], Xc = co.G[0][co.H[0] + Fa]; 256 <= Xc.value ? (uo.g = Xc.g + 256, uo.value = Xc.value) : (uo.g = 0, uo.value = 0, Fa >>= si(Xc, 8, uo), Fa >>= si(co.G[1][co.H[1] + Fa], 16, uo), Fa >>= si(co.G[2][co.H[2] + Fa], 0, uo), si(co.G[3][co.H[3] + Fa], 24, uo)) } } } ns.vc = rs, ns.Wb = as, ns.Ya = Gi, ns.yc = Uc, Oi = 1; break t } Oi = 0 } if (!(Nn = Oi)) { gn.a = 3; break e } if (0 < ar) { if (Bn.ua = 1 << ar, !sr(Bn.Wa, ar)) { gn.a = 1, Nn = 0; break e } } else Bn.ua = 0; var Yc = gn, sd = Ln, Wd = jn, ad = Yc.s, od = ad.xc; if (Yc.c = sd, Yc.i = Wd, ad.md = Yn(sd, od), ad.wc = od == 0 ? -1 : (1 << od) - 1, en) { gn.xb = Md; break e } if ((Gn = Re(Ln * jn)) == null) { gn.a = 1, Nn = 0; break e } Nn = (Nn = Rs(gn, Gn, 0, Ln, jn, jn, null)) && !Dn.h; break e } return Nn ? (An != null ? An[0] = Gn : (t(Gn == null), t(en)), gn.$ = 0, en || Bs(Bn)) : Bs(Bn), Nn } function po(Ue, Ve) { var en = Ue.c * Ue.i, gn = en + Ve + 16 * Ve; return t(Ue.c <= Ve), Ue.V = Re(gn), Ue.V == null ? (Ue.Ta = null, Ue.Ua = 0, Ue.a = 1, 0) : (Ue.Ta = Ue.V, Ue.Ua = Ue.Ba + en + Ve, 1) } function Xo(Ue, Ve) { var en = Ue.C, gn = Ve - en, An = Ue.V, Nn = Ue.Ba + Ue.c * en; for (t(Ve <= Ue.l.o); 0 < gn;) { var Ln = 16 < gn ? 16 : gn, jn = Ue.l.ma, Dn = Ue.l.width, Bn = Dn * Ln, Gn = jn.ca, ar = jn.tb + Dn * en, nr = Ue.Ta, Jn = Ue.Ua; ms(Ue, Ln, An, Nn), ki(nr, Jn, Gn, ar, Bn), Xs(jn, en, en + Ln, Gn, ar, Dn), gn -= Ln, An += Ln * Ue.c, en += Ln } t(en == Ve), Ue.C = Ue.Ma = Ve } function ta() { this.ub = this.yd = this.td = this.Rb = 0 } function da() { this.Kd = this.Ld = this.Ud = this.Td = this.i = this.c = 0 } function _l() { this.Fb = this.Bb = this.Cb = 0, this.Zb = Re(4), this.Lb = Re(4) } function vc() { this.Yb = function () { var Ue = []; return function Ve(en, gn, An) { for (var Nn = An[gn], Ln = 0; Ln < Nn && (en.push(An.length > gn + 1 ? [] : 0), !(An.length < gn + 1)); Ln++)Ve(en[Ln], gn + 1, An) }(Ue, 0, [3, 11]), Ue }() } function eu() { this.jb = Re(3), this.Wc = Me([4, 8], vc), this.Xc = Me([4, 17], vc) } function Uu() { this.Pc = this.wb = this.Tb = this.zd = 0, this.vd = new Re(4), this.od = new Re(4) } function Ha() { this.ld = this.La = this.dd = this.tc = 0 } function Yo() { this.Na = this.la = 0 } function ha() { this.Sc = [0, 0], this.Eb = [0, 0], this.Qc = [0, 0], this.ia = this.lc = 0 } function Ko() { this.ad = Re(384), this.Za = 0, this.Ob = Re(16), this.$b = this.Ad = this.ia = this.Gc = this.Hc = this.Dd = 0 } function tu() { this.uc = this.M = this.Nb = 0, this.wa = Array(new Ha), this.Y = 0, this.ya = Array(new Ko), this.aa = 0, this.l = new mo } function qa() { this.y = Re(16), this.f = Re(8), this.ea = Re(8) } function bc() { this.cb = this.a = 0, this.sc = "", this.m = new dn, this.Od = new ta, this.Kc = new da, this.ed = new Uu, this.Qa = new _l, this.Ic = this.$c = this.Aa = 0, this.D = new tu, this.Xb = this.Va = this.Hb = this.zb = this.yb = this.Ub = this.za = 0, this.Jc = Ce(8, dn), this.ia = 0, this.pb = Ce(4, ha), this.Pa = new eu, this.Bd = this.kc = 0, this.Ac = [], this.Bc = 0, this.zc = [0, 0, 0, 0], this.Gd = Array(new qa), this.Hd = 0, this.rb = Array(new Yo), this.sb = 0, this.wa = Array(new Ha), this.Y = 0, this.oc = [], this.pc = 0, this.sa = [], this.ta = 0, this.qa = [], this.ra = 0, this.Ha = [], this.B = this.R = this.Ia = 0, this.Ec = [], this.M = this.ja = this.Vb = this.Fc = 0, this.ya = Array(new Ko), this.L = this.aa = 0, this.gd = Me([4, 2], Ha), this.ga = null, this.Fa = [], this.Cc = this.qc = this.P = 0, this.Gb = [], this.Uc = 0, this.mb = [], this.nb = 0, this.rc = [], this.Ga = this.Vc = 0 } function mo() { this.T = this.U = this.ka = this.height = this.width = 0, this.y = [], this.f = [], this.ea = [], this.Rc = this.fa = this.W = this.N = this.O = 0, this.ma = "void", this.put = "VP8IoPutHook", this.ac = "VP8IoSetupHook", this.bc = "VP8IoTeardownHook", this.ha = this.Kb = 0, this.data = [], this.hb = this.ib = this.da = this.o = this.j = this.va = this.v = this.Da = this.ob = this.w = 0, this.F = [], this.J = 0 } function zu() { var Ue = new bc; return Ue != null && (Ue.a = 0, Ue.sc = "OK", Ue.cb = 0, Ue.Xb = 0, us || (us = nu)), Ue } function Xi(Ue, Ve, en) { return Ue.a == 0 && (Ue.a = Ve, Ue.sc = en, Ue.cb = 0), 0 } function Ls(Ue, Ve, en) { return 3 <= en && Ue[Ve + 0] == 157 && Ue[Ve + 1] == 1 && Ue[Ve + 2] == 42 } function xc(Ue, Ve) { if (Ue == null) return 0; if (Ue.a = 0, Ue.sc = "OK", Ve == null) return Xi(Ue, 2, "null VP8Io passed to VP8GetHeaders()"); var en = Ve.data, gn = Ve.w, An = Ve.ha; if (4 > An) return Xi(Ue, 7, "Truncated header."); var Nn = en[gn + 0] | en[gn + 1] << 8 | en[gn + 2] << 16, Ln = Ue.Od; if (Ln.Rb = !(1 & Nn), Ln.td = Nn >> 1 & 7, Ln.yd = Nn >> 4 & 1, Ln.ub = Nn >> 5, 3 < Ln.td) return Xi(Ue, 3, "Incorrect keyframe parameters."); if (!Ln.yd) return Xi(Ue, 4, "Frame not displayable."); gn += 3, An -= 3; var jn = Ue.Kc; if (Ln.Rb) { if (7 > An) return Xi(Ue, 7, "cannot parse picture header"); if (!Ls(en, gn, An)) return Xi(Ue, 3, "Bad code word"); jn.c = 16383 & (en[gn + 4] << 8 | en[gn + 3]), jn.Td = en[gn + 4] >> 6, jn.i = 16383 & (en[gn + 6] << 8 | en[gn + 5]), jn.Ud = en[gn + 6] >> 6, gn += 7, An -= 7, Ue.za = jn.c + 15 >> 4, Ue.Ub = jn.i + 15 >> 4, Ve.width = jn.c, Ve.height = jn.i, Ve.Da = 0, Ve.j = 0, Ve.v = 0, Ve.va = Ve.width, Ve.o = Ve.height, Ve.da = 0, Ve.ib = Ve.width, Ve.hb = Ve.height, Ve.U = Ve.width, Ve.T = Ve.height, _e((Nn = Ue.Pa).jb, 0, 255, Nn.jb.length), t((Nn = Ue.Qa) != null), Nn.Cb = 0, Nn.Bb = 0, Nn.Fb = 1, _e(Nn.Zb, 0, 0, Nn.Zb.length), _e(Nn.Lb, 0, 0, Nn.Lb) } if (Ln.ub > An) return Xi(Ue, 7, "bad partition length"); In(Nn = Ue.m, en, gn, Ln.ub), gn += Ln.ub, An -= Ln.ub, Ln.Rb && (jn.Ld = pn(Nn), jn.Kd = pn(Nn)), jn = Ue.Qa; var Dn, Bn = Ue.Pa; if (t(Nn != null), t(jn != null), jn.Cb = pn(Nn), jn.Cb) { if (jn.Bb = pn(Nn), pn(Nn)) { for (jn.Fb = pn(Nn), Dn = 0; 4 > Dn; ++Dn)jn.Zb[Dn] = pn(Nn) ? vn(Nn, 7) : 0; for (Dn = 0; 4 > Dn; ++Dn)jn.Lb[Dn] = pn(Nn) ? vn(Nn, 6) : 0 } if (jn.Bb) for (Dn = 0; 3 > Dn; ++Dn)Bn.jb[Dn] = pn(Nn) ? xn(Nn, 8) : 255 } else jn.Bb = 0; if (Nn.Ka) return Xi(Ue, 3, "cannot parse segment header"); if ((jn = Ue.ed).zd = pn(Nn), jn.Tb = xn(Nn, 6), jn.wb = xn(Nn, 3), jn.Pc = pn(Nn), jn.Pc && pn(Nn)) { for (Bn = 0; 4 > Bn; ++Bn)pn(Nn) && (jn.vd[Bn] = vn(Nn, 6)); for (Bn = 0; 4 > Bn; ++Bn)pn(Nn) && (jn.od[Bn] = vn(Nn, 6)) } if (Ue.L = jn.Tb == 0 ? 0 : jn.zd ? 1 : 2, Nn.Ka) return Xi(Ue, 3, "cannot parse filter header"); var Gn = An; if (An = Dn = gn, gn = Dn + Gn, jn = Gn, Ue.Xb = (1 << xn(Ue.m, 2)) - 1, Gn < 3 * (Bn = Ue.Xb)) en = 7; else { for (Dn += 3 * Bn, jn -= 3 * Bn, Gn = 0; Gn < Bn; ++Gn) { var ar = en[An + 0] | en[An + 1] << 8 | en[An + 2] << 16; ar > jn && (ar = jn), In(Ue.Jc[+Gn], en, Dn, ar), Dn += ar, jn -= ar, An += 3 } In(Ue.Jc[+Bn], en, Dn, jn), en = Dn < gn ? 0 : 5 } if (en != 0) return Xi(Ue, en, "cannot parse partitions"); for (en = xn(Dn = Ue.m, 7), An = pn(Dn) ? vn(Dn, 4) : 0, gn = pn(Dn) ? vn(Dn, 4) : 0, jn = pn(Dn) ? vn(Dn, 4) : 0, Bn = pn(Dn) ? vn(Dn, 4) : 0, Dn = pn(Dn) ? vn(Dn, 4) : 0, Gn = Ue.Qa, ar = 0; 4 > ar; ++ar) { if (Gn.Cb) { var nr = Gn.Zb[ar]; Gn.Fb || (nr += en) } else { if (0 < ar) { Ue.pb[ar] = Ue.pb[0]; continue } nr = en } var Jn = Ue.pb[ar]; Jn.Sc[0] = kc[Qs(nr + An, 127)], Jn.Sc[1] = Ic[Qs(nr + 0, 127)], Jn.Eb[0] = 2 * kc[Qs(nr + gn, 127)], Jn.Eb[1] = 101581 * Ic[Qs(nr + jn, 127)] >> 16, 8 > Jn.Eb[1] && (Jn.Eb[1] = 8), Jn.Qc[0] = kc[Qs(nr + Bn, 117)], Jn.Qc[1] = Ic[Qs(nr + Dn, 127)], Jn.lc = nr + Dn } if (!Ln.Rb) return Xi(Ue, 4, "Not a key frame."); for (pn(Nn), Ln = Ue.Pa, en = 0; 4 > en; ++en) { for (An = 0; 8 > An; ++An)for (gn = 0; 3 > gn; ++gn)for (jn = 0; 11 > jn; ++jn)Bn = yn(Nn, dl[en][An][gn][jn]) ? xn(Nn, 8) : Ma[en][An][gn][jn], Ln.Wc[en][An].Yb[gn][jn] = Bn; for (An = 0; 17 > An; ++An)Ln.Xc[en][An] = Ln.Wc[en][jd[An]] } return Ue.kc = pn(Nn), Ue.kc && (Ue.Bd = xn(Nn, 8)), Ue.cb = 1 } function nu(Ue, Ve, en, gn, An, Nn, Ln) { var jn = Ve[An].Yb[en]; for (en = 0; 16 > An; ++An) { if (!yn(Ue, jn[en + 0])) return An; for (; !yn(Ue, jn[en + 1]);)if (jn = Ve[++An].Yb[0], en = 0, An == 16) return 16; var Dn = Ve[An + 1].Yb; if (yn(Ue, jn[en + 2])) { var Bn = Ue, Gn = 0; if (yn(Bn, (nr = jn)[(ar = en) + 3])) if (yn(Bn, nr[ar + 6])) { for (jn = 0, ar = 2 * (Gn = yn(Bn, nr[ar + 8])) + (nr = yn(Bn, nr[ar + 9 + Gn])), Gn = 0, nr = Qi[ar]; nr[jn]; ++jn)Gn += Gn + yn(Bn, nr[jn]); Gn += 3 + (8 << ar) } else yn(Bn, nr[ar + 7]) ? (Gn = 7 + 2 * yn(Bn, 165), Gn += yn(Bn, 145)) : Gn = 5 + yn(Bn, 159); else Gn = yn(Bn, nr[ar + 4]) ? 3 + yn(Bn, nr[ar + 5]) : 2; jn = Dn[2] } else Gn = 1, jn = Dn[1]; Dn = Ln + Ri[An], 0 > (Bn = Ue).b && an(Bn); var ar, nr = Bn.b, Jn = (ar = Bn.Ca >> 1) - (Bn.I >> nr) >> 31; --Bn.b, Bn.Ca += Jn, Bn.Ca |= 1, Bn.I -= (ar + 1 & Jn) << nr, Nn[Dn] = ((Gn ^ Jn) - Jn) * gn[(0 < An) + 0] } return 16 } function go(Ue) { var Ve = Ue.rb[Ue.sb - 1]; Ve.la = 0, Ve.Na = 0, _e(Ue.zc, 0, 0, Ue.zc.length), Ue.ja = 0 } function ru(Ue, Ve) { if (Ue == null) return 0; if (Ve == null) return Xi(Ue, 2, "NULL VP8Io parameter in VP8Decode()."); if (!Ue.cb && !xc(Ue, Ve)) return 0; if (t(Ue.cb), Ve.ac == null || Ve.ac(Ve)) { Ve.ob && (Ue.L = 0); var en = ao[Ue.L]; if (Ue.L == 2 ? (Ue.yb = 0, Ue.zb = 0) : (Ue.yb = Ve.v - en >> 4, Ue.zb = Ve.j - en >> 4, 0 > Ue.yb && (Ue.yb = 0), 0 > Ue.zb && (Ue.zb = 0)), Ue.Va = Ve.o + 15 + en >> 4, Ue.Hb = Ve.va + 15 + en >> 4, Ue.Hb > Ue.za && (Ue.Hb = Ue.za), Ue.Va > Ue.Ub && (Ue.Va = Ue.Ub), 0 < Ue.L) { var gn = Ue.ed; for (en = 0; 4 > en; ++en) { var An; if (Ue.Qa.Cb) { var Nn = Ue.Qa.Lb[en]; Ue.Qa.Fb || (Nn += gn.Tb) } else Nn = gn.Tb; for (An = 0; 1 >= An; ++An) { var Ln = Ue.gd[en][An], jn = Nn; if (gn.Pc && (jn += gn.vd[0], An && (jn += gn.od[0])), 0 < (jn = 0 > jn ? 0 : 63 < jn ? 63 : jn)) { var Dn = jn; 0 < gn.wb && (Dn = 4 < gn.wb ? Dn >> 2 : Dn >> 1) > 9 - gn.wb && (Dn = 9 - gn.wb), 1 > Dn && (Dn = 1), Ln.dd = Dn, Ln.tc = 2 * jn + Dn, Ln.ld = 40 <= jn ? 2 : 15 <= jn ? 1 : 0 } else Ln.tc = 0; Ln.La = An } } } en = 0 } else Xi(Ue, 6, "Frame setup failed"), en = Ue.a; if (en = en == 0) { if (en) { Ue.$c = 0, 0 < Ue.Aa || (Ue.Ic = kd); e: { en = Ue.Ic, gn = 4 * (Dn = Ue.za); var Bn = 32 * Dn, Gn = Dn + 1, ar = 0 < Ue.L ? Dn * (0 < Ue.Aa ? 2 : 1) : 0, nr = (Ue.Aa == 2 ? 2 : 1) * Dn; if ((Ln = gn + 832 + (An = 3 * (16 * en + ao[Ue.L]) / 2 * Bn) + (Nn = Ue.Fa != null && 0 < Ue.Fa.length ? Ue.Kc.c * Ue.Kc.i : 0)) != Ln) en = 0; else { if (Ln > Ue.Vb) { if (Ue.Vb = 0, Ue.Ec = Re(Ln), Ue.Fc = 0, Ue.Ec == null) { en = Xi(Ue, 1, "no memory during frame initialization."); break e } Ue.Vb = Ln } Ln = Ue.Ec, jn = Ue.Fc, Ue.Ac = Ln, Ue.Bc = jn, jn += gn, Ue.Gd = Ce(Bn, qa), Ue.Hd = 0, Ue.rb = Ce(Gn + 1, Yo), Ue.sb = 1, Ue.wa = ar ? Ce(ar, Ha) : null, Ue.Y = 0, Ue.D.Nb = 0, Ue.D.wa = Ue.wa, Ue.D.Y = Ue.Y, 0 < Ue.Aa && (Ue.D.Y += Dn), t(!0), Ue.oc = Ln, Ue.pc = jn, jn += 832, Ue.ya = Ce(nr, Ko), Ue.aa = 0, Ue.D.ya = Ue.ya, Ue.D.aa = Ue.aa, Ue.Aa == 2 && (Ue.D.aa += Dn), Ue.R = 16 * Dn, Ue.B = 8 * Dn, Dn = (Bn = ao[Ue.L]) * Ue.R, Bn = Bn / 2 * Ue.B, Ue.sa = Ln, Ue.ta = jn + Dn, Ue.qa = Ue.sa, Ue.ra = Ue.ta + 16 * en * Ue.R + Bn, Ue.Ha = Ue.qa, Ue.Ia = Ue.ra + 8 * en * Ue.B + Bn, Ue.$c = 0, jn += An, Ue.mb = Nn ? Ln : null, Ue.nb = Nn ? jn : null, t(jn + Nn <= Ue.Fc + Ue.Vb), go(Ue), _e(Ue.Ac, Ue.Bc, 0, gn), en = 1 } } if (en) { if (Ve.ka = 0, Ve.y = Ue.sa, Ve.O = Ue.ta, Ve.f = Ue.qa, Ve.N = Ue.ra, Ve.ea = Ue.Ha, Ve.Vd = Ue.Ia, Ve.fa = Ue.R, Ve.Rc = Ue.B, Ve.F = null, Ve.J = 0, !Ja) { for (en = -255; 255 >= en; ++en)ts[255 + en] = 0 > en ? -en : en; for (en = -1020; 1020 >= en; ++en)sa[1020 + en] = -128 > en ? -128 : 127 < en ? 127 : en; for (en = -112; 112 >= en; ++en)jo[112 + en] = -16 > en ? -16 : 15 < en ? 15 : en; for (en = -255; 510 >= en; ++en)Mo[255 + en] = 0 > en ? 0 : 255 < en ? 255 : en; Ja = 1 } Oa = vo, va = Ec, ba = $a, ss = iu, $s = wc, Yi = yc, il = Zo, La = Jo, Hl = $u, No = Cc, Po = qu, Oo = jl, sl = Ml, ql = uu, Lo = Eo, Za = Ks, al = Pa, Ki = Hu, Ms[0] = zs, Ms[1] = su, Ms[2] = _c, Ms[3] = ou, Ms[4] = na, Ms[5] = Ca, Ms[6] = Nl, Ms[7] = ra, Ms[8] = Pl, Ms[9] = Rc, io[0] = Tl, io[1] = Sc, io[2] = Va, io[3] = Cl, io[4] = gs, io[5] = bo, io[6] = Wa, ea[0] = Xa, ea[1] = au, ea[2] = lu, ea[3] = xo, ea[4] = Ys, ea[5] = Cs, ea[6] = yo, en = 1 } else en = 0 } en && (en = function (Jn, xr) { for (Jn.M = 0; Jn.M < Jn.Va; ++Jn.M) { var dr, Wn = Jn.Jc[Jn.M & Jn.Xb], Zn = Jn.m, pr = Jn; for (dr = 0; dr < pr.za; ++dr) { var yr = Zn, vr = pr, Mr = vr.Ac, Nr = vr.Bc + 4 * dr, Hr = vr.zc, Pr = vr.ya[vr.aa + dr]; if (vr.Qa.Bb ? Pr.$b = yn(yr, vr.Pa.jb[0]) ? 2 + yn(yr, vr.Pa.jb[2]) : yn(yr, vr.Pa.jb[1]) : Pr.$b = 0, vr.kc && (Pr.Ad = yn(yr, vr.Bd)), Pr.Za = !yn(yr, 145) + 0, Pr.Za) { var Ai = Pr.Ob, Ci = 0; for (vr = 0; 4 > vr; ++vr) { var ai, ri = Hr[0 + vr]; for (ai = 0; 4 > ai; ++ai) { ri = Wu[Mr[Nr + ai]][ri]; for (var Oi = ko[yn(yr, ri[0])]; 0 < Oi;)Oi = ko[2 * Oi + yn(yr, ri[Oi])]; ri = -Oi, Mr[Nr + ai] = ri } Ee(Ai, Ci, Mr, Nr, 4), Ci += 4, Hr[0 + vr] = ri } } else ri = yn(yr, 156) ? yn(yr, 128) ? 1 : 3 : yn(yr, 163) ? 2 : 0, Pr.Ob[0] = ri, _e(Mr, Nr, ri, 4), _e(Hr, 0, ri, 4); Pr.Dd = yn(yr, 142) ? yn(yr, 114) ? yn(yr, 183) ? 1 : 3 : 2 : 0 } if (pr.m.Ka) return Xi(Jn, 7, "Premature end-of-partition0 encountered."); for (; Jn.ja < Jn.za; ++Jn.ja) { if (pr = Wn, yr = (Zn = Jn).rb[Zn.sb - 1], Mr = Zn.rb[Zn.sb + Zn.ja], dr = Zn.ya[Zn.aa + Zn.ja], Nr = Zn.kc ? dr.Ad : 0) yr.la = Mr.la = 0, dr.Za || (yr.Na = Mr.Na = 0), dr.Hc = 0, dr.Gc = 0, dr.ia = 0; else { var Ti, Zr; if (yr = Mr, Mr = pr, Nr = Zn.Pa.Xc, Hr = Zn.ya[Zn.aa + Zn.ja], Pr = Zn.pb[Hr.$b], vr = Hr.ad, Ai = 0, Ci = Zn.rb[Zn.sb - 1], ri = ai = 0, _e(vr, Ai, 0, 384), Hr.Za) var ji = 0, $r = Nr[3]; else { Oi = Re(16); var Xr = yr.Na + Ci.Na; if (Xr = us(Mr, Nr[1], Xr, Pr.Eb, 0, Oi, 0), yr.Na = Ci.Na = (0 < Xr) + 0, 1 < Xr) Oa(Oi, 0, vr, Ai); else { var Ei = Oi[0] + 3 >> 3; for (Oi = 0; 256 > Oi; Oi += 16)vr[Ai + Oi] = Ei } ji = 1, $r = Nr[0] } var Si = 15 & yr.la, Es = 15 & Ci.la; for (Oi = 0; 4 > Oi; ++Oi) { var fs = 1 & Es; for (Ei = Zr = 0; 4 > Ei; ++Ei)Si = Si >> 1 | (fs = (Xr = us(Mr, $r, Xr = fs + (1 & Si), Pr.Sc, ji, vr, Ai)) > ji) << 7, Zr = Zr << 2 | (3 < Xr ? 3 : 1 < Xr ? 2 : vr[Ai + 0] != 0), Ai += 16; Si >>= 4, Es = Es >> 1 | fs << 7, ai = (ai << 8 | Zr) >>> 0 } for ($r = Si, ji = Es >> 4, Ti = 0; 4 > Ti; Ti += 2) { for (Zr = 0, Si = yr.la >> 4 + Ti, Es = Ci.la >> 4 + Ti, Oi = 0; 2 > Oi; ++Oi) { for (fs = 1 & Es, Ei = 0; 2 > Ei; ++Ei)Xr = fs + (1 & Si), Si = Si >> 1 | (fs = 0 < (Xr = us(Mr, Nr[2], Xr, Pr.Qc, 0, vr, Ai))) << 3, Zr = Zr << 2 | (3 < Xr ? 3 : 1 < Xr ? 2 : vr[Ai + 0] != 0), Ai += 16; Si >>= 2, Es = Es >> 1 | fs << 5 } ri |= Zr << 4 * Ti, $r |= Si << 4 << Ti, ji |= (240 & Es) << Ti } yr.la = $r, Ci.la = ji, Hr.Hc = ai, Hr.Gc = ri, Hr.ia = 43690 & ri ? 0 : Pr.ia, Nr = !(ai | ri) } if (0 < Zn.L && (Zn.wa[Zn.Y + Zn.ja] = Zn.gd[dr.$b][dr.Za], Zn.wa[Zn.Y + Zn.ja].La |= !Nr), pr.Ka) return Xi(Jn, 7, "Premature end-of-file encountered.") } if (go(Jn), Zn = xr, pr = 1, dr = (Wn = Jn).D, yr = 0 < Wn.L && Wn.M >= Wn.zb && Wn.M <= Wn.Va, Wn.Aa == 0) e: { if (dr.M = Wn.M, dr.uc = yr, Ka(Wn, dr), pr = 1, dr = (Zr = Wn.D).Nb, yr = (ri = ao[Wn.L]) * Wn.R, Mr = ri / 2 * Wn.B, Oi = 16 * dr * Wn.R, Ei = 8 * dr * Wn.B, Nr = Wn.sa, Hr = Wn.ta - yr + Oi, Pr = Wn.qa, vr = Wn.ra - Mr + Ei, Ai = Wn.Ha, Ci = Wn.Ia - Mr + Ei, Es = (Si = Zr.M) == 0, ai = Si >= Wn.Va - 1, Wn.Aa == 2 && Ka(Wn, Zr), Zr.uc) for (fs = (Xr = Wn).D.M, t(Xr.D.uc), Zr = Xr.yb; Zr < Xr.Hb; ++Zr) { ji = Zr, $r = fs; var ns = (rs = (Hi = Xr).D).Nb; Ti = Hi.R; var rs = rs.wa[rs.Y + ji], as = Hi.sa, la = Hi.ta + 16 * ns * Ti + 16 * ji, Ni = rs.dd, os = rs.tc; if (os != 0) if (t(3 <= os), Hi.L == 1) 0 < ji && Za(as, la, Ti, os + 4), rs.La && Ki(as, la, Ti, os), 0 < $r && Lo(as, la, Ti, os + 4), rs.La && al(as, la, Ti, os); else { var xa = Hi.B, Bo = Hi.qa, pl = Hi.ra + 8 * ns * xa + 8 * ji, Uo = Hi.Ha, Hi = Hi.Ia + 8 * ns * xa + 8 * ji; ns = rs.ld, 0 < ji && (La(as, la, Ti, os + 4, Ni, ns), No(Bo, pl, Uo, Hi, xa, os + 4, Ni, ns)), rs.La && (Oo(as, la, Ti, os, Ni, ns), ql(Bo, pl, Uo, Hi, xa, os, Ni, ns)), 0 < $r && (il(as, la, Ti, os + 4, Ni, ns), Hl(Bo, pl, Uo, Hi, xa, os + 4, Ni, ns)), rs.La && (Po(as, la, Ti, os, Ni, ns), sl(Bo, pl, Uo, Hi, xa, os, Ni, ns)) } } if (Wn.ia && alert("todo:DitherRow"), Zn.put != null) { if (Zr = 16 * Si, Si = 16 * (Si + 1), Es ? (Zn.y = Wn.sa, Zn.O = Wn.ta + Oi, Zn.f = Wn.qa, Zn.N = Wn.ra + Ei, Zn.ea = Wn.Ha, Zn.W = Wn.Ia + Ei) : (Zr -= ri, Zn.y = Nr, Zn.O = Hr, Zn.f = Pr, Zn.N = vr, Zn.ea = Ai, Zn.W = Ci), ai || (Si -= ri), Si > Zn.o && (Si = Zn.o), Zn.F = null, Zn.J = null, Wn.Fa != null && 0 < Wn.Fa.length && Zr < Si && (Zn.J = Pc(Wn, Zn, Zr, Si - Zr), Zn.F = Wn.mb, Zn.F == null && Zn.F.length == 0)) { pr = Xi(Wn, 3, "Could not decode alpha data."); break e } Zr < Zn.j && (ri = Zn.j - Zr, Zr = Zn.j, t(!(1 & ri)), Zn.O += Wn.R * ri, Zn.N += Wn.B * (ri >> 1), Zn.W += Wn.B * (ri >> 1), Zn.F != null && (Zn.J += Zn.width * ri)), Zr < Si && (Zn.O += Zn.v, Zn.N += Zn.v >> 1, Zn.W += Zn.v >> 1, Zn.F != null && (Zn.J += Zn.v), Zn.ka = Zr - Zn.j, Zn.U = Zn.va - Zn.v, Zn.T = Si - Zr, pr = Zn.put(Zn)) } dr + 1 != Wn.Ic || ai || (Ee(Wn.sa, Wn.ta - yr, Nr, Hr + 16 * Wn.R, yr), Ee(Wn.qa, Wn.ra - Mr, Pr, vr + 8 * Wn.B, Mr), Ee(Wn.Ha, Wn.Ia - Mr, Ai, Ci + 8 * Wn.B, Mr)) } if (!pr) return Xi(Jn, 6, "Output aborted.") } return 1 }(Ue, Ve)), Ve.bc != null && Ve.bc(Ve), en &= 1 } return en ? (Ue.cb = 0, en) : 0 } function Us(Ue, Ve, en, gn, An) { An = Ue[Ve + en + 32 * gn] + (An >> 3), Ue[Ve + en + 32 * gn] = -256 & An ? 0 > An ? 0 : 255 : An } function Rl(Ue, Ve, en, gn, An, Nn) { Us(Ue, Ve, 0, en, gn + An), Us(Ue, Ve, 1, en, gn + Nn), Us(Ue, Ve, 2, en, gn - Nn), Us(Ue, Ve, 3, en, gn - An) } function Bi(Ue) { return (20091 * Ue >> 16) + Ue } function Qo(Ue, Ve, en, gn) { var An, Nn = 0, Ln = Re(16); for (An = 0; 4 > An; ++An) { var jn = Ue[Ve + 0] + Ue[Ve + 8], Dn = Ue[Ve + 0] - Ue[Ve + 8], Bn = (35468 * Ue[Ve + 4] >> 16) - Bi(Ue[Ve + 12]), Gn = Bi(Ue[Ve + 4]) + (35468 * Ue[Ve + 12] >> 16); Ln[Nn + 0] = jn + Gn, Ln[Nn + 1] = Dn + Bn, Ln[Nn + 2] = Dn - Bn, Ln[Nn + 3] = jn - Gn, Nn += 4, Ve++ } for (An = Nn = 0; 4 > An; ++An)jn = (Ue = Ln[Nn + 0] + 4) + Ln[Nn + 8], Dn = Ue - Ln[Nn + 8], Bn = (35468 * Ln[Nn + 4] >> 16) - Bi(Ln[Nn + 12]), Us(en, gn, 0, 0, jn + (Gn = Bi(Ln[Nn + 4]) + (35468 * Ln[Nn + 12] >> 16))), Us(en, gn, 1, 0, Dn + Bn), Us(en, gn, 2, 0, Dn - Bn), Us(en, gn, 3, 0, jn - Gn), Nn++, gn += 32 } function yc(Ue, Ve, en, gn) { var An = Ue[Ve + 0] + 4, Nn = 35468 * Ue[Ve + 4] >> 16, Ln = Bi(Ue[Ve + 4]), jn = 35468 * Ue[Ve + 1] >> 16; Rl(en, gn, 0, An + Ln, Ue = Bi(Ue[Ve + 1]), jn), Rl(en, gn, 1, An + Nn, Ue, jn), Rl(en, gn, 2, An - Nn, Ue, jn), Rl(en, gn, 3, An - Ln, Ue, jn) } function Ec(Ue, Ve, en, gn, An) { Qo(Ue, Ve, en, gn), An && Qo(Ue, Ve + 16, en, gn + 4) } function $a(Ue, Ve, en, gn) { va(Ue, Ve + 0, en, gn, 1), va(Ue, Ve + 32, en, gn + 128, 1) } function iu(Ue, Ve, en, gn) { var An; for (Ue = Ue[Ve + 0] + 4, An = 0; 4 > An; ++An)for (Ve = 0; 4 > Ve; ++Ve)Us(en, gn, Ve, An, Ue) } function wc(Ue, Ve, en, gn) { Ue[Ve + 0] && ss(Ue, Ve + 0, en, gn), Ue[Ve + 16] && ss(Ue, Ve + 16, en, gn + 4), Ue[Ve + 32] && ss(Ue, Ve + 32, en, gn + 128), Ue[Ve + 48] && ss(Ue, Ve + 48, en, gn + 128 + 4) } function vo(Ue, Ve, en, gn) { var An, Nn = Re(16); for (An = 0; 4 > An; ++An) { var Ln = Ue[Ve + 0 + An] + Ue[Ve + 12 + An], jn = Ue[Ve + 4 + An] + Ue[Ve + 8 + An], Dn = Ue[Ve + 4 + An] - Ue[Ve + 8 + An], Bn = Ue[Ve + 0 + An] - Ue[Ve + 12 + An]; Nn[0 + An] = Ln + jn, Nn[8 + An] = Ln - jn, Nn[4 + An] = Bn + Dn, Nn[12 + An] = Bn - Dn } for (An = 0; 4 > An; ++An)Ln = (Ue = Nn[0 + 4 * An] + 3) + Nn[3 + 4 * An], jn = Nn[1 + 4 * An] + Nn[2 + 4 * An], Dn = Nn[1 + 4 * An] - Nn[2 + 4 * An], Bn = Ue - Nn[3 + 4 * An], en[gn + 0] = Ln + jn >> 3, en[gn + 16] = Bn + Dn >> 3, en[gn + 32] = Ln - jn >> 3, en[gn + 48] = Bn - Dn >> 3, gn += 64 } function Ac(Ue, Ve, en) { var gn, An = Ve - 32, Nn = xs, Ln = 255 - Ue[An - 1]; for (gn = 0; gn < en; ++gn) { var jn, Dn = Nn, Bn = Ln + Ue[Ve - 1]; for (jn = 0; jn < en; ++jn)Ue[Ve + jn] = Dn[Bn + Ue[An + jn]]; Ve += 32 } } function su(Ue, Ve) { Ac(Ue, Ve, 4) } function au(Ue, Ve) { Ac(Ue, Ve, 8) } function Sc(Ue, Ve) { Ac(Ue, Ve, 16) } function Va(Ue, Ve) { var en; for (en = 0; 16 > en; ++en)Ee(Ue, Ve + 32 * en, Ue, Ve - 32, 16) } function Cl(Ue, Ve) { var en; for (en = 16; 0 < en; --en)_e(Ue, Ve, Ue[Ve - 1], 16), Ve += 32 } function Ga(Ue, Ve, en) { var gn; for (gn = 0; 16 > gn; ++gn)_e(Ve, en + 32 * gn, Ue, 16) } function Tl(Ue, Ve) { var en, gn = 16; for (en = 0; 16 > en; ++en)gn += Ue[Ve - 1 + 32 * en] + Ue[Ve + en - 32]; Ga(gn >> 5, Ue, Ve) } function gs(Ue, Ve) { var en, gn = 8; for (en = 0; 16 > en; ++en)gn += Ue[Ve - 1 + 32 * en]; Ga(gn >> 4, Ue, Ve) } function bo(Ue, Ve) { var en, gn = 8; for (en = 0; 16 > en; ++en)gn += Ue[Ve + en - 32]; Ga(gn >> 4, Ue, Ve) } function Wa(Ue, Ve) { Ga(128, Ue, Ve) } function Yr(Ue, Ve, en) { return Ue + 2 * Ve + en + 2 >> 2 } function _c(Ue, Ve) { var en, gn = Ve - 32; for (gn = new Uint8Array([Yr(Ue[gn - 1], Ue[gn + 0], Ue[gn + 1]), Yr(Ue[gn + 0], Ue[gn + 1], Ue[gn + 2]), Yr(Ue[gn + 1], Ue[gn + 2], Ue[gn + 3]), Yr(Ue[gn + 2], Ue[gn + 3], Ue[gn + 4])]), en = 0; 4 > en; ++en)Ee(Ue, Ve + 32 * en, gn, 0, gn.length) } function ou(Ue, Ve) { var en = Ue[Ve - 1], gn = Ue[Ve - 1 + 32], An = Ue[Ve - 1 + 64], Nn = Ue[Ve - 1 + 96]; _n(Ue, Ve + 0, 16843009 * Yr(Ue[Ve - 1 - 32], en, gn)), _n(Ue, Ve + 32, 16843009 * Yr(en, gn, An)), _n(Ue, Ve + 64, 16843009 * Yr(gn, An, Nn)), _n(Ue, Ve + 96, 16843009 * Yr(An, Nn, Nn)) } function zs(Ue, Ve) { var en, gn = 4; for (en = 0; 4 > en; ++en)gn += Ue[Ve + en - 32] + Ue[Ve - 1 + 32 * en]; for (gn >>= 3, en = 0; 4 > en; ++en)_e(Ue, Ve + 32 * en, gn, 4) } function na(Ue, Ve) { var en = Ue[Ve - 1 + 0], gn = Ue[Ve - 1 + 32], An = Ue[Ve - 1 + 64], Nn = Ue[Ve - 1 - 32], Ln = Ue[Ve + 0 - 32], jn = Ue[Ve + 1 - 32], Dn = Ue[Ve + 2 - 32], Bn = Ue[Ve + 3 - 32]; Ue[Ve + 0 + 96] = Yr(gn, An, Ue[Ve - 1 + 96]), Ue[Ve + 1 + 96] = Ue[Ve + 0 + 64] = Yr(en, gn, An), Ue[Ve + 2 + 96] = Ue[Ve + 1 + 64] = Ue[Ve + 0 + 32] = Yr(Nn, en, gn), Ue[Ve + 3 + 96] = Ue[Ve + 2 + 64] = Ue[Ve + 1 + 32] = Ue[Ve + 0 + 0] = Yr(Ln, Nn, en), Ue[Ve + 3 + 64] = Ue[Ve + 2 + 32] = Ue[Ve + 1 + 0] = Yr(jn, Ln, Nn), Ue[Ve + 3 + 32] = Ue[Ve + 2 + 0] = Yr(Dn, jn, Ln), Ue[Ve + 3 + 0] = Yr(Bn, Dn, jn) } function Nl(Ue, Ve) { var en = Ue[Ve + 1 - 32], gn = Ue[Ve + 2 - 32], An = Ue[Ve + 3 - 32], Nn = Ue[Ve + 4 - 32], Ln = Ue[Ve + 5 - 32], jn = Ue[Ve + 6 - 32], Dn = Ue[Ve + 7 - 32]; Ue[Ve + 0 + 0] = Yr(Ue[Ve + 0 - 32], en, gn), Ue[Ve + 1 + 0] = Ue[Ve + 0 + 32] = Yr(en, gn, An), Ue[Ve + 2 + 0] = Ue[Ve + 1 + 32] = Ue[Ve + 0 + 64] = Yr(gn, An, Nn), Ue[Ve + 3 + 0] = Ue[Ve + 2 + 32] = Ue[Ve + 1 + 64] = Ue[Ve + 0 + 96] = Yr(An, Nn, Ln), Ue[Ve + 3 + 32] = Ue[Ve + 2 + 64] = Ue[Ve + 1 + 96] = Yr(Nn, Ln, jn), Ue[Ve + 3 + 64] = Ue[Ve + 2 + 96] = Yr(Ln, jn, Dn), Ue[Ve + 3 + 96] = Yr(jn, Dn, Dn) } function Ca(Ue, Ve) { var en = Ue[Ve - 1 + 0], gn = Ue[Ve - 1 + 32], An = Ue[Ve - 1 + 64], Nn = Ue[Ve - 1 - 32], Ln = Ue[Ve + 0 - 32], jn = Ue[Ve + 1 - 32], Dn = Ue[Ve + 2 - 32], Bn = Ue[Ve + 3 - 32]; Ue[Ve + 0 + 0] = Ue[Ve + 1 + 64] = Nn + Ln + 1 >> 1, Ue[Ve + 1 + 0] = Ue[Ve + 2 + 64] = Ln + jn + 1 >> 1, Ue[Ve + 2 + 0] = Ue[Ve + 3 + 64] = jn + Dn + 1 >> 1, Ue[Ve + 3 + 0] = Dn + Bn + 1 >> 1, Ue[Ve + 0 + 96] = Yr(An, gn, en), Ue[Ve + 0 + 64] = Yr(gn, en, Nn), Ue[Ve + 0 + 32] = Ue[Ve + 1 + 96] = Yr(en, Nn, Ln), Ue[Ve + 1 + 32] = Ue[Ve + 2 + 96] = Yr(Nn, Ln, jn), Ue[Ve + 2 + 32] = Ue[Ve + 3 + 96] = Yr(Ln, jn, Dn), Ue[Ve + 3 + 32] = Yr(jn, Dn, Bn) } function ra(Ue, Ve) { var en = Ue[Ve + 0 - 32], gn = Ue[Ve + 1 - 32], An = Ue[Ve + 2 - 32], Nn = Ue[Ve + 3 - 32], Ln = Ue[Ve + 4 - 32], jn = Ue[Ve + 5 - 32], Dn = Ue[Ve + 6 - 32], Bn = Ue[Ve + 7 - 32]; Ue[Ve + 0 + 0] = en + gn + 1 >> 1, Ue[Ve + 1 + 0] = Ue[Ve + 0 + 64] = gn + An + 1 >> 1, Ue[Ve + 2 + 0] = Ue[Ve + 1 + 64] = An + Nn + 1 >> 1, Ue[Ve + 3 + 0] = Ue[Ve + 2 + 64] = Nn + Ln + 1 >> 1, Ue[Ve + 0 + 32] = Yr(en, gn, An), Ue[Ve + 1 + 32] = Ue[Ve + 0 + 96] = Yr(gn, An, Nn), Ue[Ve + 2 + 32] = Ue[Ve + 1 + 96] = Yr(An, Nn, Ln), Ue[Ve + 3 + 32] = Ue[Ve + 2 + 96] = Yr(Nn, Ln, jn), Ue[Ve + 3 + 64] = Yr(Ln, jn, Dn), Ue[Ve + 3 + 96] = Yr(jn, Dn, Bn) } function Rc(Ue, Ve) { var en = Ue[Ve - 1 + 0], gn = Ue[Ve - 1 + 32], An = Ue[Ve - 1 + 64], Nn = Ue[Ve - 1 + 96]; Ue[Ve + 0 + 0] = en + gn + 1 >> 1, Ue[Ve + 2 + 0] = Ue[Ve + 0 + 32] = gn + An + 1 >> 1, Ue[Ve + 2 + 32] = Ue[Ve + 0 + 64] = An + Nn + 1 >> 1, Ue[Ve + 1 + 0] = Yr(en, gn, An), Ue[Ve + 3 + 0] = Ue[Ve + 1 + 32] = Yr(gn, An, Nn), Ue[Ve + 3 + 32] = Ue[Ve + 1 + 64] = Yr(An, Nn, Nn), Ue[Ve + 3 + 64] = Ue[Ve + 2 + 64] = Ue[Ve + 0 + 96] = Ue[Ve + 1 + 96] = Ue[Ve + 2 + 96] = Ue[Ve + 3 + 96] = Nn } function Pl(Ue, Ve) { var en = Ue[Ve - 1 + 0], gn = Ue[Ve - 1 + 32], An = Ue[Ve - 1 + 64], Nn = Ue[Ve - 1 + 96], Ln = Ue[Ve - 1 - 32], jn = Ue[Ve + 0 - 32], Dn = Ue[Ve + 1 - 32], Bn = Ue[Ve + 2 - 32]; Ue[Ve + 0 + 0] = Ue[Ve + 2 + 32] = en + Ln + 1 >> 1, Ue[Ve + 0 + 32] = Ue[Ve + 2 + 64] = gn + en + 1 >> 1, Ue[Ve + 0 + 64] = Ue[Ve + 2 + 96] = An + gn + 1 >> 1, Ue[Ve + 0 + 96] = Nn + An + 1 >> 1, Ue[Ve + 3 + 0] = Yr(jn, Dn, Bn), Ue[Ve + 2 + 0] = Yr(Ln, jn, Dn), Ue[Ve + 1 + 0] = Ue[Ve + 3 + 32] = Yr(en, Ln, jn), Ue[Ve + 1 + 32] = Ue[Ve + 3 + 64] = Yr(gn, en, Ln), Ue[Ve + 1 + 64] = Ue[Ve + 3 + 96] = Yr(An, gn, en), Ue[Ve + 1 + 96] = Yr(Nn, An, gn) } function lu(Ue, Ve) { var en; for (en = 0; 8 > en; ++en)Ee(Ue, Ve + 32 * en, Ue, Ve - 32, 8) } function xo(Ue, Ve) { var en; for (en = 0; 8 > en; ++en)_e(Ue, Ve, Ue[Ve - 1], 8), Ve += 32 } function Ta(Ue, Ve, en) { var gn; for (gn = 0; 8 > gn; ++gn)_e(Ve, en + 32 * gn, Ue, 8) } function Xa(Ue, Ve) { var en, gn = 8; for (en = 0; 8 > en; ++en)gn += Ue[Ve + en - 32] + Ue[Ve - 1 + 32 * en]; Ta(gn >> 4, Ue, Ve) } function Cs(Ue, Ve) { var en, gn = 4; for (en = 0; 8 > en; ++en)gn += Ue[Ve + en - 32]; Ta(gn >> 3, Ue, Ve) } function Ys(Ue, Ve) { var en, gn = 4; for (en = 0; 8 > en; ++en)gn += Ue[Ve - 1 + 32 * en]; Ta(gn >> 3, Ue, Ve) } function yo(Ue, Ve) { Ta(128, Ue, Ve) } function Na(Ue, Ve, en) { var gn = Ue[Ve - en], An = Ue[Ve + 0], Nn = 3 * (An - gn) + hu[1020 + Ue[Ve - 2 * en] - Ue[Ve + en]], Ln = ol[112 + (Nn + 4 >> 3)]; Ue[Ve - en] = xs[255 + gn + ol[112 + (Nn + 3 >> 3)]], Ue[Ve + 0] = xs[255 + An - Ln] } function cu(Ue, Ve, en, gn) { var An = Ue[Ve + 0], Nn = Ue[Ve + en]; return aa[255 + Ue[Ve - 2 * en] - Ue[Ve - en]] > gn || aa[255 + Nn - An] > gn } function Ol(Ue, Ve, en, gn) { return 4 * aa[255 + Ue[Ve - en] - Ue[Ve + 0]] + aa[255 + Ue[Ve - 2 * en] - Ue[Ve + en]] <= gn } function Ll(Ue, Ve, en, gn, An) { var Nn = Ue[Ve - 3 * en], Ln = Ue[Ve - 2 * en], jn = Ue[Ve - en], Dn = Ue[Ve + 0], Bn = Ue[Ve + en], Gn = Ue[Ve + 2 * en], ar = Ue[Ve + 3 * en]; return 4 * aa[255 + jn - Dn] + aa[255 + Ln - Bn] > gn ? 0 : aa[255 + Ue[Ve - 4 * en] - Nn] <= An && aa[255 + Nn - Ln] <= An && aa[255 + Ln - jn] <= An && aa[255 + ar - Gn] <= An && aa[255 + Gn - Bn] <= An && aa[255 + Bn - Dn] <= An } function Eo(Ue, Ve, en, gn) { var An = 2 * gn + 1; for (gn = 0; 16 > gn; ++gn)Ol(Ue, Ve + gn, en, An) && Na(Ue, Ve + gn, en) } function Ks(Ue, Ve, en, gn) { var An = 2 * gn + 1; for (gn = 0; 16 > gn; ++gn)Ol(Ue, Ve + gn * en, 1, An) && Na(Ue, Ve + gn * en, 1) } function Pa(Ue, Ve, en, gn) { var An; for (An = 3; 0 < An; --An)Eo(Ue, Ve += 4 * en, en, gn) } function Hu(Ue, Ve, en, gn) { var An; for (An = 3; 0 < An; --An)Ks(Ue, Ve += 4, en, gn) } function wo(Ue, Ve, en, gn, An, Nn, Ln, jn) { for (Nn = 2 * Nn + 1; 0 < An--;) { if (Ll(Ue, Ve, en, Nn, Ln)) if (cu(Ue, Ve, en, jn)) Na(Ue, Ve, en); else { var Dn = Ue, Bn = Ve, Gn = en, ar = Dn[Bn - 2 * Gn], nr = Dn[Bn - Gn], Jn = Dn[Bn + 0], xr = Dn[Bn + Gn], dr = Dn[Bn + 2 * Gn], Wn = 27 * (pr = hu[1020 + 3 * (Jn - nr) + hu[1020 + ar - xr]]) + 63 >> 7, Zn = 18 * pr + 63 >> 7, pr = 9 * pr + 63 >> 7; Dn[Bn - 3 * Gn] = xs[255 + Dn[Bn - 3 * Gn] + pr], Dn[Bn - 2 * Gn] = xs[255 + ar + Zn], Dn[Bn - Gn] = xs[255 + nr + Wn], Dn[Bn + 0] = xs[255 + Jn - Wn], Dn[Bn + Gn] = xs[255 + xr - Zn], Dn[Bn + 2 * Gn] = xs[255 + dr - pr] } Ve += gn } } function fa(Ue, Ve, en, gn, An, Nn, Ln, jn) { for (Nn = 2 * Nn + 1; 0 < An--;) { if (Ll(Ue, Ve, en, Nn, Ln)) if (cu(Ue, Ve, en, jn)) Na(Ue, Ve, en); else { var Dn = Ue, Bn = Ve, Gn = en, ar = Dn[Bn - Gn], nr = Dn[Bn + 0], Jn = Dn[Bn + Gn], xr = ol[112 + ((dr = 3 * (nr - ar)) + 4 >> 3)], dr = ol[112 + (dr + 3 >> 3)], Wn = xr + 1 >> 1; Dn[Bn - 2 * Gn] = xs[255 + Dn[Bn - 2 * Gn] + Wn], Dn[Bn - Gn] = xs[255 + ar + dr], Dn[Bn + 0] = xs[255 + nr - xr], Dn[Bn + Gn] = xs[255 + Jn - Wn] } Ve += gn } } function Zo(Ue, Ve, en, gn, An, Nn) { wo(Ue, Ve, en, 1, 16, gn, An, Nn) } function Jo(Ue, Ve, en, gn, An, Nn) { wo(Ue, Ve, 1, en, 16, gn, An, Nn) } function qu(Ue, Ve, en, gn, An, Nn) { var Ln; for (Ln = 3; 0 < Ln; --Ln)fa(Ue, Ve += 4 * en, en, 1, 16, gn, An, Nn) } function jl(Ue, Ve, en, gn, An, Nn) { var Ln; for (Ln = 3; 0 < Ln; --Ln)fa(Ue, Ve += 4, 1, en, 16, gn, An, Nn) } function $u(Ue, Ve, en, gn, An, Nn, Ln, jn) { wo(Ue, Ve, An, 1, 8, Nn, Ln, jn), wo(en, gn, An, 1, 8, Nn, Ln, jn) } function Cc(Ue, Ve, en, gn, An, Nn, Ln, jn) { wo(Ue, Ve, 1, An, 8, Nn, Ln, jn), wo(en, gn, 1, An, 8, Nn, Ln, jn) } function Ml(Ue, Ve, en, gn, An, Nn, Ln, jn) { fa(Ue, Ve + 4 * An, An, 1, 8, Nn, Ln, jn), fa(en, gn + 4 * An, An, 1, 8, Nn, Ln, jn) } function uu(Ue, Ve, en, gn, An, Nn, Ln, jn) { fa(Ue, Ve + 4, 1, An, 8, Nn, Ln, jn), fa(en, gn + 4, 1, An, 8, Nn, Ln, jn) } function Dl() { this.ba = new Wi, this.ec = [], this.cc = [], this.Mc = [], this.Dc = this.Nc = this.dc = this.fc = 0, this.Oa = new xi, this.memory = 0, this.Ib = "OutputFunc", this.Jb = "OutputAlphaFunc", this.Nd = "OutputRowFunc" } function Tc() { this.data = [], this.offset = this.kd = this.ha = this.w = 0, this.na = [], this.xa = this.gb = this.Ja = this.Sa = this.P = 0 } function Nc() { this.nc = this.Ea = this.b = this.hc = 0, this.K = [], this.w = 0 } function kl() { this.ua = 0, this.Wa = new Cn, this.vb = new Cn, this.md = this.xc = this.wc = 0, this.vc = [], this.Wb = 0, this.Ya = new Rn, this.yc = new En } function Vu() { this.xb = this.a = 0, this.l = new mo, this.ca = new Wi, this.V = [], this.Ba = 0, this.Ta = [], this.Ua = 0, this.m = new Je, this.Pb = 0, this.wd = new Je, this.Ma = this.$ = this.C = this.i = this.c = this.xd = 0, this.s = new kl, this.ab = 0, this.gc = Ce(4, Nc), this.Oc = 0 } function Il() { this.Lc = this.Z = this.$a = this.i = this.c = 0, this.l = new mo, this.ic = 0, this.ca = [], this.tb = 0, this.qd = null, this.rd = 0 } function el(Ue, Ve, en, gn, An, Nn, Ln) { for (Ue = Ue == null ? 0 : Ue[Ve + 0], Ve = 0; Ve < Ln; ++Ve)An[Nn + Ve] = Ue + en[gn + Ve] & 255, Ue = An[Nn + Ve] } function Fl(Ue, Ve, en, gn, An, Nn, Ln) { var jn; if (Ue == null) el(null, null, en, gn, An, Nn, Ln); else for (jn = 0; jn < Ln; ++jn)An[Nn + jn] = Ue[Ve + jn] + en[gn + jn] & 255 } function Ao(Ue, Ve, en, gn, An, Nn, Ln) { if (Ue == null) el(null, null, en, gn, An, Nn, Ln); else { var jn, Dn = Ue[Ve + 0], Bn = Dn, Gn = Dn; for (jn = 0; jn < Ln; ++jn)Bn = Gn + (Dn = Ue[Ve + jn]) - Bn, Gn = en[gn + jn] + (-256 & Bn ? 0 > Bn ? 0 : 255 : Bn) & 255, Bn = Dn, An[Nn + jn] = Gn } } function Pc(Ue, Ve, en, gn) { var An = Ve.width, Nn = Ve.o; if (t(Ue != null && Ve != null), 0 > en || 0 >= gn || en + gn > Nn) return null; if (!Ue.Cc) { if (Ue.ga == null) { var Ln; if (Ue.ga = new Il, (Ln = Ue.ga == null) || (Ln = Ve.width * Ve.o, t(Ue.Gb.length == 0), Ue.Gb = Re(Ln), Ue.Uc = 0, Ue.Gb == null ? Ln = 0 : (Ue.mb = Ue.Gb, Ue.nb = Ue.Uc, Ue.rc = null, Ln = 1), Ln = !Ln), !Ln) { Ln = Ue.ga; var jn = Ue.Fa, Dn = Ue.P, Bn = Ue.qc, Gn = Ue.mb, ar = Ue.nb, nr = Dn + 1, Jn = Bn - 1, xr = Ln.l; if (t(jn != null && Gn != null && Ve != null), Da[0] = null, Da[1] = el, Da[2] = Fl, Da[3] = Ao, Ln.ca = Gn, Ln.tb = ar, Ln.c = Ve.width, Ln.i = Ve.height, t(0 < Ln.c && 0 < Ln.i), 1 >= Bn) Ve = 0; else if (Ln.$a = jn[Dn + 0] >> 0 & 3, Ln.Z = jn[Dn + 0] >> 2 & 3, Ln.Lc = jn[Dn + 0] >> 4 & 3, Dn = jn[Dn + 0] >> 6 & 3, 0 > Ln.$a || 1 < Ln.$a || 4 <= Ln.Z || 1 < Ln.Lc || Dn) Ve = 0; else if (xr.put = fi, xr.ac = ii, xr.bc = yi, xr.ma = Ln, xr.width = Ve.width, xr.height = Ve.height, xr.Da = Ve.Da, xr.v = Ve.v, xr.va = Ve.va, xr.j = Ve.j, xr.o = Ve.o, Ln.$a) e: { t(Ln.$a == 1), Ve = ws(); t: for (; ;) { if (Ve == null) { Ve = 0; break e } if (t(Ln != null), Ln.mc = Ve, Ve.c = Ln.c, Ve.i = Ln.i, Ve.l = Ln.l, Ve.l.ma = Ln, Ve.l.width = Ln.c, Ve.l.height = Ln.i, Ve.a = 0, tn(Ve.m, jn, nr, Jn), !Li(Ln.c, Ln.i, 1, Ve, null) || (Ve.ab == 1 && Ve.gc[0].hc == 3 && Ws(Ve.s) ? (Ln.ic = 1, jn = Ve.c * Ve.i, Ve.Ta = null, Ve.Ua = 0, Ve.V = Re(jn), Ve.Ba = 0, Ve.V == null ? (Ve.a = 1, Ve = 0) : Ve = 1) : (Ln.ic = 0, Ve = po(Ve, Ln.c)), !Ve)) break t; Ve = 1; break e } Ln.mc = null, Ve = 0 } else Ve = Jn >= Ln.c * Ln.i; Ln = !Ve } if (Ln) return null; Ue.ga.Lc != 1 ? Ue.Ga = 0 : gn = Nn - en } t(Ue.ga != null), t(en + gn <= Nn); e: { if (Ve = (jn = Ue.ga).c, Nn = jn.l.o, jn.$a == 0) { if (nr = Ue.rc, Jn = Ue.Vc, xr = Ue.Fa, Dn = Ue.P + 1 + en * Ve, Bn = Ue.mb, Gn = Ue.nb + en * Ve, t(Dn <= Ue.P + Ue.qc), jn.Z != 0) for (t(Da[jn.Z] != null), Ln = 0; Ln < gn; ++Ln)Da[jn.Z](nr, Jn, xr, Dn, Bn, Gn, Ve), nr = Bn, Jn = Gn, Gn += Ve, Dn += Ve; else for (Ln = 0; Ln < gn; ++Ln)Ee(Bn, Gn, xr, Dn, Ve), nr = Bn, Jn = Gn, Gn += Ve, Dn += Ve; Ue.rc = nr, Ue.Vc = Jn } else { if (t(jn.mc != null), Ve = en + gn, t((Ln = jn.mc) != null), t(Ve <= Ln.i), Ln.C >= Ve) Ve = 1; else if (jn.ic || tr(), jn.ic) { jn = Ln.V, nr = Ln.Ba, Jn = Ln.c; var dr = Ln.i, Wn = (xr = 1, Dn = Ln.$ / Jn, Bn = Ln.$ % Jn, Gn = Ln.m, ar = Ln.s, Ln.$), Zn = Jn * dr, pr = Jn * Ve, yr = ar.wc, vr = Wn < pr ? bi(ar, Bn, Dn) : null; t(Wn <= Zn), t(Ve <= dr), t(Ws(ar)); t: for (; ;) { for (; !Gn.h && Wn < pr;) { if (Bn & yr || (vr = bi(ar, Bn, Dn)), t(vr != null), Ye(Gn), 256 > (dr = oi(vr.G[0], vr.H[0], Gn))) jn[nr + Wn] = dr, ++Wn, ++Bn >= Jn && (Bn = 0, ++Dn <= Ve && !(Dn % 16) && _s(Ln, Dn)); else { if (!(280 > dr)) { xr = 0; break t } dr = pi(dr - 256, Gn); var Mr, Nr = oi(vr.G[4], vr.H[4], Gn); if (Ye(Gn), !(Wn >= (Nr = ni(Jn, Nr = pi(Nr, Gn))) && Zn - Wn >= dr)) { xr = 0; break t } for (Mr = 0; Mr < dr; ++Mr)jn[nr + Wn + Mr] = jn[nr + Wn + Mr - Nr]; for (Wn += dr, Bn += dr; Bn >= Jn;)Bn -= Jn, ++Dn <= Ve && !(Dn % 16) && _s(Ln, Dn); Wn < pr && Bn & yr && (vr = bi(ar, Bn, Dn)) } t(Gn.h == hn(Gn)) } _s(Ln, Dn > Ve ? Ve : Dn); break t } !xr || Gn.h && Wn < Zn ? (xr = 0, Ln.a = Gn.h ? 5 : 3) : Ln.$ = Wn, Ve = xr } else Ve = Rs(Ln, Ln.V, Ln.Ba, Ln.c, Ln.i, Ve, Xo); if (!Ve) { gn = 0; break e } } en + gn >= Nn && (Ue.Cc = 1), gn = 1 } if (!gn) return null; if (Ue.Cc && ((gn = Ue.ga) != null && (gn.mc = null), Ue.ga = null, 0 < Ue.Ga)) return alert("todo:WebPDequantizeLevels"), null } return Ue.nb + en * An } function Qe(Ue, Ve, en, gn, An, Nn) { for (; 0 < An--;) { var Ln, jn = Ue, Dn = Ve + (en ? 1 : 0), Bn = Ue, Gn = Ve + (en ? 0 : 3); for (Ln = 0; Ln < gn; ++Ln) { var ar = Bn[Gn + 4 * Ln]; ar != 255 && (ar *= 32897, jn[Dn + 4 * Ln + 0] = jn[Dn + 4 * Ln + 0] * ar >> 23, jn[Dn + 4 * Ln + 1] = jn[Dn + 4 * Ln + 1] * ar >> 23, jn[Dn + 4 * Ln + 2] = jn[Dn + 4 * Ln + 2] * ar >> 23) } Ve += Nn } } function Sn(Ue, Ve, en, gn, An) { for (; 0 < gn--;) { var Nn; for (Nn = 0; Nn < en; ++Nn) { var Ln = Ue[Ve + 2 * Nn + 0], jn = 15 & (Bn = Ue[Ve + 2 * Nn + 1]), Dn = 4369 * jn, Bn = (240 & Bn | Bn >> 4) * Dn >> 16; Ue[Ve + 2 * Nn + 0] = (240 & Ln | Ln >> 4) * Dn >> 16 & 240 | (15 & Ln | Ln << 4) * Dn >> 16 >> 4 & 15, Ue[Ve + 2 * Nn + 1] = 240 & Bn | jn } Ve += An } } function Un(Ue, Ve, en, gn, An, Nn, Ln, jn) { var Dn, Bn, Gn = 255; for (Bn = 0; Bn < An; ++Bn) { for (Dn = 0; Dn < gn; ++Dn) { var ar = Ue[Ve + Dn]; Nn[Ln + 4 * Dn] = ar, Gn &= ar } Ve += en, Ln += jn } return Gn != 255 } function $n(Ue, Ve, en, gn, An) { var Nn; for (Nn = 0; Nn < An; ++Nn)en[gn + Nn] = Ue[Ve + Nn] >> 8 } function tr() { Zs = Qe, li = Sn, ci = Un, ki = $n } function fr(Ue, Ve, en) { on[Ue] = function (gn, An, Nn, Ln, jn, Dn, Bn, Gn, ar, nr, Jn, xr, dr, Wn, Zn, pr, yr) { var vr, Mr = yr - 1 >> 1, Nr = jn[Dn + 0] | Bn[Gn + 0] << 16, Hr = ar[nr + 0] | Jn[xr + 0] << 16; t(gn != null); var Pr = 3 * Nr + Hr + 131074 >> 2; for (Ve(gn[An + 0], 255 & Pr, Pr >> 16, dr, Wn), Nn != null && (Pr = 3 * Hr + Nr + 131074 >> 2, Ve(Nn[Ln + 0], 255 & Pr, Pr >> 16, Zn, pr)), vr = 1; vr <= Mr; ++vr) { var Ai = jn[Dn + vr] | Bn[Gn + vr] << 16, Ci = ar[nr + vr] | Jn[xr + vr] << 16, ai = Nr + Ai + Hr + Ci + 524296, ri = ai + 2 * (Ai + Hr) >> 3; Pr = ri + Nr >> 1, Nr = (ai = ai + 2 * (Nr + Ci) >> 3) + Ai >> 1, Ve(gn[An + 2 * vr - 1], 255 & Pr, Pr >> 16, dr, Wn + (2 * vr - 1) * en), Ve(gn[An + 2 * vr - 0], 255 & Nr, Nr >> 16, dr, Wn + (2 * vr - 0) * en), Nn != null && (Pr = ai + Hr >> 1, Nr = ri + Ci >> 1, Ve(Nn[Ln + 2 * vr - 1], 255 & Pr, Pr >> 16, Zn, pr + (2 * vr - 1) * en), Ve(Nn[Ln + 2 * vr + 0], 255 & Nr, Nr >> 16, Zn, pr + (2 * vr + 0) * en)), Nr = Ai, Hr = Ci } 1 & yr || (Pr = 3 * Nr + Hr + 131074 >> 2, Ve(gn[An + yr - 1], 255 & Pr, Pr >> 16, dr, Wn + (yr - 1) * en), Nn != null && (Pr = 3 * Hr + Nr + 131074 >> 2, Ve(Nn[Ln + yr - 1], 255 & Pr, Pr >> 16, Zn, pr + (yr - 1) * en))) } } function Sr() { ys[Ts] = so, ys[$l] = ka, ys[ja] = Io, ys[Mc] = mu, ys[ll] = gu, ys[eo] = Wl, ys[fu] = vu, ys[Dc] = ka, ys[Do] = mu, ys[to] = gu, ys[Vl] = Wl } function jr(Ue) { return Ue & -16384 ? 0 > Ue ? 0 : 255 : Ue >> Nh } function Br(Ue, Ve) { return jr((19077 * Ue >> 8) + (26149 * Ve >> 8) - 14234) } function ti(Ue, Ve, en) { return jr((19077 * Ue >> 8) - (6419 * Ve >> 8) - (13320 * en >> 8) + 8708) } function Qr(Ue, Ve) { return jr((19077 * Ue >> 8) + (33050 * Ve >> 8) - 17685) } function mi(Ue, Ve, en, gn, An) { gn[An + 0] = Br(Ue, en), gn[An + 1] = ti(Ue, Ve, en), gn[An + 2] = Qr(Ue, Ve) } function zi(Ue, Ve, en, gn, An) { gn[An + 0] = Qr(Ue, Ve), gn[An + 1] = ti(Ue, Ve, en), gn[An + 2] = Br(Ue, en) } function Vi(Ue, Ve, en, gn, An) { var Nn = ti(Ue, Ve, en); Ve = Nn << 3 & 224 | Qr(Ue, Ve) >> 3, gn[An + 0] = 248 & Br(Ue, en) | Nn >> 5, gn[An + 1] = Ve } function Ji(Ue, Ve, en, gn, An) { var Nn = 240 & Qr(Ue, Ve) | 15; gn[An + 0] = 240 & Br(Ue, en) | ti(Ue, Ve, en) >> 4, gn[An + 1] = Nn } function es(Ue, Ve, en, gn, An) { gn[An + 0] = 255, mi(Ue, Ve, en, gn, An + 1) } function vs(Ue, Ve, en, gn, An) { zi(Ue, Ve, en, gn, An), gn[An + 3] = 255 } function pa(Ue, Ve, en, gn, An) { mi(Ue, Ve, en, gn, An), gn[An + 3] = 255 } function Qs(Ue, Ve) { return 0 > Ue ? 0 : Ue > Ve ? Ve : Ue } function ma(Ue, Ve, en) { on[Ue] = function (gn, An, Nn, Ln, jn, Dn, Bn, Gn, ar) { for (var nr = Gn + (-2 & ar) * en; Gn != nr;)Ve(gn[An + 0], Nn[Ln + 0], jn[Dn + 0], Bn, Gn), Ve(gn[An + 1], Nn[Ln + 0], jn[Dn + 0], Bn, Gn + en), An += 2, ++Ln, ++Dn, Gn += 2 * en; 1 & ar && Ve(gn[An + 0], Nn[Ln + 0], jn[Dn + 0], Bn, Gn) } } function Oc(Ue, Ve, en) { return en == 0 ? Ue == 0 ? Ve == 0 ? 6 : 5 : Ve == 0 ? 4 : 0 : en } function Ya(Ue, Ve, en, gn, An) { switch (Ue >>> 30) { case 3: va(Ve, en, gn, An, 0); break; case 2: Yi(Ve, en, gn, An); break; case 1: ss(Ve, en, gn, An) } } function Ka(Ue, Ve) { var en, gn, An = Ve.M, Nn = Ve.Nb, Ln = Ue.oc, jn = Ue.pc + 40, Dn = Ue.oc, Bn = Ue.pc + 584, Gn = Ue.oc, ar = Ue.pc + 600; for (en = 0; 16 > en; ++en)Ln[jn + 32 * en - 1] = 129; for (en = 0; 8 > en; ++en)Dn[Bn + 32 * en - 1] = 129, Gn[ar + 32 * en - 1] = 129; for (0 < An ? Ln[jn - 1 - 32] = Dn[Bn - 1 - 32] = Gn[ar - 1 - 32] = 129 : (_e(Ln, jn - 32 - 1, 127, 21), _e(Dn, Bn - 32 - 1, 127, 9), _e(Gn, ar - 32 - 1, 127, 9)), gn = 0; gn < Ue.za; ++gn) { var nr = Ve.ya[Ve.aa + gn]; if (0 < gn) { for (en = -1; 16 > en; ++en)Ee(Ln, jn + 32 * en - 4, Ln, jn + 32 * en + 12, 4); for (en = -1; 8 > en; ++en)Ee(Dn, Bn + 32 * en - 4, Dn, Bn + 32 * en + 4, 4), Ee(Gn, ar + 32 * en - 4, Gn, ar + 32 * en + 4, 4) } var Jn = Ue.Gd, xr = Ue.Hd + gn, dr = nr.ad, Wn = nr.Hc; if (0 < An && (Ee(Ln, jn - 32, Jn[xr].y, 0, 16), Ee(Dn, Bn - 32, Jn[xr].f, 0, 8), Ee(Gn, ar - 32, Jn[xr].ea, 0, 8)), nr.Za) { var Zn = Ln, pr = jn - 32 + 16; for (0 < An && (gn >= Ue.za - 1 ? _e(Zn, pr, Jn[xr].y[15], 4) : Ee(Zn, pr, Jn[xr + 1].y, 0, 4)), en = 0; 4 > en; en++)Zn[pr + 128 + en] = Zn[pr + 256 + en] = Zn[pr + 384 + en] = Zn[pr + 0 + en]; for (en = 0; 16 > en; ++en, Wn <<= 2)Zn = Ln, pr = jn + hl[en], Ms[nr.Ob[en]](Zn, pr), Ya(Wn, dr, 16 * +en, Zn, pr) } else if (Zn = Oc(gn, An, nr.Ob[0]), io[Zn](Ln, jn), Wn != 0) for (en = 0; 16 > en; ++en, Wn <<= 2)Ya(Wn, dr, 16 * +en, Ln, jn + hl[en]); for (en = nr.Gc, Zn = Oc(gn, An, nr.Dd), ea[Zn](Dn, Bn), ea[Zn](Gn, ar), Wn = dr, Zn = Dn, pr = Bn, 255 & (nr = en >> 0) && (170 & nr ? ba(Wn, 256, Zn, pr) : $s(Wn, 256, Zn, pr)), nr = Gn, Wn = ar, 255 & (en >>= 8) && (170 & en ? ba(dr, 320, nr, Wn) : $s(dr, 320, nr, Wn)), An < Ue.Ub - 1 && (Ee(Jn[xr].y, 0, Ln, jn + 480, 16), Ee(Jn[xr].f, 0, Dn, Bn + 224, 8), Ee(Jn[xr].ea, 0, Gn, ar + 224, 8)), en = 8 * Nn * Ue.B, Jn = Ue.sa, xr = Ue.ta + 16 * gn + 16 * Nn * Ue.R, dr = Ue.qa, nr = Ue.ra + 8 * gn + en, Wn = Ue.Ha, Zn = Ue.Ia + 8 * gn + en, en = 0; 16 > en; ++en)Ee(Jn, xr + en * Ue.R, Ln, jn + 32 * en, 16); for (en = 0; 8 > en; ++en)Ee(dr, nr + en * Ue.B, Dn, Bn + 32 * en, 8), Ee(Wn, Zn + en * Ue.B, Gn, ar + 32 * en, 8) } } function Bl(Ue, Ve, en, gn, An, Nn, Ln, jn, Dn) { var Bn = [0], Gn = [0], ar = 0, nr = Dn != null ? Dn.kd : 0, Jn = Dn ?? new Tc; if (Ue == null || 12 > en) return 7; Jn.data = Ue, Jn.w = Ve, Jn.ha = en, Ve = [Ve], en = [en], Jn.gb = [Jn.gb]; e: { var xr = Ve, dr = en, Wn = Jn.gb; if (t(Ue != null), t(dr != null), t(Wn != null), Wn[0] = 0, 12 <= dr[0] && !xe(Ue, xr[0], "RIFF")) { if (xe(Ue, xr[0] + 8, "WEBP")) { Wn = 3; break e } var Zn = zn(Ue, xr[0] + 4); if (12 > Zn || 4294967286 < Zn) { Wn = 3; break e } if (nr && Zn > dr[0] - 8) { Wn = 7; break e } Wn[0] = Zn, xr[0] += 12, dr[0] -= 12 } Wn = 0 } if (Wn != 0) return Wn; for (Zn = 0 < Jn.gb[0], en = en[0]; ;) { e: { var pr = Ue; dr = Ve, Wn = en; var yr = Bn, vr = Gn, Mr = xr = [0]; if ((Pr = ar = [ar])[0] = 0, 8 > Wn[0]) Wn = 7; else { if (!xe(pr, dr[0], "VP8X")) { if (zn(pr, dr[0] + 4) != 10) { Wn = 3; break e } if (18 > Wn[0]) { Wn = 7; break e } var Nr = zn(pr, dr[0] + 8), Hr = 1 + kn(pr, dr[0] + 12); if (2147483648 <= Hr * (pr = 1 + kn(pr, dr[0] + 15))) { Wn = 3; break e } Mr != null && (Mr[0] = Nr), yr != null && (yr[0] = Hr), vr != null && (vr[0] = pr), dr[0] += 18, Wn[0] -= 18, Pr[0] = 1 } Wn = 0 } } if (ar = ar[0], xr = xr[0], Wn != 0) return Wn; if (dr = !!(2 & xr), !Zn && ar) return 3; if (Nn != null && (Nn[0] = !!(16 & xr)), Ln != null && (Ln[0] = dr), jn != null && (jn[0] = 0), Ln = Bn[0], xr = Gn[0], ar && dr && Dn == null) { Wn = 0; break } if (4 > en) { Wn = 7; break } if (Zn && ar || !Zn && !ar && !xe(Ue, Ve[0], "ALPH")) { en = [en], Jn.na = [Jn.na], Jn.P = [Jn.P], Jn.Sa = [Jn.Sa]; e: { Nr = Ue, Wn = Ve, Zn = en; var Pr = Jn.gb; yr = Jn.na, vr = Jn.P, Mr = Jn.Sa, Hr = 22, t(Nr != null), t(Zn != null), pr = Wn[0]; var Ai = Zn[0]; for (t(yr != null), t(Mr != null), yr[0] = null, vr[0] = null, Mr[0] = 0; ;) { if (Wn[0] = pr, Zn[0] = Ai, 8 > Ai) { Wn = 7; break e } var Ci = zn(Nr, pr + 4); if (4294967286 < Ci) { Wn = 3; break e } var ai = 8 + Ci + 1 & -2; if (Hr += ai, 0 < Pr && Hr > Pr) { Wn = 3; break e } if (!xe(Nr, pr, "VP8 ") || !xe(Nr, pr, "VP8L")) { Wn = 0; break e } if (Ai[0] < ai) { Wn = 7; break e } xe(Nr, pr, "ALPH") || (yr[0] = Nr, vr[0] = pr + 8, Mr[0] = Ci), pr += ai, Ai -= ai } } if (en = en[0], Jn.na = Jn.na[0], Jn.P = Jn.P[0], Jn.Sa = Jn.Sa[0], Wn != 0) break } en = [en], Jn.Ja = [Jn.Ja], Jn.xa = [Jn.xa]; e: if (Pr = Ue, Wn = Ve, Zn = en, yr = Jn.gb[0], vr = Jn.Ja, Mr = Jn.xa, Nr = Wn[0], pr = !xe(Pr, Nr, "VP8 "), Hr = !xe(Pr, Nr, "VP8L"), t(Pr != null), t(Zn != null), t(vr != null), t(Mr != null), 8 > Zn[0]) Wn = 7; else { if (pr || Hr) { if (Pr = zn(Pr, Nr + 4), 12 <= yr && Pr > yr - 12) { Wn = 3; break e } if (nr && Pr > Zn[0] - 8) { Wn = 7; break e } vr[0] = Pr, Wn[0] += 8, Zn[0] -= 8, Mr[0] = Hr } else Mr[0] = 5 <= Zn[0] && Pr[Nr + 0] == 47 && !(Pr[Nr + 4] >> 5), vr[0] = Zn[0]; Wn = 0 } if (en = en[0], Jn.Ja = Jn.Ja[0], Jn.xa = Jn.xa[0], Ve = Ve[0], Wn != 0) break; if (4294967286 < Jn.Ja) return 3; if (jn == null || dr || (jn[0] = Jn.xa ? 2 : 1), Ln = [Ln], xr = [xr], Jn.xa) { if (5 > en) { Wn = 7; break } jn = Ln, nr = xr, dr = Nn, Ue == null || 5 > en ? Ue = 0 : 5 <= en && Ue[Ve + 0] == 47 && !(Ue[Ve + 4] >> 5) ? (Zn = [0], Pr = [0], yr = [0], tn(vr = new Je, Ue, Ve, en), Lr(vr, Zn, Pr, yr) ? (jn != null && (jn[0] = Zn[0]), nr != null && (nr[0] = Pr[0]), dr != null && (dr[0] = yr[0]), Ue = 1) : Ue = 0) : Ue = 0 } else { if (10 > en) { Wn = 7; break } jn = xr, Ue == null || 10 > en || !Ls(Ue, Ve + 3, en - 3) ? Ue = 0 : (nr = Ue[Ve + 0] | Ue[Ve + 1] << 8 | Ue[Ve + 2] << 16, dr = 16383 & (Ue[Ve + 7] << 8 | Ue[Ve + 6]), Ue = 16383 & (Ue[Ve + 9] << 8 | Ue[Ve + 8]), 1 & nr || 3 < (nr >> 1 & 7) || !(nr >> 4 & 1) || nr >> 5 >= Jn.Ja || !dr || !Ue ? Ue = 0 : (Ln && (Ln[0] = dr), jn && (jn[0] = Ue), Ue = 1)) } if (!Ue || (Ln = Ln[0], xr = xr[0], ar && (Bn[0] != Ln || Gn[0] != xr))) return 3; Dn != null && (Dn[0] = Jn, Dn.offset = Ve - Dn.w, t(4294967286 > Ve - Dn.w), t(Dn.offset == Dn.ha - en)); break } return Wn == 0 || Wn == 7 && ar && Dn == null ? (Nn != null && (Nn[0] |= Jn.na != null && 0 < Jn.na.length), gn != null && (gn[0] = Ln), An != null && (An[0] = xr), 0) : Wn } function So(Ue, Ve, en) { var gn = Ve.width, An = Ve.height, Nn = 0, Ln = 0, jn = gn, Dn = An; if (Ve.Da = Ue != null && 0 < Ue.Da, Ve.Da && (jn = Ue.cd, Dn = Ue.bd, Nn = Ue.v, Ln = Ue.j, 11 > en || (Nn &= -2, Ln &= -2), 0 > Nn || 0 > Ln || 0 >= jn || 0 >= Dn || Nn + jn > gn || Ln + Dn > An)) return 0; if (Ve.v = Nn, Ve.j = Ln, Ve.va = Nn + jn, Ve.o = Ln + Dn, Ve.U = jn, Ve.T = Dn, Ve.da = Ue != null && 0 < Ue.da, Ve.da) { if (!Vn(jn, Dn, en = [Ue.ib], Nn = [Ue.hb])) return 0; Ve.ib = en[0], Ve.hb = Nn[0] } return Ve.ob = Ue != null && Ue.ob, Ve.Kb = Ue == null || !Ue.Sd, Ve.da && (Ve.ob = Ve.ib < 3 * gn / 4 && Ve.hb < 3 * An / 4, Ve.Kb = 0), 1 } function Ul(Ue) { if (Ue == null) return 2; if (11 > Ue.S) { var Ve = Ue.f.RGBA; Ve.fb += (Ue.height - 1) * Ve.A, Ve.A = -Ve.A } else Ve = Ue.f.kb, Ue = Ue.height, Ve.O += (Ue - 1) * Ve.fa, Ve.fa = -Ve.fa, Ve.N += (Ue - 1 >> 1) * Ve.Ab, Ve.Ab = -Ve.Ab, Ve.W += (Ue - 1 >> 1) * Ve.Db, Ve.Db = -Ve.Db, Ve.F != null && (Ve.J += (Ue - 1) * Ve.lb, Ve.lb = -Ve.lb); return 0 } function tl(Ue, Ve, en, gn) { if (gn == null || 0 >= Ue || 0 >= Ve) return 2; if (en != null) { if (en.Da) { var An = en.cd, Nn = en.bd, Ln = -2 & en.v, jn = -2 & en.j; if (0 > Ln || 0 > jn || 0 >= An || 0 >= Nn || Ln + An > Ue || jn + Nn > Ve) return 2; Ue = An, Ve = Nn } if (en.da) { if (!Vn(Ue, Ve, An = [en.ib], Nn = [en.hb])) return 2; Ue = An[0], Ve = Nn[0] } } gn.width = Ue, gn.height = Ve; e: { var Dn = gn.width, Bn = gn.height; if (Ue = gn.S, 0 >= Dn || 0 >= Bn || !(Ue >= Ts && 13 > Ue)) Ue = 2; else { if (0 >= gn.Rd && gn.sd == null) { Ln = Nn = An = Ve = 0; var Gn = (jn = Dn * Id[Ue]) * Bn; if (11 > Ue || (Nn = (Bn + 1) / 2 * (Ve = (Dn + 1) / 2), Ue == 12 && (Ln = (An = Dn) * Bn)), (Bn = Re(Gn + 2 * Nn + Ln)) == null) { Ue = 1; break e } gn.sd = Bn, 11 > Ue ? ((Dn = gn.f.RGBA).eb = Bn, Dn.fb = 0, Dn.A = jn, Dn.size = Gn) : ((Dn = gn.f.kb).y = Bn, Dn.O = 0, Dn.fa = jn, Dn.Fd = Gn, Dn.f = Bn, Dn.N = 0 + Gn, Dn.Ab = Ve, Dn.Cd = Nn, Dn.ea = Bn, Dn.W = 0 + Gn + Nn, Dn.Db = Ve, Dn.Ed = Nn, Ue == 12 && (Dn.F = Bn, Dn.J = 0 + Gn + 2 * Nn), Dn.Tc = Ln, Dn.lb = An) } if (Ve = 1, An = gn.S, Nn = gn.width, Ln = gn.height, An >= Ts && 13 > An) if (11 > An) Ue = gn.f.RGBA, Ve &= (jn = Math.abs(Ue.A)) * (Ln - 1) + Nn <= Ue.size, Ve &= jn >= Nn * Id[An], Ve &= Ue.eb != null; else { Ue = gn.f.kb, jn = (Nn + 1) / 2, Gn = (Ln + 1) / 2, Dn = Math.abs(Ue.fa), Bn = Math.abs(Ue.Ab); var ar = Math.abs(Ue.Db), nr = Math.abs(Ue.lb), Jn = nr * (Ln - 1) + Nn; Ve &= Dn * (Ln - 1) + Nn <= Ue.Fd, Ve &= Bn * (Gn - 1) + jn <= Ue.Cd, Ve = (Ve &= ar * (Gn - 1) + jn <= Ue.Ed) & Dn >= Nn & Bn >= jn & ar >= jn, Ve &= Ue.y != null, Ve &= Ue.f != null, Ve &= Ue.ea != null, An == 12 && (Ve &= nr >= Nn, Ve &= Jn <= Ue.Tc, Ve &= Ue.F != null) } else Ve = 0; Ue = Ve ? 0 : 2 } } return Ue != 0 || en != null && en.fd && (Ue = Ul(gn)), Ue } var cs = 64, _o = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023, 2047, 4095, 8191, 16383, 32767, 65535, 131071, 262143, 524287, 1048575, 2097151, 4194303, 8388607, 16777215], nl = 24, rl = 32, zl = 8, Hs = [0, 0, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]; rr("Predictor0", "PredictorAdd0"), on.Predictor0 = function () { return 4278190080 }, on.Predictor1 = function (Ue) { return Ue }, on.Predictor2 = function (Ue, Ve, en) { return Ve[en + 0] }, on.Predictor3 = function (Ue, Ve, en) { return Ve[en + 1] }, on.Predictor4 = function (Ue, Ve, en) { return Ve[en - 1] }, on.Predictor5 = function (Ue, Ve, en) { return ur(ur(Ue, Ve[en + 1]), Ve[en + 0]) }, on.Predictor6 = function (Ue, Ve, en) { return ur(Ue, Ve[en - 1]) }, on.Predictor7 = function (Ue, Ve, en) { return ur(Ue, Ve[en + 0]) }, on.Predictor8 = function (Ue, Ve, en) { return ur(Ve[en - 1], Ve[en + 0]) }, on.Predictor9 = function (Ue, Ve, en) { return ur(Ve[en + 0], Ve[en + 1]) }, on.Predictor10 = function (Ue, Ve, en) { return ur(ur(Ue, Ve[en - 1]), ur(Ve[en + 0], Ve[en + 1])) }, on.Predictor11 = function (Ue, Ve, en) { var gn = Ve[en + 0]; return 0 >= Or(gn >> 24 & 255, Ue >> 24 & 255, (Ve = Ve[en - 1]) >> 24 & 255) + Or(gn >> 16 & 255, Ue >> 16 & 255, Ve >> 16 & 255) + Or(gn >> 8 & 255, Ue >> 8 & 255, Ve >> 8 & 255) + Or(255 & gn, 255 & Ue, 255 & Ve) ? gn : Ue }, on.Predictor12 = function (Ue, Ve, en) { var gn = Ve[en + 0]; return (Er((Ue >> 24 & 255) + (gn >> 24 & 255) - ((Ve = Ve[en - 1]) >> 24 & 255)) << 24 | Er((Ue >> 16 & 255) + (gn >> 16 & 255) - (Ve >> 16 & 255)) << 16 | Er((Ue >> 8 & 255) + (gn >> 8 & 255) - (Ve >> 8 & 255)) << 8 | Er((255 & Ue) + (255 & gn) - (255 & Ve))) >>> 0 }, on.Predictor13 = function (Ue, Ve, en) { var gn = Ve[en - 1]; return (_r((Ue = ur(Ue, Ve[en + 0])) >> 24 & 255, gn >> 24 & 255) << 24 | _r(Ue >> 16 & 255, gn >> 16 & 255) << 16 | _r(Ue >> 8 & 255, gn >> 8 & 255) << 8 | _r(Ue >> 0 & 255, gn >> 0 & 255)) >>> 0 }; var Gu = on.PredictorAdd0; on.PredictorAdd1 = Ir, rr("Predictor2", "PredictorAdd2"), rr("Predictor3", "PredictorAdd3"), rr("Predictor4", "PredictorAdd4"), rr("Predictor5", "PredictorAdd5"), rr("Predictor6", "PredictorAdd6"), rr("Predictor7", "PredictorAdd7"), rr("Predictor8", "PredictorAdd8"), rr("Predictor9", "PredictorAdd9"), rr("Predictor10", "PredictorAdd10"), rr("Predictor11", "PredictorAdd11"), rr("Predictor12", "PredictorAdd12"), rr("Predictor13", "PredictorAdd13"); var Lc = on.PredictorAdd2; zr("ColorIndexInverseTransform", "MapARGB", "32b", function (Ue) { return Ue >> 8 & 255 }, function (Ue) { return Ue }), zr("VP8LColorIndexInverseTransformAlpha", "MapAlpha", "8b", function (Ue) { return Ue }, function (Ue) { return Ue >> 8 & 255 }); var du, ia = on.ColorIndexInverseTransform, bs = on.MapARGB, Ro = on.VP8LColorIndexInverseTransformAlpha, jc = on.MapAlpha, Qa = on.VP8LPredictorsAdd = []; Qa.length = 16, (on.VP8LPredictors = []).length = 16, (on.VP8LPredictorsAdd_C = []).length = 16, (on.VP8LPredictors_C = []).length = 16; var Co, js, As, To, qs, ga, Oa, va, Yi, ba, ss, $s, il, La, Hl, No, Po, Oo, sl, ql, Lo, Za, al, Ki, Zs, li, ci, ki, ts = Re(511), sa = Re(2041), jo = Re(225), Mo = Re(767), Ja = 0, hu = sa, ol = jo, xs = Mo, aa = ts, Ts = 0, $l = 1, ja = 2, Mc = 3, ll = 4, eo = 5, fu = 6, Dc = 7, Do = 8, to = 9, Vl = 10, pu = [2, 3, 7], oa = [3, 3, 11], Js = [280, 256, 256, 256, 40], cl = [0, 1, 1, 1, 0], no = [17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], ro = [24, 7, 23, 25, 40, 6, 39, 41, 22, 26, 38, 42, 56, 5, 55, 57, 21, 27, 54, 58, 37, 43, 72, 4, 71, 73, 20, 28, 53, 59, 70, 74, 36, 44, 88, 69, 75, 52, 60, 3, 87, 89, 19, 29, 86, 90, 35, 45, 68, 76, 85, 91, 51, 61, 104, 2, 103, 105, 18, 30, 102, 106, 34, 46, 84, 92, 67, 77, 101, 107, 50, 62, 120, 1, 119, 121, 83, 93, 17, 31, 100, 108, 66, 78, 118, 122, 33, 47, 117, 123, 49, 63, 99, 109, 82, 94, 0, 116, 124, 65, 79, 16, 32, 98, 110, 48, 115, 125, 81, 95, 64, 114, 126, 97, 111, 80, 113, 127, 96, 112], ul = [2954, 2956, 2958, 2962, 2970, 2986, 3018, 3082, 3212, 3468, 3980, 5004], Ld = 8, kc = [4, 5, 6, 7, 8, 9, 10, 10, 11, 12, 13, 14, 15, 16, 17, 17, 18, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 93, 95, 96, 98, 100, 101, 102, 104, 106, 108, 110, 112, 114, 116, 118, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 143, 145, 148, 151, 154, 157], Ic = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 114, 116, 119, 122, 125, 128, 131, 134, 137, 140, 143, 146, 149, 152, 155, 158, 161, 164, 167, 170, 173, 177, 181, 185, 189, 193, 197, 201, 205, 209, 213, 217, 221, 225, 229, 234, 239, 245, 249, 254, 259, 264, 269, 274, 279, 284], us = null, Qi = [[173, 148, 140, 0], [176, 155, 140, 135, 0], [180, 157, 141, 134, 130, 0], [254, 254, 243, 230, 196, 177, 153, 140, 133, 130, 129, 0]], Ri = [0, 1, 4, 8, 5, 2, 3, 6, 9, 12, 13, 10, 7, 11, 14, 15], ko = [-0, 1, -1, 2, -2, 3, 4, 6, -3, 5, -4, -5, -6, 7, -7, 8, -8, -9], Ma = [[[[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]], [[253, 136, 254, 255, 228, 219, 128, 128, 128, 128, 128], [189, 129, 242, 255, 227, 213, 255, 219, 128, 128, 128], [106, 126, 227, 252, 214, 209, 255, 255, 128, 128, 128]], [[1, 98, 248, 255, 236, 226, 255, 255, 128, 128, 128], [181, 133, 238, 254, 221, 234, 255, 154, 128, 128, 128], [78, 134, 202, 247, 198, 180, 255, 219, 128, 128, 128]], [[1, 185, 249, 255, 243, 255, 128, 128, 128, 128, 128], [184, 150, 247, 255, 236, 224, 128, 128, 128, 128, 128], [77, 110, 216, 255, 236, 230, 128, 128, 128, 128, 128]], [[1, 101, 251, 255, 241, 255, 128, 128, 128, 128, 128], [170, 139, 241, 252, 236, 209, 255, 255, 128, 128, 128], [37, 116, 196, 243, 228, 255, 255, 255, 128, 128, 128]], [[1, 204, 254, 255, 245, 255, 128, 128, 128, 128, 128], [207, 160, 250, 255, 238, 128, 128, 128, 128, 128, 128], [102, 103, 231, 255, 211, 171, 128, 128, 128, 128, 128]], [[1, 152, 252, 255, 240, 255, 128, 128, 128, 128, 128], [177, 135, 243, 255, 234, 225, 128, 128, 128, 128, 128], [80, 129, 211, 255, 194, 224, 128, 128, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [246, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [255, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[198, 35, 237, 223, 193, 187, 162, 160, 145, 155, 62], [131, 45, 198, 221, 172, 176, 220, 157, 252, 221, 1], [68, 47, 146, 208, 149, 167, 221, 162, 255, 223, 128]], [[1, 149, 241, 255, 221, 224, 255, 255, 128, 128, 128], [184, 141, 234, 253, 222, 220, 255, 199, 128, 128, 128], [81, 99, 181, 242, 176, 190, 249, 202, 255, 255, 128]], [[1, 129, 232, 253, 214, 197, 242, 196, 255, 255, 128], [99, 121, 210, 250, 201, 198, 255, 202, 128, 128, 128], [23, 91, 163, 242, 170, 187, 247, 210, 255, 255, 128]], [[1, 200, 246, 255, 234, 255, 128, 128, 128, 128, 128], [109, 178, 241, 255, 231, 245, 255, 255, 128, 128, 128], [44, 130, 201, 253, 205, 192, 255, 255, 128, 128, 128]], [[1, 132, 239, 251, 219, 209, 255, 165, 128, 128, 128], [94, 136, 225, 251, 218, 190, 255, 255, 128, 128, 128], [22, 100, 174, 245, 186, 161, 255, 199, 128, 128, 128]], [[1, 182, 249, 255, 232, 235, 128, 128, 128, 128, 128], [124, 143, 241, 255, 227, 234, 128, 128, 128, 128, 128], [35, 77, 181, 251, 193, 211, 255, 205, 128, 128, 128]], [[1, 157, 247, 255, 236, 231, 255, 255, 128, 128, 128], [121, 141, 235, 255, 225, 227, 255, 255, 128, 128, 128], [45, 99, 188, 251, 195, 217, 255, 224, 128, 128, 128]], [[1, 1, 251, 255, 213, 255, 128, 128, 128, 128, 128], [203, 1, 248, 255, 255, 128, 128, 128, 128, 128, 128], [137, 1, 177, 255, 224, 255, 128, 128, 128, 128, 128]]], [[[253, 9, 248, 251, 207, 208, 255, 192, 128, 128, 128], [175, 13, 224, 243, 193, 185, 249, 198, 255, 255, 128], [73, 17, 171, 221, 161, 179, 236, 167, 255, 234, 128]], [[1, 95, 247, 253, 212, 183, 255, 255, 128, 128, 128], [239, 90, 244, 250, 211, 209, 255, 255, 128, 128, 128], [155, 77, 195, 248, 188, 195, 255, 255, 128, 128, 128]], [[1, 24, 239, 251, 218, 219, 255, 205, 128, 128, 128], [201, 51, 219, 255, 196, 186, 128, 128, 128, 128, 128], [69, 46, 190, 239, 201, 218, 255, 228, 128, 128, 128]], [[1, 191, 251, 255, 255, 128, 128, 128, 128, 128, 128], [223, 165, 249, 255, 213, 255, 128, 128, 128, 128, 128], [141, 124, 248, 255, 255, 128, 128, 128, 128, 128, 128]], [[1, 16, 248, 255, 255, 128, 128, 128, 128, 128, 128], [190, 36, 230, 255, 236, 255, 128, 128, 128, 128, 128], [149, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 226, 255, 128, 128, 128, 128, 128, 128, 128, 128], [247, 192, 255, 128, 128, 128, 128, 128, 128, 128, 128], [240, 128, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[1, 134, 252, 255, 255, 128, 128, 128, 128, 128, 128], [213, 62, 250, 255, 255, 128, 128, 128, 128, 128, 128], [55, 93, 255, 128, 128, 128, 128, 128, 128, 128, 128]], [[128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128], [128, 128, 128, 128, 128, 128, 128, 128, 128, 128, 128]]], [[[202, 24, 213, 235, 186, 191, 220, 160, 240, 175, 255], [126, 38, 182, 232, 169, 184, 228, 174, 255, 187, 128], [61, 46, 138, 219, 151, 178, 240, 170, 255, 216, 128]], [[1, 112, 230, 250, 199, 191, 247, 159, 255, 255, 128], [166, 109, 228, 252, 211, 215, 255, 174, 128, 128, 128], [39, 77, 162, 232, 172, 180, 245, 178, 255, 255, 128]], [[1, 52, 220, 246, 198, 199, 249, 220, 255, 255, 128], [124, 74, 191, 243, 183, 193, 250, 221, 255, 255, 128], [24, 71, 130, 219, 154, 170, 243, 182, 255, 255, 128]], [[1, 182, 225, 249, 219, 240, 255, 224, 128, 128, 128], [149, 150, 226, 252, 216, 205, 255, 171, 128, 128, 128], [28, 108, 170, 242, 183, 194, 254, 223, 255, 255, 128]], [[1, 81, 230, 252, 204, 203, 255, 192, 128, 128, 128], [123, 102, 209, 247, 188, 196, 255, 233, 128, 128, 128], [20, 95, 153, 243, 164, 173, 255, 203, 128, 128, 128]], [[1, 222, 248, 255, 216, 213, 128, 128, 128, 128, 128], [168, 175, 246, 252, 235, 205, 255, 255, 128, 128, 128], [47, 116, 215, 255, 211, 212, 255, 255, 128, 128, 128]], [[1, 121, 236, 253, 212, 214, 255, 255, 128, 128, 128], [141, 84, 213, 252, 201, 202, 255, 219, 128, 128, 128], [42, 80, 160, 240, 162, 185, 255, 205, 128, 128, 128]], [[1, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [244, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128], [238, 1, 255, 128, 128, 128, 128, 128, 128, 128, 128]]]], Wu = [[[231, 120, 48, 89, 115, 113, 120, 152, 112], [152, 179, 64, 126, 170, 118, 46, 70, 95], [175, 69, 143, 80, 85, 82, 72, 155, 103], [56, 58, 10, 171, 218, 189, 17, 13, 152], [114, 26, 17, 163, 44, 195, 21, 10, 173], [121, 24, 80, 195, 26, 62, 44, 64, 85], [144, 71, 10, 38, 171, 213, 144, 34, 26], [170, 46, 55, 19, 136, 160, 33, 206, 71], [63, 20, 8, 114, 114, 208, 12, 9, 226], [81, 40, 11, 96, 182, 84, 29, 16, 36]], [[134, 183, 89, 137, 98, 101, 106, 165, 148], [72, 187, 100, 130, 157, 111, 32, 75, 80], [66, 102, 167, 99, 74, 62, 40, 234, 128], [41, 53, 9, 178, 241, 141, 26, 8, 107], [74, 43, 26, 146, 73, 166, 49, 23, 157], [65, 38, 105, 160, 51, 52, 31, 115, 128], [104, 79, 12, 27, 217, 255, 87, 17, 7], [87, 68, 71, 44, 114, 51, 15, 186, 23], [47, 41, 14, 110, 182, 183, 21, 17, 194], [66, 45, 25, 102, 197, 189, 23, 18, 22]], [[88, 88, 147, 150, 42, 46, 45, 196, 205], [43, 97, 183, 117, 85, 38, 35, 179, 61], [39, 53, 200, 87, 26, 21, 43, 232, 171], [56, 34, 51, 104, 114, 102, 29, 93, 77], [39, 28, 85, 171, 58, 165, 90, 98, 64], [34, 22, 116, 206, 23, 34, 43, 166, 73], [107, 54, 32, 26, 51, 1, 81, 43, 31], [68, 25, 106, 22, 64, 171, 36, 225, 114], [34, 19, 21, 102, 132, 188, 16, 76, 124], [62, 18, 78, 95, 85, 57, 50, 48, 51]], [[193, 101, 35, 159, 215, 111, 89, 46, 111], [60, 148, 31, 172, 219, 228, 21, 18, 111], [112, 113, 77, 85, 179, 255, 38, 120, 114], [40, 42, 1, 196, 245, 209, 10, 25, 109], [88, 43, 29, 140, 166, 213, 37, 43, 154], [61, 63, 30, 155, 67, 45, 68, 1, 209], [100, 80, 8, 43, 154, 1, 51, 26, 71], [142, 78, 78, 16, 255, 128, 34, 197, 171], [41, 40, 5, 102, 211, 183, 4, 1, 221], [51, 50, 17, 168, 209, 192, 23, 25, 82]], [[138, 31, 36, 171, 27, 166, 38, 44, 229], [67, 87, 58, 169, 82, 115, 26, 59, 179], [63, 59, 90, 180, 59, 166, 93, 73, 154], [40, 40, 21, 116, 143, 209, 34, 39, 175], [47, 15, 16, 183, 34, 223, 49, 45, 183], [46, 17, 33, 183, 6, 98, 15, 32, 183], [57, 46, 22, 24, 128, 1, 54, 17, 37], [65, 32, 73, 115, 28, 128, 23, 128, 205], [40, 3, 9, 115, 51, 192, 18, 6, 223], [87, 37, 9, 115, 59, 77, 64, 21, 47]], [[104, 55, 44, 218, 9, 54, 53, 130, 226], [64, 90, 70, 205, 40, 41, 23, 26, 57], [54, 57, 112, 184, 5, 41, 38, 166, 213], [30, 34, 26, 133, 152, 116, 10, 32, 134], [39, 19, 53, 221, 26, 114, 32, 73, 255], [31, 9, 65, 234, 2, 15, 1, 118, 73], [75, 32, 12, 51, 192, 255, 160, 43, 51], [88, 31, 35, 67, 102, 85, 55, 186, 85], [56, 21, 23, 111, 59, 205, 45, 37, 192], [55, 38, 70, 124, 73, 102, 1, 34, 98]], [[125, 98, 42, 88, 104, 85, 117, 175, 82], [95, 84, 53, 89, 128, 100, 113, 101, 45], [75, 79, 123, 47, 51, 128, 81, 171, 1], [57, 17, 5, 71, 102, 57, 53, 41, 49], [38, 33, 13, 121, 57, 73, 26, 1, 85], [41, 10, 67, 138, 77, 110, 90, 47, 114], [115, 21, 2, 10, 102, 255, 166, 23, 6], [101, 29, 16, 10, 85, 128, 101, 196, 26], [57, 18, 10, 102, 102, 213, 34, 20, 43], [117, 20, 15, 36, 163, 128, 68, 1, 26]], [[102, 61, 71, 37, 34, 53, 31, 243, 192], [69, 60, 71, 38, 73, 119, 28, 222, 37], [68, 45, 128, 34, 1, 47, 11, 245, 171], [62, 17, 19, 70, 146, 85, 55, 62, 70], [37, 43, 37, 154, 100, 163, 85, 160, 1], [63, 9, 92, 136, 28, 64, 32, 201, 85], [75, 15, 9, 9, 64, 255, 184, 119, 16], [86, 6, 28, 5, 64, 255, 25, 248, 1], [56, 8, 17, 132, 137, 255, 55, 116, 128], [58, 15, 20, 82, 135, 57, 26, 121, 40]], [[164, 50, 31, 137, 154, 133, 25, 35, 218], [51, 103, 44, 131, 131, 123, 31, 6, 158], [86, 40, 64, 135, 148, 224, 45, 183, 128], [22, 26, 17, 131, 240, 154, 14, 1, 209], [45, 16, 21, 91, 64, 222, 7, 1, 197], [56, 21, 39, 155, 60, 138, 23, 102, 213], [83, 12, 13, 54, 192, 255, 68, 47, 28], [85, 26, 85, 85, 128, 128, 32, 146, 171], [18, 11, 7, 63, 144, 171, 4, 4, 246], [35, 27, 10, 146, 174, 171, 12, 26, 128]], [[190, 80, 35, 99, 180, 80, 126, 54, 45], [85, 126, 47, 87, 176, 51, 41, 20, 32], [101, 75, 128, 139, 118, 146, 116, 128, 85], [56, 41, 15, 176, 236, 85, 37, 9, 62], [71, 30, 17, 119, 118, 255, 17, 18, 138], [101, 38, 60, 138, 55, 70, 43, 26, 142], [146, 36, 19, 30, 171, 255, 97, 27, 20], [138, 45, 61, 62, 219, 1, 81, 188, 64], [32, 41, 20, 117, 151, 142, 20, 21, 163], [112, 19, 12, 61, 195, 128, 48, 4, 24]]], dl = [[[[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[176, 246, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 241, 252, 255, 255, 255, 255, 255, 255, 255, 255], [249, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 244, 252, 255, 255, 255, 255, 255, 255, 255, 255], [234, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 246, 254, 255, 255, 255, 255, 255, 255, 255, 255], [239, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 254, 255, 255, 255, 255, 255, 255], [250, 255, 254, 255, 254, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[217, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [225, 252, 241, 253, 255, 255, 254, 255, 255, 255, 255], [234, 250, 241, 250, 253, 255, 253, 254, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [223, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [238, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 248, 254, 255, 255, 255, 255, 255, 255, 255, 255], [249, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 255, 255, 255, 255, 255, 255, 255, 255, 255], [247, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [252, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[186, 251, 250, 255, 255, 255, 255, 255, 255, 255, 255], [234, 251, 244, 254, 255, 255, 255, 255, 255, 255, 255], [251, 251, 243, 253, 254, 255, 254, 255, 255, 255, 255]], [[255, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [236, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [251, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]], [[[248, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [250, 254, 252, 254, 255, 255, 255, 255, 255, 255, 255], [248, 254, 249, 253, 255, 255, 255, 255, 255, 255, 255]], [[255, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [246, 253, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 254, 251, 254, 254, 255, 255, 255, 255, 255, 255]], [[255, 254, 252, 255, 255, 255, 255, 255, 255, 255, 255], [248, 254, 253, 255, 255, 255, 255, 255, 255, 255, 255], [253, 255, 254, 254, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [245, 251, 254, 255, 255, 255, 255, 255, 255, 255, 255], [253, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 251, 253, 255, 255, 255, 255, 255, 255, 255, 255], [252, 253, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 254, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 252, 255, 255, 255, 255, 255, 255, 255, 255, 255], [249, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 254, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 253, 255, 255, 255, 255, 255, 255, 255, 255], [250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]], [[255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [254, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255], [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255]]]], jd = [0, 1, 2, 3, 6, 4, 5, 6, 6, 6, 6, 6, 6, 6, 6, 7, 0], io = [], Ms = [], ea = [], Md = 1, Gl = 2, Da = [], ys = []; fr("UpsampleRgbLinePair", mi, 3), fr("UpsampleBgrLinePair", zi, 3), fr("UpsampleRgbaLinePair", pa, 4), fr("UpsampleBgraLinePair", vs, 4), fr("UpsampleArgbLinePair", es, 4), fr("UpsampleRgba4444LinePair", Ji, 2), fr("UpsampleRgb565LinePair", Vi, 2); var so = on.UpsampleRgbLinePair, Io = on.UpsampleBgrLinePair, ka = on.UpsampleRgbaLinePair, mu = on.UpsampleBgraLinePair, gu = on.UpsampleArgbLinePair, Wl = on.UpsampleRgba4444LinePair, vu = on.UpsampleRgb565LinePair, Ia = 16, ds = 1 << Ia - 1, Fo = -227, bu = 482, Nh = 6, Dd = 0, Ph = Re(256), hs = Re(256), Xu = Re(256), Fc = Re(256), Bc = Re(bu - Fo), Yu = Re(bu - Fo); ma("YuvToRgbRow", mi, 3), ma("YuvToBgrRow", zi, 3), ma("YuvToRgbaRow", pa, 4), ma("YuvToBgraRow", vs, 4), ma("YuvToArgbRow", es, 4), ma("YuvToRgba4444Row", Ji, 2), ma("YuvToRgb565Row", Vi, 2); var hl = [0, 4, 8, 12, 128, 132, 136, 140, 256, 260, 264, 268, 384, 388, 392, 396], ao = [0, 2, 8], Oh = [8, 7, 6, 4, 4, 2, 2, 2, 1, 1, 1, 1], kd = 1; this.WebPDecodeRGBA = function (Ue, Ve, en, gn, An) { var Nn = $l, Ln = new Dl, jn = new Wi; Ln.ba = jn, jn.S = Nn, jn.width = [jn.width], jn.height = [jn.height]; var Dn = jn.width, Bn = jn.height, Gn = new $i; if (Gn == null || Ue == null) var ar = 2; else t(Gn != null), ar = Bl(Ue, Ve, en, Gn.width, Gn.height, Gn.Pd, Gn.Qd, Gn.format, null); if (ar != 0 ? Dn = 0 : (Dn != null && (Dn[0] = Gn.width[0]), Bn != null && (Bn[0] = Gn.height[0]), Dn = 1), Dn) { jn.width = jn.width[0], jn.height = jn.height[0], gn != null && (gn[0] = jn.width), An != null && (An[0] = jn.height); e: { if (gn = new mo, (An = new Tc).data = Ue, An.w = Ve, An.ha = en, An.kd = 1, Ve = [0], t(An != null), ((Ue = Bl(An.data, An.w, An.ha, null, null, null, Ve, null, An)) == 0 || Ue == 7) && Ve[0] && (Ue = 4), (Ve = Ue) == 0) { if (t(Ln != null), gn.data = An.data, gn.w = An.w + An.offset, gn.ha = An.ha - An.offset, gn.put = fi, gn.ac = ii, gn.bc = yi, gn.ma = Ln, An.xa) { if ((Ue = ws()) == null) { Ln = 1; break e } if (function (nr, Jn) { var xr = [0], dr = [0], Wn = [0]; t: for (; ;) { if (nr == null) return 0; if (Jn == null) return nr.a = 2, 0; if (nr.l = Jn, nr.a = 0, tn(nr.m, Jn.data, Jn.w, Jn.ha), !Lr(nr.m, xr, dr, Wn)) { nr.a = 3; break t } if (nr.xb = Gl, Jn.width = xr[0], Jn.height = dr[0], !Li(xr[0], dr[0], 1, nr, null)) break t; return 1 } return t(nr.a != 0), 0 }(Ue, gn)) { if (gn = (Ve = tl(gn.width, gn.height, Ln.Oa, Ln.ba)) == 0) { t: { gn = Ue; n: for (; ;) { if (gn == null) { gn = 0; break t } if (t(gn.s.yc != null), t(gn.s.Ya != null), t(0 < gn.s.Wb), t((en = gn.l) != null), t((An = en.ma) != null), gn.xb != 0) { if (gn.ca = An.ba, gn.tb = An.tb, t(gn.ca != null), !So(An.Oa, en, Mc)) { gn.a = 2; break n } if (!po(gn, en.width) || en.da) break n; if ((en.da || kr(gn.ca.S)) && tr(), 11 > gn.ca.S || (alert("todo:WebPInitConvertARGBToYUV"), gn.ca.f.kb.F != null && tr()), gn.Pb && 0 < gn.s.ua && gn.s.vb.X == null && !sr(gn.s.vb, gn.s.Wa.Xa)) { gn.a = 1; break n } gn.xb = 0 } if (!Rs(gn, gn.V, gn.Ba, gn.c, gn.i, en.o, Wo)) break n; An.Dc = gn.Ma, gn = 1; break t } t(gn.a != 0), gn = 0 } gn = !gn } gn && (Ve = Ue.a) } else Ve = Ue.a } else { if ((Ue = new zu) == null) { Ln = 1; break e } if (Ue.Fa = An.na, Ue.P = An.P, Ue.qc = An.Sa, xc(Ue, gn)) { if ((Ve = tl(gn.width, gn.height, Ln.Oa, Ln.ba)) == 0) { if (Ue.Aa = 0, en = Ln.Oa, t((An = Ue) != null), en != null) { if (0 < (Dn = 0 > (Dn = en.Md) ? 0 : 100 < Dn ? 255 : 255 * Dn / 100)) { for (Bn = Gn = 0; 4 > Bn; ++Bn)12 > (ar = An.pb[Bn]).lc && (ar.ia = Dn * Oh[0 > ar.lc ? 0 : ar.lc] >> 3), Gn |= ar.ia; Gn && (alert("todo:VP8InitRandom"), An.ia = 1) } An.Ga = en.Id, 100 < An.Ga ? An.Ga = 100 : 0 > An.Ga && (An.Ga = 0) } ru(Ue, gn) || (Ve = Ue.a) } } else Ve = Ue.a } Ve == 0 && Ln.Oa != null && Ln.Oa.fd && (Ve = Ul(Ln.ba)) } Ln = Ve } Nn = Ln != 0 ? null : 11 > Nn ? jn.f.RGBA.eb : jn.f.kb.y } else Nn = null; return Nn }; var Id = [3, 4, 3, 4, 4, 2, 2, 4, 4, 4, 2, 1, 1] }; function Pe(on, bn) { for (var Tn = "", fn = 0; fn < 4; fn++)Tn += String.fromCharCode(on[bn++]); return Tn } function Oe(on, bn) { return (on[bn + 0] << 0 | on[bn + 1] << 8 | on[bn + 2] << 16) >>> 0 } function je(on, bn) { return (on[bn + 0] << 0 | on[bn + 1] << 8 | on[bn + 2] << 16 | on[bn + 3] << 24) >>> 0 } new De; var Be = [0], Ie = [0], Fe = [], ze = new De, qe = e, He = function (on, bn) { var Tn = {}, fn = 0, En = !1, Pn = 0, Rn = 0; if (Tn.frames = [], !function (rn, hn, mn, Ye) { for (var an = 0; an < Ye; an++)if (rn[hn + an] != mn.charCodeAt(an)) return !0; return !1 }(on, bn, "RIFF", 4)) { for (je(on, bn += 4), bn += 8; bn < on.length;) { var In = Pe(on, bn), xn = je(on, bn += 4); bn += 4; var vn = xn + (1 & xn); switch (In) { case "VP8 ": case "VP8L": Tn.frames[fn] === void 0 && (Tn.frames[fn] = {}), (We = Tn.frames[fn]).src_off = En ? Rn : bn - 8, We.src_size = Pn + xn + 8, fn++, En && (En = !1, Pn = 0, Rn = 0); break; case "VP8X": (We = Tn.header = {}).feature_flags = on[bn]; var tn = bn + 4; We.canvas_width = 1 + Oe(on, tn), tn += 3, We.canvas_height = 1 + Oe(on, tn), tn += 3; break; case "ALPH": En = !0, Pn = vn + 8, Rn = bn - 8; break; case "ANIM": (We = Tn.header).bgcolor = je(on, bn), tn = bn + 4, We.loop_count = (dn = on)[(Je = tn) + 0] << 0 | dn[Je + 1] << 8, tn += 2; break; case "ANMF": var nn, We; (We = Tn.frames[fn] = {}).offset_x = 2 * Oe(on, bn), bn += 3, We.offset_y = 2 * Oe(on, bn), bn += 3, We.width = 1 + Oe(on, bn), bn += 3, We.height = 1 + Oe(on, bn), bn += 3, We.duration = Oe(on, bn), bn += 3, nn = on[bn++], We.dispose = 1 & nn, We.blend = nn >> 1 & 1 }In != "ANMF" && (bn += vn) } var dn, Je; return Tn } }(qe, 0); He.response = qe, He.rgbaoutput = !0, He.dataurl = !1; var Ge = He.header ? He.header : null, Ze = He.frames ? He.frames : null; if (Ge) { Ge.loop_counter = Ge.loop_count, Be = [Ge.canvas_height], Ie = [Ge.canvas_width]; for (var sn = 0; sn < Ze.length && Ze[sn].blend != 0; sn++); } var Xe = Ze[0], St = ze.WebPDecodeRGBA(qe, Xe.src_off, Xe.src_size, Ie, Be); Xe.rgba = St, Xe.imgwidth = Ie[0], Xe.imgheight = Be[0]; for (var un = 0; un < Ie[0] * Be[0] * 4; un++)Fe[un] = St[un]; return this.width = Ie, this.height = Be, this.data = Fe, this } (function (e) { var t = function () { return typeof zlibSync == "function" }, xe = function (Be, Ie, Fe, ze) { var qe = 4, He = Ce; switch (ze) { case e.image_compression.FAST: qe = 1, He = Re; break; case e.image_compression.MEDIUM: qe = 6, He = Me; break; case e.image_compression.SLOW: qe = 9, He = De }Be = Ee(Be, Ie, Fe, He); var Ge = zlibSync(Be, { level: qe }); return e.__addimage__.arrayBufferToBinaryString(Ge) }, Ee = function (Be, Ie, Fe, ze) { for (var qe, He, Ge, Ze = Be.length / Ie, sn = new Uint8Array(Be.length + Ze), Xe = Oe(), St = 0; St < Ze; St += 1) { if (Ge = St * Ie, qe = Be.subarray(Ge, Ge + Ie), ze) sn.set(ze(qe, Fe, He), Ge + St); else { for (var un, on = Xe.length, bn = []; un < on; un += 1)bn[un] = Xe[un](qe, Fe, He); var Tn = je(bn.concat()); sn.set(bn[Tn], Ge + St) } He = qe } return sn }, _e = function (Be) { var Ie = Array.apply([], Be); return Ie.unshift(0), Ie }, Re = function (Be, Ie) { var Fe, ze = [], qe = Be.length; ze[0] = 1; for (var He = 0; He < qe; He += 1)Fe = Be[He - Ie] || 0, ze[He + 1] = Be[He] - Fe + 256 & 255; return ze }, Ce = function (Be, Ie, Fe) { var ze, qe = [], He = Be.length; qe[0] = 2; for (var Ge = 0; Ge < He; Ge += 1)ze = Fe && Fe[Ge] || 0, qe[Ge + 1] = Be[Ge] - ze + 256 & 255; return qe }, Me = function (Be, Ie, Fe) { var ze, qe, He = [], Ge = Be.length; He[0] = 3; for (var Ze = 0; Ze < Ge; Ze += 1)ze = Be[Ze - Ie] || 0, qe = Fe && Fe[Ze] || 0, He[Ze + 1] = Be[Ze] + 256 - (ze + qe >>> 1) & 255; return He }, De = function (Be, Ie, Fe) { var ze, qe, He, Ge, Ze = [], sn = Be.length; Ze[0] = 4; for (var Xe = 0; Xe < sn; Xe += 1)ze = Be[Xe - Ie] || 0, qe = Fe && Fe[Xe] || 0, He = Fe && Fe[Xe - Ie] || 0, Ge = Pe(ze, qe, He), Ze[Xe + 1] = Be[Xe] - Ge + 256 & 255; return Ze }, Pe = function (Be, Ie, Fe) { if (Be === Ie && Ie === Fe) return Be; var ze = Math.abs(Ie - Fe), qe = Math.abs(Be - Fe), He = Math.abs(Be + Ie - Fe - Fe); return ze <= qe && ze <= He ? Be : qe <= He ? Ie : Fe }, Oe = function () { return [_e, Re, Ce, Me, De] }, je = function (Be) { var Ie = Be.map(function (Fe) { return Fe.reduce(function (ze, qe) { return ze + Math.abs(qe) }, 0) }); return Ie.indexOf(Math.min.apply(null, Ie)) }; e.processPNG = function (Be, Ie, Fe, ze) { var qe, He, Ge, Ze, sn, Xe, St, un, on, bn, Tn, fn, En, Pn, Rn, In = this.decode.FLATE_DECODE, xn = ""; if (this.__addimage__.isArrayBuffer(Be) && (Be = new Uint8Array(Be)), this.__addimage__.isArrayBufferView(Be)) { if (Be = (Ge = new Kt(Be)).imgData, He = Ge.bits, qe = Ge.colorSpace, sn = Ge.colors, [4, 6].indexOf(Ge.colorType) !== -1) { if (Ge.bits === 8) { on = (un = Ge.pixelBitlength == 32 ? new Uint32Array(Ge.decodePixels().buffer) : Ge.pixelBitlength == 16 ? new Uint16Array(Ge.decodePixels().buffer) : new Uint8Array(Ge.decodePixels().buffer)).length, Tn = new Uint8Array(on * Ge.colors), bn = new Uint8Array(on); var vn, tn = Ge.pixelBitlength - Ge.bits; for (Pn = 0, Rn = 0; Pn < on; Pn++) { for (En = un[Pn], vn = 0; vn < tn;)Tn[Rn++] = En >>> vn & 255, vn += Ge.bits; bn[Pn] = En >>> vn & 255 } } if (Ge.bits === 16) { on = (un = new Uint32Array(Ge.decodePixels().buffer)).length, Tn = new Uint8Array(on * (32 / Ge.pixelBitlength) * Ge.colors), bn = new Uint8Array(on * (32 / Ge.pixelBitlength)), fn = Ge.colors > 1, Pn = 0, Rn = 0; for (var nn = 0; Pn < on;)En = un[Pn++], Tn[Rn++] = En >>> 0 & 255, fn && (Tn[Rn++] = En >>> 16 & 255, En = un[Pn++], Tn[Rn++] = En >>> 0 & 255), bn[nn++] = En >>> 16 & 255; He = 8 } ze !== e.image_compression.NONE && t() ? (Be = xe(Tn, Ge.width * Ge.colors, Ge.colors, ze), St = xe(bn, Ge.width, 1, ze)) : (Be = Tn, St = bn, In = void 0) } if (Ge.colorType === 3 && (qe = this.color_spaces.INDEXED, Xe = Ge.palette, Ge.transparency.indexed)) { var We = Ge.transparency.indexed, dn = 0; for (Pn = 0, on = We.length; Pn < on; ++Pn)dn += We[Pn]; if ((dn /= 255) === on - 1 && We.indexOf(0) !== -1) Ze = [We.indexOf(0)]; else if (dn !== on) { for (un = Ge.decodePixels(), bn = new Uint8Array(un.length), Pn = 0, on = un.length; Pn < on; Pn++)bn[Pn] = We[un[Pn]]; St = xe(bn, Ge.width, 1) } } var Je = function (rn) { var hn; switch (rn) { case e.image_compression.FAST: hn = 11; break; case e.image_compression.MEDIUM: hn = 13; break; case e.image_compression.SLOW: hn = 14; break; default: hn = 12 }return hn }(ze); return In === this.decode.FLATE_DECODE && (xn = "/Predictor " + Je + " "), xn += "/Colors " + sn + " /BitsPerComponent " + He + " /Columns " + Ge.width, (this.__addimage__.isArrayBuffer(Be) || this.__addimage__.isArrayBufferView(Be)) && (Be = this.__addimage__.arrayBufferToBinaryString(Be)), (St && this.__addimage__.isArrayBuffer(St) || this.__addimage__.isArrayBufferView(St)) && (St = this.__addimage__.arrayBufferToBinaryString(St)), { alias: Fe, data: Be, index: Ie, filter: In, decodeParameters: xn, transparency: Ze, palette: Xe, sMask: St, predictor: Je, width: Ge.width, height: Ge.height, bitsPerComponent: He, colorSpace: qe } } } })(E.API), function (e) { e.processGIF89A = function (t, xe, Ee, _e) { var Re = new Zt(t), Ce = Re.width, Me = Re.height, De = []; Re.decodeAndBlitFrameRGBA(0, De); var Pe = { data: De, width: Ce, height: Me }, Oe = new Qt(100).encode(Pe, 100); return e.processJPEG.call(this, Oe, xe, Ee, _e) }, e.processGIF87A = e.processGIF89A }(E.API), te.prototype.parseHeader = function () { if (this.fileSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.reserved = this.datav.getUint32(this.pos, !0), this.pos += 4, this.offset = this.datav.getUint32(this.pos, !0), this.pos += 4, this.headerSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.width = this.datav.getUint32(this.pos, !0), this.pos += 4, this.height = this.datav.getInt32(this.pos, !0), this.pos += 4, this.planes = this.datav.getUint16(this.pos, !0), this.pos += 2, this.bitPP = this.datav.getUint16(this.pos, !0), this.pos += 2, this.compress = this.datav.getUint32(this.pos, !0), this.pos += 4, this.rawSize = this.datav.getUint32(this.pos, !0), this.pos += 4, this.hr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.vr = this.datav.getUint32(this.pos, !0), this.pos += 4, this.colors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.importantColors = this.datav.getUint32(this.pos, !0), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) { var e = this.colors === 0 ? 1 << this.bitPP : this.colors; this.palette = new Array(e); for (var t = 0; t < e; t++) { var xe = this.datav.getUint8(this.pos++, !0), Ee = this.datav.getUint8(this.pos++, !0), _e = this.datav.getUint8(this.pos++, !0), Re = this.datav.getUint8(this.pos++, !0); this.palette[t] = { red: _e, green: Ee, blue: xe, quad: Re } } } this.height < 0 && (this.height *= -1, this.bottom_up = !1) }, te.prototype.parseBGR = function () { this.pos = this.offset; try { var e = "bit" + this.bitPP, t = this.width * this.height * 4; this.data = new Uint8Array(t), this[e]() } catch (xe) { a.log("bit decode error:" + xe) } }, te.prototype.bit1 = function () { var e, t = Math.ceil(this.width / 8), xe = t % 4; for (e = this.height - 1; e >= 0; e--) { for (var Ee = this.bottom_up ? e : this.height - 1 - e, _e = 0; _e < t; _e++)for (var Re = this.datav.getUint8(this.pos++, !0), Ce = Ee * this.width * 4 + 8 * _e * 4, Me = 0; Me < 8 && 8 * _e + Me < this.width; Me++) { var De = this.palette[Re >> 7 - Me & 1]; this.data[Ce + 4 * Me] = De.blue, this.data[Ce + 4 * Me + 1] = De.green, this.data[Ce + 4 * Me + 2] = De.red, this.data[Ce + 4 * Me + 3] = 255 } xe !== 0 && (this.pos += 4 - xe) } }, te.prototype.bit4 = function () { for (var e = Math.ceil(this.width / 2), t = e % 4, xe = this.height - 1; xe >= 0; xe--) { for (var Ee = this.bottom_up ? xe : this.height - 1 - xe, _e = 0; _e < e; _e++) { var Re = this.datav.getUint8(this.pos++, !0), Ce = Ee * this.width * 4 + 2 * _e * 4, Me = Re >> 4, De = 15 & Re, Pe = this.palette[Me]; if (this.data[Ce] = Pe.blue, this.data[Ce + 1] = Pe.green, this.data[Ce + 2] = Pe.red, this.data[Ce + 3] = 255, 2 * _e + 1 >= this.width) break; Pe = this.palette[De], this.data[Ce + 4] = Pe.blue, this.data[Ce + 4 + 1] = Pe.green, this.data[Ce + 4 + 2] = Pe.red, this.data[Ce + 4 + 3] = 255 } t !== 0 && (this.pos += 4 - t) } }, te.prototype.bit8 = function () { for (var e = this.width % 4, t = this.height - 1; t >= 0; t--) { for (var xe = this.bottom_up ? t : this.height - 1 - t, Ee = 0; Ee < this.width; Ee++) { var _e = this.datav.getUint8(this.pos++, !0), Re = xe * this.width * 4 + 4 * Ee; if (_e < this.palette.length) { var Ce = this.palette[_e]; this.data[Re] = Ce.red, this.data[Re + 1] = Ce.green, this.data[Re + 2] = Ce.blue, this.data[Re + 3] = 255 } else this.data[Re] = 255, this.data[Re + 1] = 255, this.data[Re + 2] = 255, this.data[Re + 3] = 255 } e !== 0 && (this.pos += 4 - e) } }, te.prototype.bit15 = function () { for (var e = this.width % 3, t = parseInt("11111", 2), xe = this.height - 1; xe >= 0; xe--) { for (var Ee = this.bottom_up ? xe : this.height - 1 - xe, _e = 0; _e < this.width; _e++) { var Re = this.datav.getUint16(this.pos, !0); this.pos += 2; var Ce = (Re & t) / t * 255 | 0, Me = (Re >> 5 & t) / t * 255 | 0, De = (Re >> 10 & t) / t * 255 | 0, Pe = Re >> 15 ? 255 : 0, Oe = Ee * this.width * 4 + 4 * _e; this.data[Oe] = De, this.data[Oe + 1] = Me, this.data[Oe + 2] = Ce, this.data[Oe + 3] = Pe } this.pos += e } }, te.prototype.bit16 = function () { for (var e = this.width % 3, t = parseInt("11111", 2), xe = parseInt("111111", 2), Ee = this.height - 1; Ee >= 0; Ee--) { for (var _e = this.bottom_up ? Ee : this.height - 1 - Ee, Re = 0; Re < this.width; Re++) { var Ce = this.datav.getUint16(this.pos, !0); this.pos += 2; var Me = (Ce & t) / t * 255 | 0, De = (Ce >> 5 & xe) / xe * 255 | 0, Pe = (Ce >> 11) / t * 255 | 0, Oe = _e * this.width * 4 + 4 * Re; this.data[Oe] = Pe, this.data[Oe + 1] = De, this.data[Oe + 2] = Me, this.data[Oe + 3] = 255 } this.pos += e } }, te.prototype.bit24 = function () { for (var e = this.height - 1; e >= 0; e--) { for (var t = this.bottom_up ? e : this.height - 1 - e, xe = 0; xe < this.width; xe++) { var Ee = this.datav.getUint8(this.pos++, !0), _e = this.datav.getUint8(this.pos++, !0), Re = this.datav.getUint8(this.pos++, !0), Ce = t * this.width * 4 + 4 * xe; this.data[Ce] = Re, this.data[Ce + 1] = _e, this.data[Ce + 2] = Ee, this.data[Ce + 3] = 255 } this.pos += this.width % 4 } }, te.prototype.bit32 = function () { for (var e = this.height - 1; e >= 0; e--)for (var t = this.bottom_up ? e : this.height - 1 - e, xe = 0; xe < this.width; xe++) { var Ee = this.datav.getUint8(this.pos++, !0), _e = this.datav.getUint8(this.pos++, !0), Re = this.datav.getUint8(this.pos++, !0), Ce = this.datav.getUint8(this.pos++, !0), Me = t * this.width * 4 + 4 * xe; this.data[Me] = Re, this.data[Me + 1] = _e, this.data[Me + 2] = Ee, this.data[Me + 3] = Ce } }, te.prototype.getData = function () { return this.data }, function (e) { e.processBMP = function (t, xe, Ee, _e) { var Re = new te(t, !1), Ce = Re.width, Me = Re.height, De = { data: Re.getData(), width: Ce, height: Me }, Pe = new Qt(100).encode(De, 100); return e.processJPEG.call(this, Pe, xe, Ee, _e) } }(E.API), ee.prototype.getData = function () { return this.data }, function (e) { e.processWEBP = function (t, xe, Ee, _e) { var Re = new ee(t), Ce = Re.width, Me = Re.height, De = { data: Re.getData(), width: Ce, height: Me }, Pe = new Qt(100).encode(De, 100); return e.processJPEG.call(this, Pe, xe, Ee, _e) } }(E.API), E.API.processRGBA = function (e, t, xe) { for (var Ee = e.data, _e = Ee.length, Re = new Uint8Array(_e / 4 * 3), Ce = new Uint8Array(_e / 4), Me = 0, De = 0, Pe = 0; Pe < _e; Pe += 4) { var Oe = Ee[Pe], je = Ee[Pe + 1], Be = Ee[Pe + 2], Ie = Ee[Pe + 3]; Re[Me++] = Oe, Re[Me++] = je, Re[Me++] = Be, Ce[De++] = Ie } var Fe = this.__addimage__.arrayBufferToBinaryString(Re); return { alpha: this.__addimage__.arrayBufferToBinaryString(Ce), data: Fe, index: t, alias: xe, colorSpace: "DeviceRGB", bitsPerComponent: 8, width: e.width, height: e.height } }, E.API.setLanguage = function (e) { return this.internal.languageSettings === void 0 && (this.internal.languageSettings = {}, this.internal.languageSettings.isSubscribed = !1), { af: "Afrikaans", sq: "Albanian", ar: "Arabic (Standard)", "ar-DZ": "Arabic (Algeria)", "ar-BH": "Arabic (Bahrain)", "ar-EG": "Arabic (Egypt)", "ar-IQ": "Arabic (Iraq)", "ar-JO": "Arabic (Jordan)", "ar-KW": "Arabic (Kuwait)", "ar-LB": "Arabic (Lebanon)", "ar-LY": "Arabic (Libya)", "ar-MA": "Arabic (Morocco)", "ar-OM": "Arabic (Oman)", "ar-QA": "Arabic (Qatar)", "ar-SA": "Arabic (Saudi Arabia)", "ar-SY": "Arabic (Syria)", "ar-TN": "Arabic (Tunisia)", "ar-AE": "Arabic (U.A.E.)", "ar-YE": "Arabic (Yemen)", an: "Aragonese", hy: "Armenian", as: "Assamese", ast: "Asturian", az: "Azerbaijani", eu: "Basque", be: "Belarusian", bn: "Bengali", bs: "Bosnian", br: "Breton", bg: "Bulgarian", my: "Burmese", ca: "Catalan", ch: "Chamorro", ce: "Chechen", zh: "Chinese", "zh-HK": "Chinese (Hong Kong)", "zh-CN": "Chinese (PRC)", "zh-SG": "Chinese (Singapore)", "zh-TW": "Chinese (Taiwan)", cv: "Chuvash", co: "Corsican", cr: "Cree", hr: "Croatian", cs: "Czech", da: "Danish", nl: "Dutch (Standard)", "nl-BE": "Dutch (Belgian)", en: "English", "en-AU": "English (Australia)", "en-BZ": "English (Belize)", "en-CA": "English (Canada)", "en-IE": "English (Ireland)", "en-JM": "English (Jamaica)", "en-NZ": "English (New Zealand)", "en-PH": "English (Philippines)", "en-ZA": "English (South Africa)", "en-TT": "English (Trinidad & Tobago)", "en-GB": "English (United Kingdom)", "en-US": "English (United States)", "en-ZW": "English (Zimbabwe)", eo: "Esperanto", et: "Estonian", fo: "Faeroese", fj: "Fijian", fi: "Finnish", fr: "French (Standard)", "fr-BE": "French (Belgium)", "fr-CA": "French (Canada)", "fr-FR": "French (France)", "fr-LU": "French (Luxembourg)", "fr-MC": "French (Monaco)", "fr-CH": "French (Switzerland)", fy: "Frisian", fur: "Friulian", gd: "Gaelic (Scots)", "gd-IE": "Gaelic (Irish)", gl: "Galacian", ka: "Georgian", de: "German (Standard)", "de-AT": "German (Austria)", "de-DE": "German (Germany)", "de-LI": "German (Liechtenstein)", "de-LU": "German (Luxembourg)", "de-CH": "German (Switzerland)", el: "Greek", gu: "Gujurati", ht: "Haitian", he: "Hebrew", hi: "Hindi", hu: "Hungarian", is: "Icelandic", id: "Indonesian", iu: "Inuktitut", ga: "Irish", it: "Italian (Standard)", "it-CH": "Italian (Switzerland)", ja: "Japanese", kn: "Kannada", ks: "Kashmiri", kk: "Kazakh", km: "Khmer", ky: "Kirghiz", tlh: "Klingon", ko: "Korean", "ko-KP": "Korean (North Korea)", "ko-KR": "Korean (South Korea)", la: "Latin", lv: "Latvian", lt: "Lithuanian", lb: "Luxembourgish", mk: "North Macedonia", ms: "Malay", ml: "Malayalam", mt: "Maltese", mi: "Maori", mr: "Marathi", mo: "Moldavian", nv: "Navajo", ng: "Ndonga", ne: "Nepali", no: "Norwegian", nb: "Norwegian (Bokmal)", nn: "Norwegian (Nynorsk)", oc: "Occitan", or: "Oriya", om: "Oromo", fa: "Persian", "fa-IR": "Persian/Iran", pl: "Polish", pt: "Portuguese", "pt-BR": "Portuguese (Brazil)", pa: "Punjabi", "pa-IN": "Punjabi (India)", "pa-PK": "Punjabi (Pakistan)", qu: "Quechua", rm: "Rhaeto-Romanic", ro: "Romanian", "ro-MO": "Romanian (Moldavia)", ru: "Russian", "ru-MO": "Russian (Moldavia)", sz: "Sami (Lappish)", sg: "Sango", sa: "Sanskrit", sc: "Sardinian", sd: "Sindhi", si: "Singhalese", sr: "Serbian", sk: "Slovak", sl: "Slovenian", so: "Somani", sb: "Sorbian", es: "Spanish", "es-AR": "Spanish (Argentina)", "es-BO": "Spanish (Bolivia)", "es-CL": "Spanish (Chile)", "es-CO": "Spanish (Colombia)", "es-CR": "Spanish (Costa Rica)", "es-DO": "Spanish (Dominican Republic)", "es-EC": "Spanish (Ecuador)", "es-SV": "Spanish (El Salvador)", "es-GT": "Spanish (Guatemala)", "es-HN": "Spanish (Honduras)", "es-MX": "Spanish (Mexico)", "es-NI": "Spanish (Nicaragua)", "es-PA": "Spanish (Panama)", "es-PY": "Spanish (Paraguay)", "es-PE": "Spanish (Peru)", "es-PR": "Spanish (Puerto Rico)", "es-ES": "Spanish (Spain)", "es-UY": "Spanish (Uruguay)", "es-VE": "Spanish (Venezuela)", sx: "Sutu", sw: "Swahili", sv: "Swedish", "sv-FI": "Swedish (Finland)", "sv-SV": "Swedish (Sweden)", ta: "Tamil", tt: "Tatar", te: "Teluga", th: "Thai", tig: "Tigre", ts: "Tsonga", tn: "Tswana", tr: "Turkish", tk: "Turkmen", uk: "Ukrainian", hsb: "Upper Sorbian", ur: "Urdu", ve: "Venda", vi: "Vietnamese", vo: "Volapuk", wa: "Walloon", cy: "Welsh", xh: "Xhosa", ji: "Yiddish", zu: "Zulu" }[e] !== void 0 && (this.internal.languageSettings.languageCode = e, this.internal.languageSettings.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function () { this.internal.write("/Lang (" + this.internal.languageSettings.languageCode + ")") }), this.internal.languageSettings.isSubscribed = !0)), this }, Vt = E.API, Gt = Vt.getCharWidthsArray = function (e, t) { var xe, Ee, _e = (t = t || {}).font || this.internal.getFont(), Re = t.fontSize || this.internal.getFontSize(), Ce = t.charSpace || this.internal.getCharSpace(), Me = t.widths ? t.widths : _e.metadata.Unicode.widths, De = Me.fof ? Me.fof : 1, Pe = t.kerning ? t.kerning : _e.metadata.Unicode.kerning, Oe = Pe.fof ? Pe.fof : 1, je = t.doKerning !== !1, Be = 0, Ie = e.length, Fe = 0, ze = Me[0] || De, qe = []; for (xe = 0; xe < Ie; xe++)Ee = e.charCodeAt(xe), typeof _e.metadata.widthOfString == "function" ? qe.push((_e.metadata.widthOfGlyph(_e.metadata.characterToGlyph(Ee)) + Ce * (1e3 / Re) || 0) / 1e3) : (Be = je && _typeof(Pe[Ee]) === "object" && !isNaN(parseInt(Pe[Ee][Fe], 10)) ? Pe[Ee][Fe] / Oe : 0, qe.push((Me[Ee] || ze) / De + Be)), Fe = Ee; return qe }, Yt = Vt.getStringUnitWidth = function (e, t) { var xe = (t = t || {}).fontSize || this.internal.getFontSize(), Ee = t.font || this.internal.getFont(), _e = t.charSpace || this.internal.getCharSpace(); return Vt.processArabic && (e = Vt.processArabic(e)), typeof Ee.metadata.widthOfString == "function" ? Ee.metadata.widthOfString(e, xe, _e) / xe : Gt.apply(this, arguments).reduce(function (Re, Ce) { return Re + Ce }, 0) }, Jt = function (e, t, xe, Ee) { for (var _e = [], Re = 0, Ce = e.length, Me = 0; Re !== Ce && Me + t[Re] < xe;)Me += t[Re], Re++; _e.push(e.slice(0, Re)); var De = Re; for (Me = 0; Re !== Ce;)Me + t[Re] > Ee && (_e.push(e.slice(De, Re)), Me = 0, De = Re), Me += t[Re], Re++; return De !== Re && _e.push(e.slice(De, Re)), _e }, Xt = function (e, t, xe) {
  xe || (xe = {}); var Ee, _e, Re, Ce, Me, De, Pe, Oe = [], je = [Oe], Be = xe.textIndent || 0, Ie = 0, Fe = 0, ze = e.split(" "), qe = Gt.apply(this, [" ", xe])[0]; if (De = xe.lineIndent === -1 ? ze[0].length + 2 : xe.lineIndent || 0) {
    var He = Array(De).join(" "), Ge = []; ze.map(function (sn) {
      (sn = sn.split(/\s*\n/)).length > 1 ? Ge = Ge.concat(sn.map(function (Xe, St) {
        return (St && Xe.length ? `
`: "") + Xe
      })) : Ge.push(sn[0])
    }), ze = Ge, De = Yt.apply(this, [He, xe])
  } for (Re = 0, Ce = ze.length; Re < Ce; Re++) {
    var Ze = 0; if (Ee = ze[Re], De && Ee[0] == `
`&& (Ee = Ee.substr(1), Ze = 1), Be + Ie + (Fe = (_e = Gt.apply(this, [Ee, xe])).reduce(function (sn, Xe) { return sn + Xe }, 0)) > t || Ze) { if (Fe > t) { for (Me = Jt.apply(this, [Ee, _e, t - (Be + Ie), t]), Oe.push(Me.shift()), Oe = [Me.pop()]; Me.length;)je.push([Me.shift()]); Fe = _e.slice(Ee.length - (Oe[0] ? Oe[0].length : 0)).reduce(function (sn, Xe) { return sn + Xe }, 0) } else Oe = [Ee]; je.push(Oe), Be = Fe + De, Ie = qe } else Oe.push(Ee), Be += Ie + Fe, Ie = qe
  } return Pe = De ? function (sn, Xe) { return (Xe ? He : "") + sn.join(" ") } : function (sn) { return sn.join(" ") }, je.map(Pe)
}, Vt.splitTextToSize = function (e, t, xe) { var Ee, _e = (xe = xe || {}).fontSize || this.internal.getFontSize(), Re = (function (Oe) { if (Oe.widths && Oe.kerning) return { widths: Oe.widths, kerning: Oe.kerning }; var je = this.internal.getFont(Oe.fontName, Oe.fontStyle); return je.metadata.Unicode ? { widths: je.metadata.Unicode.widths || { 0: 1 }, kerning: je.metadata.Unicode.kerning || {} } : { font: je.metadata, fontSize: this.internal.getFontSize(), charSpace: this.internal.getCharSpace() } }).call(this, xe); Ee = Array.isArray(e) ? e : String(e).split(/\r?\n/); var Ce = 1 * this.internal.scaleFactor * t / _e; Re.textIndent = xe.textIndent ? 1 * xe.textIndent * this.internal.scaleFactor / _e : 0, Re.lineIndent = xe.lineIndent; var Me, De, Pe = []; for (Me = 0, De = Ee.length; Me < De; Me++)Pe = Pe.concat(Xt.apply(this, [Ee[Me], Ce, Re])); return Pe }, function (e) { e.__fontmetrics__ = e.__fontmetrics__ || {}; for (var t = "klmnopqrstuvwxyz", xe = {}, Ee = {}, _e = 0; _e < t.length; _e++)xe[t[_e]] = "0123456789abcdef"[_e], Ee["0123456789abcdef"[_e]] = t[_e]; var Re = function (je) { return "0x" + parseInt(je, 10).toString(16) }, Ce = e.__fontmetrics__.compress = function (je) { var Be, Ie, Fe, ze, qe = ["{"]; for (var He in je) { if (Be = je[He], isNaN(parseInt(He, 10)) ? Ie = "'" + He + "'" : (He = parseInt(He, 10), Ie = (Ie = Re(He).slice(2)).slice(0, -1) + Ee[Ie.slice(-1)]), typeof Be == "number") Be < 0 ? (Fe = Re(Be).slice(3), ze = "-") : (Fe = Re(Be).slice(2), ze = ""), Fe = ze + Fe.slice(0, -1) + Ee[Fe.slice(-1)]; else { if (_typeof(Be) !== "object") throw new Error("Don't know what to do with value type " + _typeof(Be) + "."); Fe = Ce(Be) } qe.push(Ie + Fe) } return qe.push("}"), qe.join("") }, Me = e.__fontmetrics__.uncompress = function (je) { if (typeof je != "string") throw new Error("Invalid argument passed to uncompress."); for (var Be, Ie, Fe, ze, qe = {}, He = 1, Ge = qe, Ze = [], sn = "", Xe = "", St = je.length - 1, un = 1; un < St; un += 1)(ze = je[un]) == "'" ? Be ? (Fe = Be.join(""), Be = void 0) : Be = [] : Be ? Be.push(ze) : ze == "{" ? (Ze.push([Ge, Fe]), Ge = {}, Fe = void 0) : ze == "}" ? ((Ie = Ze.pop())[0][Ie[1]] = Ge, Fe = void 0, Ge = Ie[0]) : ze == "-" ? He = -1 : Fe === void 0 ? xe.hasOwnProperty(ze) ? (sn += xe[ze], Fe = parseInt(sn, 16) * He, He = 1, sn = "") : sn += ze : xe.hasOwnProperty(ze) ? (Xe += xe[ze], Ge[Fe] = parseInt(Xe, 16) * He, He = 1, Fe = void 0, Xe = "") : Xe += ze; return qe }, De = { codePages: ["WinAnsiEncoding"], WinAnsiEncoding: Me("{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}") }, Pe = { Unicode: { Courier: De, "Courier-Bold": De, "Courier-BoldOblique": De, "Courier-Oblique": De, Helvetica: De, "Helvetica-Bold": De, "Helvetica-BoldOblique": De, "Helvetica-Oblique": De, "Times-Roman": De, "Times-Bold": De, "Times-BoldItalic": De, "Times-Italic": De } }, Oe = { Unicode: { "Courier-Oblique": Me("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-BoldItalic": Me("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), "Helvetica-Bold": Me("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), Courier: Me("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-BoldOblique": Me("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Bold": Me("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), Symbol: Me("{'widths'{k3uaw4r19m3m2k1t2l2l202m2y2n3m2p5n202q6o3k3m2s2l2t2l2v3r2w1t3m3m2y1t2z1wbk2sbl3r'fof'6o3n3m3o3m3p3m3q3m3r3m3s3m3t3m3u1w3v1w3w3r3x3r3y3r3z2wbp3t3l3m5v2l5x2l5z3m2q4yfr3r7v3k7w1o7x3k}'kerning'{'fof'-6o}}"), Helvetica: Me("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), "Helvetica-BoldOblique": Me("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), ZapfDingbats: Me("{'widths'{k4u2k1w'fof'6o}'kerning'{'fof'-6o}}"), "Courier-Bold": Me("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), "Times-Italic": Me("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), "Times-Roman": Me("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), "Helvetica-Oblique": Me("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}") } }; e.events.push(["addFont", function (je) { var Be = je.font, Ie = Oe.Unicode[Be.postScriptName]; Ie && (Be.metadata.Unicode = {}, Be.metadata.Unicode.widths = Ie.widths, Be.metadata.Unicode.kerning = Ie.kerning); var Fe = Pe.Unicode[Be.postScriptName]; Fe && (Be.metadata.Unicode.encoding = Fe, Be.encoding = Fe.codePages[0]) }]) }(E.API), function (e) { var t = function (xe) { for (var Ee = xe.length, _e = new Uint8Array(Ee), Re = 0; Re < Ee; Re++)_e[Re] = xe.charCodeAt(Re); return _e }; e.API.events.push(["addFont", function (xe) { var Ee = void 0, _e = xe.font, Re = xe.instance; if (!_e.isStandardFont) { if (Re === void 0) throw new Error("Font does not exist in vFS, import fonts or remove declaration doc.addFont('" + _e.postScriptName + "')."); if (typeof (Ee = Re.existsFileInVFS(_e.postScriptName) === !1 ? Re.loadFile(_e.postScriptName) : Re.getFileFromVFS(_e.postScriptName)) != "string") throw new Error("Font is not stored as string-data in vFS, import fonts or remove declaration doc.addFont('" + _e.postScriptName + "')."); (function (Ce, Me) { Me = /^\x00\x01\x00\x00/.test(Me) ? t(Me) : t(u(Me)), Ce.metadata = e.API.TTFFont.open(Me), Ce.metadata.Unicode = Ce.metadata.Unicode || { encoding: {}, kerning: {}, widths: [] }, Ce.metadata.glyIdsUsed = [0] })(_e, Ee) } }]) }(E), function (e) { function t() { return (n.canvg ? Promise.resolve(n.canvg) : __vitePreload(() => import("./index.es-ubLTknfh.js"), [])).catch(function (xe) { return Promise.reject(new Error("Could not load canvg: " + xe)) }).then(function (xe) { return xe.default ? xe.default : xe }) } E.API.addSvgAsImage = function (xe, Ee, _e, Re, Ce, Me, De, Pe) { if (isNaN(Ee) || isNaN(_e)) throw a.error("jsPDF.addSvgAsImage: Invalid coordinates", arguments), new Error("Invalid coordinates passed to jsPDF.addSvgAsImage"); if (isNaN(Re) || isNaN(Ce)) throw a.error("jsPDF.addSvgAsImage: Invalid measurements", arguments), new Error("Invalid measurements (width and/or height) passed to jsPDF.addSvgAsImage"); var Oe = document.createElement("canvas"); Oe.width = Re, Oe.height = Ce; var je = Oe.getContext("2d"); je.fillStyle = "#fff", je.fillRect(0, 0, Oe.width, Oe.height); var Be = { ignoreMouse: !0, ignoreAnimation: !0, ignoreDimensions: !0 }, Ie = this; return t().then(function (Fe) { return Fe.fromString(je, xe, Be) }, function () { return Promise.reject(new Error("Could not load canvg.")) }).then(function (Fe) { return Fe.render(Be) }).then(function () { Ie.addImage(Oe.toDataURL("image/jpeg", 1), Ee, _e, Re, Ce, De, Pe) }) } }(), E.API.putTotalPages = function (e) { var t, xe = 0; parseInt(this.internal.getFont().id.substr(1), 10) < 15 ? (t = new RegExp(e, "g"), xe = this.internal.getNumberOfPages()) : (t = new RegExp(this.pdfEscape16(e, this.internal.getFont()), "g"), xe = this.pdfEscape16(this.internal.getNumberOfPages() + "", this.internal.getFont())); for (var Ee = 1; Ee <= this.internal.getNumberOfPages(); Ee++)for (var _e = 0; _e < this.internal.pages[Ee].length; _e++)this.internal.pages[Ee][_e] = this.internal.pages[Ee][_e].replace(t, xe); return this }, E.API.viewerPreferences = function (e, t) {
  var xe; e = e || {}, t = t || !1; var Ee, _e, Re, Ce = { HideToolbar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideMenubar: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, HideWindowUI: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, FitWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, CenterWindow: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.3 }, DisplayDocTitle: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.4 }, NonFullScreenPageMode: { defaultValue: "UseNone", value: "UseNone", type: "name", explicitSet: !1, valueSet: ["UseNone", "UseOutlines", "UseThumbs", "UseOC"], pdfVersion: 1.3 }, Direction: { defaultValue: "L2R", value: "L2R", type: "name", explicitSet: !1, valueSet: ["L2R", "R2L"], pdfVersion: 1.3 }, ViewArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, ViewClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintArea: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintClip: { defaultValue: "CropBox", value: "CropBox", type: "name", explicitSet: !1, valueSet: ["MediaBox", "CropBox", "TrimBox", "BleedBox", "ArtBox"], pdfVersion: 1.4 }, PrintScaling: { defaultValue: "AppDefault", value: "AppDefault", type: "name", explicitSet: !1, valueSet: ["AppDefault", "None"], pdfVersion: 1.6 }, Duplex: { defaultValue: "", value: "none", type: "name", explicitSet: !1, valueSet: ["Simplex", "DuplexFlipShortEdge", "DuplexFlipLongEdge", "none"], pdfVersion: 1.7 }, PickTrayByPDFSize: { defaultValue: !1, value: !1, type: "boolean", explicitSet: !1, valueSet: [!0, !1], pdfVersion: 1.7 }, PrintPageRange: { defaultValue: "", value: "", type: "array", explicitSet: !1, valueSet: null, pdfVersion: 1.7 }, NumCopies: { defaultValue: 1, value: 1, type: "integer", explicitSet: !1, valueSet: null, pdfVersion: 1.7 } }, Me = Object.keys(Ce), De = [], Pe = 0, Oe = 0, je = 0; function Be(Fe, ze) { var qe, He = !1; for (qe = 0; qe < Fe.length; qe += 1)Fe[qe] === ze && (He = !0); return He } if (this.internal.viewerpreferences === void 0 && (this.internal.viewerpreferences = {}, this.internal.viewerpreferences.configuration = JSON.parse(JSON.stringify(Ce)), this.internal.viewerpreferences.isSubscribed = !1), xe = this.internal.viewerpreferences.configuration, e === "reset" || t === !0) { var Ie = Me.length; for (je = 0; je < Ie; je += 1)xe[Me[je]].value = xe[Me[je]].defaultValue, xe[Me[je]].explicitSet = !1 } if (_typeof(e) === "object") { for (_e in e) if (Re = e[_e], Be(Me, _e) && Re !== void 0) { if (xe[_e].type === "boolean" && typeof Re == "boolean") xe[_e].value = Re; else if (xe[_e].type === "name" && Be(xe[_e].valueSet, Re)) xe[_e].value = Re; else if (xe[_e].type === "integer" && Number.isInteger(Re)) xe[_e].value = Re; else if (xe[_e].type === "array") { for (Pe = 0; Pe < Re.length; Pe += 1)if (Ee = !0, Re[Pe].length === 1 && typeof Re[Pe][0] == "number") De.push(String(Re[Pe] - 1)); else if (Re[Pe].length > 1) { for (Oe = 0; Oe < Re[Pe].length; Oe += 1)typeof Re[Pe][Oe] != "number" && (Ee = !1); Ee === !0 && De.push([Re[Pe][0] - 1, Re[Pe][1] - 1].join(" ")) } xe[_e].value = "[" + De.join(" ") + "]" } else xe[_e].value = xe[_e].defaultValue; xe[_e].explicitSet = !0 } } return this.internal.viewerpreferences.isSubscribed === !1 && (this.internal.events.subscribe("putCatalog", function () {
    var Fe, ze = []; for (Fe in xe) xe[Fe].explicitSet === !0 && (xe[Fe].type === "name" ? ze.push("/" + Fe + " /" + xe[Fe].value) : ze.push("/" + Fe + " " + xe[Fe].value)); ze.length !== 0 && this.internal.write(`/ViewerPreferences
<<
`+ ze.join(`
`) + `
>>`)
  }), this.internal.viewerpreferences.isSubscribed = !0), this.internal.viewerpreferences.configuration = xe, this
}, function (e) { var t = function () { var Ee = '<rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#"><rdf:Description rdf:about="" xmlns:jspdf="' + this.internal.__metadata__.namespaceuri + '"><jspdf:metadata>', _e = unescape(encodeURIComponent('<x:xmpmeta xmlns:x="adobe:ns:meta/">')), Re = unescape(encodeURIComponent(Ee)), Ce = unescape(encodeURIComponent(this.internal.__metadata__.metadata)), Me = unescape(encodeURIComponent("</jspdf:metadata></rdf:Description></rdf:RDF>")), De = unescape(encodeURIComponent("</x:xmpmeta>")), Pe = Re.length + Ce.length + Me.length + _e.length + De.length; this.internal.__metadata__.metadata_object_number = this.internal.newObject(), this.internal.write("<< /Type /Metadata /Subtype /XML /Length " + Pe + " >>"), this.internal.write("stream"), this.internal.write(_e + Re + Ce + Me + De), this.internal.write("endstream"), this.internal.write("endobj") }, xe = function () { this.internal.__metadata__.metadata_object_number && this.internal.write("/Metadata " + this.internal.__metadata__.metadata_object_number + " 0 R") }; e.addMetadata = function (Ee, _e) { return this.internal.__metadata__ === void 0 && (this.internal.__metadata__ = { metadata: Ee, namespaceuri: _e || "http://jspdf.default.namespaceuri/" }, this.internal.events.subscribe("putCatalog", xe), this.internal.events.subscribe("postPutResources", t)), this } }(E.API), function (e) {
  var t = e.API, xe = t.pdfEscape16 = function (Re, Ce) { for (var Me, De = Ce.metadata.Unicode.widths, Pe = ["", "0", "00", "000", "0000"], Oe = [""], je = 0, Be = Re.length; je < Be; ++je) { if (Me = Ce.metadata.characterToGlyph(Re.charCodeAt(je)), Ce.metadata.glyIdsUsed.push(Me), Ce.metadata.toUnicode[Me] = Re.charCodeAt(je), De.indexOf(Me) == -1 && (De.push(Me), De.push([parseInt(Ce.metadata.widthOfGlyph(Me), 10)])), Me == "0") return Oe.join(""); Me = Me.toString(16), Oe.push(Pe[4 - Me.length], Me) } return Oe.join("") }, Ee = function (Re) {
    var Ce, Me, De, Pe, Oe, je, Be; for (Oe = `/CIDInit /ProcSet findresource begin
12 dict begin
begincmap
/CIDSystemInfo <<
  /Registry (Adobe)
  /Ordering (UCS)
  /Supplement 0
>> def
/CMapName /Adobe-Identity-UCS def
/CMapType 2 def
1 begincodespacerange
<0000><ffff>
endcodespacerange`, De = [], je = 0, Be = (Me = Object.keys(Re).sort(function (Ie, Fe) { return Ie - Fe })).length; je < Be; je++)Ce = Me[je], De.length >= 100 && (Oe += `
`+ De.length + ` beginbfchar
`+ De.join(`
`) + `
endbfchar`, De = []), Re[Ce] !== void 0 && Re[Ce] !== null && typeof Re[Ce].toString == "function" && (Pe = ("0000" + Re[Ce].toString(16)).slice(-4), Ce = ("0000" + (+Ce).toString(16)).slice(-4), De.push("<" + Ce + "><" + Pe + ">")); return De.length && (Oe += `
`+ De.length + ` beginbfchar
`+ De.join(`
`) + `
endbfchar
`), Oe += `endcmap
CMapName currentdict /CMap defineresource pop
end
end`}; t.events.push(["putFont", function (Re) { (function (Ce) { var Me = Ce.font, De = Ce.out, Pe = Ce.newObject, Oe = Ce.putStream; if (Me.metadata instanceof e.API.TTFFont && Me.encoding === "Identity-H") { for (var je = Me.metadata.Unicode.widths, Be = Me.metadata.subset.encode(Me.metadata.glyIdsUsed, 1), Ie = "", Fe = 0; Fe < Be.length; Fe++)Ie += String.fromCharCode(Be[Fe]); var ze = Pe(); Oe({ data: Ie, addLength1: !0, objectId: ze }), De("endobj"); var qe = Pe(); Oe({ data: Ee(Me.metadata.toUnicode), addLength1: !0, objectId: qe }), De("endobj"); var He = Pe(); De("<<"), De("/Type /FontDescriptor"), De("/FontName /" + F(Me.fontName)), De("/FontFile2 " + ze + " 0 R"), De("/FontBBox " + e.API.PDFObject.convert(Me.metadata.bbox)), De("/Flags " + Me.metadata.flags), De("/StemV " + Me.metadata.stemV), De("/ItalicAngle " + Me.metadata.italicAngle), De("/Ascent " + Me.metadata.ascender), De("/Descent " + Me.metadata.decender), De("/CapHeight " + Me.metadata.capHeight), De(">>"), De("endobj"); var Ge = Pe(); De("<<"), De("/Type /Font"), De("/BaseFont /" + F(Me.fontName)), De("/FontDescriptor " + He + " 0 R"), De("/W " + e.API.PDFObject.convert(je)), De("/CIDToGIDMap /Identity"), De("/DW 1000"), De("/Subtype /CIDFontType2"), De("/CIDSystemInfo"), De("<<"), De("/Supplement 0"), De("/Registry (Adobe)"), De("/Ordering (" + Me.encoding + ")"), De(">>"), De(">>"), De("endobj"), Me.objectNumber = Pe(), De("<<"), De("/Type /Font"), De("/Subtype /Type0"), De("/ToUnicode " + qe + " 0 R"), De("/BaseFont /" + F(Me.fontName)), De("/Encoding /" + Me.encoding), De("/DescendantFonts [" + Ge + " 0 R]"), De(">>"), De("endobj"), Me.isAlreadyPutted = !0 } })(Re) }]), t.events.push(["putFont", function (Re) { (function (Ce) { var Me = Ce.font, De = Ce.out, Pe = Ce.newObject, Oe = Ce.putStream; if (Me.metadata instanceof e.API.TTFFont && Me.encoding === "WinAnsiEncoding") { for (var je = Me.metadata.rawData, Be = "", Ie = 0; Ie < je.length; Ie++)Be += String.fromCharCode(je[Ie]); var Fe = Pe(); Oe({ data: Be, addLength1: !0, objectId: Fe }), De("endobj"); var ze = Pe(); Oe({ data: Ee(Me.metadata.toUnicode), addLength1: !0, objectId: ze }), De("endobj"); var qe = Pe(); De("<<"), De("/Descent " + Me.metadata.decender), De("/CapHeight " + Me.metadata.capHeight), De("/StemV " + Me.metadata.stemV), De("/Type /FontDescriptor"), De("/FontFile2 " + Fe + " 0 R"), De("/Flags 96"), De("/FontBBox " + e.API.PDFObject.convert(Me.metadata.bbox)), De("/FontName /" + F(Me.fontName)), De("/ItalicAngle " + Me.metadata.italicAngle), De("/Ascent " + Me.metadata.ascender), De(">>"), De("endobj"), Me.objectNumber = Pe(); for (var He = 0; He < Me.metadata.hmtx.widths.length; He++)Me.metadata.hmtx.widths[He] = parseInt(Me.metadata.hmtx.widths[He] * (1e3 / Me.metadata.head.unitsPerEm)); De("<</Subtype/TrueType/Type/Font/ToUnicode " + ze + " 0 R/BaseFont/" + F(Me.fontName) + "/FontDescriptor " + qe + " 0 R/Encoding/" + Me.encoding + " /FirstChar 29 /LastChar 255 /Widths " + e.API.PDFObject.convert(Me.metadata.hmtx.widths) + ">>"), De("endobj"), Me.isAlreadyPutted = !0 } })(Re) }]); var _e = function (Re) { var Ce, Me = Re.text || "", De = Re.x, Pe = Re.y, Oe = Re.options || {}, je = Re.mutex || {}, Be = je.pdfEscape, Ie = je.activeFontKey, Fe = je.fonts, ze = Ie, qe = "", He = 0, Ge = "", Ze = Fe[ze].encoding; if (Fe[ze].encoding !== "Identity-H") return { text: Me, x: De, y: Pe, options: Oe, mutex: je }; for (Ge = Me, ze = Ie, Array.isArray(Me) && (Ge = Me[0]), He = 0; He < Ge.length; He += 1)Fe[ze].metadata.hasOwnProperty("cmap") && (Ce = Fe[ze].metadata.cmap.unicode.codeMap[Ge[He].charCodeAt(0)]), Ce || Ge[He].charCodeAt(0) < 256 && Fe[ze].metadata.hasOwnProperty("Unicode") ? qe += Ge[He] : qe += ""; var sn = ""; return parseInt(ze.slice(1)) < 14 || Ze === "WinAnsiEncoding" ? sn = Be(qe, ze).split("").map(function (Xe) { return Xe.charCodeAt(0).toString(16) }).join("") : Ze === "Identity-H" && (sn = xe(qe, Fe[ze])), je.isHex = !0, { text: sn, x: De, y: Pe, options: Oe, mutex: je } }; t.events.push(["postProcessText", function (Re) { var Ce = Re.text || "", Me = [], De = { text: Ce, x: Re.x, y: Re.y, options: Re.options, mutex: Re.mutex }; if (Array.isArray(Ce)) { var Pe = 0; for (Pe = 0; Pe < Ce.length; Pe += 1)Array.isArray(Ce[Pe]) && Ce[Pe].length === 3 ? Me.push([_e(Object.assign({}, De, { text: Ce[Pe][0] })).text, Ce[Pe][1], Ce[Pe][2]]) : Me.push(_e(Object.assign({}, De, { text: Ce[Pe] })).text); Re.text = Me } else Re.text = _e(Object.assign({}, De, { text: Ce })).text }])
}(E), function (e) { var t = function () { return this.internal.vFS === void 0 && (this.internal.vFS = {}), !0 }; e.existsFileInVFS = function (xe) { return t.call(this), this.internal.vFS[xe] !== void 0 }, e.addFileToVFS = function (xe, Ee) { return t.call(this), this.internal.vFS[xe] = Ee, this }, e.getFileFromVFS = function (xe) { return t.call(this), this.internal.vFS[xe] !== void 0 ? this.internal.vFS[xe] : null } }(E.API), function (e) { e.__bidiEngine__ = e.prototype.__bidiEngine__ = function (Ee) { var _e, Re, Ce, Me, De, Pe, Oe, je = t, Be = [[0, 3, 0, 1, 0, 0, 0], [0, 3, 0, 1, 2, 2, 0], [0, 3, 0, 17, 2, 0, 1], [0, 3, 5, 5, 4, 1, 0], [0, 3, 21, 21, 4, 0, 1], [0, 3, 5, 5, 4, 2, 0]], Ie = [[2, 0, 1, 1, 0, 1, 0], [2, 0, 1, 1, 0, 2, 0], [2, 0, 2, 1, 3, 2, 0], [2, 0, 2, 33, 3, 1, 1]], Fe = { L: 0, R: 1, EN: 2, AN: 3, N: 4, B: 5, S: 6 }, ze = { 0: 0, 5: 1, 6: 2, 7: 3, 32: 4, 251: 5, 254: 6, 255: 7 }, qe = ["(", ")", "(", "<", ">", "<", "[", "]", "[", "{", "}", "{", "«", "»", "«", "‹", "›", "‹", "⁅", "⁆", "⁅", "⁽", "⁾", "⁽", "₍", "₎", "₍", "≤", "≥", "≤", "〈", "〉", "〈", "﹙", "﹚", "﹙", "﹛", "﹜", "﹛", "﹝", "﹞", "﹝", "﹤", "﹥", "﹤"], He = new RegExp(/^([1-4|9]|1[0-9]|2[0-9]|3[0168]|4[04589]|5[012]|7[78]|159|16[0-9]|17[0-2]|21[569]|22[03489]|250)$/), Ge = !1, Ze = 0; this.__bidiEngine__ = {}; var sn = function (fn) { var En = fn.charCodeAt(), Pn = En >> 8, Rn = ze[Pn]; return Rn !== void 0 ? je[256 * Rn + (255 & En)] : Pn === 252 || Pn === 253 ? "AL" : He.test(Pn) ? "L" : Pn === 8 ? "R" : "N" }, Xe = function (fn) { for (var En, Pn = 0; Pn < fn.length; Pn++) { if ((En = sn(fn.charAt(Pn))) === "L") return !1; if (En === "R") return !0 } return !1 }, St = function (fn, En, Pn, Rn) { var In, xn, vn, tn, nn = En[Rn]; switch (nn) { case "L": case "R": Ge = !1; break; case "N": case "AN": break; case "EN": Ge && (nn = "AN"); break; case "AL": Ge = !0, nn = "R"; break; case "WS": nn = "N"; break; case "CS": Rn < 1 || Rn + 1 >= En.length || (In = Pn[Rn - 1]) !== "EN" && In !== "AN" || (xn = En[Rn + 1]) !== "EN" && xn !== "AN" ? nn = "N" : Ge && (xn = "AN"), nn = xn === In ? xn : "N"; break; case "ES": nn = (In = Rn > 0 ? Pn[Rn - 1] : "B") === "EN" && Rn + 1 < En.length && En[Rn + 1] === "EN" ? "EN" : "N"; break; case "ET": if (Rn > 0 && Pn[Rn - 1] === "EN") { nn = "EN"; break } if (Ge) { nn = "N"; break } for (vn = Rn + 1, tn = En.length; vn < tn && En[vn] === "ET";)vn++; nn = vn < tn && En[vn] === "EN" ? "EN" : "N"; break; case "NSM": if (Ce && !Me) { for (tn = En.length, vn = Rn + 1; vn < tn && En[vn] === "NSM";)vn++; if (vn < tn) { var We = fn[Rn], dn = We >= 1425 && We <= 2303 || We === 64286; if (In = En[vn], dn && (In === "R" || In === "AL")) { nn = "R"; break } } } nn = Rn < 1 || (In = En[Rn - 1]) === "B" ? "N" : Pn[Rn - 1]; break; case "B": Ge = !1, _e = !0, nn = Ze; break; case "S": Re = !0, nn = "N"; break; case "LRE": case "RLE": case "LRO": case "RLO": case "PDF": Ge = !1; break; case "BN": nn = "N" }return nn }, un = function (fn, En, Pn) { var Rn = fn.split(""); return Pn && on(Rn, Pn, { hiLevel: Ze }), Rn.reverse(), En && En.reverse(), Rn.join("") }, on = function (fn, En, Pn) { var Rn, In, xn, vn, tn, nn = -1, We = fn.length, dn = 0, Je = [], rn = Ze ? Ie : Be, hn = []; for (Ge = !1, _e = !1, Re = !1, In = 0; In < We; In++)hn[In] = sn(fn[In]); for (xn = 0; xn < We; xn++) { if (tn = dn, Je[xn] = St(fn, hn, Je, xn), Rn = 240 & (dn = rn[tn][Fe[Je[xn]]]), dn &= 15, En[xn] = vn = rn[dn][5], Rn > 0) if (Rn === 16) { for (In = nn; In < xn; In++)En[In] = 1; nn = -1 } else nn = -1; if (rn[dn][6]) nn === -1 && (nn = xn); else if (nn > -1) { for (In = nn; In < xn; In++)En[In] = vn; nn = -1 } hn[xn] === "B" && (En[xn] = 0), Pn.hiLevel |= vn } Re && function (mn, Ye, an) { for (var pn = 0; pn < an; pn++)if (mn[pn] === "S") { Ye[pn] = Ze; for (var yn = pn - 1; yn >= 0 && mn[yn] === "WS"; yn--)Ye[yn] = Ze } }(hn, En, We) }, bn = function (fn, En, Pn, Rn, In) { if (!(In.hiLevel < fn)) { if (fn === 1 && Ze === 1 && !_e) return En.reverse(), void (Pn && Pn.reverse()); for (var xn, vn, tn, nn, We = En.length, dn = 0; dn < We;) { if (Rn[dn] >= fn) { for (tn = dn + 1; tn < We && Rn[tn] >= fn;)tn++; for (nn = dn, vn = tn - 1; nn < vn; nn++, vn--)xn = En[nn], En[nn] = En[vn], En[vn] = xn, Pn && (xn = Pn[nn], Pn[nn] = Pn[vn], Pn[vn] = xn); dn = tn } dn++ } } }, Tn = function (fn, En, Pn) { var Rn = fn.split(""), In = { hiLevel: Ze }; return Pn || (Pn = []), on(Rn, Pn, In), function (xn, vn, tn) { if (tn.hiLevel !== 0 && Oe) for (var nn, We = 0; We < xn.length; We++)vn[We] === 1 && (nn = qe.indexOf(xn[We])) >= 0 && (xn[We] = qe[nn + 1]) }(Rn, Pn, In), bn(2, Rn, En, Pn, In), bn(1, Rn, En, Pn, In), Rn.join("") }; return this.__bidiEngine__.doBidiReorder = function (fn, En, Pn) { if (function (In, xn) { if (xn) for (var vn = 0; vn < In.length; vn++)xn[vn] = vn; Me === void 0 && (Me = Xe(In)), Pe === void 0 && (Pe = Xe(In)) }(fn, En), Ce || !De || Pe) if (Ce && De && Me ^ Pe) Ze = Me ? 1 : 0, fn = un(fn, En, Pn); else if (!Ce && De && Pe) Ze = Me ? 1 : 0, fn = Tn(fn, En, Pn), fn = un(fn, En); else if (!Ce || Me || De || Pe) { if (Ce && !De && Me ^ Pe) fn = un(fn, En), Me ? (Ze = 0, fn = Tn(fn, En, Pn)) : (Ze = 1, fn = Tn(fn, En, Pn), fn = un(fn, En)); else if (Ce && Me && !De && Pe) Ze = 1, fn = Tn(fn, En, Pn), fn = un(fn, En); else if (!Ce && !De && Me ^ Pe) { var Rn = Oe; Me ? (Ze = 1, fn = Tn(fn, En, Pn), Ze = 0, Oe = !1, fn = Tn(fn, En, Pn), Oe = Rn) : (Ze = 0, fn = Tn(fn, En, Pn), fn = un(fn, En), Ze = 1, Oe = !1, fn = Tn(fn, En, Pn), Oe = Rn, fn = un(fn, En)) } } else Ze = 0, fn = Tn(fn, En, Pn); else Ze = Me ? 1 : 0, fn = Tn(fn, En, Pn); return fn }, this.__bidiEngine__.setOptions = function (fn) { fn && (Ce = fn.isInputVisual, De = fn.isOutputVisual, Me = fn.isInputRtl, Pe = fn.isOutputRtl, Oe = fn.isSymmetricSwapping) }, this.__bidiEngine__.setOptions(Ee), this.__bidiEngine__ }; var t = ["BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "S", "B", "S", "WS", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "B", "B", "B", "S", "WS", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "BN", "BN", "BN", "BN", "BN", "BN", "B", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "BN", "CS", "N", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "L", "N", "N", "BN", "N", "N", "ET", "ET", "EN", "EN", "N", "L", "N", "N", "N", "EN", "L", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "L", "N", "N", "N", "N", "N", "ET", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "NSM", "R", "NSM", "NSM", "R", "NSM", "NSM", "R", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AN", "AN", "AN", "AN", "AN", "AN", "N", "N", "AL", "ET", "ET", "AL", "CS", "AL", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "AN", "ET", "AN", "AN", "AL", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AN", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "NSM", "NSM", "N", "NSM", "NSM", "NSM", "NSM", "AL", "AL", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "NSM", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "R", "R", "N", "N", "N", "N", "R", "N", "N", "N", "N", "N", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "WS", "BN", "BN", "BN", "L", "R", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "B", "LRE", "RLE", "PDF", "LRO", "RLO", "CS", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "WS", "BN", "BN", "BN", "BN", "BN", "N", "LRI", "RLI", "FSI", "PDI", "BN", "BN", "BN", "BN", "BN", "BN", "EN", "L", "N", "N", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "L", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "ES", "ES", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "R", "NSM", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "ES", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "N", "R", "R", "R", "R", "R", "N", "R", "N", "R", "R", "N", "R", "R", "N", "R", "R", "R", "R", "R", "R", "R", "R", "R", "R", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "NSM", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "CS", "N", "CS", "N", "N", "CS", "N", "N", "N", "N", "N", "N", "N", "N", "N", "ET", "N", "N", "ES", "ES", "N", "N", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "AL", "AL", "AL", "AL", "AL", "N", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "AL", "N", "N", "BN", "N", "N", "N", "ET", "ET", "ET", "N", "N", "N", "N", "N", "ES", "CS", "ES", "CS", "CS", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "EN", "CS", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "L", "N", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "L", "L", "L", "N", "N", "L", "L", "L", "N", "N", "N", "ET", "ET", "N", "N", "N", "ET", "ET", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N", "N"], xe = new e.__bidiEngine__({ isInputVisual: !0 }); e.API.events.push(["postProcessText", function (Ee) { var _e = Ee.text; Ee.x, Ee.y; var Re = Ee.options || {}; Ee.mutex, Re.lang; var Ce = []; if (Re.isInputVisual = typeof Re.isInputVisual != "boolean" || Re.isInputVisual, xe.setOptions(Re), Object.prototype.toString.call(_e) === "[object Array]") { var Me = 0; for (Ce = [], Me = 0; Me < _e.length; Me += 1)Object.prototype.toString.call(_e[Me]) === "[object Array]" ? Ce.push([xe.doBidiReorder(_e[Me][0]), _e[Me][1], _e[Me][2]]) : Ce.push([xe.doBidiReorder(_e[Me])]); Ee.text = Ce } else Ee.text = xe.doBidiReorder(_e); xe.setOptions({ isInputVisual: !0 }) }]) }(E), E.API.TTFFont = function () { function e(t) { var xe; if (this.rawData = t, xe = this.contents = new ne(t), this.contents.pos = 4, xe.readString(4) === "ttcf") throw new Error("TTCF not supported."); xe.pos = 0, this.parse(), this.subset = new Le(this), this.registerTTF() } return e.open = function (t) { return new e(t) }, e.prototype.parse = function () { return this.directory = new ie(this.contents), this.head = new se(this), this.name = new pe(this), this.cmap = new ue(this), this.toUnicode = {}, this.hhea = new he(this), this.maxp = new ge(this), this.hmtx = new me(this), this.post = new fe(this), this.os2 = new le(this), this.loca = new Ne(this), this.glyf = new be(this), this.ascender = this.os2.exists && this.os2.ascender || this.hhea.ascender, this.decender = this.os2.exists && this.os2.decender || this.hhea.decender, this.lineGap = this.os2.exists && this.os2.lineGap || this.hhea.lineGap, this.bbox = [this.head.xMin, this.head.yMin, this.head.xMax, this.head.yMax] }, e.prototype.registerTTF = function () { var t, xe, Ee, _e, Re; if (this.scaleFactor = 1e3 / this.head.unitsPerEm, this.bbox = (function () { var Ce, Me, De, Pe; for (Pe = [], Ce = 0, Me = (De = this.bbox).length; Ce < Me; Ce++)t = De[Ce], Pe.push(Math.round(t * this.scaleFactor)); return Pe }).call(this), this.stemV = 0, this.post.exists ? (Ee = 255 & (_e = this.post.italic_angle), (32768 & (xe = _e >> 16)) != 0 && (xe = -(1 + (65535 ^ xe))), this.italicAngle = +(xe + "." + Ee)) : this.italicAngle = 0, this.ascender = Math.round(this.ascender * this.scaleFactor), this.decender = Math.round(this.decender * this.scaleFactor), this.lineGap = Math.round(this.lineGap * this.scaleFactor), this.capHeight = this.os2.exists && this.os2.capHeight || this.ascender, this.xHeight = this.os2.exists && this.os2.xHeight || 0, this.familyClass = (this.os2.exists && this.os2.familyClass || 0) >> 8, this.isSerif = (Re = this.familyClass) === 1 || Re === 2 || Re === 3 || Re === 4 || Re === 5 || Re === 7, this.isScript = this.familyClass === 10, this.flags = 0, this.post.isFixedPitch && (this.flags |= 1), this.isSerif && (this.flags |= 2), this.isScript && (this.flags |= 8), this.italicAngle !== 0 && (this.flags |= 64), this.flags |= 32, !this.cmap.unicode) throw new Error("No unicode cmap for font") }, e.prototype.characterToGlyph = function (t) { var xe; return ((xe = this.cmap.unicode) != null ? xe.codeMap[t] : void 0) || 0 }, e.prototype.widthOfGlyph = function (t) { var xe; return xe = 1e3 / this.head.unitsPerEm, this.hmtx.forGlyph(t).advance * xe }, e.prototype.widthOfString = function (t, xe, Ee) { var _e, Re, Ce, Me; for (Ce = 0, Re = 0, Me = (t = "" + t).length; 0 <= Me ? Re < Me : Re > Me; Re = 0 <= Me ? ++Re : --Re)_e = t.charCodeAt(Re), Ce += this.widthOfGlyph(this.characterToGlyph(_e)) + Ee * (1e3 / xe) || 0; return Ce * (xe / 1e3) }, e.prototype.lineHeight = function (t, xe) { var Ee; return xe == null && (xe = !1), Ee = xe ? this.lineGap : 0, (this.ascender + Ee - this.decender) / 1e3 * t }, e }(); var re, ne = function () { function e(t) { this.data = t ?? [], this.pos = 0, this.length = this.data.length } return e.prototype.readByte = function () { return this.data[this.pos++] }, e.prototype.writeByte = function (t) { return this.data[this.pos++] = t }, e.prototype.readUInt32 = function () { return 16777216 * this.readByte() + (this.readByte() << 16) + (this.readByte() << 8) + this.readByte() }, e.prototype.writeUInt32 = function (t) { return this.writeByte(t >>> 24 & 255), this.writeByte(t >> 16 & 255), this.writeByte(t >> 8 & 255), this.writeByte(255 & t) }, e.prototype.readInt32 = function () { var t; return (t = this.readUInt32()) >= 2147483648 ? t - 4294967296 : t }, e.prototype.writeInt32 = function (t) { return t < 0 && (t += 4294967296), this.writeUInt32(t) }, e.prototype.readUInt16 = function () { return this.readByte() << 8 | this.readByte() }, e.prototype.writeUInt16 = function (t) { return this.writeByte(t >> 8 & 255), this.writeByte(255 & t) }, e.prototype.readInt16 = function () { var t; return (t = this.readUInt16()) >= 32768 ? t - 65536 : t }, e.prototype.writeInt16 = function (t) { return t < 0 && (t += 65536), this.writeUInt16(t) }, e.prototype.readString = function (t) { var xe, Ee; for (Ee = [], xe = 0; 0 <= t ? xe < t : xe > t; xe = 0 <= t ? ++xe : --xe)Ee[xe] = String.fromCharCode(this.readByte()); return Ee.join("") }, e.prototype.writeString = function (t) { var xe, Ee, _e; for (_e = [], xe = 0, Ee = t.length; 0 <= Ee ? xe < Ee : xe > Ee; xe = 0 <= Ee ? ++xe : --xe)_e.push(this.writeByte(t.charCodeAt(xe))); return _e }, e.prototype.readShort = function () { return this.readInt16() }, e.prototype.writeShort = function (t) { return this.writeInt16(t) }, e.prototype.readLongLong = function () { var t, xe, Ee, _e, Re, Ce, Me, De; return t = this.readByte(), xe = this.readByte(), Ee = this.readByte(), _e = this.readByte(), Re = this.readByte(), Ce = this.readByte(), Me = this.readByte(), De = this.readByte(), 128 & t ? -1 * (72057594037927940 * (255 ^ t) + 281474976710656 * (255 ^ xe) + 1099511627776 * (255 ^ Ee) + 4294967296 * (255 ^ _e) + 16777216 * (255 ^ Re) + 65536 * (255 ^ Ce) + 256 * (255 ^ Me) + (255 ^ De) + 1) : 72057594037927940 * t + 281474976710656 * xe + 1099511627776 * Ee + 4294967296 * _e + 16777216 * Re + 65536 * Ce + 256 * Me + De }, e.prototype.writeLongLong = function (t) { var xe, Ee; return xe = Math.floor(t / 4294967296), Ee = 4294967295 & t, this.writeByte(xe >> 24 & 255), this.writeByte(xe >> 16 & 255), this.writeByte(xe >> 8 & 255), this.writeByte(255 & xe), this.writeByte(Ee >> 24 & 255), this.writeByte(Ee >> 16 & 255), this.writeByte(Ee >> 8 & 255), this.writeByte(255 & Ee) }, e.prototype.readInt = function () { return this.readInt32() }, e.prototype.writeInt = function (t) { return this.writeInt32(t) }, e.prototype.read = function (t) { var xe, Ee; for (xe = [], Ee = 0; 0 <= t ? Ee < t : Ee > t; Ee = 0 <= t ? ++Ee : --Ee)xe.push(this.readByte()); return xe }, e.prototype.write = function (t) { var xe, Ee, _e, Re; for (Re = [], Ee = 0, _e = t.length; Ee < _e; Ee++)xe = t[Ee], Re.push(this.writeByte(xe)); return Re }, e }(), ie = function () { var e; function t(xe) { var Ee, _e, Re; for (this.scalarType = xe.readInt(), this.tableCount = xe.readShort(), this.searchRange = xe.readShort(), this.entrySelector = xe.readShort(), this.rangeShift = xe.readShort(), this.tables = {}, _e = 0, Re = this.tableCount; 0 <= Re ? _e < Re : _e > Re; _e = 0 <= Re ? ++_e : --_e)Ee = { tag: xe.readString(4), checksum: xe.readInt(), offset: xe.readInt(), length: xe.readInt() }, this.tables[Ee.tag] = Ee } return t.prototype.encode = function (xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze; for (ze in Ie = Object.keys(xe).length, De = Math.log(2), je = 16 * Math.floor(Math.log(Ie) / De), Ce = Math.floor(je / De), Oe = 16 * Ie - je, (_e = new ne).writeInt(this.scalarType), _e.writeShort(Ie), _e.writeShort(je), _e.writeShort(Ce), _e.writeShort(Oe), Re = 16 * Ie, Pe = _e.pos + Re, Me = null, Fe = [], xe) for (Be = xe[ze], _e.writeString(ze), _e.writeInt(e(Be)), _e.writeInt(Pe), _e.writeInt(Be.length), Fe = Fe.concat(Be), ze === "head" && (Me = Pe), Pe += Be.length; Pe % 4;)Fe.push(0), Pe++; return _e.write(Fe), Ee = 2981146554 - e(_e.data), _e.pos = Me + 8, _e.writeUInt32(Ee), _e.data }, e = function (xe) { var Ee, _e, Re, Ce; for (xe = ve.call(xe); xe.length % 4;)xe.push(0); for (Re = new ne(xe), _e = 0, Ee = 0, Ce = xe.length; Ee < Ce; Ee = Ee += 4)_e += Re.readUInt32(); return 4294967295 & _e }, t }(), ae = {}.hasOwnProperty, oe = function (e, t) { for (var xe in t) ae.call(t, xe) && (e[xe] = t[xe]); function Ee() { this.constructor = e } return Ee.prototype = t.prototype, e.prototype = new Ee, e.__super__ = t.prototype, e }; re = function () { function e(t) { var xe; this.file = t, xe = this.file.directory.tables[this.tag], this.exists = !!xe, xe && (this.offset = xe.offset, this.length = xe.length, this.parse(this.file.contents)) } return e.prototype.parse = function () { }, e.prototype.encode = function () { }, e.prototype.raw = function () { return this.exists ? (this.file.contents.pos = this.offset, this.file.contents.read(this.length)) : null }, e }(); var se = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "head", t.prototype.parse = function (xe) { return xe.pos = this.offset, this.version = xe.readInt(), this.revision = xe.readInt(), this.checkSumAdjustment = xe.readInt(), this.magicNumber = xe.readInt(), this.flags = xe.readShort(), this.unitsPerEm = xe.readShort(), this.created = xe.readLongLong(), this.modified = xe.readLongLong(), this.xMin = xe.readShort(), this.yMin = xe.readShort(), this.xMax = xe.readShort(), this.yMax = xe.readShort(), this.macStyle = xe.readShort(), this.lowestRecPPEM = xe.readShort(), this.fontDirectionHint = xe.readShort(), this.indexToLocFormat = xe.readShort(), this.glyphDataFormat = xe.readShort() }, t.prototype.encode = function (xe) { var Ee; return (Ee = new ne).writeInt(this.version), Ee.writeInt(this.revision), Ee.writeInt(this.checkSumAdjustment), Ee.writeInt(this.magicNumber), Ee.writeShort(this.flags), Ee.writeShort(this.unitsPerEm), Ee.writeLongLong(this.created), Ee.writeLongLong(this.modified), Ee.writeShort(this.xMin), Ee.writeShort(this.yMin), Ee.writeShort(this.xMax), Ee.writeShort(this.yMax), Ee.writeShort(this.macStyle), Ee.writeShort(this.lowestRecPPEM), Ee.writeShort(this.fontDirectionHint), Ee.writeShort(xe), Ee.writeShort(this.glyphDataFormat), Ee.data }, t }(), ce = function () { function e(t, xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze, qe, He, Ge, Ze; switch (this.platformID = t.readUInt16(), this.encodingID = t.readShort(), this.offset = xe + t.readInt(), je = t.pos, t.pos = this.offset, this.format = t.readUInt16(), this.length = t.readUInt16(), this.language = t.readUInt16(), this.isUnicode = this.platformID === 3 && this.encodingID === 1 && this.format === 4 || this.platformID === 0 && this.format === 4, this.codeMap = {}, this.format) { case 0: for (De = 0; De < 256; ++De)this.codeMap[De] = t.readByte(); break; case 4: for (Ie = t.readUInt16(), Be = Ie / 2, t.pos += 6, Re = function () { var sn, Xe; for (Xe = [], De = sn = 0; 0 <= Be ? sn < Be : sn > Be; De = 0 <= Be ? ++sn : --sn)Xe.push(t.readUInt16()); return Xe }(), t.pos += 2, ze = function () { var sn, Xe; for (Xe = [], De = sn = 0; 0 <= Be ? sn < Be : sn > Be; De = 0 <= Be ? ++sn : --sn)Xe.push(t.readUInt16()); return Xe }(), Pe = function () { var sn, Xe; for (Xe = [], De = sn = 0; 0 <= Be ? sn < Be : sn > Be; De = 0 <= Be ? ++sn : --sn)Xe.push(t.readUInt16()); return Xe }(), Oe = function () { var sn, Xe; for (Xe = [], De = sn = 0; 0 <= Be ? sn < Be : sn > Be; De = 0 <= Be ? ++sn : --sn)Xe.push(t.readUInt16()); return Xe }(), _e = (this.length - t.pos + this.offset) / 2, Me = function () { var sn, Xe; for (Xe = [], De = sn = 0; 0 <= _e ? sn < _e : sn > _e; De = 0 <= _e ? ++sn : --sn)Xe.push(t.readUInt16()); return Xe }(), De = He = 0, Ze = Re.length; He < Ze; De = ++He)for (qe = Re[De], Ee = Ge = Fe = ze[De]; Fe <= qe ? Ge <= qe : Ge >= qe; Ee = Fe <= qe ? ++Ge : --Ge)Oe[De] === 0 ? Ce = Ee + Pe[De] : (Ce = Me[Oe[De] / 2 + (Ee - Fe) - (Be - De)] || 0) !== 0 && (Ce += Pe[De]), this.codeMap[Ee] = 65535 & Ce }t.pos = je } return e.encode = function (t, xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze, qe, He, Ge, Ze, sn, Xe, St, un, on, bn, Tn, fn, En, Pn, Rn, In, xn, vn, tn, nn, We, dn, Je, rn, hn, mn, Ye, an, pn, yn, _n, On, kn; switch (Rn = new ne, Ce = Object.keys(t).sort(function (zn, sr) { return zn - sr }), xe) { case "macroman": for (ze = 0, qe = function () { var zn = []; for (Fe = 0; Fe < 256; ++Fe)zn.push(0); return zn }(), Ge = { 0: 0 }, Re = {}, In = 0, nn = Ce.length; In < nn; In++)Ge[yn = t[_e = Ce[In]]] == null && (Ge[yn] = ++ze), Re[_e] = { old: t[_e], new: Ge[t[_e]] }, qe[_e] = Ge[t[_e]]; return Rn.writeUInt16(1), Rn.writeUInt16(0), Rn.writeUInt32(12), Rn.writeUInt16(0), Rn.writeUInt16(262), Rn.writeUInt16(0), Rn.write(qe), { charMap: Re, subtable: Rn.data, maxGlyphID: ze + 1 }; case "unicode": for (En = [], je = [], Ze = 0, Ge = {}, Ee = {}, He = Pe = null, xn = 0, We = Ce.length; xn < We; xn++)Ge[Xe = t[_e = Ce[xn]]] == null && (Ge[Xe] = ++Ze), Ee[_e] = { old: Xe, new: Ge[Xe] }, Me = Ge[Xe] - _e, He != null && Me === Pe || (He && je.push(He), En.push(_e), Pe = Me), He = _e; for (He && je.push(He), je.push(65535), En.push(65535), Tn = 2 * (bn = En.length), on = 2 * Math.pow(Math.log(bn) / Math.LN2, 2), Be = Math.log(on / 2) / Math.LN2, un = 2 * bn - on, De = [], St = [], Ie = [], Fe = vn = 0, dn = En.length; vn < dn; Fe = ++vn) { if (fn = En[Fe], Oe = je[Fe], fn === 65535) { De.push(0), St.push(0); break } if (fn - (Pn = Ee[fn].new) >= 32768) for (De.push(0), St.push(2 * (Ie.length + bn - Fe)), _e = tn = fn; fn <= Oe ? tn <= Oe : tn >= Oe; _e = fn <= Oe ? ++tn : --tn)Ie.push(Ee[_e].new); else De.push(Pn - fn), St.push(0) } for (Rn.writeUInt16(3), Rn.writeUInt16(1), Rn.writeUInt32(12), Rn.writeUInt16(4), Rn.writeUInt16(16 + 8 * bn + 2 * Ie.length), Rn.writeUInt16(0), Rn.writeUInt16(Tn), Rn.writeUInt16(on), Rn.writeUInt16(Be), Rn.writeUInt16(un), an = 0, Je = je.length; an < Je; an++)_e = je[an], Rn.writeUInt16(_e); for (Rn.writeUInt16(0), pn = 0, rn = En.length; pn < rn; pn++)_e = En[pn], Rn.writeUInt16(_e); for (_n = 0, hn = De.length; _n < hn; _n++)Me = De[_n], Rn.writeUInt16(Me); for (On = 0, mn = St.length; On < mn; On++)sn = St[On], Rn.writeUInt16(sn); for (kn = 0, Ye = Ie.length; kn < Ye; kn++)ze = Ie[kn], Rn.writeUInt16(ze); return { charMap: Ee, subtable: Rn.data, maxGlyphID: Ze + 1 } } }, e }(), ue = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "cmap", t.prototype.parse = function (xe) { var Ee, _e, Re; for (xe.pos = this.offset, this.version = xe.readUInt16(), Re = xe.readUInt16(), this.tables = [], this.unicode = null, _e = 0; 0 <= Re ? _e < Re : _e > Re; _e = 0 <= Re ? ++_e : --_e)Ee = new ce(xe, this.offset), this.tables.push(Ee), Ee.isUnicode && this.unicode == null && (this.unicode = Ee); return !0 }, t.encode = function (xe, Ee) { var _e, Re; return Ee == null && (Ee = "macroman"), _e = ce.encode(xe, Ee), (Re = new ne).writeUInt16(0), Re.writeUInt16(1), _e.table = Re.data.concat(_e.subtable), _e }, t }(), he = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "hhea", t.prototype.parse = function (xe) { return xe.pos = this.offset, this.version = xe.readInt(), this.ascender = xe.readShort(), this.decender = xe.readShort(), this.lineGap = xe.readShort(), this.advanceWidthMax = xe.readShort(), this.minLeftSideBearing = xe.readShort(), this.minRightSideBearing = xe.readShort(), this.xMaxExtent = xe.readShort(), this.caretSlopeRise = xe.readShort(), this.caretSlopeRun = xe.readShort(), this.caretOffset = xe.readShort(), xe.pos += 8, this.metricDataFormat = xe.readShort(), this.numberOfMetrics = xe.readUInt16() }, t }(), le = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "OS/2", t.prototype.parse = function (xe) { if (xe.pos = this.offset, this.version = xe.readUInt16(), this.averageCharWidth = xe.readShort(), this.weightClass = xe.readUInt16(), this.widthClass = xe.readUInt16(), this.type = xe.readShort(), this.ySubscriptXSize = xe.readShort(), this.ySubscriptYSize = xe.readShort(), this.ySubscriptXOffset = xe.readShort(), this.ySubscriptYOffset = xe.readShort(), this.ySuperscriptXSize = xe.readShort(), this.ySuperscriptYSize = xe.readShort(), this.ySuperscriptXOffset = xe.readShort(), this.ySuperscriptYOffset = xe.readShort(), this.yStrikeoutSize = xe.readShort(), this.yStrikeoutPosition = xe.readShort(), this.familyClass = xe.readShort(), this.panose = function () { var Ee, _e; for (_e = [], Ee = 0; Ee < 10; ++Ee)_e.push(xe.readByte()); return _e }(), this.charRange = function () { var Ee, _e; for (_e = [], Ee = 0; Ee < 4; ++Ee)_e.push(xe.readInt()); return _e }(), this.vendorID = xe.readString(4), this.selection = xe.readShort(), this.firstCharIndex = xe.readShort(), this.lastCharIndex = xe.readShort(), this.version > 0 && (this.ascent = xe.readShort(), this.descent = xe.readShort(), this.lineGap = xe.readShort(), this.winAscent = xe.readShort(), this.winDescent = xe.readShort(), this.codePageRange = function () { var Ee, _e; for (_e = [], Ee = 0; Ee < 2; Ee = ++Ee)_e.push(xe.readInt()); return _e }(), this.version > 1)) return this.xHeight = xe.readShort(), this.capHeight = xe.readShort(), this.defaultChar = xe.readShort(), this.breakChar = xe.readShort(), this.maxContext = xe.readShort() }, t }(), fe = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "post", t.prototype.parse = function (xe) { var Ee, _e, Re; switch (xe.pos = this.offset, this.format = xe.readInt(), this.italicAngle = xe.readInt(), this.underlinePosition = xe.readShort(), this.underlineThickness = xe.readShort(), this.isFixedPitch = xe.readInt(), this.minMemType42 = xe.readInt(), this.maxMemType42 = xe.readInt(), this.minMemType1 = xe.readInt(), this.maxMemType1 = xe.readInt(), this.format) { case 65536: break; case 131072: var Ce; for (_e = xe.readUInt16(), this.glyphNameIndex = [], Ce = 0; 0 <= _e ? Ce < _e : Ce > _e; Ce = 0 <= _e ? ++Ce : --Ce)this.glyphNameIndex.push(xe.readUInt16()); for (this.names = [], Re = []; xe.pos < this.offset + this.length;)Ee = xe.readByte(), Re.push(this.names.push(xe.readString(Ee))); return Re; case 151552: return _e = xe.readUInt16(), this.offsets = xe.read(_e); case 196608: break; case 262144: return this.map = (function () { var Me, De, Pe; for (Pe = [], Ce = Me = 0, De = this.file.maxp.numGlyphs; 0 <= De ? Me < De : Me > De; Ce = 0 <= De ? ++Me : --Me)Pe.push(xe.readUInt32()); return Pe }).call(this) } }, t }(), de = function (e, t) { this.raw = e, this.length = e.length, this.platformID = t.platformID, this.encodingID = t.encodingID, this.languageID = t.languageID }, pe = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "name", t.prototype.parse = function (xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be, Ie; for (xe.pos = this.offset, xe.readShort(), Ee = xe.readShort(), De = xe.readShort(), _e = [], Ce = 0; 0 <= Ee ? Ce < Ee : Ce > Ee; Ce = 0 <= Ee ? ++Ce : --Ce)_e.push({ platformID: xe.readShort(), encodingID: xe.readShort(), languageID: xe.readShort(), nameID: xe.readShort(), length: xe.readShort(), offset: this.offset + De + xe.readShort() }); for (Pe = {}, Ce = je = 0, Be = _e.length; je < Be; Ce = ++je)Re = _e[Ce], xe.pos = Re.offset, Oe = xe.readString(Re.length), Me = new de(Oe, Re), Pe[Ie = Re.nameID] == null && (Pe[Ie] = []), Pe[Re.nameID].push(Me); this.strings = Pe, this.copyright = Pe[0], this.fontFamily = Pe[1], this.fontSubfamily = Pe[2], this.uniqueSubfamily = Pe[3], this.fontName = Pe[4], this.version = Pe[5]; try { this.postscriptName = Pe[6][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "") } catch { this.postscriptName = Pe[4][0].raw.replace(/[\x00-\x19\x80-\xff]/g, "") } return this.trademark = Pe[7], this.manufacturer = Pe[8], this.designer = Pe[9], this.description = Pe[10], this.vendorUrl = Pe[11], this.designerUrl = Pe[12], this.license = Pe[13], this.licenseUrl = Pe[14], this.preferredFamily = Pe[15], this.preferredSubfamily = Pe[17], this.compatibleFull = Pe[18], this.sampleText = Pe[19] }, t }(), ge = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "maxp", t.prototype.parse = function (xe) { return xe.pos = this.offset, this.version = xe.readInt(), this.numGlyphs = xe.readUInt16(), this.maxPoints = xe.readUInt16(), this.maxContours = xe.readUInt16(), this.maxCompositePoints = xe.readUInt16(), this.maxComponentContours = xe.readUInt16(), this.maxZones = xe.readUInt16(), this.maxTwilightPoints = xe.readUInt16(), this.maxStorage = xe.readUInt16(), this.maxFunctionDefs = xe.readUInt16(), this.maxInstructionDefs = xe.readUInt16(), this.maxStackElements = xe.readUInt16(), this.maxSizeOfInstructions = xe.readUInt16(), this.maxComponentElements = xe.readUInt16(), this.maxComponentDepth = xe.readUInt16() }, t }(), me = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "hmtx", t.prototype.parse = function (xe) { var Ee, _e, Re, Ce, Me, De, Pe; for (xe.pos = this.offset, this.metrics = [], Ee = 0, De = this.file.hhea.numberOfMetrics; 0 <= De ? Ee < De : Ee > De; Ee = 0 <= De ? ++Ee : --Ee)this.metrics.push({ advance: xe.readUInt16(), lsb: xe.readInt16() }); for (Re = this.file.maxp.numGlyphs - this.file.hhea.numberOfMetrics, this.leftSideBearings = function () { var Oe, je; for (je = [], Ee = Oe = 0; 0 <= Re ? Oe < Re : Oe > Re; Ee = 0 <= Re ? ++Oe : --Oe)je.push(xe.readInt16()); return je }(), this.widths = (function () { var Oe, je, Be, Ie; for (Ie = [], Oe = 0, je = (Be = this.metrics).length; Oe < je; Oe++)Ce = Be[Oe], Ie.push(Ce.advance); return Ie }).call(this), _e = this.widths[this.widths.length - 1], Pe = [], Ee = Me = 0; 0 <= Re ? Me < Re : Me > Re; Ee = 0 <= Re ? ++Me : --Me)Pe.push(this.widths.push(_e)); return Pe }, t.prototype.forGlyph = function (xe) { return xe in this.metrics ? this.metrics[xe] : { advance: this.metrics[this.metrics.length - 1].advance, lsb: this.leftSideBearings[xe - this.metrics.length] } }, t }(), ve = [].slice, be = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "glyf", t.prototype.parse = function () { return this.cache = {} }, t.prototype.glyphFor = function (xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be; return xe in this.cache ? this.cache[xe] : (Ce = this.file.loca, Ee = this.file.contents, _e = Ce.indexOf(xe), (Re = Ce.lengthOf(xe)) === 0 ? this.cache[xe] = null : (Ee.pos = this.offset + _e, Me = (De = new ne(Ee.read(Re))).readShort(), Oe = De.readShort(), Be = De.readShort(), Pe = De.readShort(), je = De.readShort(), this.cache[xe] = Me === -1 ? new we(De, Oe, Be, Pe, je) : new ye(De, Me, Oe, Be, Pe, je), this.cache[xe])) }, t.prototype.encode = function (xe, Ee, _e) { var Re, Ce, Me, De, Pe; for (Me = [], Ce = [], De = 0, Pe = Ee.length; De < Pe; De++)Re = xe[Ee[De]], Ce.push(Me.length), Re && (Me = Me.concat(Re.encode(_e))); return Ce.push(Me.length), { table: Me, offsets: Ce } }, t }(), ye = function () { function e(t, xe, Ee, _e, Re, Ce) { this.raw = t, this.numberOfContours = xe, this.xMin = Ee, this.yMin = _e, this.xMax = Re, this.yMax = Ce, this.compound = !1 } return e.prototype.encode = function () { return this.raw.data }, e }(), we = function () { function e(t, xe, Ee, _e, Re) { var Ce, Me; for (this.raw = t, this.xMin = xe, this.yMin = Ee, this.xMax = _e, this.yMax = Re, this.compound = !0, this.glyphIDs = [], this.glyphOffsets = [], Ce = this.raw; Me = Ce.readShort(), this.glyphOffsets.push(Ce.pos), this.glyphIDs.push(Ce.readUInt16()), 32 & Me;)Ce.pos += 1 & Me ? 4 : 2, 128 & Me ? Ce.pos += 8 : 64 & Me ? Ce.pos += 4 : 8 & Me && (Ce.pos += 2) } return e.prototype.encode = function () { var t, xe, Ee; for (xe = new ne(ve.call(this.raw.data)), t = 0, Ee = this.glyphIDs.length; t < Ee; ++t)xe.pos = this.glyphOffsets[t]; return xe.data }, e }(), Ne = function (e) { function t() { return t.__super__.constructor.apply(this, arguments) } return oe(t, re), t.prototype.tag = "loca", t.prototype.parse = function (xe) { var Ee, _e; return xe.pos = this.offset, Ee = this.file.head.indexToLocFormat, this.offsets = Ee === 0 ? (function () { var Re, Ce; for (Ce = [], _e = 0, Re = this.length; _e < Re; _e += 2)Ce.push(2 * xe.readUInt16()); return Ce }).call(this) : (function () { var Re, Ce; for (Ce = [], _e = 0, Re = this.length; _e < Re; _e += 4)Ce.push(xe.readUInt32()); return Ce }).call(this) }, t.prototype.indexOf = function (xe) { return this.offsets[xe] }, t.prototype.lengthOf = function (xe) { return this.offsets[xe + 1] - this.offsets[xe] }, t.prototype.encode = function (xe, Ee) { for (var _e = new Uint32Array(this.offsets.length), Re = 0, Ce = 0, Me = 0; Me < _e.length; ++Me)if (_e[Me] = Re, Ce < Ee.length && Ee[Ce] == Me) { ++Ce, _e[Me] = Re; var De = this.offsets[Me], Pe = this.offsets[Me + 1] - De; Pe > 0 && (Re += Pe) } for (var Oe = new Array(4 * _e.length), je = 0; je < _e.length; ++je)Oe[4 * je + 3] = 255 & _e[je], Oe[4 * je + 2] = (65280 & _e[je]) >> 8, Oe[4 * je + 1] = (16711680 & _e[je]) >> 16, Oe[4 * je] = (4278190080 & _e[je]) >> 24; return Oe }, t }(), Le = function () { function e(t) { this.font = t, this.subset = {}, this.unicodes = {}, this.next = 33 } return e.prototype.generateCmap = function () { var t, xe, Ee, _e, Re; for (xe in _e = this.font.cmap.tables[0].codeMap, t = {}, Re = this.subset) Ee = Re[xe], t[xe] = _e[Ee]; return t }, e.prototype.glyphsFor = function (t) { var xe, Ee, _e, Re, Ce, Me, De; for (_e = {}, Ce = 0, Me = t.length; Ce < Me; Ce++)_e[Re = t[Ce]] = this.font.glyf.glyphFor(Re); for (Re in xe = [], _e) (Ee = _e[Re]) != null && Ee.compound && xe.push.apply(xe, Ee.glyphIDs); if (xe.length > 0) for (Re in De = this.glyphsFor(xe)) Ee = De[Re], _e[Re] = Ee; return _e }, e.prototype.encode = function (t, xe) { var Ee, _e, Re, Ce, Me, De, Pe, Oe, je, Be, Ie, Fe, ze, qe, He; for (_e in Ee = ue.encode(this.generateCmap(), "unicode"), Ce = this.glyphsFor(t), Ie = { 0: 0 }, He = Ee.charMap) Ie[(De = He[_e]).old] = De.new; for (Fe in Be = Ee.maxGlyphID, Ce) Fe in Ie || (Ie[Fe] = Be++); return Oe = function (Ge) { var Ze, sn; for (Ze in sn = {}, Ge) sn[Ge[Ze]] = Ze; return sn }(Ie), je = Object.keys(Oe).sort(function (Ge, Ze) { return Ge - Ze }), ze = function () { var Ge, Ze, sn; for (sn = [], Ge = 0, Ze = je.length; Ge < Ze; Ge++)Me = je[Ge], sn.push(Oe[Me]); return sn }(), Re = this.font.glyf.encode(Ce, ze, Ie), Pe = this.font.loca.encode(Re.offsets, ze), qe = { cmap: this.font.cmap.raw(), glyf: Re.table, loca: Pe, hmtx: this.font.hmtx.raw(), hhea: this.font.hhea.raw(), maxp: this.font.maxp.raw(), post: this.font.post.raw(), name: this.font.name.raw(), head: this.font.head.encode(xe) }, this.font.os2.exists && (qe["OS/2"] = this.font.os2.raw()), this.font.directory.encode(qe) }, e }(); E.API.PDFObject = function () {
  var e; function t() { } return e = function (xe, Ee) { return (Array(Ee + 1).join("0") + xe).slice(-Ee) }, t.convert = function (xe) {
    var Ee, _e, Re, Ce; if (Array.isArray(xe)) return "[" + function () { var Me, De, Pe; for (Pe = [], Me = 0, De = xe.length; Me < De; Me++)Ee = xe[Me], Pe.push(t.convert(Ee)); return Pe }().join(" ") + "]"; if (typeof xe == "string") return "/" + xe; if (xe?.isString) return "(" + xe + ")"; if (xe instanceof Date) return "(D:" + e(xe.getUTCFullYear(), 4) + e(xe.getUTCMonth(), 2) + e(xe.getUTCDate(), 2) + e(xe.getUTCHours(), 2) + e(xe.getUTCMinutes(), 2) + e(xe.getUTCSeconds(), 2) + "Z)"; if ({}.toString.call(xe) === "[object Object]") {
      for (_e in Re = ["<<"], xe) Ce = xe[_e], Re.push("/" + _e + " " + t.convert(Ce)); return Re.push(">>"), Re.join(`
`)
    } return "" + xe
  }, t
}(); pdfjs.GlobalWorkerOptions.workerSrc = `//cdnjs.cloudflare.com/ajax/libs/pdf.js/${pdfjs.version}/pdf.worker.js`; const DocumentScanner = () => {
  const [e, t] = reactExports.useState(null), [xe, Ee] = reactExports.useState([]), [_e, Re] = reactExports.useState(null), [Ce, Me] = reactExports.useState(""), [De, Pe] = reactExports.useState(!1), [Oe, je] = reactExports.useState(""), Be = reactExports.useRef(null), Ie = reactExports.useRef(null), Fe = reactExports.useCallback(() => { const Ze = Ie.current.getScreenshot(); Ze && (Ee(sn => [...sn, Ze]), Pe(!1)) }, []), ze = Ze => { const sn = Ze.target.files[0]; if (!sn) return; const Xe = sn.type; if (Xe.startsWith("image/")) { const St = new FileReader; St.onload = () => { t(St.result), Re(null) }, St.readAsDataURL(sn) } else Xe === "application/pdf" && (Re(sn), t(null), je(sn.name)) }, qe = async () => { if (!Ce) return alert("Enter Patient MRN"); const Ze = Be.current?.cropper; if (!Ze) return; const sn = Ze.getCroppedCanvas(), Xe = await new Promise(on => sn.toBlob(on, "image/jpeg")), St = new File([Xe], "cropped-image.jpg", { type: "image/jpeg" }); console.log(St); const un = new FormData; un.append("file", St), un.append("patientMRN", Ce), un.append("employeeId", "12345"), console.log(Xe); try { await axiosInstance.post("/clerk/uploadDoc", un), alert("Image uploaded successfully!"), t(null) } catch (on) { console.error(on), alert("Upload failed") } }, He = async () => { if (!Ce || !_e) return alert("Missing Patient MRN or PDF"); const Ze = new FormData; Ze.append("file", _e), Ze.append("patientMRN", Ce), Ze.append("employeeId", "1234"); try { const sn = await axiosInstance.post("/clerk/uploadDoc", Ze); alert("PDF uploaded successfully!"), Re(null), je("") } catch (sn) { console.error(sn), alert("Upload failed") } }, Ge = async () => { if (!Ce || xe.length === 0) return alert("Add MRN and capture images"); const Ze = new E; for (let un = 0; un < xe.length; un++)un !== 0 && Ze.addPage(), Ze.addImage(xe[un], "JPEG", 10, 10, 190, 270); const sn = Ze.output("blob"), Xe = new File([sn], "scanned-document.pdf", { type: "application/pdf" }), St = new FormData; St.append("file", Xe), St.append("scannerClerk", "687903b74d2933e28308743f"), St.append("patientMRN", Ce), St.append("employeeId", "1234"); try { await axiosInstance.post("/clerk/uploadDoc", St), alert("Scanned PDF uploaded successfully!"), Ee([]) } catch (un) { console.error(un), alert("Upload failed") } }; return jsxRuntimeExports.jsxs("div", {
    className: "max-w-3xl mx-auto p-4", children: [jsxRuntimeExports.jsx("h1", { className: "text-xl font-semibold mb-4", children: "Document Scanner" }), jsxRuntimeExports.jsx("label", { className: "block text-sm font-medium mb-1 text-gray-700", children: "Enter Patient MRN" }), jsxRuntimeExports.jsx("input", { type: "text", value: Ce, onChange: Ze => Me(Ze.target.value), className: "w-full mb-4 px-3 py-2 border rounded-md text-sm", placeholder: "e.g., MRN123456" }), jsxRuntimeExports.jsx("input", {
      type: "file", accept: "image/*,application/pdf", onChange: ze, className: `mb-4 block w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4\r
                   file:rounded-full file:border-0 file:text-sm file:font-semibold\r
                   file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100`}), jsxRuntimeExports.jsx("button", { onClick: () => Pe(!0), className: "mb-4 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition", children: "Open Camera" }), De && jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [jsxRuntimeExports.jsx(Webcam, { audio: !1, ref: Ie, screenshotFormat: "image/jpeg", className: "w-full rounded-md", videoConstraints: { facingMode: "environment" } }), jsxRuntimeExports.jsx("button", { onClick: Fe, className: "mt-2 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition", children: "Capture Image" })] }), xe.length > 0 && jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [jsxRuntimeExports.jsx("h2", { className: "text-lg font-medium mb-2", children: "Captured Images" }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-2", children: xe.map((Ze, sn) => jsxRuntimeExports.jsxs("div", { className: "relative", children: [jsxRuntimeExports.jsx("img", { src: Ze, alt: `Captured ${sn}`, className: "w-full rounded shadow" }), jsxRuntimeExports.jsx("button", { onClick: () => { const Xe = [...xe]; Xe.splice(sn, 1), Ee(Xe) }, className: "absolute top-1 right-1 bg-red-600 text-white text-xs px-2 py-1 rounded hover:bg-red-700", children: "Delete" })] }, sn)) }), jsxRuntimeExports.jsx("button", { onClick: Ge, className: "mt-4 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition", children: "Upload All as PDF" }), jsxRuntimeExports.jsx("button", { onClick: () => Ee([]), className: "mt-2 bg-red-500 text-white px-4 py-2 rounded-md hover:bg-red-600 transition ml-2", children: "Clear Captured Images" })] }), e && jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: "w-full h-[60vh] mb-4", children: jsxRuntimeExports.jsx(l$1, { src: e, ref: Be, style: { height: "100%", width: "100%" }, aspectRatio: NaN, guides: !0, viewMode: 1, dragMode: "move", autoCropArea: 1, background: !1 }) }), jsxRuntimeExports.jsx("button", { onClick: qe, className: "bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition", children: "Upload Cropped Image" })] }), _e && jsxRuntimeExports.jsxs("div", { className: "mt-4", children: [jsxRuntimeExports.jsxs("p", { className: "text-sm mb-2 text-gray-600", children: ["PDF selected: ", Oe] }), jsxRuntimeExports.jsx("button", { onClick: He, className: "bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition", children: "Upload PDF" })] })]
  })
}, getAllMyScannedDocs = ({ page: e, limit: t }) => axiosInstance.get(`/clerk/clerkDocs?page=${e}&limit=${t}`), deleteScannedDoc = e => axiosInstance.get("/clerk/deleteDoc/" + e), searchClerkDocuments = ({ searchTerm: e, page: t, limit: xe }) => axiosInstance.get(`/clerk/search?query=${e}&page=${t}&limit=${xe}`), updateStatus = e => axiosInstance.post("/clerk/updateStatus", { id: e }); pdfjs.GlobalWorkerOptions.workerSrc = new URL("/assets/pdf.worker.min-DKQKFyKK.js", import.meta.url).toString(); const PDFPreviewer = ({ filePath: e }) => { const [t, xe] = reactExports.useState(null), [Ee, _e] = reactExports.useState(0); reactExports.useEffect(() => { const Ce = () => { const Me = document.getElementById("pdf-container"); Me && _e(Me.offsetWidth - 40) }; return Ce(), window.addEventListener("resize", Ce), () => window.removeEventListener("resize", Ce) }, []); const Re = ({ numPages: Ce }) => { xe(Ce) }; return console.log("PDF file path:", e), jsxRuntimeExports.jsx("div", { id: "pdf-container", className: "w-full max-w-4xl mx-auto p-4 overflow-y-auto max-h-[85vh] bg-white rounded-lg", children: e ? jsxRuntimeExports.jsx(Document, { file: e, onLoadSuccess: Re, className: "flex flex-col items-center", children: Array.from(new Array(t || 0), (Ce, Me) => jsxRuntimeExports.jsx("div", { className: "mb-4 shadow-lg", children: jsxRuntimeExports.jsx(Page, { pageNumber: Me + 1, width: Ee, renderTextLayer: !1, renderAnnotationLayer: !1, className: "border rounded" }) }, Me)) }) : jsxRuntimeExports.jsx("p", { className: "text-center text-gray-500", children: "No PDF file provided" }) }) }, Preview = ({ filePath: e }) => { console.log("Previewing file:", e); const t = e?.toLowerCase().endsWith(".pdf"); return console.log("Is PDF:", t), jsxRuntimeExports.jsx("div", { className: "w-[60vw] h-[90vh] flex justify-center items-center", children: t ? jsxRuntimeExports.jsx(PDFPreviewer, { filePath: e }) : jsxRuntimeExports.jsx("img", { src: e, alt: "Preview", className: "max-w-full max-h-[80vh] object-contain" }) }) }, configurePDFWorker = () => { pdfjs.GlobalWorkerOptions.workerSrc || (pdfjs.GlobalWorkerOptions.workerSrc = new URL("/assets/pdf.worker.min-DKQKFyKK.js", import.meta.url).toString(), console.log("PDF.js worker configured:", pdfjs.GlobalWorkerOptions.workerSrc)) }; configurePDFWorker(); const STATUS_CONFIG$1 = { draft: { bg: "bg-yellow-100", text: "text-yellow-800", dot: "bg-yellow-500" }, rejected: { bg: "bg-red-100", text: "text-red-800", dot: "bg-red-500" }, submitted: { bg: "bg-green-100", text: "text-green-800", dot: "bg-green-500" }, approved: { bg: "bg-blue-100", text: "text-blue-800", dot: "bg-blue-500" }, default: { bg: "bg-gray-200", text: "text-gray-800", dot: "bg-gray-500" } }, ScannedDocumentCard = React.memo(({ document: e, deleteButton: t, onDelete: xe, isScanner: Ee, isApprover: _e }) => { const { showError: Re, showSuccess: Ce } = useToastError(), { id: Me, fileName: De, filePath: Pe, patientMRN: Oe, status: je, scannedAt: Be, comment: Ie, employeeId: Fe, uploadedAt: ze, scanner: qe, uploader: He, reviewedAt: Ge, approver: Ze } = e, [sn, Xe] = reactExports.useState(!1), [St, un] = reactExports.useState(!1), [on, bn] = reactExports.useState(!0), [Tn, fn] = reactExports.useState(!1), En = useNavigate(), Pn = Pe?.toLowerCase().endsWith(".pdf"), Rn = reactExports.useCallback(async () => { fn(!0); try { await updateStatus(Me), Ce("Document submitted successfully") } catch (We) { console.error(We), Re("Could not update the document") } finally { fn(!1) } }, [Me, Ce, Re]), In = reactExports.useCallback(() => { En("/rescan", { state: { id: Me, fileName: De, filePath: Pe, uploadedAt: ze } }) }, [Me, De, Pe, ze, En]), xn = reactExports.useCallback(We => { We.target === We.currentTarget && Xe(!1) }, []); reactExports.useEffect(() => { const We = dn => { dn.key === "Escape" && (Xe(!1), un(!1)) }; return (sn || St) && window.addEventListener("keydown", We), () => window.removeEventListener("keydown", We) }, [sn, St]); const vn = reactExports.useCallback(() => { bn(!1) }, []), tn = reactExports.useCallback(We => { bn(!1), Re("Failed to load document preview"), console.error(We) }, [Re]), nn = STATUS_CONFIG$1[je] || STATUS_CONFIG$1.default; return jsxRuntimeExports.jsxs(Card, { className: "w-full max-w-md relative shadow-md hover:shadow-lg transition-shadow duration-200", children: [jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: jsxRuntimeExports.jsxs(CardTitle, { className: "flex items-center gap-2 text-lg", children: [jsxRuntimeExports.jsx(FileText, { className: "h-5 w-5 text-blue-500", "aria-hidden": "true" }), jsxRuntimeExports.jsx("span", { className: "truncate", title: De, children: De })] }) }), jsxRuntimeExports.jsx(CardContent, { className: "pt-2", children: jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [jsxRuntimeExports.jsxs("div", { className: "relative w-full h-48 overflow-hidden rounded-lg mb-2 border border-gray-200", children: [on && jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 flex items-center justify-center bg-gray-100", children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-6 w-6 animate-spin text-gray-500" }), jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading..." })] }), Pn ? jsxRuntimeExports.jsx(Document, { file: getStaticUrl(Pe), onLoadSuccess: vn, onLoadError: tn, loading: null, children: jsxRuntimeExports.jsx(Page, { pageNumber: 1, width: 300, renderTextLayer: !1, renderAnnotationLayer: !1, className: "w-full h-full object-cover" }) }) : jsxRuntimeExports.jsx("img", { src: getStaticUrl(Pe), alt: De, className: "w-full h-48 object-cover rounded-lg", onLoad: vn, onError: tn })] }), jsxRuntimeExports.jsxs("div", { className: "space-y-1.5 text-sm text-gray-600", children: [jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Patient MRN:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Oe })] }), jsxRuntimeExports.jsxs("p", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Status:" }), jsxRuntimeExports.jsxs("span", { className: cn$1("flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium capitalize", nn.bg, nn.text), children: [jsxRuntimeExports.jsx("span", { className: cn$1("w-2 h-2 rounded-full", nn.dot) }), je] }), (je === "draft" || je === "rejected") && jsxRuntimeExports.jsx("button", { className: "underline text-blue-600 hover:text-blue-800 text-sm ml-2 transition-colors", onClick: In, "aria-label": `Rescan or resubmit ${De}`, children: "Rescan/Resubmit" })] })] }), jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 mt-4", children: [jsxRuntimeExports.jsx(Button, { variant: "outline", className: "flex-1 h-10", onClick: () => Xe(!0), "aria-label": `Preview ${De}`, children: "Preview" }), jsxRuntimeExports.jsxs(Dialog, { open: St, onOpenChange: un, children: [jsxRuntimeExports.jsx(DialogTrigger, { asChild: !0, children: jsxRuntimeExports.jsxs(Button, { variant: "outline", className: "flex-1 h-10", "aria-label": `View details for ${De}`, children: [jsxRuntimeExports.jsx(Info, { className: "h-4 w-4 mr-2" }), " Info"] }) }), jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { className: "text-lg font-semibold", children: "Document Details" }) }), jsxRuntimeExports.jsxs("div", { className: "space-y-4 text-sm text-gray-600", children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "General" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Document ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Me })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "File Name:" }), " ", jsxRuntimeExports.jsx("span", { className: "truncate", title: De, children: De })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Patient MRN:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Oe })] })] }), Ie && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Comments" }), jsxRuntimeExports.jsx("p", { className: "text-gray-700", children: Ie })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Scanner Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Fe })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", qe?.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", qe?.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${qe?.email}`, className: "text-blue-600 hover:underline", children: qe?.email || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Scanned At:" }), " ", new Date(Be).toLocaleString()] })] }), He && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Uploader Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: He.employeeId || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", He.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", He.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${He.email}`, className: "text-blue-600 hover:underline", children: He.email || "N/A" })] }), ze && jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Uploaded At:" }), " ", new Date(ze).toLocaleString()] })] }), Ze && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Approver Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Ze.employeeId || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", Ze.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", Ze.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${Ze.email}`, className: "text-blue-600 hover:underline", children: Ze.email || "N/A" })] }), Ge && jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Reviewed At:" }), " ", new Date(Ge).toLocaleString()] })] })] })] })] })] }), Ee && je === "draft" && jsxRuntimeExports.jsx(Button, { onClick: Rn, className: "w-full mt-4 bg-blue-600 hover:bg-blue-700 text-white h-10", "aria-label": "Submit document", disabled: Tn, children: Tn ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin mr-2" }), "Submitting..."] }) : "Submit Document" })] }) }), sn && jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-50 flex items-center justify-center bg-black/80", onClick: xn, role: "dialog", "aria-modal": "true", "aria-label": `Preview ${De}`, children: jsxRuntimeExports.jsxs("div", { className: "relative w-[90vw] md:w-[60vw] h-[90vh] overflow-auto bg-white rounded-lg shadow-xl", children: [jsxRuntimeExports.jsx("button", { className: "absolute top-2 right-2 text-gray-600 hover:text-gray-800 transition-colors", onClick: () => Xe(!1), "aria-label": "Close preview", children: jsxRuntimeExports.jsx("svg", { className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) }), jsxRuntimeExports.jsx(Preview, { filePath: getStaticUrl(Pe) })] }) }), t && jsxRuntimeExports.jsx(Button, { variant: "destructive", size: "icon", onClick: xe, title: "Delete Document", className: "absolute top-2 right-2 bg-red-600 hover:bg-red-700", "aria-label": `Delete ${De}`, children: jsxRuntimeExports.jsx(Trash2, { className: "h-4 w-4" }) })] }) }), SearchBar = ({ onSearch: e }) => { const [t, xe] = reactExports.useState(""), Ee = Re => { const Ce = Re.target.value; xe(Ce) }, _e = Re => { Re.preventDefault(), e(t) }; return jsxRuntimeExports.jsxs("form", { onSubmit: _e, className: "flex w-full max-w-4xl p-4 bg-white items-center gap-3 mb-4", children: [jsxRuntimeExports.jsx(FormField, { label: "Search Documents", id: "search", name: "search", value: t, onChange: Ee, placeholder: "Enter document name or MRN...", className: "w-full", required: !0 }), jsxRuntimeExports.jsx(Button, { type: "submit", "aria-label": "Search", className: "inline-flex items-center justify-center px-4 py-2 text-white rounded-lg transition", children: jsxRuntimeExports.jsx(Search, { className: "w-5 h-5" }) })] }) }; function Pagination({ className: e, ...t }) { return jsxRuntimeExports.jsx("nav", { role: "navigation", "aria-label": "pagination", "data-slot": "pagination", className: cn$1("mx-auto flex w-full justify-center", e), ...t }) } function PaginationContent({ className: e, ...t }) { return jsxRuntimeExports.jsx("ul", { "data-slot": "pagination-content", className: cn$1("flex flex-row items-center gap-1", e), ...t }) } function PaginationItem(e) { return jsxRuntimeExports.jsx("li", { "data-slot": "pagination-item", ...e }) } function PaginationLink({ className: e, isActive: t, size: xe = "icon", ...Ee }) { return jsxRuntimeExports.jsx("a", { "aria-current": t ? "page" : void 0, "data-slot": "pagination-link", "data-active": t, className: cn$1(buttonVariants({ variant: t ? "outline" : "ghost", size: xe }), e), ...Ee }) } function PaginationPrevious({ className: e, ...t }) { return jsxRuntimeExports.jsxs(PaginationLink, { "aria-label": "Go to previous page", size: "default", className: cn$1("gap-1 px-2.5 sm:pl-2.5", e), ...t, children: [jsxRuntimeExports.jsx(ChevronLeft, {}), jsxRuntimeExports.jsx("span", { className: "hidden sm:block", children: "Previous" })] }) } function PaginationNext({ className: e, ...t }) { return jsxRuntimeExports.jsxs(PaginationLink, { "aria-label": "Go to next page", size: "default", className: cn$1("gap-1 px-2.5 sm:pr-2.5", e), ...t, children: [jsxRuntimeExports.jsx("span", { className: "hidden sm:block", children: "Next" }), jsxRuntimeExports.jsx(ChevronRight, {})] }) } const DisplayScannedDocs = () => { const e = useQueryClient(), { showError: t, showSuccess: xe } = useToastError(), [Ee, _e] = reactExports.useState(!1), [Re, Ce] = reactExports.useState(null), [Me, De] = reactExports.useState(""), [Pe, Oe] = reactExports.useState(1), je = 9, Be = reactExports.useRef(null), { data: Ie, isLoading: Fe, error: ze, isFetching: qe } = useQuery({ queryKey: ["scanned-docs", Me, Pe], queryFn: async () => { const on = { page: Pe, limit: je }; return Me ? await searchClerkDocuments({ searchTerm: Me, ...on }) : await getAllMyScannedDocs(on) }, keepPreviousData: !0 }), He = useMutation({ mutationFn: deleteScannedDoc, onSuccess: () => { e.invalidateQueries(["scanned-docs"]), xe("Document deleted successfully"), _e(!1), Ce(null) }, onError: on => { t(on, "Failed to delete document") } }), Ge = reactExports.useCallback(on => { Ce(on), _e(!0) }, []), Ze = reactExports.useCallback(() => { Re && He.mutate(Re) }, [Re, He]), sn = reactExports.useCallback(on => { De(on.trim()), Oe(1) }, []), Xe = reactExports.useCallback(() => { De(""), Oe(1), Be.current && (Be.current.value = "") }, []); if (ze) return t(ze, ze.statusCode === 400 ? "Please enter a search term" : "Failed to fetch documents"), jsxRuntimeExports.jsxs("div", { className: "text-center text-red-500", role: "alert", children: ["Error: ", ze.message] }); const St = Ie?.data?.data?.data || [], un = Ie?.data?.data?.totalPages || 1; return jsxRuntimeExports.jsxs("div", { className: "p-4 w-full", children: [jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-6", children: "My Scanned Documents" }), jsxRuntimeExports.jsxs("div", { className: "mb-6 flex items-center gap-2", children: [jsxRuntimeExports.jsx(SearchBar, { onSearch: sn, placeholder: "Search documents..." }), Me && jsxRuntimeExports.jsx(Button, { variant: "outline", size: "icon", onClick: Xe, "aria-label": "Clear search", title: "Clear search", children: jsxRuntimeExports.jsx(X$1, { className: "h-4 w-4" }) })] }), Fe || qe ? jsxRuntimeExports.jsx("div", { className: "flex justify-center items-center h-64", children: jsxRuntimeExports.jsx(LoaderCircle, { className: "h-8 w-8 animate-spin" }) }) : jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6", children: St.length > 0 ? St.map(on => jsxRuntimeExports.jsx(ScannedDocumentCard, { document: on, deleteButton: on.status === "draft", onDelete: () => Ge(on.id), isScanner: !0 }, on.id)) : jsxRuntimeExports.jsxs("div", { className: "text-center py-12 col-span-full", children: [jsxRuntimeExports.jsx("p", { className: "text-lg text-gray-600", children: Me ? "No documents found matching your search." : "You have no scanned documents yet." }), !Me && jsxRuntimeExports.jsx(Button, { className: "mt-4", onClick: () => window.location.href = "/scan", children: "Scan a New Document" })] }) }), un > 1 && jsxRuntimeExports.jsx(Pagination, { className: "mt-6 flex justify-center", children: jsxRuntimeExports.jsxs(PaginationContent, { children: [jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationPrevious, { onClick: () => Oe(on => Math.max(on - 1, 1)), className: Pe === 1 ? "pointer-events-none opacity-50" : "" }) }), [...Array(un)].map((on, bn) => { const Tn = bn + 1; return jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationLink, { onClick: () => Oe(Tn), isActive: Pe === Tn, children: Tn }) }, Tn) }), jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationNext, { onClick: () => Oe(on => Math.min(on + 1, un)), className: Pe === un ? "pointer-events-none opacity-50" : "" }) })] }) })] }), jsxRuntimeExports.jsx(Dialog, { open: Ee, onOpenChange: _e, children: jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { children: "Confirm Document Deletion" }) }), jsxRuntimeExports.jsx("p", { className: "text-sm text-gray-600", children: "Are you sure you want to delete this document? This action cannot be undone." }), jsxRuntimeExports.jsxs("div", { className: "flex gap-2 mt-4 justify-end", children: [jsxRuntimeExports.jsx(Button, { variant: "outline", onClick: () => _e(!1), disabled: He.isLoading, children: "Cancel" }), jsxRuntimeExports.jsx(Button, { variant: "destructive", onClick: Ze, disabled: He.isLoading, children: He.isLoading ? "Deleting..." : "Delete" })] })] }) })] }) }, items = [{ title: "Review Documents", url: "/approver/review", icon: Scan }, { title: "Approved Documents", url: "/approver/approved", icon: Inbox }, { title: "Rejected Documents", url: "/approver/rejected", icon: Inbox }]; function AppSidebar() { return jsxRuntimeExports.jsx(Sidebar, { className: "mt-16", children: jsxRuntimeExports.jsx(SidebarContent, { children: jsxRuntimeExports.jsx(SidebarGroup, { children: jsxRuntimeExports.jsx(SidebarGroupContent, { children: jsxRuntimeExports.jsx(SidebarMenu, { children: items.map(e => jsxRuntimeExports.jsx(SidebarMenuItem, { children: jsxRuntimeExports.jsx(SidebarMenuButton, { asChild: !0, children: jsxRuntimeExports.jsxs("a", { href: e.url, children: [jsxRuntimeExports.jsx(e.icon, {}), jsxRuntimeExports.jsx("span", { children: e.title })] }) }) }, e.title)) }) }) }) }) }) } const ApproverDashboard = () => jsxRuntimeExports.jsx("div", { children: jsxRuntimeExports.jsxs(SidebarProvider, { children: [jsxRuntimeExports.jsx(AppSidebar, {}), jsxRuntimeExports.jsx(SidebarTrigger, {}), jsxRuntimeExports.jsx(Outlet, {})] }) }), ApproverPage = () => jsxRuntimeExports.jsx(ProtectedRoute, { roles: ["Approver"], children: jsxRuntimeExports.jsx(ApproverDashboard, {}) }), getScannedDocuments = ({ page: e = 1, limit: t = 10 } = {}) => axiosInstance.get("/approver/scannedDocs", { params: { page: e, limit: t } }), getAllMyApprovedDocuments = ({ page: e = 1, limit: t = 10 } = {}) => axiosInstance.get("/approver/approvedDocs", { params: { page: e, limit: t } }), getAllMyRejectedDocuments = ({ page: e = 1, limit: t = 10 } = {}) => axiosInstance.get("/approver/rejectedDocs", { params: { page: e, limit: t } }), approveDocument = e => axiosInstance.post(`/approver/approve/${e}`), rejectDocument = (e, t) => axiosInstance.post(`/approver/reject/${e}`, t), searchDocuments = ({ query: e, page: t = 1, limit: xe = 10 }) => axiosInstance.get("/approver/search", { params: { query: e, page: t, limit: xe } }), STATUS_CONFIG = { draft: { bg: "bg-yellow-100", text: "text-yellow-800", dot: "bg-yellow-500" }, rejected: { bg: "bg-red-100", text: "text-red-800", dot: "bg-red-500" }, submitted: { bg: "bg-green-100", text: "text-green-800", dot: "bg-green-500" }, approved: { bg: "bg-blue-100", text: "text-blue-800", dot: "bg-blue-500" }, default: { bg: "bg-gray-200", text: "text-gray-800", dot: "bg-gray-500" } }, ReviewDocumentCard = React.memo(({ document: e, refetch: t }) => { const { id: xe, fileName: Ee, filePath: _e, patientMRN: Re, status: Ce, scannedAt: Me, comment: De, employeeId: Pe, uploadedAt: Oe, scanner: je, uploader: Be, reviewedAt: Ie, approver: Fe } = e, [ze, qe] = reactExports.useState(!1), [He, Ge] = reactExports.useState(!1), [Ze, sn] = reactExports.useState(""), [Xe, St] = reactExports.useState(!1), [un, on] = reactExports.useState(!0), { showError: bn, showSuccess: Tn } = useToastError(), fn = useQueryClient(), En = _e?.toLowerCase().endsWith(".pdf"), Pn = reactExports.useCallback(dn => { dn.target === dn.currentTarget && St(!1) }, []); reactExports.useEffect(() => { const dn = Je => { Je.key === "Escape" && (St(!1), qe(!1), Ge(!1)) }; return (Xe || ze || He) && window.addEventListener("keydown", dn), () => window.removeEventListener("keydown", dn) }, [Xe, ze, He]); const Rn = reactExports.useCallback(() => { on(!1) }, []), In = reactExports.useCallback(dn => { on(!1), bn("Failed to load document preview"), console.error(dn) }, [bn]), xn = useMutation({ mutationFn: () => approveDocument(e.id), onSuccess: () => { Tn(`${Ee} approved successfully.`), fn.invalidateQueries(["approver-scanned-docs"]), t?.() }, onError: dn => { bn(`Failed to approve document: ${dn.message}`), console.error(dn) } }), vn = useMutation({ mutationFn: () => rejectDocument(e.id, { rejectComment: Ze }), onSuccess: () => { Tn(`${Ee} rejected successfully.`), qe(!1), sn(""), fn.invalidateQueries(["approver-scanned-docs"]), t?.() }, onError: dn => { bn(`Failed to reject document: ${dn.message}`), qe(!1), console.error(dn) } }), tn = reactExports.useCallback(() => { xn.mutate() }, [xn]), nn = reactExports.useCallback(() => { if (!Ze.trim()) { bn("Please provide a reason for rejection"); return } vn.mutate() }, [Ze, vn, bn]), We = STATUS_CONFIG[Ce] || STATUS_CONFIG.default; return jsxRuntimeExports.jsxs(Card, { className: "w-full max-w-sm relative shadow-md hover:shadow-lg transition-shadow duration-200", children: [jsxRuntimeExports.jsx(CardHeader, { className: "pb-2", children: jsxRuntimeExports.jsxs(CardTitle, { className: "flex items-center gap-2 text-lg", children: [jsxRuntimeExports.jsx(FileText, { className: "h-5 w-5 text-blue-500", "aria-hidden": "true" }), jsxRuntimeExports.jsx("span", { className: "truncate", title: Ee, children: Ee })] }) }), jsxRuntimeExports.jsx(CardContent, { className: "pt-2", children: jsxRuntimeExports.jsxs("div", { className: "space-y-3", children: [jsxRuntimeExports.jsxs("div", { className: "relative w-full h-48 overflow-hidden rounded-lg mb-2 border border-gray-200", children: [un && jsxRuntimeExports.jsxs("div", { className: "absolute inset-0 flex items-center justify-center bg-gray-100", children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-6 w-6 animate-spin text-gray-500" }), jsxRuntimeExports.jsx("span", { className: "ml-2 text-gray-500", children: "Loading..." })] }), En ? jsxRuntimeExports.jsx(Document, { file: getStaticUrl(_e), onLoadSuccess: Rn, onLoadError: In, loading: null, children: jsxRuntimeExports.jsx(Page, { pageNumber: 1, width: 300, renderTextLayer: !1, renderAnnotationLayer: !1, className: "w-full h-full object-cover" }) }) : jsxRuntimeExports.jsx("img", { src: getStaticUrl(_e), alt: Ee, className: "w-full h-48 object-cover rounded-lg", onLoad: Rn, onError: In })] }), jsxRuntimeExports.jsxs("div", { className: "space-y-1.5 text-sm text-gray-600", children: [jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Patient MRN:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Re })] }), jsxRuntimeExports.jsxs("p", { className: "flex items-center gap-2", children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Status:" }), jsxRuntimeExports.jsxs("span", { className: cn$1("flex items-center gap-1 px-2 py-0.5 rounded-full text-xs font-medium capitalize", We.bg, We.text), children: [jsxRuntimeExports.jsx("span", { className: cn$1("w-2 h-2 rounded-full", We.dot) }), Ce] })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Scanned At:" }), " ", new Date(Me).toLocaleString()] })] }), jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 mt-4", children: [jsxRuntimeExports.jsx(Button, { variant: "outline", className: "h-10", onClick: () => St(!0), "aria-label": `Preview ${Ee}`, children: "Preview" }), jsxRuntimeExports.jsxs(Dialog, { open: He, onOpenChange: Ge, children: [jsxRuntimeExports.jsx(DialogTrigger, { asChild: !0, children: jsxRuntimeExports.jsxs(Button, { variant: "outline", className: "h-10", "aria-label": `View details for ${Ee}`, children: [jsxRuntimeExports.jsx(Info, { className: "h-4 w-4 mr-2" }), " Info"] }) }), jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsx(DialogTitle, { className: "text-lg font-semibold", children: "Document Details" }) }), jsxRuntimeExports.jsxs("div", { className: "space-y-4 text-sm text-gray-600", children: [jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "General" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Document ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: xe })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "File Name:" }), " ", jsxRuntimeExports.jsx("span", { className: "truncate", title: Ee, children: Ee })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Patient MRN:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Re })] })] }), De && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Comments" }), jsxRuntimeExports.jsx("p", { className: "text-gray-700", children: De })] }), jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Scanner Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Pe })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", je?.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", je?.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${je?.email}`, className: "text-blue-600 hover:underline", children: je?.email || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Scanned At:" }), " ", new Date(Me).toLocaleString()] })] }), Be && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Uploader Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Be.employeeId || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", Be.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", Be.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${Be.email}`, className: "text-blue-600 hover:underline", children: Be.email || "N/A" })] }), Oe && jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Uploaded At:" }), " ", new Date(Oe).toLocaleString()] })] }), Fe && jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h4", { className: "font-medium text-gray-800 border-b pb-1 mb-2", children: "Approver Details" }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Employee ID:" }), " ", jsxRuntimeExports.jsx("span", { className: "font-mono", children: Fe.employeeId || "N/A" })] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Name:" }), " ", Fe.fullName || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Department:" }), " ", Fe.department || "N/A"] }), jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Email:" }), " ", jsxRuntimeExports.jsx("a", { href: `mailto:${Fe.email}`, className: "text-blue-600 hover:underline", children: Fe.email || "N/A" })] }), Ie && jsxRuntimeExports.jsxs("p", { children: [jsxRuntimeExports.jsx("span", { className: "font-medium", children: "Reviewed At:" }), " ", new Date(Ie).toLocaleString()] })] })] })] })] })] }), Ce === "submitted" && jsxRuntimeExports.jsxs("div", { className: "grid grid-cols-2 gap-2 mt-4", children: [jsxRuntimeExports.jsx(Button, { onClick: tn, disabled: xn.isPending || vn.isPending, className: "h-10 bg-green-600 hover:bg-green-700 text-white", "aria-label": `Approve ${Ee}`, children: xn.isPending ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin mr-2" }), "Approving..."] }) : "Approve" }), jsxRuntimeExports.jsx(Button, { onClick: () => qe(!0), disabled: xn.isPending || vn.isPending, variant: "destructive", className: "h-10", "aria-label": `Reject ${Ee}`, children: vn.isPending ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin mr-2" }), "Rejecting..."] }) : "Reject" })] })] }) }), Xe && jsxRuntimeExports.jsx("div", { className: "fixed inset-0 z-50 flex items-center justify-center bg-black/80", onClick: Pn, role: "dialog", "aria-modal": "true", "aria-label": `Preview ${Ee}`, children: jsxRuntimeExports.jsxs("div", { className: "relative w-[90vw] md:w-[60vw] h-[90vh] overflow-auto bg-white rounded-lg shadow-xl", children: [jsxRuntimeExports.jsx("button", { className: "absolute top-2 right-2 text-gray-600 hover:text-gray-800 transition-colors", onClick: () => St(!1), "aria-label": "Close preview", children: jsxRuntimeExports.jsx("svg", { className: "h-6 w-6", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: jsxRuntimeExports.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M6 18L18 6M6 6l12 12" }) }) }), jsxRuntimeExports.jsx(Preview, { filePath: getStaticUrl(_e) })] }) }), jsxRuntimeExports.jsx(Dialog, { open: ze, onOpenChange: qe, children: jsxRuntimeExports.jsxs(DialogContent, { className: "sm:max-w-md", children: [jsxRuntimeExports.jsx(DialogHeader, { children: jsxRuntimeExports.jsxs(DialogTitle, { children: ["Reject Document: ", Ee] }) }), jsxRuntimeExports.jsxs("div", { className: "py-4 space-y-2", children: [jsxRuntimeExports.jsx(Input, { value: Ze, onChange: dn => sn(dn.target.value), placeholder: "Enter reason for rejection", className: "w-full", "aria-label": "Reason for rejection" }), !Ze.trim() && jsxRuntimeExports.jsx("p", { className: "text-sm text-red-500", children: "Please provide a reason for rejection" })] }), jsxRuntimeExports.jsxs(DialogFooter, { children: [jsxRuntimeExports.jsx(Button, { variant: "ghost", onClick: () => qe(!1), disabled: vn.isPending, "aria-label": "Cancel rejection", children: "Cancel" }), jsxRuntimeExports.jsx(Button, { onClick: nn, disabled: vn.isPending || !Ze.trim(), className: "bg-red-600 hover:bg-red-700 text-white", "aria-label": "Submit rejection", children: vn.isPending ? jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [jsxRuntimeExports.jsx(LoaderCircle, { className: "h-4 w-4 animate-spin mr-2" }), "Submitting..."] }) : "Submit Rejection" })] })] }) })] }) }), ReviewSection = () => { const [e, t] = reactExports.useState(""), [xe, Ee] = reactExports.useState(1), _e = 9, { data: Re, isLoading: Ce, error: Me } = useQuery({ queryKey: ["approver-scanned-docs", e, xe], queryFn: async () => { const je = { page: xe, limit: _e }; return e ? await searchDocuments({ query: e, ...je }) : await getScannedDocuments(je) }, keepPreviousData: !0 }), De = reactExports.useCallback(je => { t(je.trim()), Ee(1) }, []), Pe = Re?.data?.data?.data || [], Oe = Re?.data?.data?.totalPages || 1; return Ce ? jsxRuntimeExports.jsx("div", { children: "Loading..." }) : Me ? jsxRuntimeExports.jsx("div", { className: "text-center text-red-500", role: "alert", children: "Error loading documents" }) : jsxRuntimeExports.jsxs("div", { className: "w-full p-4", children: [jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4 w-full", children: "Scanned Documents to Review" }), jsxRuntimeExports.jsx(SearchBar, { onSearch: De, placeholder: "Search documents..." }), jsxRuntimeExports.jsx("div", { className: "flex w-full gap-4 flex-wrap justify-center mt-6", children: Pe.length > 0 ? Pe.map(je => jsxRuntimeExports.jsx(ReviewDocumentCard, { document: je }, je.id)) : jsxRuntimeExports.jsx("div", { children: "No documents found" }) }), Oe > 1 && jsxRuntimeExports.jsx(Pagination, { className: "mt-6 flex justify-center", children: jsxRuntimeExports.jsxs(PaginationContent, { children: [jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationPrevious, { onClick: () => Ee(je => Math.max(je - 1, 1)), className: xe === 1 ? "pointer-events-none opacity-50" : "" }) }), [...Array(Oe)].map((je, Be) => { const Ie = Be + 1; return jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationLink, { onClick: () => Ee(Ie), isActive: xe === Ie, children: Ie }) }, Ie) }), jsxRuntimeExports.jsx(PaginationItem, { children: jsxRuntimeExports.jsx(PaginationNext, { onClick: () => Ee(je => Math.min(je + 1, Oe)), className: xe === Oe ? "pointer-events-none opacity-50" : "" }) })] }) })] }) }, RejectedSection = () => { const { data: e, isPending: t, isError: xe } = useQuery({ queryKey: ["approver-rejected-docs"], queryFn: getAllMyRejectedDocuments }); return jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4", children: "Rejected Documents" }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4", children: e?.data?.data?.data?.map(Ee => jsxRuntimeExports.jsx(ScannedDocumentCard, { document: Ee }, Ee.id)) })] }) }, ApprovedSection = () => { const { data: e, isPending: t, isError: xe } = useQuery({ queryKey: ["approver-approved-docs"], queryFn: getAllMyApprovedDocuments }); return jsxRuntimeExports.jsxs("div", { children: [jsxRuntimeExports.jsx("h1", { className: "text-2xl font-bold mb-4", children: "Approved Documents" }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6", children: e?.data?.data?.data?.map(Ee => jsxRuntimeExports.jsx(ScannedDocumentCard, { document: Ee }, Ee.id)) })] }) }, Rescan = () => {
  const { state: e } = useLocation(), t = reactExports.useRef(null), [xe, Ee] = reactExports.useState("draft"), [_e, Re] = reactExports.useState("submitted"), [Ce, Me] = reactExports.useState([]), [De, Pe] = reactExports.useState(!1), [Oe, je] = reactExports.useState(null); if (!e) return jsxRuntimeExports.jsx("p", { children: "No document data provided." }); const { id: Be, fileName: Ie, filePath: Fe, uploadedAt: ze } = e, qe = reactExports.useCallback(() => { const Xe = t.current.getScreenshot(); Xe && (Me(St => [...St, Xe]), Pe(!1)) }, []), He = Xe => { const St = Xe.target.files[0]; St && je(St) }, Ge = () => { const Xe = new E; return Ce.forEach((St, un) => { un !== 0 && Xe.addPage(), Xe.addImage(St, "JPEG", 10, 10, 190, 270) }), Xe.output("blob") }, Ze = async (Xe, St) => { const un = new FormData; un.append("id", Be), un.append("file", Xe), un.append("status", St); try { await axiosInstance.post("/clerk/updateDoc", un), alert("Document updated successfully!"), Me([]), je(null) } catch (on) { console.error(on), alert("Failed to update document.") } }, sn = async Xe => { if (Ce.length > 0) { const St = Ge(), un = new File([St], "rescanned-document.pdf", { type: "application/pdf" }); await Ze(un, Xe) } else Oe ? await Ze(Oe, Xe) : alert("Please capture images or upload a file.") }; return jsxRuntimeExports.jsxs("div", {
    className: "max-w-3xl mx-auto p-4", children: [jsxRuntimeExports.jsx("h1", { className: "text-xl font-semibold mb-4", children: "Rescan or Resubmit Document" }), jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 mb-2", children: ["Document ID: ", Be] }), jsxRuntimeExports.jsxs("p", { className: "text-sm text-gray-600 mb-4", children: ["Old File: ", Ie] }), jsxRuntimeExports.jsx("input", {
      type: "file", accept: "image/*,application/pdf", onChange: He, className: `mb-4 block w-full text-sm text-gray-700 file:mr-4 file:py-2 file:px-4\r
                   file:rounded-full file:border-0 file:text-sm file:font-semibold\r
                   file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100`}), jsxRuntimeExports.jsx("button", { onClick: () => Pe(!0), className: "mb-4 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition", children: "Open Camera" }), De && jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [jsxRuntimeExports.jsx(Webcam, { audio: !1, ref: t, screenshotFormat: "image/jpeg", className: "w-full rounded-md", videoConstraints: { facingMode: "environment" } }), jsxRuntimeExports.jsx("button", { onClick: qe, className: "mt-2 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition", children: "Capture Image" })] }), Ce.length > 0 && jsxRuntimeExports.jsxs("div", { className: "mb-4", children: [jsxRuntimeExports.jsx("h2", { className: "text-lg font-medium mb-2", children: "Captured Images" }), jsxRuntimeExports.jsx("div", { className: "grid grid-cols-2 gap-2", children: Ce.map((Xe, St) => jsxRuntimeExports.jsxs("div", { className: "relative", children: [jsxRuntimeExports.jsx("img", { src: Xe, alt: `Captured ${St}`, className: "w-full rounded shadow" }), jsxRuntimeExports.jsx("button", { onClick: () => { const un = [...Ce]; un.splice(St, 1), Me(un) }, className: "absolute top-1 right-1 bg-red-600 text-white text-xs px-2 py-1 rounded hover:bg-red-700", children: "Delete" })] }, St)) })] }), jsxRuntimeExports.jsx("button", { onClick: () => sn("draft"), className: "mt-4 bg-blue-600 text-white px-4 py-2 rounded-md hover:bg-blue-700 transition mr-2", children: "Upload as Draft" }), jsxRuntimeExports.jsx("button", { onClick: () => sn("submitted"), className: "mt-4 bg-green-600 text-white px-4 py-2 rounded-md hover:bg-green-700 transition", children: "Upload as Submitted" })]
  })
}, PDFTest = () => { const [e, t] = React.useState(null), xe = ({ numPages: Re }) => { console.log("Test PDF loaded successfully with", Re, "pages"), t(Re) }, Ee = Re => { console.error("Test PDF load error:", Re) }; return jsxRuntimeExports.jsxs("div", { className: "p-4 border-2 border-dashed border-gray-300 rounded-lg", children: [jsxRuntimeExports.jsx("h3", { className: "text-lg font-semibold mb-4", children: "PDF Test Component" }), jsxRuntimeExports.jsxs("div", { className: "bg-gray-50 p-4 rounded", children: [jsxRuntimeExports.jsx(Document, { file: "data:application/pdf;base64,JVBERi0xLjEKJcKlwrHDqwoKMSAwIG9iago8PAovVHlwZSAvQ2F0YWxvZwovUGFnZXMgMiAwIFIKPj4KZW5kb2JqCgoyIDAgb2JqCjw8Ci9UeXBlIC9QYWdlcwovS2lkcyBbMyAwIFJdCi9Db3VudCAxCj4+CmVuZG9iagoKMyAwIG9iago8PAovVHlwZSAvUGFnZQovUGFyZW50IDIgMCBSCi9SZXNvdXJjZXMgPDwKL0ZvbnQgPDwKL0YxIDQgMCBSCj4+Cj4+Ci9NZWRpYUJveCBbMCAwIDYxMiA3OTJdCi9Db250ZW50cyA1IDAgUgo+PgplbmRvYmoKCjQgMCBvYmoKPDwKL1R5cGUgL0ZvbnQKL1N1YnR5cGUgL1R5cGUxCi9CYXNlRm9udCAvSGVsdmV0aWNhCj4+CmVuZG9iagoKNSAwIG9iago8PAovTGVuZ3RoIDQ0Cj4+CnN0cmVhbQpCVAovRjEgMTIgVGYKNzIgNzIwIFRkCihUZXN0IFBERiBGaWxlKSBUagoKRVQKZW5kc3RyZWFtCmVuZG9iagoKeHJlZgowIDYKMDAwMDAwMDAwMCA2NTUzNSBmIAowMDAwMDAwMDA5IDAwMDAwIG4gCjAwMDAwMDAwNTggMDAwMDAgbiAKMDAwMDAwMDExNSAwMDAwMCBuIAowMDAwMDAwMjQ1IDAwMDAwIG4gCjAwMDAwMDAzMDcgMDAwMDAgbiAKdHJhaWxlcgo8PAovU2l6ZSA2Ci9Sb290IDEgMCBSCj4+CnN0YXJ0eHJlZgo0MDAKJSVFT0YK", onLoadSuccess: xe, onLoadError: Ee, className: "flex flex-col items-center", children: Array.from(new Array(e || 0), (Re, Ce) => jsxRuntimeExports.jsx("div", { className: "mb-4", children: jsxRuntimeExports.jsx(Page, { pageNumber: Ce + 1, width: 400, renderTextLayer: !1, renderAnnotationLayer: !1, className: "border rounded shadow" }) }, Ce)) }), !e && jsxRuntimeExports.jsx("p", { className: "text-center text-gray-500", children: "Loading test PDF..." })] })] }) }, App = () => jsxRuntimeExports.jsxs(BrowserRouter, { children: [jsxRuntimeExports.jsx(Navbar, {}), jsxRuntimeExports.jsxs(Routes, { children: [jsxRuntimeExports.jsx(Route, { path: "/", element: jsxRuntimeExports.jsx(Dashboard, {}) }), jsxRuntimeExports.jsx(Route, { path: "/login", element: jsxRuntimeExports.jsx(Login, {}) }), jsxRuntimeExports.jsx(Route, { path: "/register", element: jsxRuntimeExports.jsx(Register, {}) }), jsxRuntimeExports.jsx(Route, { path: "/admin", element: jsxRuntimeExports.jsx(AdminDashboardPage, {}) }), jsxRuntimeExports.jsx(Route, { path: "/reset-password", element: jsxRuntimeExports.jsx(PasswordResetRequest, {}) }), jsxRuntimeExports.jsx(Route, { path: "/reset-password/:token", element: jsxRuntimeExports.jsx(PasswordReset, {}) }), jsxRuntimeExports.jsx(Route, { path: "/profile", element: jsxRuntimeExports.jsx(Profile, {}) }), jsxRuntimeExports.jsx(Route, { path: "/unauthorized", element: jsxRuntimeExports.jsx(Unauthorized, {}) }), jsxRuntimeExports.jsxs(Route, { path: "/scanner", element: jsxRuntimeExports.jsx(ScannerPage, {}), children: [jsxRuntimeExports.jsx(Route, { index: !0, element: jsxRuntimeExports.jsx(DocumentScanner, {}) }), jsxRuntimeExports.jsx(Route, { path: "scan", element: jsxRuntimeExports.jsx(DocumentScanner, {}) }), jsxRuntimeExports.jsx(Route, { path: "docs", element: jsxRuntimeExports.jsx(DisplayScannedDocs, {}) })] }), jsxRuntimeExports.jsx(Route, { path: "/rescan", element: jsxRuntimeExports.jsx(Rescan, {}) }), jsxRuntimeExports.jsxs(Route, { path: "/approver", element: jsxRuntimeExports.jsx(ApproverPage, {}), children: [jsxRuntimeExports.jsx(Route, { index: !0, element: jsxRuntimeExports.jsx(ReviewSection, {}) }), jsxRuntimeExports.jsx(Route, { path: "review", element: jsxRuntimeExports.jsx(ReviewSection, {}) }), jsxRuntimeExports.jsx(Route, { path: "approved", element: jsxRuntimeExports.jsx(ApprovedSection, {}) }), jsxRuntimeExports.jsx(Route, { path: "rejected", element: jsxRuntimeExports.jsx(RejectedSection, {}) })] }), jsxRuntimeExports.jsx(Route, { path: "/test", element: jsxRuntimeExports.jsx(PDFTest, {}) })] }), jsxRuntimeExports.jsx(Toaster, {})] }); ReactDOM$1.createRoot(document.getElementById("root")).render(jsxRuntimeExports.jsx(React.StrictMode, { children: jsxRuntimeExports.jsx(QueryClientProvider, { client: queryClient, children: jsxRuntimeExports.jsx(AuthProvider, { children: jsxRuntimeExports.jsx(App, {}) }) }) })); export { _typeof as _, commonjsGlobal as c, getDefaultExportFromCjs as g };
